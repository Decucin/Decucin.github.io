<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog of Decucin</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-04-14T10:49:14.272Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Decucin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode每日一题</title>
    <link href="http://yoursite.com/2021/04/14/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    <id>http://yoursite.com/2021/04/14/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</id>
    <published>2021-04-14T09:47:55.217Z</published>
    <updated>2021-04-14T10:49:14.272Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode每日一题"><a href="#leetcode每日一题" class="headerlink" title="leetcode每日一题"></a>leetcode每日一题</h1><p>此处记录我leetcode的每日一题题解，由于是初学，因此很多地方可能会解释不清，所给题解也不一定是最优解！</p><a id="more"></a><h2 id="2021-4-13"><a href="#2021-4-13" class="headerlink" title="2021/4/13"></a>2021/4/13</h2><h3 id="题目：二叉搜索树节点最小距离"><a href="#题目：二叉搜索树节点最小距离" class="headerlink" title="题目：二叉搜索树节点最小距离"></a>题目：<a href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/" target="_blank" rel="noopener">二叉搜索树节点最小距离</a></h3><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给你一个二叉搜索树的根节点 <code>root</code> ，返回 <strong>树中任意两不同节点值之间的最小差值</strong> 。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>首先应该明白的一点，什么是二叉搜索树，其具有什么特性，这些特性中哪些是能帮助解题的。</p><p>接下来只要回答上面的问题即可。</p><p>首先什么是二叉搜索树：</p><p><a href="https://baike.baidu.com/item/二叉查找树/7077965" target="_blank" rel="noopener">二叉查找树</a>（Binary Search Tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的<a href="https://baike.baidu.com/item/二叉树/1602879" target="_blank" rel="noopener">二叉树</a>： 若它的左子树不空，则左子树上所有结点的值均小于它的<a href="https://baike.baidu.com/item/根结点/9795570" target="_blank" rel="noopener">根结点</a>的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为<a href="https://baike.baidu.com/item/二叉排序树/10905079" target="_blank" rel="noopener">二叉排序树</a>。二叉搜索树作为一种经典的数据结构，它既有链表的快速插入与删除操作的特点，又有数组快速查找的优势；所以应用十分广泛，例如在文件系统和数据库系统一般会采用这种数据结构进行高效率的排序与检索操作。</p><p>之后是其具有的性质：</p><p>1.若任意结点的左子树不空，则左子树上所有结点的值均不大于它的根结点的值。</p><p>2.若任意结点的右子树不空，则右子树上所有结点的值均不小于它的根结点的值。</p><p>3.任意结点的左、右子树也分别为二叉搜索树。</p><p>其中能帮助我们解题的部分：</p><p>由二叉搜索树的性质可知，将二叉搜索树中序遍历能得到一个有序数组，由此相邻两个元素之间差值的最小值即为题目所求。</p><p>经此分析已得到解题方法，现在考虑对其进行优化，若是将遍历结果放到数组中无疑会增加空间，除此之外遍历时也比较繁琐，但如果增加pre指针指向前一个元素，那便可在遍历的同时直接更新相邻元素的最小值，即题目所求。但此方法切记pre的值最初应该设为一个负值，之后更新为节点的数据。</p><p>完整题解如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pre;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDiffInBST</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        pre = -<span class="number">1</span>;</span><br><span class="line">        ans = Integer.MAX_VALUE;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        <span class="keyword">if</span>(pre == -<span class="number">1</span>)&#123;</span><br><span class="line">            pre = root.val;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans = Math.min(ans, root.val - pre);</span><br><span class="line">            pre = root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2021-4-14"><a href="#2021-4-14" class="headerlink" title="2021/4/14"></a>2021/4/14</h2><h3 id="题目：实现-Trie-前缀树"><a href="#题目：实现-Trie-前缀树" class="headerlink" title="题目：实现 Trie (前缀树)"></a>题目：<a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/" target="_blank" rel="noopener">实现 Trie (前缀树)</a></h3><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>Trie（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p><p>请你实现 Trie 类：</p><p>Trie() 初始化前缀树对象。<br>void insert(String word) 向前缀树中插入字符串 word 。<br>boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。<br>boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>什么是前缀树？</p><p><a href="https://baike.baidu.com/item/%E5%AD%97%E5%85%B8%E6%A0%91/9825209?fromtitle=%E5%89%8D%E7%BC%80%E6%A0%91&fromid=2501595&fr=aladdin" target="_blank" rel="noopener">字典树</a>，又称单词查找树，<a href="https://baike.baidu.com/item/Trie树" target="_blank" rel="noopener">Trie树</a>，是一种<a href="https://baike.baidu.com/item/树形结构/9663807" target="_blank" rel="noopener">树形结构</a>，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的<a href="https://baike.baidu.com/item/字符" target="_blank" rel="noopener">字符</a>串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。</p><p>前缀树的性质：</p><p>根节点不包含字符，除根节点外每一个节点都只包含一个字符； 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串； 每个节点的所有子节点包含的字符都不相同。</p><p>综上，前缀树的每个节点用于表示单词的一个字母，从根节点开始，每个节点至多有26个节点（26个小写字母），所以得到前缀树应该具有的元素，一个标志其是否为词尾元素的标记符，用于保存子节点的节点数组。</p><p>至于初始化操作，只需要分别初始化标志符（置为false）和节点数组（置为null）。</p><p>插入操作只需将需要插入的字符一个一个放入前缀树中，每放入一个字符，二叉树的节点就向下移动到插入的位置即可，在插入完成后记得将此节点的标志符置为true，表示某个词的结束。</p><p>检索单词是否在前缀树中：按照单词中每个字母出现的顺序探索前缀树，若能一直向下探索并且最后的节点是某个词的结束（标识符为true），那么单词便在前缀树中，反之则不在。</p><p>检索前缀是否为插入的字符串的前缀：与检索单词类似，也是一直向下探索，但最后无需分辨是否是某个词的结束，即能够向下遍历便说明前缀存在，反之不存在。</p><p>完整题解如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isEnd;</span><br><span class="line">    <span class="keyword">private</span> Trie[] next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isEnd = <span class="keyword">false</span>;</span><br><span class="line">        next = <span class="keyword">new</span> Trie[<span class="number">26</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        Trie node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.next[word.charAt(i) - <span class="string">'a'</span>] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                node.next[word.charAt(i) - <span class="string">'a'</span>] = <span class="keyword">new</span> Trie();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.next[word.charAt(i)- <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        node.isEnd = <span class="keyword">true</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        Trie node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.next[word.charAt(i) - <span class="string">'a'</span>] != <span class="keyword">null</span>)&#123;</span><br><span class="line">                node = node.next[word.charAt(i) - <span class="string">'a'</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.isEnd == <span class="keyword">true</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        Trie node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.next[prefix.charAt(i) - <span class="string">'a'</span>] != <span class="keyword">null</span>)&#123;</span><br><span class="line">                node = node.next[prefix.charAt(i) - <span class="string">'a'</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;leetcode每日一题&quot;&gt;&lt;a href=&quot;#leetcode每日一题&quot; class=&quot;headerlink&quot; title=&quot;leetcode每日一题&quot;&gt;&lt;/a&gt;leetcode每日一题&lt;/h1&gt;&lt;p&gt;此处记录我leetcode的每日一题题解，由于是初学，因此很多地方可能会解释不清，所给题解也不一定是最优解！&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>用C或C++语言设计并实现一个可进行复数运算的演示程序</title>
    <link href="http://yoursite.com/2021/04/02/%E7%94%A8C%E6%88%96C++%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E5%B9%B6%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8F%AF%E8%BF%9B%E8%A1%8C%E5%A4%8D%E6%95%B0%E8%BF%90%E7%AE%97%E7%9A%84%E6%BC%94%E7%A4%BA%E7%A8%8B%E5%BA%8F/"/>
    <id>http://yoursite.com/2021/04/02/%E7%94%A8C%E6%88%96C++%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E5%B9%B6%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8F%AF%E8%BF%9B%E8%A1%8C%E5%A4%8D%E6%95%B0%E8%BF%90%E7%AE%97%E7%9A%84%E6%BC%94%E7%A4%BA%E7%A8%8B%E5%BA%8F/</id>
    <published>2021-04-02T15:26:53.861Z</published>
    <updated>2021-04-02T15:43:41.678Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用C或C-语言设计并实现一个可进行复数运算的演示程序"><a href="#用C或C-语言设计并实现一个可进行复数运算的演示程序" class="headerlink" title="用C或C++语言设计并实现一个可进行复数运算的演示程序"></a>用C或C++语言设计并实现一个可进行复数运算的演示程序</h1><p>上学期的编程实践，觉得很有意思，然后这学期新学了c++，便想到利用c++对上学期的编程实践项目进行复原。</p><a id="more"></a><p>第一个程序便是复数运算。首先进行科普（不过我相信能看到这篇博客的人不至于连什么是复数都不知道）：</p><p><strong>我们把形如z=a+bi（a,b均为实数）的数称为复数，其中a称为<a href="https://baike.baidu.com/item/实部/53626919" target="_blank" rel="noopener">实部</a>，b称为虚部，i称为<a href="https://baike.baidu.com/item/虚数" target="_blank" rel="noopener">虚数</a>单位。当z的虚部等于零时，常称z为实数；当z的<a href="https://baike.baidu.com/item/虚部/5231815" target="_blank" rel="noopener">虚部</a>不等于零时，实部等于零时，常称z为<a href="https://baike.baidu.com/item/纯虚数/3386848" target="_blank" rel="noopener">纯虚数</a>。复数域是实数域的代数闭包，即任何复系数多项式在复数域中总有根。</strong></p><p>接下来便是真正的进入程序的分析：</p><h2 id="复数的构造"><a href="#复数的构造" class="headerlink" title="复数的构造"></a>复数的构造</h2><p>在c++中，这便是复数类的构造函数。从复数定义中不难看出，复数分为两部分，实部和虚部，一旦确定了实部和虚部，那复数也就唯一确定了。因此构造函数代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cpxNum(double ral, double imag)&#123;</span><br><span class="line">c_ral &#x3D; ral;</span><br><span class="line">c_imag &#x3D; imag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于构造函数中并未进行内存申请，因此不必考虑重新撰写析构函数。</p><h2 id="复数的四则运算"><a href="#复数的四则运算" class="headerlink" title="复数的四则运算"></a>复数的四则运算</h2><p>最先考虑到的便是c++四则运算符的重载，实现起来也比较简单，参照复数四则运算的公式很容易得出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">cpxNum operator+(const cpxNum&amp; c2) &#123;</span><br><span class="line">cpxNum result;</span><br><span class="line">result.c_ral &#x3D; this-&gt;c_ral + c2.c_ral;</span><br><span class="line">result.c_imag &#x3D; this-&gt;c_imag + c2.c_imag;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cpxNum operator-(const cpxNum&amp; c2) &#123;</span><br><span class="line">cpxNum result;</span><br><span class="line">result.c_ral &#x3D; this-&gt;c_ral - c2.c_ral;</span><br><span class="line">result.c_imag &#x3D; this-&gt;c_imag - c2.c_imag;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cpxNum operator*(const cpxNum&amp; c2) &#123;</span><br><span class="line">cpxNum result;</span><br><span class="line">result.c_ral &#x3D; this-&gt;c_ral * c2.c_ral - this-&gt;c_imag * c2.c_imag;</span><br><span class="line">result.c_imag &#x3D; this-&gt;c_ral * c2.c_imag + this-&gt;c_imag * c2.c_ral;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cpxNum operator&#x2F;(const cpxNum&amp; c2) &#123;</span><br><span class="line">cpxNum result;</span><br><span class="line">result.c_ral &#x3D; 0;</span><br><span class="line">result.c_imag &#x3D; (this-&gt;c_ral * c2.c_ral + this-&gt;c_imag * c2.c_imag) * (this-&gt;c_imag * c2.c_ral - this-&gt;c_ral * c2.c_ral) &#x2F; (c2.c_ral * c2.c_ral + c2.c_imag * c2.c_imag);</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复数的打印"><a href="#复数的打印" class="headerlink" title="复数的打印"></a>复数的打印</h2><p>需要考虑以下几种情况，首先是0（实部虚部均为0），此时直接打印0即可；之后是纯虚数（实部为0），此时不需要打印实部，直接打印虚部即可；再然后是实数（虚部为0），此时不需打印虚部，之后的话再把虚部为负数的情况单独讨论即可，也比较简单，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void print() &#123;</span><br><span class="line">if (c_ral &#x3D;&#x3D; 0.0 &amp;&amp; c_imag &#x3D;&#x3D; 0)</span><br><span class="line">cout &lt;&lt; &#39;0&#39;;</span><br><span class="line">else if (c_imag &#x3D;&#x3D; 0)</span><br><span class="line">cout &lt;&lt; c_ral;</span><br><span class="line">else if (c_ral &#x3D;&#x3D; 0)</span><br><span class="line">cout &lt;&lt; c_imag &lt;&lt; &#39;i&#39;;</span><br><span class="line">else if (c_imag &lt; 0)</span><br><span class="line">cout &lt;&lt; c_ral &lt;&lt; c_imag &lt;&lt; &#39;i&#39;;</span><br><span class="line">else</span><br><span class="line">cout &lt;&lt; c_ral &lt;&lt; &#39;+&#39; &lt;&lt; c_imag &lt;&lt; &#39;i&#39;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>此实验较为简单，毕竟是编程实践1中的第一个实验，主要是为了抽象数据类型ADT的实现，在c++中便是类的体现，算法部分基本没有障碍，只是打印部分需要略微进行考虑。</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>完整代码参考我的<a href="https://github.com/Decucin/-1/tree/main/%E5%A4%8D%E6%95%B0%E8%BF%90%E7%AE%97" target="_blank" rel="noopener">github</a>。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;用C或C-语言设计并实现一个可进行复数运算的演示程序&quot;&gt;&lt;a href=&quot;#用C或C-语言设计并实现一个可进行复数运算的演示程序&quot; class=&quot;headerlink&quot; title=&quot;用C或C++语言设计并实现一个可进行复数运算的演示程序&quot;&gt;&lt;/a&gt;用C或C++语言设计并实现一个可进行复数运算的演示程序&lt;/h1&gt;&lt;p&gt;上学期的编程实践，觉得很有意思，然后这学期新学了c++，便想到利用c++对上学期的编程实践项目进行复原。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>数据结构算法合集（C语言版）</title>
    <link href="http://yoursite.com/2020/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%EF%BC%88C%E8%AF%AD%E8%A8%80%E7%89%88%EF%BC%89/"/>
    <id>http://yoursite.com/2020/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%EF%BC%88C%E8%AF%AD%E8%A8%80%E7%89%88%EF%BC%89/</id>
    <published>2020-11-27T05:19:23.117Z</published>
    <updated>2020-09-27T15:58:12.782Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构算法合集（C语言版）"><a href="#数据结构算法合集（C语言版）" class="headerlink" title="数据结构算法合集（C语言版）"></a>数据结构算法合集（C语言版）</h1><p>在学习《数据结构（C语言版）》一书时，我将其中的算法在此记录，以便有需要时进行查阅。</p><a id="more"></a><p><strong>注：以&amp;开头的参数为引用参数。</strong></p><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><p>定义抽象数据类型的格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ADT 抽象数据类型名&#123;</span><br><span class="line">数据对象：&lt;数据对象的定义&gt;</span><br><span class="line">数据关系：&lt;数据关系的定义&gt;</span><br><span class="line">基本操作：&lt;基本操作的定义&gt;</span><br><span class="line">&#125;ADT 抽象数据类型名</span><br></pre></td></tr></table></figure><p>操作的定义格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">基本操作名（参数表）</span><br><span class="line">初始条件:&lt;初始条件描述&gt;</span><br><span class="line">操作结果:&lt;操作结果描述&gt;</span><br></pre></td></tr></table></figure><p>预定义常量和类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;函数结果状态代码</span><br><span class="line">#defineTRUE1</span><br><span class="line">#defineFALSE0</span><br><span class="line">#defineOK1</span><br><span class="line">#defineERROR0</span><br><span class="line">#defineINFEASIBLE-1</span><br><span class="line">#defineOVERFLOW-2</span><br><span class="line">&#x2F;&#x2F;Status是函数的类型，其值是函数结果的状态代码</span><br><span class="line">typedefintStatus;</span><br></pre></td></tr></table></figure><p>基本操作的算法的函数描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">函数类型函数名（函数参数表）&#123;</span><br><span class="line">&#x2F;&#x2F;算法说明</span><br><span class="line">语句序列</span><br><span class="line">&#125;&#x2F;&#x2F;函数名</span><br></pre></td></tr></table></figure><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>扩大线性表LA，将存在于线性表LB中而不存在于线性表LA中的数据元素插入到线性表LA中去：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void union(List &amp;La, List)&#123;</span><br><span class="line">&#x2F;&#x2F;将所有在线性表Lb中但不在La中的数据元素插入到La中</span><br><span class="line">La_len &#x3D; ListLenth(La);&#x2F;&#x2F;求线性表长度</span><br><span class="line">Lb_len &#x3D; ListLenth(Lb);&#x2F;&#x2F;求线性表长度</span><br><span class="line">for(i &#x3D; 1; i &lt;&#x3D; Lb_len; i++)&#123;</span><br><span class="line">GetElem(Lb,i,e);</span><br><span class="line">if(!LocateElem(La, e, equal))</span><br><span class="line">ListInsert(La, ++La_len, e);&#x2F;&#x2F;La中不存在和e相同的数据元素，则插入之</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F; union</span><br></pre></td></tr></table></figure><p>已知线性表LA，LB中数据元素均按值非递减有序排列，现需将LA，LB归并为新的线性表LC，且LC中的数据元素仍按值非递减有序排列：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void MergeList(List La, List Lb, List &amp;Lc)&#123;</span><br><span class="line">&#x2F;&#x2F;已知线性表La和Lb中的数据元素按值非递减排列</span><br><span class="line">&#x2F;&#x2F;归并La和Lb得到新的线性表Lc，Lc的数据元素也按值非递减排列</span><br><span class="line">InitList(Lc);</span><br><span class="line">i &#x3D; j &#x3D; 1;</span><br><span class="line">k &#x3D; 0;</span><br><span class="line">La_len &#x3D; ListLenth(La);</span><br><span class="line">Lb_len &#x3D; ListLenth(Lb);</span><br><span class="line">while((i &lt;&#x3D; La_len) &amp;&amp; (j &lt;&#x3D; Lb_len))&#123;&#x2F;&#x2F;La与Lb均非空</span><br><span class="line">GetElem(La, i, ai);</span><br><span class="line">GetElem(Lb, j, bj);</span><br><span class="line">if(ai &lt;&#x3D; bj)&#123;</span><br><span class="line">ListInsert(Lc, ++k;, ai);</span><br><span class="line">++i;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">ListInsert(Lc, ++k, bj);</span><br><span class="line">++j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">while(i &lt;&#x3D; La_len)&#123;</span><br><span class="line">GetElem(La, i++, ai);</span><br><span class="line">ListInsert(Lc, ++k, ai);</span><br><span class="line">&#125;</span><br><span class="line">while(j &lt;&#x3D; Lb_len)&#123;</span><br><span class="line">GetElem(Lb, j++, bj);</span><br><span class="line">ListInsert(Lc, ++k,bj);</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;MergeList</span><br></pre></td></tr></table></figure><p>用数组来描述顺序存储结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;-----线性表的动态分配顺序存储结构-----</span><br><span class="line">#define LIST_INIT_SIZE 100  &#x2F;&#x2F;线性表存储空间的初始分配量</span><br><span class="line">#define LISTINCREMENT 10    &#x2F;&#x2F;线性表存储空间的分配增量</span><br><span class="line">typedef struct&#123;</span><br><span class="line">ElemType *elem;   &#x2F;&#x2F;存储空间基址</span><br><span class="line">int lenth;        &#x2F;&#x2F;当前长度</span><br><span class="line">int listsize;     &#x2F;&#x2F;当前分配的存储容量（以sizeof(ElemType)为单位</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure><p>顺序表的初始化（分配一个预定义大小的数组空间，并将线性表的当前长度设为“0”）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Status InitList_Sq(SqList &amp;L)&#123;</span><br><span class="line">&#x2F;&#x2F;构造一个空的线性表L</span><br><span class="line">L.elem &#x3D; (ElemType *)malloc(LIST_INIT_SIZE * sizeof(ElemType));</span><br><span class="line">if(!L.elem)</span><br><span class="line">exit(OVERFLOW);</span><br><span class="line">L.lenth &#x3D; 0;</span><br><span class="line">L.listsize &#x3D; LIST_INIT_SIZE;</span><br><span class="line">return OK;</span><br><span class="line">&#125;&#x2F;&#x2F;InitList_Sq</span><br></pre></td></tr></table></figure><p>线性表的插入（在第i个元素之前插入一个元素）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Status ListInsert_Sq(SqList &amp;L, int i, ElemType e)&#123;</span><br><span class="line">&#x2F;&#x2F;在顺序线性表L中第i个位置之前插入新的元素e</span><br><span class="line">if(i &lt; 1 || i &gt; L.lenth + 1)</span><br><span class="line">retur ERROR;&#x2F;&#x2F;i值不合法</span><br><span class="line">if(L.lenth &gt;&#x3D; L.listsize)&#123;&#x2F;&#x2F;当前存储空间已满，增加分配</span><br><span class="line">newbase &#x3D; (ElemType *)realloc(L.elem, (L.Listsize + LISTINCREMENT) * sizeof(ElemType));</span><br><span class="line">if(!newbase)</span><br><span class="line">exit(OVERFLOW);         &#x2F;&#x2F;存储分配失败</span><br><span class="line">L.elm &#x3D; newbase;            &#x2F;&#x2F;新基址</span><br><span class="line">L.listsize +&#x3D; LISTINCREMENT;&#x2F;&#x2F;增加存储容量</span><br><span class="line">&#125;</span><br><span class="line">q &#x3D; &amp;(L.elem[i-1]);&#x2F;&#x2F;q为插入位置</span><br><span class="line">for(p &#x3D; &amp;(L.elem[L.lenth-1]);</span><br><span class="line">p &gt;&#x3D; q; --p) * (p+1) &#x3D; *p;</span><br><span class="line">&#x2F;&#x2F;插入位置及之后的元素右移</span><br><span class="line">*q &#x3D; e;       &#x2F;&#x2F;插入e</span><br><span class="line">++L.lenth;    &#x2F;&#x2F;表长增1</span><br><span class="line">return OK;</span><br><span class="line">&#125;&#x2F;&#x2F;ListInsert_Sq</span><br><span class="line">&#x2F;&#x2F;先操作地址再操作值，否则无法确定后一数的具体位置</span><br></pre></td></tr></table></figure><p>线性表的删除（删除第i个元素，并用e返回其值）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Status ListDelete_Sq(SqList &amp;L, int i, ElemType &amp;e)&#123;</span><br><span class="line">&#x2F;&#x2F;在顺序线性表L中删除第i个元素，并用e返回其值</span><br><span class="line">if((i &lt; 1) || (i &gt; L.lenth))  &#x2F;&#x2F;i值不合法</span><br><span class="line">return ERROR;    </span><br><span class="line">p &#x3D; &amp;(L.elem[i-1]);  &#x2F;&#x2F;p为被删除元素的位置</span><br><span class="line">e &#x3D; *p;       &#x2F;&#x2F;被删除元素赋值给e</span><br><span class="line">q &#x3D; L.elem + L.lenth - 1;  &#x2F;&#x2F;表尾元素的位置</span><br><span class="line">for(++q; p &lt;&#x3D;q; ++p)  &#x2F;&#x2F;被删除元素之后的元素左移</span><br><span class="line">*(p-1) &#x3D; *p;      </span><br><span class="line">--L.lenth;     &#x2F;&#x2F;表长减1</span><br><span class="line">return OK;     </span><br><span class="line">&#125;&#x2F;&#x2F;ListDelete_Sq</span><br></pre></td></tr></table></figure><p>进行两个元素之间的比较（查找第一个值与e满足compare()的元素的位序）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int LocateElem_Sq(SqList L, ElemType e, Status(*compare)(ElemType, ElemType))&#123;</span><br><span class="line">&#x2F;&#x2F;在顺序表L中查找第一个值与e满足compare()的元素的位序</span><br><span class="line">&#x2F;&#x2F;若找到，返回其在L中的位序，否则返回0</span><br><span class="line">i &#x3D; 1;           &#x2F;&#x2F;i的初值为第1个元素的位序</span><br><span class="line">p &#x3D; L.elem;      &#x2F;&#x2F;p的初值为第1个元素的存储位置</span><br><span class="line">while(i &lt;&#x3D; L.lenth &amp;&amp; !(*compare)(*p++, e))</span><br><span class="line">++i;</span><br><span class="line">if(i &lt;&#x3D; L.lenth)</span><br><span class="line">return i;</span><br><span class="line">else</span><br><span class="line">return 0;</span><br><span class="line">&#125;&#x2F;&#x2F;LocateElem_Sq</span><br></pre></td></tr></table></figure><p>书中算法2.7与之前的算法类似，因此此处不在重复，但书中提到一点：即当*pa = *pb，即两集合中元素相同时，只需将两者其中之一插入Lc，并将两者均后移即可。（合并线性表LA，LB为新表LC算法）</p><p>单链表的表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;-----线性表的单链表存储结构-----</span><br><span class="line">typedef struct LNode&#123;</span><br><span class="line">ElemType data;</span><br><span class="line">struct LNode *next;</span><br><span class="line">&#125;LNode, *LinkList;</span><br></pre></td></tr></table></figure><p>单链表中获取第i个元素的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Status GetElem_L(LinkList L, int i, ElemType &amp;e)&#123;</span><br><span class="line">&#x2F;&#x2F;L为带头结点的单链表的头指针</span><br><span class="line">&#x2F;&#x2F;当第i个元素存在时，其值赋给e并返回OK，否则返回ERROR</span><br><span class="line">p &#x3D; L-&gt;next;  &#x2F;&#x2F;初始化，p指向第1个结点</span><br><span class="line">j &#x3D; 1;    &#x2F;&#x2F;j为计数器</span><br><span class="line">while(p &amp;&amp; j&lt;i)&#123;   &#x2F;&#x2F;顺指针向后查找，直到p指向第i个元素或p为空</span><br><span class="line">p &#x3D; p-&gt;next;</span><br><span class="line">++j;</span><br><span class="line">&#125;</span><br><span class="line">if(!p || j&gt;i)   &#x2F;&#x2F;第i个元素不存在</span><br><span class="line">return ERROR; </span><br><span class="line">e &#x3D; p-&gt;data;    &#x2F;&#x2F;取第i个元素</span><br><span class="line">return OK;</span><br><span class="line">&#125;&#x2F;&#x2F;GetElem_L</span><br></pre></td></tr></table></figure><p>单链表添加元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Status ListInsert_L(LinkList &amp;L, int i, ElemType e)&#123;</span><br><span class="line">&#x2F;&#x2F;在带头结点的单链线性表L中第i个位置之前插入元素</span><br><span class="line">p &#x3D; L;</span><br><span class="line">j &#x3D; 0;</span><br><span class="line">while(p &amp;&amp; j &lt; i-1)&#123;</span><br><span class="line">p &#x3D; p-&gt;next;</span><br><span class="line">++j;</span><br><span class="line">&#125;&#x2F;&#x2F;寻找第i-1个结点</span><br><span class="line">if(!p || j&gt;i-1) &#x2F;&#x2F;i小于1或者大于表长加1</span><br><span class="line">return ERROR;</span><br><span class="line">s &#x3D; (LinkList)malloc(sizeof(LNode)); &#x2F;&#x2F;生成新结点</span><br><span class="line">s-&gt;data &#x3D; e;</span><br><span class="line">s-&gt;next &#x3D; p-&gt;next;</span><br><span class="line">&#x2F;&#x2F;插入L中</span><br><span class="line">p-next &#x3D; s;</span><br><span class="line">return OK;</span><br><span class="line">&#125;&#x2F;&#x2F;ListInsert_L</span><br></pre></td></tr></table></figure><p>单链表删除元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Status ListDelete_L(LinkList &amp;L, int i, ElemType &amp;e)&#123;</span><br><span class="line">&#x2F;&#x2F;在带头结点的单链线性表L中，删除第i个元素，并由e返回其值</span><br><span class="line">p &#x3D; L;</span><br><span class="line">j &#x3D; 0;</span><br><span class="line">while(p-&gt;next &amp;&amp; j &lt; i-1)&#123; &#x2F;&#x2F;寻找第i个结点，并令p指向其前驱</span><br><span class="line">p &#x3D; p-&gt;next;</span><br><span class="line">++j;</span><br><span class="line">&#125;</span><br><span class="line">if(!(p-&gt;next) || j&gt;i-1)</span><br><span class="line">return ERROR;&#x2F;&#x2F;删除位置不合理</span><br><span class="line">q &#x3D; p-&gt;next;</span><br><span class="line">p-&gt;next &#x3D; q-&gt;next;&#x2F;&#x2F;删除并释放结点</span><br><span class="line">e &#x3D; q-&gt;data;</span><br><span class="line">free(q);</span><br><span class="line">return OK;</span><br><span class="line">&#125;&#x2F;&#x2F;ListDelete_L</span><br></pre></td></tr></table></figure><p>从表尾到表头逆向建立单链表的算法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void CreateList_L(LinkLIst &amp;L, int n)&#123;</span><br><span class="line">&#x2F;&#x2F;逆位序输入n个元素的值，建立带头结点的单链线性表L</span><br><span class="line">L &#x3D; (Linklist)malloc(sizeof(LNode));</span><br><span class="line">L-&gt;next &#x3D; NULL;  &#x2F;&#x2F;先建立一个带头结点的单链表</span><br><span class="line">for(i &#x3D; n; i &gt; 0; --i)&#123;</span><br><span class="line">p &#x3D; (LinkList)malloc(sizeof(LNode));  &#x2F;&#x2F;生成新结点</span><br><span class="line">scanf(&amp;p-&gt;data);   &#x2F;&#x2F;输入元素值</span><br><span class="line">p-&gt;next &#x3D; L-&gt;next &#x3D; p;  &#x2F;&#x2F;插入到表头</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;CreateList_L</span><br></pre></td></tr></table></figure><p>将两个有序链表合并为一个有序链表:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void MergeList_L(LinkList &amp;La, LinkList &amp;Lb, LinkList &amp;Lc)&#123;</span><br><span class="line">&#x2F;&#x2F;已知单链线性表La和Lb的元素按值非递减排列</span><br><span class="line">&#x2F;&#x2F;归并La和Lb得到新的单链线性表Lc，Lc的元素也按值非递减排列</span><br><span class="line">pa &#x3D; La-&gt;next;</span><br><span class="line">pb &#x3D; Lb-&gt;next;</span><br><span class="line">Lc &#x3D; pc &#x3D;La;    &#x2F;&#x2F;用La的头结点作为Lc的头结点</span><br><span class="line">while(pa &amp;&amp; pb)&#123;</span><br><span class="line">if(pa-&gt;data &lt;&#x3D; pb-&gt;data)&#123;</span><br><span class="line">pc-&gt;next &#x3D; pa;</span><br><span class="line">pc &#x3D; pa;</span><br><span class="line">pa &#x3D; pa-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">pc-&gt;next &#x3D; pb;</span><br><span class="line">pc &#x3D; pb;</span><br><span class="line">pb &#x3D; pb-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pc-&gt;next &#x3D; pa? pa : pb;  &#x2F;&#x2F;插入剩余段</span><br><span class="line">free(Lb);   &#x2F;&#x2F;释放Lb的头结点</span><br><span class="line">&#125;&#x2F;&#x2F;MergeList_L</span><br></pre></td></tr></table></figure><p>一维数组描述线性链表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;-----线性表的静态单链表存储结构-----</span><br><span class="line">#define MAXSIZE 1000</span><br><span class="line">typedef struct&#123;</span><br><span class="line">ElemType data;</span><br><span class="line">int cur;</span><br><span class="line">&#125;component,SLinkList[MAXSIZE];</span><br></pre></td></tr></table></figure><p>在静态链表中实现定位：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int LocateElem_SL(SLinkList S, ElemType e)&#123;</span><br><span class="line">&#x2F;&#x2F;在静态单链线性表L中查找第1个值为e的元素</span><br><span class="line">&#x2F;&#x2F;若找到，则返回它在L的位序，否则返回0</span><br><span class="line">i &#x3D; S[0].cur;   &#x2F;&#x2F;i指示表中第一个结点</span><br><span class="line">while(i &amp;&amp; S[i].data !&#x3D; e)</span><br><span class="line">i &#x3D; S[i].cur;    &#x2F;&#x2F;在表中顺链查找</span><br><span class="line">return i;</span><br><span class="line">&#125;&#x2F;&#x2F;LOcateElem_SL</span><br></pre></td></tr></table></figure><p><strong>注：为了辨明静态链表（数组）中哪些分量未被使用，可将所有未被使用过以及被删除的分量用游标链成一个备用的链表，需要插入时便可从备用链表上取得第一个结点作为待插入的新结点，需要删除时将从链表中删除下来的结点链接到备用链表上。</strong></p><p>将数组空间初始化为链表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void InitSpace_SL(SLinkList &amp;space)&#123;</span><br><span class="line">&#x2F;&#x2F;将一维数组space中各分量链成一个备用链表，space[0].cur为头指针</span><br><span class="line">&#x2F;&#x2F;“0”表示空指针</span><br><span class="line">for(i &#x3D; 0; i &lt; MAXSIZE - 1; ++i)</span><br><span class="line">space[i].cur &#x3D; i + 1；</span><br><span class="line">space[MAXSIZE-1].cur &#x3D; 0;</span><br><span class="line">&#125;&#x2F;&#x2F;InitSpace_SL</span><br></pre></td></tr></table></figure><p>从备用空间取得一个结点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int Malloc_SL(SLinkList &amp;space)&#123;</span><br><span class="line">&#x2F;&#x2F;若备用空间链表非空，则返回分配的结点下标，否则返回0</span><br><span class="line">i &#x3D; space[0].cur;</span><br><span class="line">if(space[0].cur)</span><br><span class="line">space[0].cur &#x3D; space[i].cur;</span><br><span class="line">return i;</span><br><span class="line">&#125;&#x2F;&#x2F;Malloc_SL</span><br></pre></td></tr></table></figure><p>将空闲结点链接到备用列表上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void Free_SL(SLinkList &amp;space, int k)&#123;</span><br><span class="line">&#x2F;&#x2F;将下标为k的空闲结点回收到备用列表</span><br><span class="line">space[k].cur &#x3D; space[0].cur;</span><br><span class="line">space[0].cur &#x3D; k;</span><br><span class="line">&#125;&#x2F;&#x2F;Free_SL</span><br></pre></td></tr></table></figure><p>已知集合A,B，求集合(A-B)U(B-A)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">void difference(SLinkList &amp;space, int &amp;s)&#123;</span><br><span class="line">&#x2F;&#x2F;依次输入集合A和B的元素，在一维数组space中建立表示集合(A-B)U(B-A)的静态链表，S为其头指针</span><br><span class="line">&#x2F;&#x2F;假设备用空间足够大，space[0].cur为其头指针</span><br><span class="line">InitSpace_SL(space);    &#x2F;&#x2F;初始化备用空间</span><br><span class="line">S &#x3D; Malloc_SL(space);   &#x2F;&#x2F;生成S的头结点</span><br><span class="line">r &#x3D; S;                  &#x2F;&#x2F;r指向S的当前最后一个结点</span><br><span class="line">scanf(m, n);            &#x2F;&#x2F;输入A和B的元素个数</span><br><span class="line">for(j &#x3D; 1; j &lt;&#x3D; m; ++j)&#123;&#x2F;&#x2F;建立集合A的链表</span><br><span class="line">i &#x3D; Malloc_SL(space);&#x2F;&#x2F;分配结点</span><br><span class="line">scanf(space[i].data);&#x2F;&#x2F;输入A的元素值</span><br><span class="line">space[r].cur &#x3D; i;</span><br><span class="line">r &#x3D; i;&#x2F;&#x2F;插入到表尾</span><br><span class="line">&#125;&#x2F;&#x2F;for</span><br><span class="line">space[r].cur &#x3D; 0;        &#x2F;&#x2F;尾结点的指针为空</span><br><span class="line">for(j &#x3D; 1; j &lt;&#x3D; n; ++j)&#123;&#x2F;&#x2F;依次输入B的元素，若不在当前表中，则插入，否则删除</span><br><span class="line">scanf(b);</span><br><span class="line">p &#x3D; S;</span><br><span class="line">k &#x3D; space[S].cur    &#x2F;&#x2F;k指向集合A中第一个结点</span><br><span class="line">while(k !&#x3D; space[r].cur &amp;&amp; space[k].data !&#x3D; b)&#123;&#x2F;&#x2F;在当前表中查找</span><br><span class="line">p &#x3D; k;</span><br><span class="line">k &#x3D; space[k].cur;</span><br><span class="line">&#125;&#x2F;&#x2F;while</span><br><span class="line">if(k &#x3D;&#x3D; space[r].cur)&#123;&#x2F;&#x2F;当前表中不存在该元素，插入在r所指结点之后，且r的位置不变</span><br><span class="line">i &#x3D; Malloc_SL(space);</span><br><span class="line">space[i].data &#x3D; b;</span><br><span class="line">space[i].cur &#x3D; space[r].cur;</span><br><span class="line">space[r].cur &#x3D; i;</span><br><span class="line">&#125;&#x2F;&#x2F;if</span><br><span class="line">else&#123;&#x2F;&#x2F;该元素已在表中，删除之</span><br><span class="line">space[p].cur &#x3D; space[k].cur;</span><br><span class="line">Free_SL(space, k);</span><br><span class="line">if(r &#x3D;&#x3D; k)</span><br><span class="line">r &#x3D; p;      &#x2F;&#x2F;若删除的是r所指结点，则需修改尾指针</span><br><span class="line">&#125;&#x2F;&#x2F;else</span><br><span class="line">&#125;&#x2F;&#x2F;for</span><br><span class="line">&#125;&#x2F;&#x2F;difference</span><br></pre></td></tr></table></figure><p>双向链表的C语言表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;-----线性表的双向链表存储结构-----</span><br><span class="line">typedef struct DuLNode&#123;</span><br><span class="line">ElemType data;</span><br><span class="line">struct DuLNode *prior;</span><br><span class="line">struct DuLNode *next;</span><br><span class="line">&#125;DuLNode, *DuLinkList;</span><br></pre></td></tr></table></figure><p>双向链表插入元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Status ListInsert_DuL(DuLinkList &amp;L, int i, ElemType e)&#123;</span><br><span class="line">&#x2F;&#x2F;在带头结点的双链循环线性表L中第i个位置之前插入元素e</span><br><span class="line">if(!(p &#x3D; GetElemP_DuL(L, i)))    &#x2F;&#x2F;在L中确定插入位置</span><br><span class="line">return ERROR;                &#x2F;&#x2F;p&#x3D;NULL，即插入位置不合法</span><br><span class="line">if(!(s &#x3D; (DuLinkList)malloc(sizeof(DuLNode))))</span><br><span class="line">return ERROR;</span><br><span class="line">s-&gt;data &#x3D; e;</span><br><span class="line">s-&gt;piror &#x3D; p-&gt;piror;</span><br><span class="line">p-&gt;piror-&gt;next &#x3D; s;</span><br><span class="line">s-&gt;next &#x3D; p;</span><br><span class="line">p-&gt;piror &#x3D; s;</span><br><span class="line">return OK;</span><br><span class="line">&#125;&#x2F;&#x2F;ListInsert_DuL</span><br></pre></td></tr></table></figure><p>双向链表删除元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Status ListDelete_DuL(DuLinkList &amp;L, int i, ElemType &amp;e)&#123;</span><br><span class="line">&#x2F;&#x2F;删除带头结点的双链循环线性表L的第i个元素</span><br><span class="line">if(!(p &#x3D; GetElemP_DuL(L, i)))  &#x2F;&#x2F;在L中确定第i个元素的位置指针p</span><br><span class="line">return ERROR;</span><br><span class="line">e &#x3D; p-&gt;data;</span><br><span class="line">p-&gt;piror-&gt;next &#x3D; p-&gt;next;</span><br><span class="line">p-&gt;next-&gt;piror &#x3D; p-&gt;piror;</span><br><span class="line">free(p);</span><br><span class="line">return OK;</span><br><span class="line">&#125;&#x2F;&#x2F;ListDelete_DuL</span><br></pre></td></tr></table></figure><p>一个带头结点的线性链表定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">typedef struct LNode&#123;&#x2F;&#x2F;结点类型</span><br><span class="line">ElemType data;</span><br><span class="line">struct LNode *next;</span><br><span class="line">&#125;*Link, *Position;</span><br><span class="line"></span><br><span class="line">typedef struct&#123;&#x2F;&#x2F;链表类型</span><br><span class="line">Link head, tail;  &#x2F;&#x2F;分别指向线性链表中的头结点和最后一个结点</span><br><span class="line">int len;          &#x2F;&#x2F;指示线性链表中数据元素的个数</span><br><span class="line">&#125; LinkList;</span><br><span class="line"></span><br><span class="line">Status MakeNode(Link &amp;p, ElemType e);</span><br><span class="line">&#x2F;&#x2F;分配由p指向的值为e的结点，并返回OK；若分配失败，则返回ERROR</span><br><span class="line">void FreeNode( Link &amp;p);</span><br><span class="line">&#x2F;&#x2F;释放p所指结点</span><br><span class="line"></span><br><span class="line">Status InitList(LinkList &amp;L);</span><br><span class="line">&#x2F;&#x2F;构造一个空的线性表L</span><br><span class="line">Status DestroyList(LinkList &amp;L);</span><br><span class="line">&#x2F;&#x2F;销毁线性链表L，L不再存在</span><br><span class="line">Status ClearList(LinkList &amp;L);</span><br><span class="line">&#x2F;&#x2F;将线性链表L重置为空表，并释放原链表L的结点空间</span><br><span class="line">Status InsFirst(Link h, Link s);</span><br><span class="line">&#x2F;&#x2F;已知h指向线性链表的头结点，将s所指结点插入在第一个结点之前</span><br><span class="line">Status DelFirst(Link h, Link &amp;q);</span><br><span class="line">&#x2F;&#x2F;已知h指向线性链表的头结点，删除链表中的第一个结点并以q返回</span><br><span class="line">Status Append(LinkList &amp;L,Link s);</span><br><span class="line">&#x2F;&#x2F;将指针s所指（彼此以指针相链）的一串结点链在线性链表L的最后一个结点</span><br><span class="line">&#x2F;&#x2F;之后，并改变链表L的尾指针指向新的尾结点</span><br><span class="line">Status Remove(LinkList &amp;L, Link &amp;q);</span><br><span class="line">&#x2F;&#x2F;删除线性链表L中的尾结点并以q返回，改变链表L的尾指针指向新的尾结点</span><br><span class="line">Status InsBefore(LinkList &amp;L, Link &amp;p, Link s);</span><br><span class="line">&#x2F;&#x2F;已知p指向线性链表L中的一个结点，将s所指结点插入在p所指结点之前，并修改指针p指向新的结点</span><br><span class="line">Status InsAfter(LinkList &amp;L, Link &amp;p, Link s);</span><br><span class="line">&#x2F;&#x2F;已知p指向线性链表L中的一个结点，将s所指结点插入在p所指结点之后，并修改指针p指向新的结点</span><br><span class="line">Status SetCurElem( Link &amp;p, ElemType e);</span><br><span class="line">&#x2F;&#x2F;已知p指向线性链表中的一个结点，用e更新p所指结点中数据元素的值</span><br><span class="line">ElemType GetCurElem(Link p);</span><br><span class="line">&#x2F;&#x2F;已知p指向线性链表中的一个结点，返回p所指结点中数据元素的值</span><br><span class="line">Status ListEmpty(LinkList L);</span><br><span class="line">&#x2F;&#x2F;若线性链表L为空表，则返回TURE，否则返回FALSE</span><br><span class="line">int ListLength(LinkList L);</span><br><span class="line">&#x2F;&#x2F;返回线性链表L中元素个数</span><br><span class="line">Position GetHead(LinkList L);</span><br><span class="line">&#x2F;&#x2F;返回线性链表L中头结点的位置</span><br><span class="line">Position GetLast(LinkList L);</span><br><span class="line">&#x2F;&#x2F;返回线性链表L中最后一个结点的位置</span><br><span class="line">Position PriorPos(LinkList L, Link p);</span><br><span class="line">&#x2F;&#x2F;已知p指向线性链表L中的一个结点，返回p所指结点的直接前驱的位置</span><br><span class="line">&#x2F;&#x2F;若无前驱，则返回NULL</span><br><span class="line">Position NextPos(LinkList L, Link p);</span><br><span class="line">&#x2F;&#x2F;已知p指向线性链表L中的一个结点，返回p所指结点的直接后继的位置</span><br><span class="line">&#x2F;&#x2F;若无后继，则返回NULL</span><br><span class="line">Status LocatePos(LinkList L, int i, Link &amp;p);</span><br><span class="line">&#x2F;&#x2F;返回p指示线性链表L中第i个结点的位置并返回OK；i值不合法时返回ERROR</span><br><span class="line">Position LocateElem(LinkList L, ElemType e, Status (*compare)(ElemType, ElemType));</span><br><span class="line">&#x2F;&#x2F;返回线性链表L中第1个与e满足函数compare()关系的元素的位置</span><br><span class="line">&#x2F;&#x2F;若不存在这样的元素，则返回NULL</span><br><span class="line">Status ListTraverse(LinkList L, Status (*visit)());</span><br><span class="line">&#x2F;&#x2F;依次对L的每个元素调用函数visit()，一旦visit()失败，则操作失败</span><br></pre></td></tr></table></figure><p>在第i个元素之前插入元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Status ListInsert_L(LinkList &amp;L, int i, ElemType e)&#123;</span><br><span class="line">&#x2F;&#x2F;在带头结点的单链线性表L的第i个元素之前插入元素e</span><br><span class="line">if(!LocatePos(L, i-1, h))</span><br><span class="line">return ERROR;    &#x2F;&#x2F;i值不合法</span><br><span class="line">if(!MakeNode(s, e))</span><br><span class="line">return ERROR;    &#x2F;&#x2F;结点存储分配失败</span><br><span class="line">InsFirst(h, s);      &#x2F;&#x2F;对于从第i个结点开始的链表，第i-1个结点是它的头结点</span><br><span class="line">return Ok;</span><br><span class="line">&#125;&#x2F;&#x2F;ListInsert_L</span><br></pre></td></tr></table></figure><p>两按值非递减排列的单链线性表合并为新的按值非递减排列的单链线性表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Status MergeList_L(LinkList &amp;La, LinkList &amp;Lb, LinkList &amp;Lc, int (*compare)(ElemType, Elemtype))&#123;</span><br><span class="line">&#x2F;&#x2F;已知单链线性表La和Lb的元素按值非递减排列</span><br><span class="line">&#x2F;&#x2F;排列La和Lb得到新的单链线性表Lc，Lc的元素也按值非递减排列</span><br><span class="line">if(!InitList(Lc))</span><br><span class="line">return ERROR;</span><br><span class="line">ha &#x3D; GetHead(La);     &#x2F;&#x2F;ha指向La的头结点</span><br><span class="line">hb &#x3D; GetHead(Lb);     &#x2F;&#x2F;hb指向Lb的头结点</span><br><span class="line">pa &#x3D; NextPos(La, ha); &#x2F;&#x2F;pa指向La中当前结点</span><br><span class="line">pb &#x3D; NextPos(Lb, hb); &#x2F;&#x2F;pb指向Lb中当前结点</span><br><span class="line">while(pa&amp;&amp;pb)&#123;        &#x2F;&#x2F;La和Lb均非空</span><br><span class="line">a &#x3D; GetCurElem(pa);</span><br><span class="line">b &#x3D; GetCurElem(pb);  &#x2F;&#x2F;a和b为当前两表中比较元素</span><br><span class="line">if((*compare)(a, b) &lt;&#x3D; 0)&#123;  &#x2F;&#x2F;a&lt;&#x3D;b</span><br><span class="line">DelFirst(ha, q);</span><br><span class="line">Append(Lc, q);</span><br><span class="line">pa &#x3D; NextPos(La, ha);</span><br><span class="line">&#125;</span><br><span class="line">else&#123;  &#x2F;&#x2F;a&gt;&#x3D;b</span><br><span class="line">DelFirst(hb, q);</span><br><span class="line">Append(Lc, q);</span><br><span class="line">pb &#x3D; NextPos(Lb, hb);</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;while</span><br><span class="line">if(pa)</span><br><span class="line">Append(Lc, pa);   &#x2F;&#x2F;链接La中剩余结点</span><br><span class="line">else</span><br><span class="line">Append(Lc, pb);   &#x2F;&#x2F;链接Lb中剩余结点</span><br><span class="line">FreeNode(ha);</span><br><span class="line">FreeNode(hb);         &#x2F;&#x2F;释放La和Lb的头结点</span><br><span class="line">return OK;</span><br><span class="line">&#125;&#x2F;&#x2F;MergeList_L</span><br></pre></td></tr></table></figure><p>抽象数据类型一元多项式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ADT Polynomial&#123;</span><br><span class="line">数据对象：D &#x3D; &#123;ai | ai ∈ TermSet, i &#x3D; 1,2,...,m,  m&gt;&#x3D;0</span><br><span class="line">TermSet中的每个元素包含一个表示系数的实数和表示指数的整数&#125;</span><br><span class="line"></span><br><span class="line">数据关系：R1 &#x3D; &#123;&lt;a(i-1),ai&gt;|a(i-1),ai∈D,且a(i-1)中的指数值&lt;ai中的指数值，i&#x3D;2,...,n&#125;</span><br><span class="line">基本操作：</span><br><span class="line">CreatPolyn( &amp;P, m )</span><br><span class="line">  操作结果：输入m项的系数和指数，建立一元多项式P</span><br><span class="line">  DestroyPolyn( &amp;P )</span><br><span class="line">  初始条件：一元多项式P已存在</span><br><span class="line">  操作结果：销毁一元多项式P</span><br><span class="line">  PrintPolyn( P )</span><br><span class="line">  初始条件：一元多项式P已存在</span><br><span class="line">  操作结果：打印输出一元多项式P</span><br><span class="line">  PolynLength( P )</span><br><span class="line">  初始条件：一元多项式P已存在</span><br><span class="line">  操作结果：返回一元多项式P中的项数</span><br><span class="line">  AddPolyn( &amp;Pa, &amp;Pb )</span><br><span class="line">  初始条件：一元多项式Pa和Pb已存在</span><br><span class="line">  操作结果：完成多项式相加运算，即：Pa &#x3D; Pa + Pb，并销毁一元多项式Pb</span><br><span class="line">  SubtractPolyn( &amp;Pa, &amp;Pb )</span><br><span class="line">  操作结果：完成多项式相减运算，即Pa&#x3D; Pa - Pb，并销毁一元多项式Pb</span><br><span class="line">  MultiplyPolyn( &amp;Pa, &amp;Pb )</span><br><span class="line">  初始条件：一元多项式Pa和Pb已存在</span><br><span class="line">  操作结果：完成多项式相乘运算，即Pa &#x3D; Pa * Pb，并销毁一元多项式Pb</span><br><span class="line">&#125;ADT Polynomial</span><br></pre></td></tr></table></figure><p>LocateElem()函数作用略有不同：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Status LocateElem(LinkList L, Elemtype e, Position &amp;q, int (*compare)(Elemtype, ElemType));</span><br><span class="line">&#x2F;&#x2F;若有序链表L中存在与e满足判定函数compaare()取值为0的元素，则q指示L中第一个值为e的结点的位置</span><br><span class="line">&#x2F;&#x2F;并返回TRUE，否则q指示第一个与e满足判定函数compare()取值&gt;0的元素的前驱位置，并返回FALSE</span><br></pre></td></tr></table></figure><p>OrderInsert()函数作用略有不同：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Status OrderInsert( LinkList &amp;L, ElemType e, int (*compare)(ElemType, ElemType));</span><br><span class="line">&#x2F;&#x2F;按有序判定函数compare()的约定，将值为e的结点插入到有序链表L的 适当位置上</span><br></pre></td></tr></table></figure><p>抽象数据类型Polynomial的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">typedef struct&#123;    &#x2F;&#x2F;项的表示，多项式的项作为LinkList的数据元素</span><br><span class="line">float coef;    &#x2F;&#x2F;系数</span><br><span class="line">int   expn;    &#x2F;&#x2F;指数</span><br><span class="line">&#125;term, ElemType;   &#x2F;&#x2F;两个类型名：term用于本ADT，ElemType为LinkList的数据对象名</span><br><span class="line"></span><br><span class="line">typedef LinkList polynomial;    &#x2F;&#x2F;用带表头结点的有序链表表示多项式</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F;-----基本操作的函数原型说明-----</span><br><span class="line">void CreatPolyn( Polynomial &amp;p, int m )&#123;</span><br><span class="line">&#x2F;&#x2F;输入m项的系数和指数，建立表示一元多项式的有序链表P</span><br><span class="line">InitList(P);</span><br><span class="line">h &#x3D; GetHead(P);</span><br><span class="line">e.coef &#x3D; 0.0;</span><br><span class="line">e.expn &#x3D; -1;</span><br><span class="line">SetCurElem(h,e);   &#x2F;&#x2F;设置头结点的数据元素</span><br><span class="line">for( i &#x3D; 1; i&lt;&#x3D;m; ++i)&#123;  &#x2F;&#x2F;依次输入m个非零项</span><br><span class="line">scanf(e.coef, e.expn);</span><br><span class="line">if(!LocateElem( P, e, q, (*cmp)()))&#123;  &#x2F;&#x2F;当前链表中不存在该指数项</span><br><span class="line">if(MakeNode(s,e))</span><br><span class="line">InsFirst( q, s );  &#x2F;&#x2F;生成结点并插入链表</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;CreatPolyn</span><br></pre></td></tr></table></figure><p>多项式加法实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">void AddPolyn( polynomial &amp;Pa, polynomial &amp;Pb)&#123;</span><br><span class="line">&#x2F;&#x2F;多项式加法：Pa &#x3D; Pa+Pb，利用两个多项式的结点构成“和多项式”</span><br><span class="line">ha &#x3D; GetHead(Pa);   &#x2F;&#x2F;ha指向Pa的头结点</span><br><span class="line">hb &#x3D; GetHead(Pb);   &#x2F;&#x2F;hb指向Pb的头结点</span><br><span class="line">qa &#x3D; NextPos(Pa,ha);   &#x2F;&#x2F;qa指向Pa中当前结点</span><br><span class="line">qb &#x3D; NextPos(Pb,hb);   &#x2F;&#x2F;qb指向Pb中当前结点</span><br><span class="line">while(qa &amp;&amp; Qb)&#123;&#x2F;&#x2F;qa和qb均非空</span><br><span class="line">a &#x3D; GetCurElem(qa);</span><br><span class="line">b &#x3D; GetCurElem(qb);   &#x2F;&#x2F;a和b为两表中当前比较元素</span><br><span class="line">switch( *cmp(a,b))&#123;</span><br><span class="line">case -1:    &#x2F;&#x2F;多项式Pa中当前结点的指数值小</span><br><span class="line">ha &#x3D; qa;</span><br><span class="line">qa &#x3D; NextPos(Pa, qa);</span><br><span class="line">break;</span><br><span class="line">case 0:     &#x2F;&#x2F;两者的指数值相等</span><br><span class="line">sum &#x3D; a.coef + b.coef;</span><br><span class="line">if(sum !&#x3D; 0.0)&#123;&#x2F;&#x2F;修改多项式Pa中当前结点的系数值</span><br><span class="line">SetCurElem(qa,sum);</span><br><span class="line">ha &#x3D; qa;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;&#x2F;&#x2F;删除多项式Pa中当前结点</span><br><span class="line">DelFirst(ha, qa);</span><br><span class="line">FreeNode(qa);</span><br><span class="line">&#125;</span><br><span class="line">DelFirst(hb, qb);</span><br><span class="line">FreeNode(qb);</span><br><span class="line">qb &#x3D; NextPos(Pb, hb);</span><br><span class="line">qa &#x3D; NextPos(Pa, ha);</span><br><span class="line">break;</span><br><span class="line">case 1:&#x2F;&#x2F;多项式Pb中当前结点的指数值小</span><br><span class="line">DelFirst(hb, qb);</span><br><span class="line">InsFirst( ha, qb);</span><br><span class="line">qb &#x3D; NextPos(Pb, hb);</span><br><span class="line">ha &#x3D; NextPos(Pa,ha);</span><br><span class="line">break;</span><br><span class="line">&#125;&#x2F;&#x2F;switch</span><br><span class="line">&#125;&#x2F;&#x2F;while</span><br><span class="line">if(!ListEmpty (Pb))</span><br><span class="line">Append(Pa, qb);&#x2F;&#x2F;链接Pb中剩余结点</span><br><span class="line">FreeNode(hb);&#x2F;&#x2F;释放Pb的头结点</span><br><span class="line">&#125;&#x2F;&#x2F;AddPolyn</span><br></pre></td></tr></table></figure><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><p>栈的抽象数据类型定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">ADTStack&#123;</span><br><span class="line">数据对象：D &#x3D; &#123;ai|ai∈ElemSet, i &#x3D; 1,2,...,n,n&gt;&#x3D;0&#125;</span><br><span class="line">数据关系：R1 &#x3D; &#123; &lt;a(i-1),ai&gt;|a(i-1),ai∈D, i &#x3D; 2,...,n&#125;</span><br><span class="line">约定an端为栈顶，ai端为栈底</span><br><span class="line">基本操作：</span><br><span class="line">InitStack(&amp;S)</span><br><span class="line">操作结果：构造一个空栈S</span><br><span class="line">DestroyStack(&amp;S)</span><br><span class="line">初始条件：栈S已存在</span><br><span class="line">操作结果：栈S被销毁</span><br><span class="line">ClearStack(&amp;S)</span><br><span class="line">初始条件：栈S已存在</span><br><span class="line">操作结果：将S清为空栈</span><br><span class="line">StackEmpty(S)</span><br><span class="line">初始条件：栈S已存在</span><br><span class="line">操作结果：若栈S为空栈，则返回TRUE，否则返回FALSE</span><br><span class="line">StackLength(S)</span><br><span class="line">初始条件：栈S已存在</span><br><span class="line">操作结果：返回S的元素个数，即栈的长度</span><br><span class="line">GetTop(S,&amp;e)</span><br><span class="line">初始条件：栈S已存在且非空</span><br><span class="line">操作结果：用e返回S的栈顶元素</span><br><span class="line">Push(&amp;S, &amp;e)</span><br><span class="line">初始条件：栈S已存在</span><br><span class="line">操作结果：插入元素e为新的栈顶元素</span><br><span class="line">Pop(&amp;S, &amp;e)</span><br><span class="line">初始条件：栈S已存在且非空</span><br><span class="line">操作结果：删除S的栈顶元素，并用e返回其值</span><br><span class="line">StackTraverse(S,visit())</span><br><span class="line">初始条件：栈S已存在且非空</span><br><span class="line">操作结果：从栈底到栈顶依次对S的每个元素调用函数visit()，一旦visit()失败，则操作失败</span><br><span class="line">&#125;ADTStack</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;之后也多为如上定义，并将插入元素操作称为入栈，删除栈顶元素的操作为出栈</span><br></pre></td></tr></table></figure><p>顺序栈的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedefstruct&#123;</span><br><span class="line">SElemType*base;</span><br><span class="line">SElemType*top;</span><br><span class="line">intstacksize;</span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure><p>顺序栈的模块说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;ADT Stack的表示与实现&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-----栈的顺序存储表示-----</span><br><span class="line"></span><br><span class="line">#define STACK_INIT_SIZE100;&#x2F;&#x2F;存储空间初始分配量</span><br><span class="line">#defineSTACKINCREMENT10;&#x2F;&#x2F;存储空间分配增量</span><br><span class="line">typedefstruct&#123;</span><br><span class="line">SElemType*base;&#x2F;&#x2F;在栈构造之前和销毁之后，base的值为NULL</span><br><span class="line">SElemType*top;&#x2F;&#x2F;栈顶指针</span><br><span class="line">intstacksize;&#x2F;&#x2F;当前已分配的存储空间，以元素为单位</span><br><span class="line">&#125;SqStack;</span><br><span class="line">&#x2F;&#x2F;-----基本操作的函数原型说明-----</span><br><span class="line">StatusInitStack(SqStack &amp;S);</span><br><span class="line">&#x2F;&#x2F;构造一个空栈S</span><br><span class="line">StatusDestroyStack(SqStack &amp;S);</span><br><span class="line">&#x2F;&#x2F;销毁栈S，S不在存在</span><br><span class="line">StatusClearStack(SqStack&amp;S);</span><br><span class="line">&#x2F;&#x2F;把S置为空栈</span><br><span class="line">StatusStackEmpty(SqStackS);</span><br><span class="line">&#x2F;&#x2F;若栈S为空栈，则返回TRUE，否则返回FALSE</span><br><span class="line">int StackLength(SqStack S);</span><br><span class="line">&#x2F;&#x2F;返回S的元素个数，即栈的长度</span><br><span class="line">Status GetTop(SqStack S, SElemType &amp;e);</span><br><span class="line">&#x2F;&#x2F;若栈不空，则用e返回S的栈顶元素，并返回OK，否则返回ERROR</span><br><span class="line">Status Push(SqStack &amp;S,SElemType e);</span><br><span class="line">&#x2F;&#x2F;插入元素e为新的栈顶元素</span><br><span class="line">Status Pop(SqStack &amp;S, SElemType &amp;e);</span><br><span class="line">&#x2F;&#x2F;若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK，否则返回ERROR</span><br><span class="line">Status StackTraverse(SqStack S, Status (*visit)());</span><br><span class="line">&#x2F;&#x2F;从栈底到栈顶依次对栈中每个元素调用函数visit()，一旦visit()失败，则操作失败</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-----基本操作的算法描述（部分） -----</span><br><span class="line">Status InitStack (SqStack &amp;S)&#123;</span><br><span class="line">&#x2F;&#x2F;构造一个空栈S</span><br><span class="line">S.base &#x3D; (SElemType*)malloc(STACK_INIT_SIZE * sizeof(SElemType));</span><br><span class="line">if(!S.base)</span><br><span class="line">exit(OVERFLOW);&#x2F;&#x2F;存储分配失败</span><br><span class="line">S.top &#x3D; S.base;</span><br><span class="line">S.stacksize &#x3D; STACK_INIT_SIZE;</span><br><span class="line">return OK;</span><br><span class="line">&#125;&#x2F;&#x2F;InitStack</span><br><span class="line"></span><br><span class="line">StatusGetTop(SqStackS, SElemType &amp;e)&#123;</span><br><span class="line">&#x2F;&#x2F;若栈不空，则用e返回S的栈顶元素，并返回OK，否则返回ERROR</span><br><span class="line">if(S.top &#x3D;&#x3D; S.base)</span><br><span class="line">return ERROR;</span><br><span class="line">e &#x3D; *(S.top - 1);</span><br><span class="line">return OK;</span><br><span class="line">&#125;&#x2F;&#x2F;GetTop</span><br><span class="line"></span><br><span class="line">StatusPush(SqStack &amp;S, SElemType e)&#123;</span><br><span class="line">&#x2F;&#x2F;插入元素e为新的栈顶元素</span><br><span class="line">if(S.top - S.base &gt;&#x3D; S.stacksize)&#123;&#x2F;&#x2F;栈满，追加存储空间</span><br><span class="line">S.base &#x3D; (SElemType*)realloc( S.base, (S.stacksize + STACKINCREMENT) * sizeof(SElemType));</span><br><span class="line">if(!S.base)</span><br><span class="line">exit(OVERFLOW);&#x2F;&#x2F;存储分配失败</span><br><span class="line"></span><br><span class="line">S.top &#x3D; S.base + S.stacksize;</span><br><span class="line">S.stacksize +&#x3D; STACKINCREMENT;</span><br><span class="line">&#125;</span><br><span class="line">*S.top++ &#x3D; e;</span><br><span class="line">return OK;</span><br><span class="line">&#125;&#x2F;&#x2F;Push</span><br><span class="line"></span><br><span class="line">StatusPop(SqStack&amp;S,SEleType &amp;e)&#123;</span><br><span class="line">&#x2F;&#x2F;若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK，否则返回FALSE</span><br><span class="line">if(S.top &#x3D;&#x3D; S.base)</span><br><span class="line">return ERROR;</span><br><span class="line">e &#x3D; * --S.top;</span><br><span class="line">return OK;</span><br><span class="line">&#125;&#x2F;&#x2F;Pop</span><br></pre></td></tr></table></figure><p>十进制转八进制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;进制计算与打印过程刚好相反，满足栈的特性</span><br><span class="line"></span><br><span class="line">void conversion()&#123;</span><br><span class="line">&#x2F;&#x2F;对于输入的任意一个非负十进制整数，打印输出与其等值的八进制数</span><br><span class="line">InitStack(S);&#x2F;&#x2F;构造空栈</span><br><span class="line">scanf(&quot;%d&quot;,N);</span><br><span class="line">while(N)&#123;</span><br><span class="line">Push(S, N % 8);</span><br><span class="line">N &#x3D; N&#x2F;8;</span><br><span class="line">&#125;</span><br><span class="line">while(!StackEmpty(S))&#123;</span><br><span class="line">Pop(S,e);</span><br><span class="line">printf(&quot;%d&quot;,e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;conversion</span><br></pre></td></tr></table></figure><p>行编辑程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void LineEdit()&#123;</span><br><span class="line">&#x2F;&#x2F;利用字符栈S，从终端接受一行并传送至调用过程的数据区</span><br><span class="line">InitStack(S);&#x2F;&#x2F;构造空栈S</span><br><span class="line">ch &#x3D; getchar();&#x2F;&#x2F;从终端接收第一个字符</span><br><span class="line">while(ch !&#x3D; EOF)&#123;&#x2F;&#x2F;EOF为全文结束符</span><br><span class="line">while(ch !&#x3D; EOF &amp;&amp; ch !&#x3D; &#39;\n&#39;)&#123;</span><br><span class="line">switch(ch)&#123;</span><br><span class="line">case &#39;#&#39;:</span><br><span class="line">Pop(S,c);</span><br><span class="line">break;&#x2F;&#x2F;仅当栈非空时退栈</span><br><span class="line">case &#39;@&#39;:</span><br><span class="line">ClearStack(S);</span><br><span class="line">break;&#x2F;&#x2F;重置S为空栈</span><br><span class="line">default:</span><br><span class="line">Push(S,ch);</span><br><span class="line">break;&#x2F;&#x2F;有效字符进栈，未考虑栈满情况</span><br><span class="line">&#125;</span><br><span class="line">ch &#x3D; getchar();&#x2F;&#x2F;从终端接收下一个字符</span><br><span class="line">&#125;</span><br><span class="line">将从栈底到栈顶的栈内字符传送至调用过程的数据区</span><br><span class="line">ClearStack(S);&#x2F;&#x2F;重置S为空栈</span><br><span class="line">if(ch!&#x3D;EOF)</span><br><span class="line">ch &#x3D; getchar();</span><br><span class="line">&#125;</span><br><span class="line">DestroyStack(S);</span><br><span class="line">&#125;&#x2F;&#x2F;LineEdit</span><br></pre></td></tr></table></figure><p>求迷宫中一条从入口到出口的路径的算法描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">do&#123;</span><br><span class="line">若当前位置可通，则&#123;</span><br><span class="line">将当前位置压入栈顶；   &#x2F;&#x2F;  纳入路径</span><br><span class="line">若当前位置是出口位置，则结束；&#x2F;&#x2F;求得路径存放在栈中</span><br><span class="line">否则切换当前位置的东邻方块为新的当前位置；</span><br><span class="line">&#125;</span><br><span class="line">否则&#123;</span><br><span class="line">若栈不空且栈顶位置尚有其他地方尚未探索，则&#123;</span><br><span class="line">设定新的当前位置为沿顺时针方向旋转找到的栈顶位置的下一邻块</span><br><span class="line">&#125;</span><br><span class="line">若栈不空但栈顶位置的四周均不可通，则&#123;</span><br><span class="line">删去栈顶位置； &#x2F;&#x2F;从路径中删去该通道块</span><br><span class="line">若栈不空，则重新测试新的栈顶位置，，</span><br><span class="line">直至找到一个可通的相邻块或出栈至栈空；</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;while(栈不空)</span><br></pre></td></tr></table></figure><p>实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">typedefstruct&#123;</span><br><span class="line">intord;&#x2F;&#x2F;通道块在路径上的“序号”</span><br><span class="line">PosTypeseat;&#x2F;&#x2F;通道块在迷宫中的“坐标位置”</span><br><span class="line">intdi;&#x2F;&#x2F;从此通道块走向下一通道块的“方向”</span><br><span class="line">&#125;SElemType;&#x2F;&#x2F;栈的元素类型</span><br><span class="line"></span><br><span class="line">StatusMazePath( MazeTypemaze, PosType start, PosType end )&#123;</span><br><span class="line">&#x2F;&#x2F;若迷宫maze中存在从入口start到出口end的通道，则求得一条存放在栈中（从栈底到栈顶），并返回TRUE；</span><br><span class="line">&#x2F;&#x2F;否则返回FALSE</span><br><span class="line">InitStack(S);</span><br><span class="line">curpos &#x3D; start;&#x2F;&#x2F;设定“当前位置”为“入口位置”</span><br><span class="line">curstep &#x3D; 1;&#x2F;&#x2F;探索第一步</span><br><span class="line">do&#123;</span><br><span class="line">if(Pass(curpos))&#123;&#x2F;&#x2F;当前位置可以通过，即是未曾走到过的通道块</span><br><span class="line">FootPrint(curpos);&#x2F;&#x2F;留下足迹</span><br><span class="line">e &#x3D; ( curstep, curpos, 1 );&#x2F;&#x2F;此处e为SElemType类型的栈（书中未提及）</span><br><span class="line">Push(S,e);&#x2F;&#x2F;加入路径</span><br><span class="line">if(curpos&#x3D;&#x3D;end)</span><br><span class="line">return(TRUE);&#x2F;&#x2F;到达终点，出口</span><br><span class="line">curpos &#x3D; NextPos( curpos, 1 );&#x2F;&#x2F;下一位置是当前位置的东邻</span><br><span class="line">curstep++;&#x2F;&#x2F;探索下一步</span><br><span class="line">&#125;&#x2F;&#x2F;if</span><br><span class="line">else&#123;&#x2F;&#x2F;当前位置不能通过</span><br><span class="line">if(!StackEmpty(S))&#123;</span><br><span class="line">Pop(S,e);</span><br><span class="line">while(e.di &#x3D;&#x3D; 4 &amp;&amp; !StackEmpty(S))&#123;</span><br><span class="line">MarkPrint(e.seat);</span><br><span class="line">Pop(S,e);&#x2F;&#x2F;留下不能通过的标记，并退回一步</span><br><span class="line">&#125;&#x2F;&#x2F;while</span><br><span class="line">if(e.di&lt;4)&#123;</span><br><span class="line">e.di++;</span><br><span class="line">Push(S,e);&#x2F;&#x2F;换下一个方向探索</span><br><span class="line">curpos &#x3D; NextPos(e.seat, e.di);&#x2F;&#x2F;设定当前位置是该新方向上的相邻块</span><br><span class="line">&#125;&#x2F;&#x2F;if</span><br><span class="line">&#125;&#x2F;&#x2F;if</span><br><span class="line">&#125;&#x2F;&#x2F;else</span><br><span class="line">&#125;while( !StackEmpty(S));</span><br><span class="line">return (FALSE);</span><br><span class="line">&#125;&#x2F;&#x2F;MazePath</span><br></pre></td></tr></table></figure><p>带优先级的算术表达式求值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">OperandTypeEvaluateExpression()&#123;</span><br><span class="line">&#x2F;&#x2F;算数表达式求值的算符优先算法</span><br><span class="line">&#x2F;&#x2F;设OPTR和OPND分别为运算符栈和运算数栈，OP为运算符集合</span><br><span class="line">InitStack(OPTR);</span><br><span class="line">Push(OPTR, &#39;#&#39;);</span><br><span class="line">InitStack(OPND);</span><br><span class="line">c &#x3D; getchar();</span><br><span class="line">while(c!&#x3D;&#39;#&#39; || GetTop(OPTR)!&#x3D;&#39;#&#39;)&#123;</span><br><span class="line">if(!In(c, OP))&#123;</span><br><span class="line">Push(OPND, c);</span><br><span class="line">c &#x3D; getchar();</span><br><span class="line">&#125;&#x2F;&#x2F;不是运算符则进栈</span><br><span class="line">else&#123;</span><br><span class="line">switch(Precede(GetTop(OPTR),c))&#123;&#x2F;&#x2F;Precede()函数用于监测运算符优先级</span><br><span class="line">case &#39;&lt;&#39;:&#x2F;&#x2F;栈顶元素优先权低</span><br><span class="line">Push(OPTR, c);</span><br><span class="line">c &#x3D; getchar();</span><br><span class="line">break;</span><br><span class="line">case &#39;&#x3D;&#39;:&#x2F;&#x2F;脱括号并接受下一字符</span><br><span class="line">Pop(OPTR, x);</span><br><span class="line">c &#x3D; getchar();</span><br><span class="line">break;</span><br><span class="line">case &#39;&gt;&#39;:&#x2F;&#x2F;退栈并将运算结果入栈</span><br><span class="line">Pop(OPTR, theta);</span><br><span class="line">Pop(OPND, b);</span><br><span class="line">Pop(OPND, a);</span><br><span class="line">Push(OPND, Operate(a, theta, b));</span><br><span class="line">break;</span><br><span class="line">&#125;&#x2F;&#x2F;switch</span><br><span class="line">&#125;&#x2F;&#x2F;else</span><br><span class="line">&#125;&#x2F;&#x2F;while</span><br><span class="line">return GetTop(OPND);</span><br><span class="line">&#125;&#x2F;&#x2F;EvaluateExpression</span><br></pre></td></tr></table></figure><p>求解n阶Hanoi塔问题的C函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void hanoi(int n, char x, char y, char z)</span><br><span class="line">&#x2F;&#x2F;将塔座x上按直径由小到大且自上而下编号为1至n的n个圆盘按规则搬动到塔座z上，y可用作辅助塔座</span><br><span class="line">&#x2F;&#x2F;搬动操作move(x, n, z)可定义为（c是初值为0的全局变量，对搬动计数）：</span><br><span class="line">&#x2F;&#x2F;printf(&quot;%i. Move disk %i from %c to %c\n&quot;, ++c, n, x, z);</span><br><span class="line">&#123;</span><br><span class="line">if(n&#x3D;&#x3D;1)</span><br><span class="line">move(x,1,z);</span><br><span class="line">else&#123;</span><br><span class="line">honoi(n-1, x, z,y);&#x2F;&#x2F;将x上编号为1至n-1的圆盘移到y，z作辅助塔</span><br><span class="line">move(x, n, z);&#x2F;&#x2F;将编号为n的圆盘从x移到z</span><br><span class="line">hanoi(n-1, y, x, z);&#x2F;&#x2F;将y上编号为1至n-1的圆盘移到z，x作辅助塔</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>队列的抽象数据类型定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">ADTQueue&#123;</span><br><span class="line">数据对象:D&#x3D;&#123;ai|ai∈ElemSet, i &#x3D; 1,2,...,n, n&gt;&#x3D;0&#125;</span><br><span class="line">数据关系:R1&#x3D;&#123;&lt;a(i-1),ai&gt;|a(i-1),ai∈D, i&#x3D;2,...,n&#125;</span><br><span class="line">约定其中a1端为队列头，an端为队列尾</span><br><span class="line">基本操作：</span><br><span class="line">InitQueue(&amp;Q)</span><br><span class="line">操作结果：构造一个空队列Q</span><br><span class="line">DesTroyQueue(&amp;Q)</span><br><span class="line">初始条件：队列Q已存在</span><br><span class="line">操作结果：队列Q被销毁，不再存在</span><br><span class="line">ClearQueue(&amp;Q)</span><br><span class="line">初始条件：队列Q已存在</span><br><span class="line">操作结果：将Q清为空队列</span><br><span class="line">QueueEmpty(Q)</span><br><span class="line">初始条件：队列Q已存在</span><br><span class="line">操作结果：若Q为空队列，则返回TRUE，否则返回FALSE</span><br><span class="line">QueueLength(Q)</span><br><span class="line">初始条件：队列Q已存在</span><br><span class="line">操作结果：返回Q的元素个数，即队列的长度</span><br><span class="line">GetHead(Q, &amp;e)</span><br><span class="line">初始条件：队列Q已存在</span><br><span class="line">操作结果：用e返回Q的队头元素</span><br><span class="line">EnQueue(&amp;Q, e)</span><br><span class="line">初始条件：队列Q已存在</span><br><span class="line">操作结果：插入元素e为Q的新的队尾元素</span><br><span class="line">DeQueue(&amp;Q, &amp;e)</span><br><span class="line">初始条件：队列Q已存在</span><br><span class="line">操作结果：删除Q的队头元素，并用e返回其值</span><br><span class="line">QueueTraverse(Q,visit())</span><br><span class="line">初始条件：队列Q已存在</span><br><span class="line">操作结果：从队头到队尾，依次对Q的每个数据元素调用函数visit()。一旦visit()失败，则操作失败</span><br><span class="line">&#125;ADT Queue</span><br></pre></td></tr></table></figure><p>单链队列的表示与实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;ADT Queue的表示与实现&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-----单链队列——队列的链式存储结构-----</span><br><span class="line">typedefstructQNode&#123;</span><br><span class="line">QElemTypedata;</span><br><span class="line">structQNode*next;</span><br><span class="line">&#125;QNode, *QueuePtr;</span><br><span class="line">typedefstruct&#123;</span><br><span class="line">QueuePtrfront;&#x2F;&#x2F;队头指针</span><br><span class="line">QueuePtrrear;&#x2F;&#x2F;队尾指针</span><br><span class="line">&#125;&#x2F;&#x2F;LinkQueue;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-----基本操作的函数原型说明-----</span><br><span class="line">StatusInitQueue(LinkQueue&amp;Q)</span><br><span class="line">&#x2F;&#x2F;构造一个空队列Q</span><br><span class="line">StatusDestroyQueue(LinkQueue &amp;Q)</span><br><span class="line">&#x2F;&#x2F;销毁队列Q，Q不再存在</span><br><span class="line">StatusClearQueue(LinkQueue &amp;Q)</span><br><span class="line">&#x2F;&#x2F;将Q清为空队列</span><br><span class="line">StatusQueueEmpty(LinkQueue Q)</span><br><span class="line">&#x2F;&#x2F;若队列Q为空队列，则返回TRUE，否则返回FALSE</span><br><span class="line">intQueueLength(LinkQueue Q)</span><br><span class="line">&#x2F;&#x2F;返回队列Q的元素个数，即队列长度</span><br><span class="line">StatusGetHead(LinkQueue Q, QElemType &amp;e)</span><br><span class="line">&#x2F;&#x2F;若队列不空，则用e返回Q的队头元素，并返回OK，否则返回ERROR</span><br><span class="line">StatusEnQueue(LinkQueue &amp;Q, QElemType &amp;e)</span><br><span class="line">&#x2F;&#x2F;插入元素e为Q新的队尾元素</span><br><span class="line">StatusDeQueue(LinkQueue &amp;Q, QElemType &amp;e)</span><br><span class="line">&#x2F;&#x2F;若队列不空，则删除Q的队头元素，用e返回其值，并返回OK，否则返回ERROR</span><br><span class="line">StatusQueueTraverse(LinkQueue Q, visit())</span><br><span class="line">&#x2F;&#x2F;从队头到队尾依次对队列Q中每个元素调用函数visit()。一旦visit()失败，则操作失败</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-----基本操作的算法描述（部分） -----</span><br><span class="line">StatusInitQueue(LinkQueue&amp;Q)&#123;</span><br><span class="line">&#x2F;&#x2F;构造一个空队列Q</span><br><span class="line">Q.front &#x3D; Q.rear &#x3D; (QueuePtr)malloc(sizeof(QNode));</span><br><span class="line">if(!Q.front)</span><br><span class="line">exit(OVERFLOW);&#x2F;&#x2F;存储分配失败</span><br><span class="line">Q.front-&gt;next &#x3D; NULL;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StatusDestroyQueue(LinkQueue&amp;Q)&#123;</span><br><span class="line">&#x2F;&#x2F;销毁队列Q</span><br><span class="line">while(Q.front)&#123;</span><br><span class="line">Q.rear &#x3D; Q.front-&gt;next;</span><br><span class="line">free(Q.front);</span><br><span class="line">Q.front &#x3D; Q.rear;</span><br><span class="line">&#125;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StatusEnQueue(LinkQueue &amp;Q, QElemTypee)&#123;</span><br><span class="line">&#x2F;&#x2F;插入元素e为Q的新的队尾元素</span><br><span class="line">p &#x3D; (QueuePtr)malloc(sizeof(QNode));</span><br><span class="line">if(!p)</span><br><span class="line">exit(OVERFLOW);&#x2F;&#x2F;存储分配失败</span><br><span class="line">p-&gt;data &#x3D; e;</span><br><span class="line">p-&gt;next &#x3D; NULL;</span><br><span class="line">Q.rear-&gt;next &#x3D; p;</span><br><span class="line">Q.rear &#x3D; p;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StatusDeQueue(LinkQueue &amp;Q, QElemType &amp;e)&#123;</span><br><span class="line">&#x2F;&#x2F;若队列不空，则删除Q的队头元素，用e返回其值，并返回OK，否则返回ERROR</span><br><span class="line">if(Q.front &#x3D;&#x3D; Q.rear)</span><br><span class="line">return ERROR;</span><br><span class="line">p &#x3D; Q.front-&gt;next;</span><br><span class="line">e &#x3D; p-&gt;data;</span><br><span class="line">Q.front-&gt;next &#x3D; p-&gt;next;</span><br><span class="line">if(Q.rear &#x3D;&#x3D; p)&#x2F;&#x2F;队列中最后一个元素被删除，队列尾指针也丢失了，需对其也进行赋值</span><br><span class="line">Q.rear &#x3D; Q.front;</span><br><span class="line">free(p);</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环队列类型说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;-----循环队列——队列的顺序存储结构-----</span><br><span class="line">#defineMAXQSIZE100&#x2F;&#x2F;最大队列长度</span><br><span class="line">typedefstruct&#123;</span><br><span class="line">QElemType*base;&#x2F;&#x2F;初始化的动态分配存储空间</span><br><span class="line">intfront;&#x2F;&#x2F;头指针，若队列不空，指向队列头元素</span><br><span class="line">intrear;&#x2F;&#x2F;尾指针，若队列不空，指向队列尾元素的下一位置</span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-----循环队列的基本操作的算法描述-----</span><br><span class="line">StatusInitQueue(SqQueue &amp;Q)&#123;</span><br><span class="line">&#x2F;&#x2F;构造一个空队列Q</span><br><span class="line">Q.base &#x3D; (QElemType*)malloc(MAXSIZE * sizeof(QElemType));</span><br><span class="line">if(!Q.base)</span><br><span class="line">exit(OVERFLOW);</span><br><span class="line">Q.front &#x3D; Q.rear &#x3D; 0;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">intQueueLength(SqQueueQ)&#123;</span><br><span class="line">&#x2F;&#x2F;返回Q的元素个数，即队列的长度</span><br><span class="line">return (Q.rear - Q.front + MAXSIZE) % MASIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StatusEnQueue(SqQueue&amp;Q, QElemType e)&#123;</span><br><span class="line">&#x2F;&#x2F;插入元素e为Q的新的队尾元素</span><br><span class="line">if((Q.rear + 1) % MAXSIZE &#x3D;&#x3D; Q.front)</span><br><span class="line">return ERROR;&#x2F;&#x2F;队列满</span><br><span class="line">Q.base[Q.rear] &#x3D; e;</span><br><span class="line">Q.rear &#x3D; (Q.rear + 1) % MAXSIZE;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StatusDeQueue(SqQueue&amp;Q, QElemType &amp;e)&#123;</span><br><span class="line">&#x2F;&#x2F;若队列不空，则删除Q的队头元素，用e返回其值，并返回OK，否则返回ERROR</span><br><span class="line">if(Q.front &#x3D;&#x3D; Q.rear)</span><br><span class="line">returnERROR;</span><br><span class="line">e &#x3D; Q.base[Q.front];</span><br><span class="line">Q.front &#x3D; (Q.front + 1) % MAXSIZE;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>银行客户的离散事件驱动模拟程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void Bank_Simulation(int CloseTime)&#123;</span><br><span class="line">&#x2F;&#x2F;银行业务模拟，统计一天内客户在银行逗留的平均时间</span><br><span class="line"></span><br><span class="line">OpenForDay();&#x2F;&#x2F;初始化</span><br><span class="line">while(MoreEvent)&#123;</span><br><span class="line">EventDrived(OccurTime, EventType);&#x2F;&#x2F;事件驱动</span><br><span class="line">switch(EventType)&#123;</span><br><span class="line">case &#39;A&#39;:&#x2F;&#x2F;处理客户到达事件</span><br><span class="line">CustomerArrived();</span><br><span class="line">break;</span><br><span class="line">case &#39;D&#39;:&#x2F;&#x2F;处理客户离开事件</span><br><span class="line">CustomerDeparture();</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">Invalid();</span><br><span class="line">&#125;&#x2F;&#x2F;switch</span><br><span class="line">&#125;&#x2F;&#x2F;while</span><br><span class="line">CloseForDay;&#x2F;&#x2F;计算平均逗留时间</span><br><span class="line">&#125;&#x2F;&#x2F;Bank_Simulation</span><br></pre></td></tr></table></figure><p>所需有序链表和队列的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedefstruct&#123;</span><br><span class="line">intOccurTime;&#x2F;&#x2F;事件发生时刻</span><br><span class="line">intNType;&#x2F;&#x2F;事件类型，0表示到达事件，1至4表示四个窗口的离开事件</span><br><span class="line">&#125;Event, Elemtype;&#x2F;&#x2F;事件类型，有序链表LinkList的数据元素类型</span><br><span class="line"></span><br><span class="line">typedefLinkList EventList;&#x2F;&#x2F;事件链表类型，定义为有序链表</span><br><span class="line"></span><br><span class="line">typedefstruct&#123;</span><br><span class="line">intArrivalTime;&#x2F;&#x2F;到达时刻</span><br><span class="line">intDuration;&#x2F;&#x2F;办理事务所需时间</span><br><span class="line">&#125;QElemType;&#x2F;&#x2F;队列的数据元素类型</span><br></pre></td></tr></table></figure><p>银行事件驱动模拟程序算法实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;程序中用到的主要变量</span><br><span class="line">EventListev;&#x2F;&#x2F;事件表</span><br><span class="line">Eventen;&#x2F;&#x2F;事件</span><br><span class="line">LinkQueueq[5];&#x2F;&#x2F;4个客户队列</span><br><span class="line">QElemTypecustomer;&#x2F;&#x2F;客户记录</span><br><span class="line">intTotalTime, CustomerNum;&#x2F;&#x2F;累计客户逗留时间，客户数</span><br><span class="line"></span><br><span class="line">intcmp(Event a, Event b);</span><br><span class="line">&#x2F;&#x2F;依事件a发生的时刻&lt;,&#x3D;或&gt;事件b的发生时刻分别返回-1，0或1</span><br><span class="line"></span><br><span class="line">void OpenForDay()&#123;</span><br><span class="line">&#x2F;&#x2F;初始化操作</span><br><span class="line">TotalTime &#x3D; 0;&#x2F;&#x2F;初始化累计时间为0</span><br><span class="line">CustomerNum &#x3D; 0;&#x2F;&#x2F;初始化客户数为0</span><br><span class="line">InitList(ev);&#x2F;&#x2F;初始化事件链表为空表</span><br><span class="line">en.OcuurTime &#x3D; 0;</span><br><span class="line">en.NType &#x3D; 0;&#x2F;&#x2F;设定第一个客户到达事件</span><br><span class="line">OrderInsert(ev, en, cmp);&#x2F;&#x2F;插入事件表</span><br><span class="line">for(i&#x3D;1; i&lt;&#x3D;4; ++i)</span><br><span class="line">InitQueue(q[i]);&#x2F;&#x2F;置空队列</span><br><span class="line">&#125;&#x2F;&#x2F;OpenForDay</span><br><span class="line"></span><br><span class="line">void CustomerDeparture()&#123;</span><br><span class="line">&#x2F;&#x2F;处理客户离开事件，en.NType&gt;0</span><br><span class="line">i &#x3D; en.Ntype;</span><br><span class="line">DelQueue(q[i], customer);&#x2F;&#x2F;删除第i队列的排头客户</span><br><span class="line">TotalTime +&#x3D; en.OccurTime - customer.ArrivalTime;&#x2F;&#x2F;累计客户逗留时间</span><br><span class="line">if(!QueueEmpty(q[i]))&#123;&#x2F;&#x2F;设定第i队列的一个离开事件并插入事件表</span><br><span class="line">GetHead(q[i], customer);</span><br><span class="line">OrderInsert(ev, (en.OccurTime + customer.Duration, i),(*cmp)());</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;CustomerDeparture</span><br><span class="line"></span><br><span class="line">void Bank_Simulation(int CloseTime)&#123;</span><br><span class="line">OpenForDay();&#x2F;&#x2F;初始化</span><br><span class="line">while(!ListEmpty(ev))&#123;</span><br><span class="line">DelFirst(GetHead(ev), p);</span><br><span class="line">en 66&#x3D; GetCurElem(p);</span><br><span class="line">if(en.NType &#x3D;&#x3D; 0)</span><br><span class="line">CustomerArrived();&#x2F;&#x2F;处理客户到达事件</span><br><span class="line">else</span><br><span class="line">CustomerDeparture();&#x2F;&#x2F;处理客户离开事件</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;计算并输出平均逗留时间</span><br><span class="line">printf(&quot;The AverageTimeis%f\n&quot;,(float)TotalTime&#x2F;CustomerNum);</span><br><span class="line">&#125;&#x2F;&#x2F;Bank_Simulation</span><br></pre></td></tr></table></figure><h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><p>串的抽象数据类型定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">ADTString&#123;</span><br><span class="line">数据对象：D&#x3D;&#123;ai|ai∈CharacterSet, i &#x3D; 1,2,...,n, n&gt;&#x3D;0&#125;</span><br><span class="line">数据关系：R1&#x3D;&#123;&lt;a(i-1), ai&gt;|a(i-1),ai∈D, i &#x3D; 2,...,n&#125;</span><br><span class="line">基本操作：</span><br><span class="line">StrAssign(&amp;T, chars)</span><br><span class="line">初始条件：chars是字符串常量</span><br><span class="line">操作结果：生成一个其值等于chars的串T</span><br><span class="line">StrCopy(&amp;T, S)</span><br><span class="line">初始条件：串S存在</span><br><span class="line">操作结果：由串S复制得到串T</span><br><span class="line">StrEmpty(S)</span><br><span class="line">初始条件：串S存在</span><br><span class="line">操作结果：若S为空串，返回TRUE，否则返回FALSE</span><br><span class="line">StrCompare(S, T)</span><br><span class="line">初始条件：串S和T存在</span><br><span class="line">操作结果：若S&gt;T，则返回值&gt;0，若S&#x3D;T，则返回值&#x3D;0，若S&lt;T，则返回值&lt;0</span><br><span class="line">StrLength(S)</span><br><span class="line">初始条件：串S存在</span><br><span class="line">操作结果：返回S的元素个数，称为串的长度</span><br><span class="line">ClearString(&amp;S)</span><br><span class="line">初始条件：串S存在</span><br><span class="line">操作结果：将S清空为空串</span><br><span class="line">Concat(&amp;T, S1, S2)</span><br><span class="line">初始条件：串S1和S2存在</span><br><span class="line">操作结果：用T返回由S1和S2联接而成的新串</span><br><span class="line">SubString(&amp;Sub, S, pos, len)</span><br><span class="line">初始条件：串S存在，1&lt;&#x3D;pos&lt;&#x3D;StrLength(S)且0&lt;&#x3D;len&lt;&#x3D;StrLength(S)-pos+1</span><br><span class="line">操作结果：用Sub返回串S的第pos个字符起长度为len的子串</span><br><span class="line">Index(S, T, pos)</span><br><span class="line">初始条件：串S和T存在，T是非空串，1&lt;&#x3D;pos&lt;&#x3D;StrLength(S)</span><br><span class="line">操作结果：若主串S中存在和串T值相同的子串，则返回它在主串S中第pos个字符之后第一次出现的位置，否则函数值为0</span><br><span class="line">Replace(&amp;S, T, V)</span><br><span class="line">初始条件：串S，T和V存在，T是非空串</span><br><span class="line">操作结果：用V替换主串S中出现的所有与T相等的不重叠的子串</span><br><span class="line">StrInsert(&amp;S, pos, T)</span><br><span class="line">初始条件：串S和T存在，1&lt;&#x3D;pos&lt;&#x3D;SreLength(S)+1</span><br><span class="line">操作结果：在串S的第pos个字符之前插入串T</span><br><span class="line">StrDelete(&amp;S, pos, len)</span><br><span class="line">初始条件：串S存在，1&lt;&#x3D;pos&lt;&#x3D;StrLength(S)-len+1</span><br><span class="line">操作结果：从串S中删除第pos个字符起长度为len的字串</span><br><span class="line">DestoryString(&amp;S)</span><br><span class="line">初始条件：串S存在</span><br><span class="line">操作结果：串S被销毁</span><br><span class="line">&#125;ADT String</span><br></pre></td></tr></table></figure><p>利用判定、求串长和求子串等操作实现定位函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int Index(String S, String T, int pos)&#123;</span><br><span class="line">&#x2F;&#x2F;T为非空串。若主串S中第pos个字符之后存在与T相等的子串，则返回第一个这样的子串在S中的位置，否则返回0</span><br><span class="line">if(pos&gt;0)&#123;</span><br><span class="line">n &#x3D; StrLength(S);</span><br><span class="line">m &#x3D; StrLength(T);</span><br><span class="line">i &#x3D; pos;</span><br><span class="line">while(i &lt;&#x3D; n - m + 1)&#123;</span><br><span class="line">SubString(sub, S, i, m);</span><br><span class="line">if(StrCompare(sub,T) !&#x3D; 0)</span><br><span class="line">++i;</span><br><span class="line">else</span><br><span class="line">return i;&#x2F;&#x2F;返回子串在主串中的位置</span><br><span class="line">&#125;&#x2F;&#x2F;while</span><br><span class="line">&#125;&#x2F;&#x2F;if</span><br><span class="line">return 0;&#x2F;&#x2F;S中不存在与T相等的子串</span><br><span class="line">&#125;&#x2F;&#x2F;Index</span><br></pre></td></tr></table></figure><p>定长数组描述串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;-----串的定长顺序存储表示-----</span><br><span class="line">#defineMAXSTRLEN255&#x2F;&#x2F;用户可在255以内定义最大串长</span><br><span class="line">typedefunsigned charSString[MAXSTRLEN + 1];&#x2F;&#x2F;0号单元存放串的长度</span><br></pre></td></tr></table></figure><p>串联接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">StatusConcat(SString &amp;T,SString S1, SString S2)&#123;</span><br><span class="line">&#x2F;&#x2F;用T返回由S1和S2联接而成的新串。若未截断，则返回TRUE，否则返回FALSE</span><br><span class="line">if(S1[0] + S2[0] &lt;&#x3D; MAXSTRLEN)&#123;&#x2F;&#x2F;未截断</span><br><span class="line">T[1..S1[0]] &#x3D; S1[1..S1[0]];</span><br><span class="line">T[S1[0]+1..S1[0]+S2[0]] &#x3D; S2[1..S2[0]];</span><br><span class="line">T[0] &#x3D; S1[0] + S2[0];</span><br><span class="line">uncut &#x3D; TRUE;</span><br><span class="line">&#125;</span><br><span class="line">else if(S1[0] &lt; MAXSTRLEN)&#123;&#x2F;&#x2F;截断</span><br><span class="line">T[1..S1[0]] &#x3D; S1[1..S1[0]];</span><br><span class="line">T[S1[0] + 1..MAXSTRLEN] &#x3D; S2[1..MAXSTRLEN-S1[0]];</span><br><span class="line">T[0] &#x3D; MAXSTRLEN;</span><br><span class="line">uncut &#x3D; FALSE;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">T[0..MAXSTRLEN] &#x3D; S1[0..MAXSTRLEN];</span><br><span class="line">&#x2F;&#x2F;T[0] &#x3D;&#x3D; S1[0] &#x3D;&#x3D;MAXSTRLEN</span><br><span class="line">uncut &#x3D; FALSE;</span><br><span class="line">&#125;</span><br><span class="line">return uncut;</span><br><span class="line">&#125;&#x2F;&#x2F;Concat</span><br><span class="line">&#x2F;&#x2F;因为0位表示长度，故1..S1[0]表示从S1的第一个元素到最后一个元素，1..S2[0]同理</span><br></pre></td></tr></table></figure><p>求子串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">StatusSubString(SString &amp;Sub,SString S, int pos, int len)&#123;</span><br><span class="line">&#x2F;&#x2F;用Sub返回串S的第pos个字符起长度为Len的子串</span><br><span class="line">&#x2F;&#x2F;其中，1&lt;&#x3D;pos&lt;&#x3D;StrLength(S)且0&lt;&#x3D;len&lt;&#x3D;StrLength(S)-pos+1</span><br><span class="line">if(pos &lt; 1 || pos &gt; S[0] || len &lt; 0 || len &gt; S[0]-pos+1)</span><br><span class="line">return ERROR;</span><br><span class="line">Sub[1..len] &#x3D; S[pos..pos+len-1];</span><br><span class="line">Sub[0] &#x3D; len;</span><br><span class="line">returnOK;</span><br><span class="line">&#125;&#x2F;&#x2F;SubString</span><br></pre></td></tr></table></figure><p>堆分配存储表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;-----串的堆分配存储表示 -----</span><br><span class="line">typedefstruct&#123;</span><br><span class="line">char*ch;&#x2F;&#x2F;若是非空串，则按串长分配存储区，否则ch为NULL</span><br><span class="line">intlength;&#x2F;&#x2F;串长度</span><br><span class="line">&#125;HString;</span><br></pre></td></tr></table></figure><p>串的插入操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Status StrInsert(HString &amp;S, int pos, HString T)&#123;</span><br><span class="line">&#x2F;&#x2F;1&lt;&#x3D;pos&lt;&#x3D;Strlength(S)+1。在串的第pos个字符之前插入串T</span><br><span class="line">if(pos&lt;1||pos&gt;S.length+1)</span><br><span class="line">returnERROR;&#x2F;&#x2F;pos不合法</span><br><span class="line">if(T.length)&#123;&#x2F;&#x2F;T非空，则重新分配空间，插入T</span><br><span class="line">if(!(S.ch &#x3D; (char *)realloc(S.ch, (S.length+T.length)*sizeof(char))))</span><br><span class="line">exit(OVERFLOW);</span><br><span class="line">for(i&#x3D;S.length-1; i&gt;&#x3D;pos-1; --i)&#x2F;&#x2F;为插入T而腾出位置</span><br><span class="line">S.ch[i+T.length] &#x3D; S.ch[i];</span><br><span class="line">S.ch[pos-1..pos+T.length-2] &#x3D; T.ch[0..T.length-1];&#x2F;&#x2F;插入T</span><br><span class="line">S.length +&#x3D; T.length;</span><br><span class="line">&#125;</span><br><span class="line">return OK;</span><br><span class="line">&#125;&#x2F;&#x2F;StrInsert</span><br></pre></td></tr></table></figure><p>串的表示与实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;ADT String的表示与实现 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x2F;&#x2F;-----串的堆分配存储表示 -----</span><br><span class="line">typedefstruct&#123;</span><br><span class="line">char*ch;&#x2F;&#x2F;若是非空串，则按串长分配存储区，否则ch为NULL</span><br><span class="line">intlength;&#x2F;&#x2F;串长度</span><br><span class="line">&#125;HString;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-----基本操作的函数原型说明-----</span><br><span class="line">StatusStrAssign(HString &amp;T, char *chars);</span><br><span class="line">&#x2F;&#x2F;生成一个其值为串常量chars的串T</span><br><span class="line">intStrLength(HString S);</span><br><span class="line">&#x2F;&#x2F;返回S的元素个数，称为串的长度</span><br><span class="line">intStrCompare(HString S, HString T);</span><br><span class="line">&#x2F;&#x2F;若S&gt;T，则返回值&gt;0，若S&#x3D;T，则返回值&#x3D;0，若S&lt;T，则返回值&lt;0</span><br><span class="line">StatusClearString(HString &amp;S);</span><br><span class="line">&#x2F;&#x2F;将S清为空串，并释放S所占的空间</span><br><span class="line">StatusConcat(HString &amp;T, HString S1, HString S2);</span><br><span class="line">&#x2F;&#x2F;用T返回由S1和S2联接而成的新串</span><br><span class="line">HStringSubString(HString S, int pos, int len);</span><br><span class="line">&#x2F;&#x2F;1&lt;&#x3D;pos&lt;&#x3D;StrLength(S)且0&lt;&#x3D;len&lt;&#x3D;StrLength(S)-pos+1</span><br><span class="line">&#x2F;&#x2F;返回串S的第pos个字符起长度为len的子串</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-----基本操作的算法描述-----</span><br><span class="line">StatusStrAssign(HString &amp;T, char *chars)&#123;</span><br><span class="line">&#x2F;&#x2F;生成一个其值等于串常量chars的串T</span><br><span class="line">if(T.ch)</span><br><span class="line">free(T.ch);&#x2F;&#x2F;释放T原空间</span><br><span class="line">for(i&#x3D;0, c&#x3D;chars; *c; ++i, ++c)</span><br><span class="line">;&#x2F;&#x2F;求chars的长度i</span><br><span class="line">if(!i)&#123;</span><br><span class="line">T.ch &#x3D; NULL;</span><br><span class="line">T.length &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">if(!(T.ch&#x3D;(char *)malloc(i * sizeof(char))))</span><br><span class="line">exit(OVERFLOW);</span><br><span class="line">T.ch[0..i-1]&#x3D;chars[0..i-1];</span><br><span class="line">T.length &#x3D; i;</span><br><span class="line">&#125;</span><br><span class="line">returnOK;</span><br><span class="line">&#125;&#x2F;&#x2F;StrAssign</span><br><span class="line"></span><br><span class="line">intStrLength(HString S)&#123;</span><br><span class="line">&#x2F;&#x2F;返回S的元素个数，称为串的长度</span><br><span class="line">returnS.length;</span><br><span class="line">&#125;&#x2F;&#x2F;StrLength</span><br><span class="line"></span><br><span class="line">int StrCompare(HStringS, HStringT)&#123;</span><br><span class="line">&#x2F;&#x2F;若S&gt;T，则返回值&gt;0；若S&#x3D;T，则返回值&#x3D;0；若S&lt;T，则返回值&lt;0</span><br><span class="line">for(i&#x3D;0; i&lt;S.length&amp;&amp;S.T.length; ++i)</span><br><span class="line">if(S.ch[i]!&#x3D;T.ch[i])</span><br><span class="line">returnS.ch[i] - T.ch[i];</span><br><span class="line">returnS.length-T.length;</span><br><span class="line">&#125;&#x2F;&#x2F;StrCompare</span><br><span class="line"></span><br><span class="line">StatusClearString(HString&amp;S)&#123;</span><br><span class="line">&#x2F;&#x2F;将S清为空串</span><br><span class="line">if(S.ch)&#123;</span><br><span class="line">free(S.ch);</span><br><span class="line">S.ch &#x3D; NULL;</span><br><span class="line">&#125;</span><br><span class="line">S.length &#x3D; 0;</span><br><span class="line">returnOK;</span><br><span class="line">&#125;&#x2F;&#x2F;ClearString</span><br><span class="line"></span><br><span class="line">StatusConcat(HString&amp;T, HStringS1, HStringS2)&#123;</span><br><span class="line">&#x2F;&#x2F;用T返回由S1和S2联接而成的新串</span><br><span class="line">if(T.ch)</span><br><span class="line">free(T.ch);&#x2F;&#x2F;释放旧空间</span><br><span class="line">if(!(T.ch &#x3D; (char *)malloc((S1.length+S2.length) * sizeof(char))))</span><br><span class="line">exit(OVERFLOW);</span><br><span class="line">T.ch[0..S1.length-1] &#x3D; S1[0..S1.length-1];</span><br><span class="line">T.length &#x3D; S1.length + S2.length;</span><br><span class="line">T.ch[S1.length..T.length-1] &#x3D; S2.ch[0..S2.length-1];</span><br><span class="line">returnOK;</span><br><span class="line">&#125;&#x2F;&#x2F;Concat</span><br><span class="line"></span><br><span class="line">StatusSubString(HString &amp;Sub, HString S, int pos, int len)&#123;</span><br><span class="line">&#x2F;&#x2F;用Sub返回串S的第pos个字符起长度为len的子串</span><br><span class="line">&#x2F;&#x2F;其中，1&lt;&#x3D;pos&lt;&#x3D;StrLength(S)且0&lt;&#x3D;len&lt;&#x3D;StrLength(S)-pos+1</span><br><span class="line">if(pos &lt; 1 || pos &gt; S.length || len &lt; 0 || len &gt; S.length-pos+1)</span><br><span class="line">returnERROR;</span><br><span class="line">if(Sub.ch)</span><br><span class="line">free(Sub.ch);</span><br><span class="line">if(!len)&#123;</span><br><span class="line">Sub.ch &#x3D; NULL;</span><br><span class="line">Sub.length &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">Sub.ch &#x3D; (char *)malloc(len * sizeof(char));</span><br><span class="line">Sub.ch[0..len-1] &#x3D; S.ch[pos-1..pos+len-2];</span><br><span class="line">Sub.length &#x3D; len;</span><br><span class="line">&#125;</span><br><span class="line">returnOK;</span><br><span class="line">&#125;&#x2F;&#x2F;SubString</span><br></pre></td></tr></table></figure><p>串的块链结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;串的块链存储表示 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">#defineCHUNKSIZE80&#x2F;&#x2F;可由用户定义块的大小</span><br><span class="line">typedefstructChunk&#123;</span><br><span class="line">charch[CHUNKSIZE];</span><br><span class="line">structChunk*next;</span><br><span class="line">&#125;Chunk;</span><br><span class="line">typedefstruct&#123;</span><br><span class="line">Chunk*head, *tail;&#x2F;&#x2F;串的头和尾指针</span><br><span class="line">intcurlen;&#x2F;&#x2F;串的当前长度</span><br><span class="line">&#125;LString;</span><br></pre></td></tr></table></figure><p>求子串位置的定位函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">intIndex(SString S, SString T, intpos)&#123;</span><br><span class="line">&#x2F;&#x2F;返回子串T在主串S中第pos个字符之后的位置。若不存在，则函数值为0</span><br><span class="line">&#x2F;&#x2F;其中，T非空，1&lt;&#x3D;pos&lt;&#x3D;StrLength(S)</span><br><span class="line">i &#x3D; pos;</span><br><span class="line">j &#x3D; 1;</span><br><span class="line">while(i &lt;&#x3D; S[0] &amp;&amp; j &lt;&#x3D; T[0])&#123;</span><br><span class="line">if(S[i] &#x3D;&#x3D; T[j])&#123;</span><br><span class="line">++i;</span><br><span class="line">++j;</span><br><span class="line">&#125;&#x2F;&#x2F;继续比较后继字符</span><br><span class="line">else&#123;</span><br><span class="line">i &#x3D; i-j+2;</span><br><span class="line">j &#x3D; 1;</span><br><span class="line">&#125;&#x2F;&#x2F;指针后退重新开始匹配</span><br><span class="line">&#125;</span><br><span class="line">if(j &gt; T[0])</span><br><span class="line">returni-T[0];</span><br><span class="line">else</span><br><span class="line">return0;</span><br><span class="line">&#125;&#x2F;&#x2F;Index</span><br></pre></td></tr></table></figure><p>利用模式串的next()函数的KMP算法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">intIndex_KMP(SString S, SString T, intpos)&#123;</span><br><span class="line">&#x2F;&#x2F;利用模式串T的next函数求T在主串S中第pos个字符之后的位置的KMP算法</span><br><span class="line">&#x2F;&#x2F;其中，T非空，1&lt;&#x3D;pos&lt;&#x3D;StrLength(S)</span><br><span class="line">i &#x3D; pos;</span><br><span class="line">j &#x3D; 1;</span><br><span class="line">while(i &lt;&#x3D; S[0] &amp;&amp; j &lt;&#x3D; T[0])&#123;</span><br><span class="line">if( j &#x3D;&#x3D; 0 || S[i] &#x3D;&#x3D; T[j] )&#123;</span><br><span class="line">++i;</span><br><span class="line">++j;</span><br><span class="line">&#125;&#x2F;&#x2F;继续比较后继字符</span><br><span class="line">else</span><br><span class="line">j &#x3D; next[j];</span><br><span class="line">&#125;</span><br><span class="line">if(j &gt; T[0])</span><br><span class="line">returni - T[0];</span><br><span class="line">else</span><br><span class="line">return0;</span><br><span class="line">&#125;&#x2F;&#x2F;Index_KMP</span><br></pre></td></tr></table></figure><p>KMP算法中的next函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void get_next(SString T, int next[])&#123;</span><br><span class="line">&#x2F;&#x2F;求模式串T的next函数值并存入数组next</span><br><span class="line">i &#x3D; 1;</span><br><span class="line">next[1] &#x3D; 0;</span><br><span class="line">j &#x3D; 0;</span><br><span class="line">while(i &lt; T[0])&#123;</span><br><span class="line">if(j &#x3D;&#x3D; 0 || T[i] &#x3D;&#x3D; T[j])&#123;</span><br><span class="line">++i;</span><br><span class="line">++j;</span><br><span class="line">next[i] &#x3D; j;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">j &#x3D; next[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;get_next</span><br></pre></td></tr></table></figure><p>计算next函数修正值的算法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void get_nextval(SString T, int nextval[])&#123;</span><br><span class="line">&#x2F;&#x2F;求模式串T的next函数修正值并存入数组nextval</span><br><span class="line">i &#x3D; 1;</span><br><span class="line">nextval[1] &#x3D; 0;</span><br><span class="line">j &#x3D; 0;</span><br><span class="line">while(i&lt;T[0])&#123;</span><br><span class="line">if(j &#x3D;&#x3D; 0 || T[i] &#x3D;&#x3D; T[j])&#123;</span><br><span class="line">++i;</span><br><span class="line">++j;</span><br><span class="line">if(T[i] !&#x3D; T[j])</span><br><span class="line">nextval[i] &#x3D; j;</span><br><span class="line">else</span><br><span class="line">nextval[i] &#x3D; nextval[j];</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">j &#x3D; nextval[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;get_nextval</span><br></pre></td></tr></table></figure><p>词典索引表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#defineMaxBookNum1000&#x2F;&#x2F;假设只对1000本书建索引表</span><br><span class="line">#defineMaxKeyNum2500&#x2F;&#x2F;索引表的最大容量</span><br><span class="line">#defineMaxLineLen500&#x2F;&#x2F;书目串的最大长度</span><br><span class="line">#defineMaxWordNum10&#x2F;&#x2F;词表的最大容量</span><br><span class="line"></span><br><span class="line">typedefstruct&#123;</span><br><span class="line">char*item[];&#x2F;&#x2F;字符串的数组</span><br><span class="line">intlast;&#x2F;&#x2F;词表的长度</span><br><span class="line">&#125;WordListType;&#x2F;&#x2F;词表类型（顺序表）</span><br><span class="line">typedefintElemType;&#x2F;&#x2F;定义链表的数据元素类型为整型（书号类型）</span><br><span class="line">typedefstruct&#123;</span><br><span class="line">HStringkey;&#x2F;&#x2F;关键词</span><br><span class="line">LinkList bnolist;&#x2F;&#x2F;存放书号索引的链表</span><br><span class="line">&#125;IdxTermType;&#x2F;&#x2F;索引项类型</span><br><span class="line">typedefstruct&#123;</span><br><span class="line">IdxTermTypeitem[MaxKetNum+1];</span><br><span class="line">intlast;</span><br><span class="line">&#125;IdxListType;&#x2F;&#x2F;索引表类型（有序表）</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;主要变量</span><br><span class="line">char*buf;&#x2F;&#x2F;书目串缓冲区</span><br><span class="line">WordListTypewdlist;&#x2F;&#x2F;词表</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;基本操作</span><br><span class="line">voidInitIdxList(IdxListType&amp;idxlist);</span><br><span class="line">&#x2F;&#x2F;初始化操作，置索引表idxlist为空表，且在idxlist.item[0]设一空串</span><br><span class="line">voidGetLine(FILE f);</span><br><span class="line">&#x2F;&#x2F;从文件f读入一个书目信息到书目缓冲区buf</span><br><span class="line">voidExtractKeyWord(ElemType&amp;bno);</span><br><span class="line">&#x2F;&#x2F;从buf中提取书名关键词到词表wdlist，书号存入bno</span><br><span class="line">StatusInsIdxList(IdxListType &amp;idxlist, ElemType bno);</span><br><span class="line">&#x2F;&#x2F;将书号为bno的书名关键词按词典顺序插入索引表idxlist</span><br><span class="line">void PutText(FILE g, IdxListType idxlist);</span><br><span class="line">&#x2F;&#x2F;将生成的索引表idxlist输出到文件g</span><br><span class="line"></span><br><span class="line">void main()&#123;&#x2F;&#x2F;主函数</span><br><span class="line">if(f &#x3D; openf(&quot;BookInfo.txt&quot;,&quot;r&quot;))&#123;</span><br><span class="line">if(g &#x3D; openf(&quot;BookIdx.txt&quot;,&quot;w&quot;))&#123;</span><br><span class="line">InitIdxList(idxlist);&#x2F;&#x2F;初始化索引表idxlist为空表</span><br><span class="line">while(!feof(f))&#123;</span><br><span class="line">GetLine(f);&#x2F;&#x2F;从文件f读入一个书目信息到buf</span><br><span class="line">ExtractKeyWord(BookNo);&#x2F;&#x2F;从buf提取关键词到词表，书号存入BookNo</span><br><span class="line">InsIdxList(idxlist, BookNo);&#x2F;&#x2F;将书号为BookNo的关键词插入索引表</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">PutText(g, idxlist);&#x2F;&#x2F;将生成的索引表idxlist输出到文件g</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;main</span><br></pre></td></tr></table></figure><p>实现插入操作所必须函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">voidGetWord(int i, HString&amp;wd);</span><br><span class="line">&#x2F;&#x2F;用wd返回词表wdlist中第i个关键词</span><br><span class="line">intLocate(IdxListType idxlist, HString wd, Boolean &amp;b);</span><br><span class="line">&#x2F;&#x2F;在索引表idxlist中查询是否存在与wd相等的关键词</span><br><span class="line">&#x2F;&#x2F;若存在，则返回其在索引表中的位置，且b取值TRUE，否则返回插入位置，且b取值FALSE</span><br><span class="line">void InsertNewKey(IdxListType &amp;idxlist, int i, HString wd);</span><br><span class="line">&#x2F;&#x2F;在索引表idxlist的第i项上插入新关键词wd，并初始化书号索引的链表为空表</span><br><span class="line">StatusInsIdxList(IdxListType&amp;idxlist, int i, int bno);</span><br><span class="line">&#x2F;&#x2F;在索引表idxlist的第i项中插入书号为bno的索引</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;插入算法</span><br><span class="line">StatusInsIdxList(IdxListType &amp;idxlist, int bno)&#123;</span><br><span class="line">for(i&#x3D;0; i&lt;wdlist.last; ++i)&#123;</span><br><span class="line">GetWord(i, wd);</span><br><span class="line">j &#x3D; Locate(idxlist, wd, b);</span><br><span class="line">if(!b)</span><br><span class="line">InsertNewKey(idxlist, j, wd);&#x2F;&#x2F;插入新的索引项</span><br><span class="line">if(!InsertBook(idxlist,j,bno))</span><br><span class="line">returnOVERFLOW；&#x2F;&#x2F;插入书号索引</span><br><span class="line">&#125;</span><br><span class="line">returnOK;</span><br><span class="line">&#125;&#x2F;&#x2F;InsertIdxList</span><br><span class="line"></span><br><span class="line">void GetWord(int i, HString &amp;wd)&#123;</span><br><span class="line">p&#x3D; *(wd.list.item + i);&#x2F;&#x2F;取词表中第i个字符串</span><br><span class="line">StrAssign(wd,p);&#x2F;&#x2F;生成关键字字符串</span><br><span class="line">&#125;&#x2F;&#x2F;GetWord</span><br><span class="line"></span><br><span class="line">int Locate(IdxListType&amp;idxlist, HString wd, Boolean &amp;b)&#123;</span><br><span class="line">for(i &#x3D; idxlist.last - 1; (m &#x3D; StrCompare(idxlist.item[i].key, wd)) &gt; 0; --i)</span><br><span class="line">;</span><br><span class="line">if(m&#x3D;&#x3D;0)&#123;</span><br><span class="line">b &#x3D;TRUE;</span><br><span class="line">returni;&#x2F;&#x2F;找到</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">b &#x3D; FALSE;</span><br><span class="line">return i+1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;Locate</span><br><span class="line"></span><br><span class="line">void InsertNewKey(int i, StrType wd)&#123;</span><br><span class="line">for(j &#x3D; idxlist.last-1; j&gt;&#x3D;1; --j)&#x2F;&#x2F;后移索引项</span><br><span class="line">idxlist.item[j+1] &#x3D; idxlist.item[j];</span><br><span class="line">&#x2F;&#x2F;插入新的索引项</span><br><span class="line">StrCopy(idxlist.item[i].key, wd);&#x2F;&#x2F;串赋值</span><br><span class="line">InitList(idxlist.item[i].bnolist);&#x2F;&#x2F;初始化书号索引表为空表</span><br><span class="line">++idxlist.last;</span><br><span class="line">&#125;&#x2F;&#x2F;InsertNewKey</span><br><span class="line"></span><br><span class="line">StatusInsertBook(IdxListType &amp;idxlist, int i, int bno)&#123;</span><br><span class="line">if(!MakeNode(p, bno))</span><br><span class="line">returnERROR;&#x2F;&#x2F;分配失败</span><br><span class="line">Appand(idxlist.item[i].bnolist, p);&#x2F;&#x2F;插入新的书号索引</span><br><span class="line">returnOK;</span><br><span class="line">&#125;&#x2F;&#x2F;InserBook</span><br></pre></td></tr></table></figure><h2 id="数组与广义表"><a href="#数组与广义表" class="headerlink" title="数组与广义表"></a>数组与广义表</h2><p>数组的抽象数据类型定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ADTArray&#123;</span><br><span class="line">数据对象：ji&#x3D;0,...,bi-1,i &#x3D; 1,2,...,n</span><br><span class="line">D &#x3D; &#123;aj1j2...jn |n(&gt;0)称为数组的维数，bi是数组第i维的长度，ji是数组元素的第i维下标，aj1j2...jn∈ElemSet&#125;</span><br><span class="line">数据关系：R &#x3D; &#123;R1, R2, ..., Rn&#125;</span><br><span class="line">Ri &#x3D; &#123;&lt;aj1...ji...jn , aj1...ji+1...jn&gt;|0&lt;&#x3D;jk&lt;&#x3D;bk-1, 1&lt;&#x3D;k&lt;&#x3D;n且k≠i,0&lt;&#x3D;ji&lt;&#x3D;bi-2,aj1...ji...jn , aj1...ji+1...jn∈D, i&#x3D;2,...,n&#125;</span><br><span class="line">基本操作：</span><br><span class="line">InitArray(&amp;A, n, bound1, ..., boundn)</span><br><span class="line">操作结果：若维数n和各维长度合法，则构造相应数组A，并返回OK</span><br><span class="line">DestroyArray(&amp;A)</span><br><span class="line">操作结果：销毁数组A</span><br><span class="line">value(A, &amp;e, index1, ..., indexn)</span><br><span class="line">初始条件：A是n维数组，e为元素变量，随后是n个下标值</span><br><span class="line">操作结果：若各下标不超界，则e赋值为所指定的A的元素值，并返回OK</span><br><span class="line">Assign(&amp;A, e, index1, ..., indexn)</span><br><span class="line">初始条件：A是n维数组，e为元素变量，随后是n个下标</span><br><span class="line">操作结果：若下标不越界，则将e的值赋给所指定的A的元素，并返回OK</span><br><span class="line">&#125;ADT Array</span><br></pre></td></tr></table></figure><p>数组的顺序存储表示及实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;-----数组的顺序存储表示 -----</span><br><span class="line">#include&lt;stdio.h&gt;&#x2F;&#x2F;标准头文件，提供宏va_start、va_arg和va_end</span><br><span class="line">&#x2F;&#x2F;用于存取变长参数表</span><br><span class="line">#defineMAX_ARRAY_DIM8&#x2F;&#x2F;假设数组维数的最大值为8</span><br><span class="line">typedefstruct&#123;</span><br><span class="line">ElemType*base;&#x2F;&#x2F;数组元素基址，由InitArray分配</span><br><span class="line">intdim;&#x2F;&#x2F;数组维数</span><br><span class="line">int*bounds;&#x2F;&#x2F;数组维数基址，由InitArray分配</span><br><span class="line">int*constanst;&#x2F;&#x2F;数组映像函数常量基址，由InitArray分配</span><br><span class="line">&#125;Array;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-----基本操作的函数原型说明 -----</span><br><span class="line">StatusInitArray(Array&amp;A, intdim, ...);</span><br><span class="line">&#x2F;&#x2F;若维数dim和各维长度合法，则构造相应的数组A，并返回OK</span><br><span class="line">StatusDestroyArray(Array&amp;A);</span><br><span class="line">&#x2F;&#x2F;销毁数组A</span><br><span class="line">StatusValue(ArrayA, ElemType&amp;e, ...);</span><br><span class="line">&#x2F;&#x2F;A是n维数组，e为元素变量，随后是n个下标值</span><br><span class="line">&#x2F;&#x2F;若各下标不超界，则e的赋值给所指定的A的元素值，并返回OK</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-----基本操作的算法描述 -----</span><br><span class="line">StatusInitArray(Array&amp;A, int dim, ...)&#123;</span><br><span class="line">&#x2F;&#x2F;若维数dim和各维长度合法，则构造相应的数组A，并返回OK</span><br><span class="line">if(dim &lt; 1 || dim &gt; MAX_ARRAY_DIM)</span><br><span class="line">returnERROR;</span><br><span class="line">A.dim &#x3D; dim;</span><br><span class="line">A.bounds &#x3D; (int*)malloc(dim * sizeof( int ));</span><br><span class="line">if(!A.bounds)</span><br><span class="line">exit(OVERFLOW);</span><br><span class="line">&#x2F;&#x2F;若各维长度合法，则存入A.bounds，并求出A的元素总数elemtotal</span><br><span class="line">elemtotal &#x3D; 1;</span><br><span class="line">va_start(ap, dim);&#x2F;&#x2F;ap为va_list类型，是存放变长参数表信息的数组</span><br><span class="line">for(i &#x3D; 0; i&lt;dim; ++i)&#123;</span><br><span class="line">A.bounds[i] &#x3D; va_arg(ap, int);</span><br><span class="line">if(A.bounds[i]&lt;0)</span><br><span class="line">returnUNDERFLOW;</span><br><span class="line">elemtotal *&#x3D; A.bounds[i];</span><br><span class="line">&#125;</span><br><span class="line">va_end(ap);</span><br><span class="line">A.base &#x3D; (ElemType*)malloc(elemtotal * sizeof(ElemType));</span><br><span class="line">if(!A.base)</span><br><span class="line">exit(OVERFLOW);</span><br><span class="line">&#x2F;&#x2F;求映像函数的常数c，并存入A.constants[i-1], i &#x3D; 1,...,dim</span><br><span class="line">A.constants &#x3D; (int *)malloc(dim * sizeof(int));</span><br><span class="line">if(!A.constants)</span><br><span class="line">exit(OVERFLOW);</span><br><span class="line">A.constants[dim-1] &#x3D; 1;&#x2F;&#x2F;L&#x3D;1，指针的增减以元素的大小为单位</span><br><span class="line">for( i &#x3D; dim-2; i&gt;&#x3D;0; --i )</span><br><span class="line">A.constants[i] &#x3D; A.bounds[i + 1] * A.constants[i + 1];</span><br><span class="line">returnOK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StatusDestroyArray(Array&amp;A)&#123;</span><br><span class="line">&#x2F;&#x2F;销毁数组A</span><br><span class="line">if(！A.base)</span><br><span class="line">returnERROR;</span><br><span class="line">free(A.base);</span><br><span class="line">A.base &#x3D; NULL;</span><br><span class="line">if(A.bounds)</span><br><span class="line">returnERROR;</span><br><span class="line">free(A.bounds);</span><br><span class="line">A.bounds &#x3D; NULL;</span><br><span class="line">if(!A.constants)</span><br><span class="line">returnERROR;</span><br><span class="line">free(A.constants);</span><br><span class="line">A.constants &#x3D; NULL;</span><br><span class="line">returnOK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StatusLocate(Array A, va_list ap, int&amp;off)&#123;</span><br><span class="line">&#x2F;&#x2F;若ap指示的各下标值合法，则求出该元素在A中的相对地址off</span><br><span class="line">off &#x3D; 0;</span><br><span class="line">for( i &#x3D; 0; i&lt;A.dim; ++i)&#123;</span><br><span class="line">ind &#x3D; va_arg(ap, int);</span><br><span class="line">if(ind&lt;0 || ind&gt;&#x3D;A.bounds[i])</span><br><span class="line">returnOVERFLOW;</span><br><span class="line">off +&#x3D; A.constants[i] * ind;</span><br><span class="line">&#125;</span><br><span class="line">returnOK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StatusValue(Array A, ElemType&amp;e, ...)&#123;</span><br><span class="line">&#x2F;&#x2F;A是n维数组，e为元素变量，随后是n个下标值</span><br><span class="line">&#x2F;&#x2F;若各下标值不超界，则e赋值为所指定的A的元素值，并返回OK</span><br><span class="line">va_start(ap, e);</span><br><span class="line">if((result &#x3D; Locate(A, ap, off))&lt;&#x3D;0)</span><br><span class="line">returnresult;</span><br><span class="line">e &#x3D; *(A.base + off);</span><br><span class="line">returnOK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StatusAssign(Array &amp;A, ElemType e, ...)&#123;</span><br><span class="line">&#x2F;&#x2F;A是n维数组，e为元素变量，随后是n个下标值</span><br><span class="line">&#x2F;&#x2F;若下标不超界，则将e的值赋给所指定的A的元素，并返回OK</span><br><span class="line">va_start(ap, e);</span><br><span class="line">if((result &#x3D; Locate(A, ap, off))&lt;&#x3D;0)</span><br><span class="line">returnresult;</span><br><span class="line">*(A.base + off) &#x3D; e;</span><br><span class="line">returnOK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>稀疏矩阵的抽象数据类型定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">ADTSparseMatrix&#123;</span><br><span class="line">数据对象：D &#x3D; &#123;aij|i &#x3D; 1,2,...,n;ai,j∈ElemSet，m和n分别称为矩阵的行数和列数&#125;</span><br><span class="line">数据关系：R &#x3D; &#123;Row, Col&#125;</span><br><span class="line">Row &#x3D; &#123;&lt;ai,j,ai,j+1&gt;| 1&lt;&#x3D;i&lt;&#x3D;m, 1&lt;&#x3D;j&lt;&#x3D;n-1&#125;</span><br><span class="line">Col &#x3D; &#123;&lt;ai,j,ai+1,j&gt;| 1&lt;&#x3D;i&lt;&#x3D;m-1, 1&lt;&#x3D;j&lt;&#x3D;n&#125; </span><br><span class="line">基本操作：</span><br><span class="line">CreateSMatrix(&amp;M);</span><br><span class="line">操作结果：创建稀疏矩阵M</span><br><span class="line">DestroySMatrix(&amp;M);</span><br><span class="line">初始条件：稀疏矩阵M存在</span><br><span class="line">操作结果：销毁稀疏矩阵M</span><br><span class="line">PrintSMatrix(M);</span><br><span class="line">初始条件：稀疏矩阵M存在</span><br><span class="line">操作结果：输出稀疏矩阵M</span><br><span class="line">CopySMatrix(M, &amp;T);</span><br><span class="line">初始条件：稀疏矩阵M存在</span><br><span class="line">操作结果：由稀疏矩阵M复制得到T</span><br><span class="line">AddSMatrix(M, N, &amp;Q);</span><br><span class="line">初始条件：稀疏矩阵M与N的行数与列数对应相等</span><br><span class="line">操作结果：求稀疏矩阵的和Q &#x3D; M + N</span><br><span class="line">SubSMatrix(M, N, &amp;Q);</span><br><span class="line">初始条件：稀疏矩阵M与N的行数与列数对应相等</span><br><span class="line">操作结果：求稀疏矩阵的差Q &#x3D; M - N</span><br><span class="line">MultSMatrix(M, N, &amp;Q);</span><br><span class="line">初始条件：稀疏矩阵M的列数等于N的行数</span><br><span class="line">操作结果：求稀疏矩阵乘积Q &#x3D; M * N</span><br><span class="line">TransposeSmatrix(M, &amp;T);</span><br><span class="line">初始条件：稀疏矩阵M存在</span><br><span class="line">操作结果：求稀疏矩阵M的转置矩阵T</span><br><span class="line">&#125;ADT SparseMatrix</span><br></pre></td></tr></table></figure><p>稀疏矩阵的三元组表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;-----稀疏矩阵的三元组顺序表存储表示-----</span><br><span class="line">#defineMAXSIZE12500&#x2F;&#x2F;假设非零元个数的最大值为12500</span><br><span class="line">typedefstruct&#123;</span><br><span class="line">inti, j;&#x2F;&#x2F;该非零元的行下标和列下标</span><br><span class="line">ElemTypee;</span><br><span class="line">&#125;Triple</span><br><span class="line">typedefstruct&#123;</span><br><span class="line">Tripledata[MAXSIZE + 1];&#x2F;&#x2F;非零元三元组表，data[0]未用</span><br><span class="line">intmu, nu, tu;&#x2F;&#x2F;矩阵的行数，列数和非零元个数</span><br><span class="line">&#125;TSMatrix;</span><br></pre></td></tr></table></figure><p>三元组表示求稀疏矩阵的转置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">StatusTransposeSMatrix(TSMatrix M, TSMatrix &amp;T)&#123;</span><br><span class="line">&#x2F;&#x2F;采用三元组表存储表示，求稀疏矩阵M的转置矩阵T</span><br><span class="line">T.mu &#x3D; M.nu;</span><br><span class="line">T.nu &#x3D; M.nu;</span><br><span class="line">T.tu &#x3D; M.tu;</span><br><span class="line">if(T.tu)&#123;</span><br><span class="line">q &#x3D; 1;</span><br><span class="line">for(col &#x3D; 1; col&lt;&#x3D;M.nu; ++col)&#123;</span><br><span class="line">for(p &#x3D; 1; p&lt;&#x3D;M.tu; ++p)&#123;</span><br><span class="line">if(M.data[p].j &#x3D;&#x3D; col)&#123;</span><br><span class="line">T.data[q].i &#x3D; M.data[p].j;</span><br><span class="line">T.data[q].j &#x3D; M.data[p].i;</span><br><span class="line">T.data[q].e &#x3D; M.data[p].e;</span><br><span class="line">++q;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">returnOK;</span><br><span class="line">&#125;&#x2F;&#x2F;TransposeSMatrix</span><br></pre></td></tr></table></figure><p>快速转置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">StatusFastTransposeSMatrix(TSMatrix M, TSMatrix &amp;T)&#123;</span><br><span class="line">&#x2F;&#x2F;采用三元组顺序表存储表示，求稀疏矩阵M的转置矩阵T</span><br><span class="line">T.mu &#x3D; M.nu;</span><br><span class="line">T.nu &#x3D; M.mu;</span><br><span class="line">T.tu &#x3D; M.tu;</span><br><span class="line">if(T.tu)&#123;</span><br><span class="line">for(col &#x3D; 1; col&lt;&#x3D;M.nu; ++col)</span><br><span class="line">num[col] &#x3D; 0;</span><br><span class="line">for(t &#x3D; 1; t&lt;&#x3D;M.tu; ++t)</span><br><span class="line">++num[M.data[t].j];&#x2F;&#x2F;求M中每一列含非零元个数</span><br><span class="line">cpot[1] &#x3D; 1;</span><br><span class="line">&#x2F;&#x2F;求第col列中第一个非零元在b.data中的序号</span><br><span class="line">for(col &#x3D; 2; col&lt;&#x3D;M.nu; ++col)</span><br><span class="line">cpot[col] &#x3D; cpot[col - 1] + num[col - 1];</span><br><span class="line">for(p &#x3D; 1; p&lt;&#x3D;M.tu; ++p)&#123;</span><br><span class="line">col &#x3D; M.data[p].j;</span><br><span class="line">q &#x3D; cpot[col];</span><br><span class="line">T.data[q].i &#x3D; M.data[p].j;</span><br><span class="line">T.data[q].j &#x3D; M.data[p].i;</span><br><span class="line">T.data[q].e &#x3D; M.data[p].e;</span><br><span class="line">++cpot[col];</span><br><span class="line">&#125;&#x2F;&#x2F;for</span><br><span class="line">&#125;&#x2F;&#x2F;if</span><br><span class="line">returnOK;</span><br><span class="line">&#125;&#x2F;&#x2F;FastTransposeSmatrix</span><br></pre></td></tr></table></figure><p>行逻辑链接的顺序表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedefstruct&#123;</span><br><span class="line">Tripledata[MAXSIZE + 1];&#x2F;&#x2F;非零元三元组表</span><br><span class="line">intrpos[MAXRC + !];&#x2F;&#x2F;各行第一个非零元的位置表</span><br><span class="line">intmu, nu, tu;&#x2F;&#x2F;矩阵的行数、列数和非零元个数</span><br><span class="line">&#125;RLSMatrix;</span><br></pre></td></tr></table></figure><p>两个矩阵相乘的过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Q初始化;</span><br><span class="line">if(Q是非零矩阵)&#123;&#x2F;&#x2F;逐行压缩</span><br><span class="line">for(arow &#x3D; 1; arow&lt;&#x3D;M.mu; ++arow)&#123;&#x2F;&#x2F;处理M的每一行</span><br><span class="line">ctemp[ ] &#x3D; 0;&#x2F;&#x2F;累加器清零</span><br><span class="line">计算Q中第arow行的积并存入ctemp[ ]中;</span><br><span class="line">将ctemp[ ]中的非零元压缩存储到Q.data;</span><br><span class="line">&#125;&#x2F;&#x2F;forarow</span><br><span class="line">&#125;&#x2F;&#x2F;if</span><br></pre></td></tr></table></figure><p>求精后可得：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">StatusMultSMatrix(RLSMatrix M, RLSMatrix N, RLSMatrix&amp;Q)&#123;</span><br><span class="line">&#x2F;&#x2F;求矩阵乘积Q &#x3D; M * N，采用行逻辑链接存储表示</span><br><span class="line">if(M.nu !&#x3D; N.mu)</span><br><span class="line">returnERROR;</span><br><span class="line">Q.mu &#x3D; M.mu;</span><br><span class="line">Q.nu &#x3D; N.nu;</span><br><span class="line">Q.tu &#x3D; 0;&#x2F;&#x2F;Q初始化</span><br><span class="line">if(M.tu * N.tu !&#x3D; 0)&#123;&#x2F;&#x2F;Q是非零矩阵</span><br><span class="line">for(arow &#x3D; 1; arow&lt;&#x3D;M.mu; ++arow)&#123;&#x2F;&#x2F;处理M的每一行</span><br><span class="line">ctemp[ ] &#x3D; 0;&#x2F;&#x2F;当前行各元素累加器清零</span><br><span class="line">Q.rpos[arow] &#x3D; Q.tu + 1;</span><br><span class="line">if(arow&lt;M.mu)</span><br><span class="line">tp &#x3D; M.rpos[arow + 1];</span><br><span class="line">else&#123;</span><br><span class="line">tp &#x3D; M.tu + 1;</span><br><span class="line">&#125;</span><br><span class="line">for(p &#x3D; M.rpos[arow]; p&lt;tp; ++p)&#123;&#x2F;&#x2F;对当前行中每一个非零元</span><br><span class="line">brow &#x3D; M.data[p].j;&#x2F;&#x2F;找到对应元在N中的行号</span><br><span class="line">if(brow &lt; N.mu)</span><br><span class="line">t &#x3D; N.rpos[brow + 1];</span><br><span class="line">else&#123;</span><br><span class="line">t &#x3D; N.tu + 1;</span><br><span class="line">&#125;</span><br><span class="line">for(q &#x3D; N.rpos[brow]; q&lt;t; ++q)&#123;</span><br><span class="line">ccol &#x3D; N.data[q].j;&#x2F;&#x2F;乘积元素在Q中列号</span><br><span class="line">ctemp[ccol] +&#x3D; M.data[p].e * N.data[q].e;</span><br><span class="line">&#125;&#x2F;&#x2F;for q</span><br><span class="line">&#125;&#x2F;&#x2F;求得Q中第crow( &#x3D;arow)行的非零元</span><br><span class="line">for(ccol &#x3D; 1; ccol&lt;&#x3D;Q.nu; ++ccol)&#x2F;&#x2F;压缩存储该行非零元</span><br><span class="line">if(ctemp[ccol])&#123;</span><br><span class="line">if( ++Q.tu &gt; MAXSIZE)</span><br><span class="line">returnERROR;</span><br><span class="line">Q.data[Q.tu] &#x3D; (arow, ccol, ctemp[ccol]);</span><br><span class="line">&#125;&#x2F;&#x2F;if</span><br><span class="line">&#125;&#x2F;&#x2F;for arow</span><br><span class="line">&#125;&#x2F;&#x2F;if</span><br><span class="line">returnOK;</span><br><span class="line">&#125;&#x2F;&#x2F;MultSMatrix</span><br></pre></td></tr></table></figure><p>稀疏矩阵的十字链表存储表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;-----稀疏矩阵的十字链表存储表示 -----</span><br><span class="line">typedefstruct OLNode&#123;</span><br><span class="line">inti, j;&#x2F;&#x2F;该非零元的行和列下标</span><br><span class="line">ElemTypee;</span><br><span class="line">structOLNode*right, *down;&#x2F;&#x2F;该非零元所在行表和列表的后继链域</span><br><span class="line">&#125;OLNode;*OLink;</span><br><span class="line"></span><br><span class="line">typedefstruct&#123;</span><br><span class="line">Olink*rhead, *chead;&#x2F;&#x2F;行和列链表的头指针向量基址，由CreatSMatrix分配</span><br><span class="line">intmu, nu, tu;&#x2F;&#x2F;稀疏矩阵的行数、列数和非零元个数</span><br><span class="line">&#125;CrossList;</span><br><span class="line"></span><br><span class="line">StatusCreatSMatrix_OL(CrossList &amp;M)&#123;</span><br><span class="line">&#x2F;&#x2F;创建稀疏矩阵，用十字链表存储表示</span><br><span class="line">if(M)</span><br><span class="line">free(M);</span><br><span class="line">scanf(&amp;m, &amp;n, &amp;t);&#x2F;&#x2F;输入m的行数、列数和非零元个数</span><br><span class="line">M.mu :&#x3D; m；</span><br><span class="line">M.nu :&#x3D; n;</span><br><span class="line">M.tu :&#x3D; t;</span><br><span class="line">if(!(M.rhead &#x3D; (OLink *)malloc((m + 1) * sizeof(OLink))))</span><br><span class="line">exit(OVERFLOW);</span><br><span class="line">if(!(M.chead &#x3D; (OLink *)malloc((m + 1) * sizeof(OLink))))</span><br><span class="line">exit(OVERFLOW);</span><br><span class="line">M.rhead[ ] &#x3D; M.chead[ ] &#x3D; NULL;&#x2F;&#x2F;初始化行列头指针向量；各行列链表为空链表</span><br><span class="line">for(scanf(&amp;i, &amp;j, &amp;e); i!&#x3D;0; scanf(&amp;i, &amp;j, &amp;e))&#123;&#x2F;&#x2F;按任意次序输入非零元</span><br><span class="line">if(!(p &#x3D; (OLNode *)malloc(sizeof(OLNode))))</span><br><span class="line">exit(OVERFLOW);</span><br><span class="line">p-&gt;i &#x3D; i;</span><br><span class="line">p-&gt;j &#x3D; j;</span><br><span class="line">p-&gt;e &#x3D; e;&#x2F;&#x2F;生成结点</span><br><span class="line">if(M.rhead[i] &#x3D;&#x3D; NULL || M.rhead[i]-&gt;j&gt;j)&#123;</span><br><span class="line">p-&gt;right &#x3D; M.rhead[i];</span><br><span class="line">M.rhead[i] &#x3D; p;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;&#x2F;&#x2F;巡查在行表中的插入位置</span><br><span class="line">for( q &#x3D; M.rhead[i]; (q-&gt;right) &amp;&amp; q-&gt;right-&gt;j&lt;j; q &#x3D; q-&gt;right)</span><br><span class="line">;</span><br><span class="line">p-&gt;right &#x3D; q-&gt;right;</span><br><span class="line">q-&gt;rignt &#x3D; p;</span><br><span class="line">&#125;&#x2F;&#x2F;完成行插入</span><br><span class="line">if(M.chead[j] &#x3D;&#x3D; NULL || M.chead[j]-&gt;i&gt;i)&#123;</span><br><span class="line">p-&gt;down &#x3D; M.chead[j];</span><br><span class="line">M.chead[j] &#x3D; p;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;&#x2F;&#x2F;巡查在列表中的插入位置</span><br><span class="line">for( q &#x3D; M.chead[i]; (q-&gt;down) &amp;&amp; q-&gt;down-&gt;i&lt;i; q &#x3D; q-&gt;down)</span><br><span class="line">;</span><br><span class="line">p-&gt;down &#x3D; q-&gt;down;</span><br><span class="line">q-&gt;down &#x3D; p;</span><br><span class="line">&#125;&#x2F;&#x2F;完成列插入</span><br><span class="line">&#125;</span><br><span class="line">returnOK;</span><br><span class="line">&#125;&#x2F;&#x2F;CreateSMatrix_OL</span><br></pre></td></tr></table></figure><p>广义表的抽象数据类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">ADTGList&#123;</span><br><span class="line">数据对象：D &#x3D; &#123;ei|i &#x3D; 1,2,...,n;ei∈AtomSet或ei∈GList,AtomSet为某个元素的数据对象&#125;</span><br><span class="line">数据关系：R1 &#x3D; &#123;&lt;ei-1, ei&gt;|ei-1,ei∈D, 2&lt;&#x3D;i&lt;&#x3D;n&#125;</span><br><span class="line">基本操作：</span><br><span class="line">InitGList(&amp;L);</span><br><span class="line">操作结果：创建空间的广义表L</span><br><span class="line">CreateGList(&amp;L, S);</span><br><span class="line">初始条件：S是广义表的书写形式串</span><br><span class="line">操作结果：由S创建广义表L</span><br><span class="line">DestroyGList(&amp;L);</span><br><span class="line">初始条件：广义表L存在</span><br><span class="line">操作结果：销毁广义表L</span><br><span class="line">CopyGList(&amp;T, L);</span><br><span class="line">初始条件：广义表L存在</span><br><span class="line">操作结果：由广义表L复制得到广义表T</span><br><span class="line">GListLength(L);</span><br><span class="line">初始条件：广义表L存在</span><br><span class="line">操作结果：求广义表的长度，即元素个数</span><br><span class="line">GListDepth(L);</span><br><span class="line">初始条件：广义表L存在</span><br><span class="line">操作结果：求广义表的深度</span><br><span class="line">GListEmpty(L);</span><br><span class="line">初始条件：广义表L存在</span><br><span class="line">操作结果：判定广义表L是否为空</span><br><span class="line">GetHead(L);</span><br><span class="line">初始条件：广义表L存在</span><br><span class="line">操作结果：取广义表L的头</span><br><span class="line">GetTail(L);</span><br><span class="line">初始条件：广义表L存在</span><br><span class="line">操作结果：取广义表L的尾</span><br><span class="line">InsertFirst_GL(&amp;L, &amp;e);</span><br><span class="line">初始条件：广义表L存在</span><br><span class="line">操作结果：插入元素e作为广义表的第一元素</span><br><span class="line">DeleteFirst_GL(&amp;L, &amp;e);</span><br><span class="line">初始条件：广义表L存在</span><br><span class="line">操作结果：删除广义表的第一元素，并用e返回其值</span><br><span class="line">Traverse_GL(L, Visit());</span><br><span class="line">初始条件：广义表L存在</span><br><span class="line">操作结果：遍历广义表L，用函数Visit处理每个元素</span><br><span class="line">&#125;ADTGList</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;数据结构算法合集（C语言版）&quot;&gt;&lt;a href=&quot;#数据结构算法合集（C语言版）&quot; class=&quot;headerlink&quot; title=&quot;数据结构算法合集（C语言版）&quot;&gt;&lt;/a&gt;数据结构算法合集（C语言版）&lt;/h1&gt;&lt;p&gt;在学习《数据结构（C语言版）》一书时，我将其中的算法在此记录，以便有需要时进行查阅。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>准备工作</title>
    <link href="http://yoursite.com/2020/11/27/%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/"/>
    <id>http://yoursite.com/2020/11/27/%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/</id>
    <published>2020-11-27T04:30:15.825Z</published>
    <updated>2020-05-11T05:06:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是搭建个人博客的前提，<strong>重中之重</strong>。</p><a id="more"></a><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="git账号的注册"><a href="#git账号的注册" class="headerlink" title="git账号的注册"></a>git账号的注册</h2><p>这一步不必过多赘述，直接到<a href="https://github.com/" target="_blank" rel="noopener">git官网</a>进行注册即可。</p><h2 id="git-bash的安装"><a href="#git-bash的安装" class="headerlink" title="git bash的安装"></a>git bash的安装</h2><p>建议在<a href="https://gitforwindows.org/" target="_blank" rel="noopener">git bash for windows</a>下载并默认安装。</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200507153851645.png" alt="image-20200507153851645"></p><h2 id="node-js的下载安装"><a href="#node-js的下载安装" class="headerlink" title="node.js的下载安装"></a>node.js的下载安装</h2><p>先在<a href="http://nodejs.org/zh-cn" target="_blank" rel="noopener">http://nodejs.org/zh-cn</a>下载，建议下载长期支持版，之后按照提示默认安装即可（也可更改安装目录，取决于自身），win+r打开运行框，输入cmd运行，在命令框中输入node -v,如出现版本号证明已安装好.</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200507153937372.png" alt="image-20200507153937372"></p><h2 id="npm的安装"><a href="#npm的安装" class="headerlink" title="npm的安装"></a>npm的安装</h2><p>在git bash中输入以下代码安装hexo：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo</span><br></pre></td></tr></table></figure><p>至此，准备工作基本完成。</p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>会出现以下结果：</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200507234805322.png" alt="image-20200507234805322"></p><p>如图所示出现版本号证明安装完毕。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是搭建个人博客的前提，&lt;strong&gt;重中之重&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>我在链表中出现的问题</title>
    <link href="http://yoursite.com/2020/11/27/%E6%88%91%E5%9C%A8%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/11/27/%E6%88%91%E5%9C%A8%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2020-11-27T04:30:15.824Z</published>
    <updated>2020-05-19T06:55:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="我在链表中出现的问题："><a href="#我在链表中出现的问题：" class="headerlink" title="我在链表中出现的问题："></a>我在链表中出现的问题：</h1><p>链表是一种比较基础的数据结构，与数组相比，各有优劣，链表更利于删除数据，但数组更便于访问数据。</p><p>当我初学链表时犯过以下错误：</p><a id="more"></a><p>此处以学生成绩系统为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct stuent</span><br><span class="line">&#123;</span><br><span class="line">char name[9];&#x2F;&#x2F;名称</span><br><span class="line">int score;&#x2F;&#x2F;成绩</span><br><span class="line">struct student *next;&#x2F;&#x2F;下一节点</span><br><span class="line">&#125;Stu;</span><br><span class="line">&#x2F;&#x2F;此处用typedef是为了后续方便，可用可不用</span><br></pre></td></tr></table></figure><h2 id="忘记循环申请新节点空间"><a href="#忘记循环申请新节点空间" class="headerlink" title="忘记循环申请新节点空间"></a>忘记循环申请新节点空间</h2><p>在链表的构建中，我将新节点插入到链表之中后，往往会忘记再次为新节点申请空间，这就导致为节点赋值时程序出现bug。</p><h2 id="头插法和尾插法分不清"><a href="#头插法和尾插法分不清" class="headerlink" title="头插法和尾插法分不清"></a>头插法和尾插法分不清</h2><p>头插法是直接将新节点插入到头节点之后，这就导致在使用头插法插入节点的过程中先插入的反而后输出；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;头插法</span><br><span class="line">for(int i &#x3D; 0;i &lt; n;i++)&#x2F;&#x2F;此处n为你要添加的节点个数</span><br><span class="line">&#123;</span><br><span class="line">new &#x3D; (Stu *)malloc(sizeof(Stu));&#x2F;&#x2F;此处的Stu是你定义的结构体类型名称</span><br><span class="line">new-&gt;name &#x3D; x;&#x2F;&#x2F;x代表学生姓名</span><br><span class="line">new-&gt;score &#x3D; y;&#x2F;&#x2F;y代表学生成绩</span><br><span class="line">new-&gt;next &#x3D; head-&gt;next;</span><br><span class="line">head-&gt;next &#x3D; new;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尾插法与头插法相比略微有些麻烦，因为尾插法还需要一个尾节点，插入过程中便是将新节点插入到尾节点之后,但要注意必须首先找到尾节点所在。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">tail &#x3D; head;</span><br><span class="line">while(tail-&gt;next !&#x3D; NULL)&#x2F;&#x2F;找到尾节点所在</span><br><span class="line">&#123;</span><br><span class="line">tail &#x3D; tail-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;尾插法</span><br><span class="line">for(int i &#x3D; 0;i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">new &#x3D; (Stu *)malloc(sizeof(Stu));</span><br><span class="line">new-&gt;name &#x3D; x;</span><br><span class="line">new-&gt;score &#x3D; y;</span><br><span class="line">new-&gt;next &#x3D; tail-&gt;next;&#x2F;&#x2F;连接新节点与NULL(new-&gt;next &#x3D; NULL;)</span><br><span class="line">tail-&gt;next &#x3D; new;&#x2F;&#x2F;连接尾节点与新节点</span><br><span class="line">tail &#x3D; new;&#x2F;&#x2F;之后以新节点作为尾节点(tail &#x3D; tail-&gt;next;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>暂时先写这么多，日后补充。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;我在链表中出现的问题：&quot;&gt;&lt;a href=&quot;#我在链表中出现的问题：&quot; class=&quot;headerlink&quot; title=&quot;我在链表中出现的问题：&quot;&gt;&lt;/a&gt;我在链表中出现的问题：&lt;/h1&gt;&lt;p&gt;链表是一种比较基础的数据结构，与数组相比，各有优劣，链表更利于删除数据，但数组更便于访问数据。&lt;/p&gt;
&lt;p&gt;当我初学链表时犯过以下错误：&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>选取合适主题，美化博客</title>
    <link href="http://yoursite.com/2020/11/27/%E9%80%89%E5%8F%96%E5%90%88%E9%80%82%E4%B8%BB%E9%A2%98%EF%BC%8C%E7%BE%8E%E5%8C%96%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2020/11/27/%E9%80%89%E5%8F%96%E5%90%88%E9%80%82%E4%B8%BB%E9%A2%98%EF%BC%8C%E7%BE%8E%E5%8C%96%E5%8D%9A%E5%AE%A2/</id>
    <published>2020-11-27T04:30:15.824Z</published>
    <updated>2020-05-07T16:17:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>可以看到，我们博客的主题十分单调，并不好看，因此我们需要为我们的博客更换主题，这里我推荐next主题，它是目前应用较多的hexo主题。</p><a id="more"></a><h1 id="选取合适主题，美化博客"><a href="#选取合适主题，美化博客" class="headerlink" title="选取合适主题，美化博客"></a>选取合适主题，美化博客</h1><h2 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h2><p>打开博客根目录进入git bash，输入以下代码下载next主题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure><p>等待安装完成。</p><h2 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h2><h3 id="根目录配置"><a href="#根目录配置" class="headerlink" title="根目录配置"></a>根目录配置</h3><p>打开博客根目录中的_config.yml文件，找到其中的theme字段，将其值改为next，之后可根据需要更改#site字段下的内容，比如title（文章标题），description（简介或格言），author（网站作者），language（主题语言），timezone（时区）。</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200508000724611.png" alt="image-20200508000724611"></p><p>依旧注意冒号后的空格，如果有一对单引号，直接将内容填至单引号中即可，主题语言打开themes/next/language中查看。</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200508000808782.png" alt="image-20200508000808782"></p><h3 id="修改主题配置文件"><a href="#修改主题配置文件" class="headerlink" title="修改主题配置文件"></a>修改主题配置文件</h3><p>在由于next主题有四种类型，Muse、Mist、Pisces、Gemini，默认为Muse，如需更改，只要打开根目录/themes/next下的_config,yml，找到#Scheme字段，将你需要的主题前的#删除即可，记得其它三个主题前必须要有#。</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200508000927983.png" alt="image-20200508000927983"></p><h2 id="展示"><a href="#展示" class="headerlink" title="展示"></a>展示</h2><p>回到根目录打开git bash，输入以下指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><p>完成后你的博客主题便已经更改完毕。</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200508001021436.png" alt="image-20200508001021436"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;可以看到，我们博客的主题十分单调，并不好看，因此我们需要为我们的博客更换主题，这里我推荐next主题，它是目前应用较多的hexo主题。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>使用虚拟机时碰到的问题</title>
    <link href="http://yoursite.com/2020/11/27/%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%97%B6%E7%A2%B0%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/11/27/%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%97%B6%E7%A2%B0%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2020-11-27T04:30:15.823Z</published>
    <updated>2020-06-04T04:34:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>在使用VBOX创建虚拟机的过程中，我发现我的虚拟机无法连接上网络，因此记录下我的解决方法。</p><a id="more"></a><h1 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h1><p>我的VBOX是6.1.8版本，虚拟机安装的系统为CentOS 8.0版本，如果版本不同，解决方式可能略有不同。</p><h1 id="CentOS中常用的进行网络设置的代码"><a href="#CentOS中常用的进行网络设置的代码" class="headerlink" title="CentOS中常用的进行网络设置的代码"></a>CentOS中常用的进行网络设置的代码</h1><p>重启网络服务的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection reload</span><br></pre></td></tr></table></figure><p>查看基本网络参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure><p>检查默认网关地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route -n</span><br></pre></td></tr></table></figure><p>检查DNS服务器地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;resolv.conf</span><br></pre></td></tr></table></figure><p>可视化配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmtui</span><br></pre></td></tr></table></figure><h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><p>我一开始使用的是net连接模式，但尝试了很多次都无法正确连上网，之后我将注意力转移到了桥接模式，这里记录以下我是如何使用仅主机网络模式将虚拟机连上网的。</p><h3 id="虚拟机使用仅主机网络联网"><a href="#虚拟机使用仅主机网络联网" class="headerlink" title="虚拟机使用仅主机网络联网"></a>虚拟机使用仅主机网络联网</h3><h4 id="1-首先将虚拟机网络与计算机已经连接好的网络进行桥接"><a href="#1-首先将虚拟机网络与计算机已经连接好的网络进行桥接" class="headerlink" title="1.首先将虚拟机网络与计算机已经连接好的网络进行桥接"></a>1.首先将虚拟机网络与计算机已经连接好的网络进行桥接</h4><p>依次打开电脑的“控制面板”–&gt;“网络和Internet”–&gt;“网络连接”查看当前计算机的网络连接，之后选择计算机已经连上的网络以及虚拟机的网卡，右键选择桥接。</p><h4 id="2-将虚拟机的网络连接方式设置为仅主机"><a href="#2-将虚拟机的网络连接方式设置为仅主机" class="headerlink" title="2.将虚拟机的网络连接方式设置为仅主机"></a>2.将虚拟机的网络连接方式设置为仅主机</h4><p>打开VBOX虚拟机管理器，右键虚拟机选择设置，选择“网络”，将连接方式改为“仅主机（Host-Only）网络”，点击确定即可。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在使用VBOX创建虚拟机的过程中，我发现我的虚拟机无法连接上网络，因此记录下我的解决方法。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>连接本地计算机和git服务器</title>
    <link href="http://yoursite.com/2020/11/27/%E8%BF%9E%E6%8E%A5%E6%9C%AC%E5%9C%B0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%92%8Cgit%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://yoursite.com/2020/11/27/%E8%BF%9E%E6%8E%A5%E6%9C%AC%E5%9C%B0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%92%8Cgit%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2020-11-27T04:30:15.823Z</published>
    <updated>2020-05-07T16:00:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>只有将两者连接以后我们的git bash才和我们的git账户关联起来，通过密钥进行访问。</p><a id="more"></a><h1 id="连接本地计算机和git服务器"><a href="#连接本地计算机和git服务器" class="headerlink" title="连接本地计算机和git服务器"></a>连接本地计算机和git服务器</h1><h2 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h2><p>打开git bash，在终端配置user.name和user.email信息，输入以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;user.name&quot;&#x2F;&#x2F;user.name处填写你的GitHub用户名</span><br><span class="line">git config --global user.email &quot;user.email&quot;&#x2F;&#x2F;user.email处填写你注册GitHUb是所用的邮箱</span><br></pre></td></tr></table></figure><h2 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h2><p>在git bash中输入以下代码生成ssh密钥文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;YourEmil&quot;&#x2F;&#x2F;YouEmail处填写你注册GitHub的邮箱</span><br></pre></td></tr></table></figure><p>然后输入三个回车即可，即默认不需要设置密码。</p><p>通过以上步骤便得到了两个文件，id_rsa和id_rsa.pub。</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200507235517482.png" alt="image-20200507235517482"></p><h2 id="COPY密钥"><a href="#COPY密钥" class="headerlink" title="COPY密钥"></a>COPY密钥</h2><p>打开id_rsa.pub文件，复制全部内容。</p><h2 id="将密钥粘贴到GitHub的ssh-key处"><a href="#将密钥粘贴到GitHub的ssh-key处" class="headerlink" title="将密钥粘贴到GitHub的ssh key处"></a>将密钥粘贴到GitHub的ssh key处</h2><p>打开GitHub，点击你的GitHub头像，选择Settings，选择SSH and GPG keys，点击New SSH key，Title随便设置，在Key中粘贴刚刚复制的id_rsa.pub的内容。</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200507235601143.png" alt="image-20200507235601143"></p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200507235722777.png" alt="image-20200507235722777"></p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200507235758027.png" alt="image-20200507235758027"></p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200507235835301.png" alt="image-20200507235835301"></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>在git bash中输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>再输入yes，如果看到Hi后面有你的用户名证明连接成功。</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200508000007626.png" alt="image-20200508000007626"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;只有将两者连接以后我们的git bash才和我们的git账户关联起来，通过密钥进行访问。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>利用hexo写出博客框架</title>
    <link href="http://yoursite.com/2020/11/27/%E5%88%A9%E7%94%A8hexo%E5%86%99%E5%87%BA%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2020/11/27/%E5%88%A9%E7%94%A8hexo%E5%86%99%E5%87%BA%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6/</id>
    <published>2020-11-27T04:30:15.822Z</published>
    <updated>2020-05-07T16:02:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo是基于<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fnodejs.org%2Fen%2F" target="_blank" rel="noopener">Nodejs</a>开发的，可以将<code>markdown</code>转换成<code>html</code>的框架，十分适合个人博客的搭建。</p><a id="more"></a><h1 id="利用hexo写出博客框架"><a href="#利用hexo写出博客框架" class="headerlink" title="利用hexo写出博客框架"></a>利用hexo写出博客框架</h1><h2 id="建立myBlog目录"><a href="#建立myBlog目录" class="headerlink" title="建立myBlog目录"></a>建立myBlog目录</h2><p>在计算机的恰当位置建立文件夹（位置任意，名称任意，但建议具有代表性）。</p><h2 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h2><p>进入刚刚建立的文件夹，选择git bash here进入git bash，输入以下代码初始化博客：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init</span><br><span class="line">$ hexo g #生成</span><br><span class="line">$ hexo s #开启本地预览</span><br></pre></td></tr></table></figure><p>此时你可以在浏览器中输入<a href="http://localhost:4000进行访问，本地预览我们的博客。">http://localhost:4000进行访问，本地预览我们的博客。</a></p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200508000155058.png" alt="image-20200508000155058"></p><p>观看完之后CTRL+C关闭。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Hexo是基于&lt;a href=&quot;https://links.jianshu.com/go?to=https%3A%2F%2Fnodejs.org%2Fen%2F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Nodejs&lt;/a&gt;开发的，可以将&lt;code&gt;markdown&lt;/code&gt;转换成&lt;code&gt;html&lt;/code&gt;的框架，十分适合个人博客的搭建。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>创建git仓库</title>
    <link href="http://yoursite.com/2020/11/27/%E5%88%9B%E5%BB%BAgit%E4%BB%93%E5%BA%93/"/>
    <id>http://yoursite.com/2020/11/27/%E5%88%9B%E5%BB%BAgit%E4%BB%93%E5%BA%93/</id>
    <published>2020-11-27T04:30:15.821Z</published>
    <updated>2020-05-07T16:16:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>既然是利用GitHub进行托管，那么必须将其放到相应的库中。</p><a id="more"></a><h1 id="创建git仓库"><a href="#创建git仓库" class="headerlink" title="创建git仓库"></a>创建git仓库</h1><p>打开<a href="https://www.github.com/" target="_blank" rel="noopener">github官网</a>，登录自己申请的账号后，点开右上角的加号，选择New repository，在Repository name下输入仓库名，必须是username.github.io（此处的username必须是你github的用户名），选择Public，勾选Initialize this repository with a README，点击Create repository，仓库至此创建完成。</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200507235203205.png" alt="image-20200507235203205"></p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200507235311764.png" alt="image-20200507235311764"></p><p>由于此处我已经建立过，所以会显示邮箱已存在。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;既然是利用GitHub进行托管，那么必须将其放到相应的库中。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>将该框架上传到github</title>
    <link href="http://yoursite.com/2020/11/27/%E5%B0%86%E8%AF%A5%E6%A1%86%E6%9E%B6%E4%B8%8A%E4%BC%A0%E5%88%B0github/"/>
    <id>http://yoursite.com/2020/11/27/%E5%B0%86%E8%AF%A5%E6%A1%86%E6%9E%B6%E4%B8%8A%E4%BC%A0%E5%88%B0github/</id>
    <published>2020-11-27T04:30:15.821Z</published>
    <updated>2020-05-07T16:06:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>在前面我们搭建好了框架，但只有将其上传到GitHub中才能通过浏览器访问，而不是像之前一样只能本地访问。</p><a id="more"></a><h1 id="将该框架上传到github"><a href="#将该框架上传到github" class="headerlink" title="将该框架上传到github"></a>将该框架上传到github</h1><h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><p>已经配置好SSH Key。</p><h2 id="开始配置"><a href="#开始配置" class="headerlink" title="开始配置"></a>开始配置</h2><p>之后便是打开文件夹中的_config.yml文件（文本编辑器打开即可），找到最后的部分，将其更改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:username&#x2F;username.github.io.git&#x2F;&#x2F;其实就是在repo处填上你的github page地址</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200508000329237.png" alt="image-20200508000329237"></p><p>注意：每个冒号后都有且只有一个半角的空格符，如果type处已有一对单引号，只需将git输到单引号中即可。</p><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>如缺少此步骤，在hexo g命令时会出现“deployer:git not found”。 </p><p>在你的博客文件夹中选择git bash here，输入以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h2 id="提交到GitHub"><a href="#提交到GitHub" class="headerlink" title="提交到GitHub"></a>提交到GitHub</h2><p>输入以下代码将博客在GitHub上托管：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean            ##清除缓存</span><br><span class="line">$ hexo g                ##生成静态网页</span><br><span class="line">$ hexo d                ##将其部署到服务器上</span><br></pre></td></tr></table></figure><p>之后需要输入你GitHub的用户名和密码进行验证。</p><h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><p>在浏览器中输入<a href="https://username.github.io就可以看到你搭建的博客了。" target="_blank" rel="noopener">https://username.github.io就可以看到你搭建的博客了。</a></p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200508000546988.png" alt="image-20200508000546988"></p><p>此处我使用了主题，后面会介绍到。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在前面我们搭建好了框架，但只有将其上传到GitHub中才能通过浏览器访问，而不是像之前一样只能本地访问。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2020/11/27/hello-world/"/>
    <id>http://yoursite.com/2020/11/27/hello-world/</id>
    <published>2020-11-27T04:30:15.820Z</published>
    <updated>2020-05-06T11:50:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>build-a-blog</title>
    <link href="http://yoursite.com/2020/11/27/build-a-blog/"/>
    <id>http://yoursite.com/2020/11/27/build-a-blog/</id>
    <published>2020-11-27T04:30:15.819Z</published>
    <updated>2020-05-07T04:58:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="这篇文章用来记录搭建博客的过程"><a href="#这篇文章用来记录搭建博客的过程" class="headerlink" title="这篇文章用来记录搭建博客的过程"></a><center>这篇文章用来记录搭建博客的过程</center></h3><h4 id="一、准备工作（git账号的注册、node-js、npm的安装）"><a href="#一、准备工作（git账号的注册、node-js、npm的安装）" class="headerlink" title="一、准备工作（git账号的注册、node.js、npm的安装）"></a><a href="https://decucin.github.io/2020/05/07/%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/" target="_blank" rel="noopener">一、准备工作（git账号的注册、node.js、npm的安装）</a></h4><h4 id="二、创建git仓库"><a href="#二、创建git仓库" class="headerlink" title="二、创建git仓库"></a><a href="https://decucin.github.io/2020/05/07/%E5%88%9B%E5%BB%BAgit%E4%BB%93%E5%BA%93/" target="_blank" rel="noopener">二、创建git仓库</a></h4><h4 id="三、连接本地计算机和git服务器"><a href="#三、连接本地计算机和git服务器" class="headerlink" title="三、连接本地计算机和git服务器"></a><a href="https://decucin.github.io/2020/05/07/%E8%BF%9E%E6%8E%A5%E6%9C%AC%E5%9C%B0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%92%8Cgit%E6%9C%8D%E5%8A%A1%E5%99%A8/" target="_blank" rel="noopener">三、连接本地计算机和git服务器</a></h4><h4 id="四、利用hexo写出博客框架"><a href="#四、利用hexo写出博客框架" class="headerlink" title="四、利用hexo写出博客框架"></a><a href="https://decucin.github.io/2020/05/07/%E5%88%A9%E7%94%A8hexo%E5%86%99%E5%87%BA%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6/" target="_blank" rel="noopener">四、利用hexo写出博客框架</a></h4><h4 id="五、将该框架上传到github"><a href="#五、将该框架上传到github" class="headerlink" title="五、将该框架上传到github"></a><a href="https://decucin.github.io/2020/05/07/%E5%B0%86%E8%AF%A5%E6%A1%86%E6%9E%B6%E4%B8%8A%E4%BC%A0%E5%88%B0github/" target="_blank" rel="noopener">五、将该框架上传到github</a></h4><h4 id="六、选取合适主题，美化博客"><a href="#六、选取合适主题，美化博客" class="headerlink" title="六、选取合适主题，美化博客"></a><a href="https://decucin.github.io/2020/05/07/%E9%80%89%E5%8F%96%E5%90%88%E9%80%82%E4%B8%BB%E9%A2%98%EF%BC%8C%E7%BE%8E%E5%8C%96%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">六、选取合适主题，美化博客</a></h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;这篇文章用来记录搭建博客的过程&quot;&gt;&lt;a href=&quot;#这篇文章用来记录搭建博客的过程&quot; class=&quot;headerlink&quot; title=&quot;这篇文章用来记录搭建博客的过程&quot;&gt;&lt;/a&gt;&lt;center&gt;这篇文章用来记录搭建博客的过程&lt;/center&gt;&lt;/h3&gt;&lt;h4 </summary>
      
    
    
    
    
  </entry>
  
</feed>
