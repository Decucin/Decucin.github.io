<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog of Decucin</title>
  
  
  <link href="http://decucin.github.io/atom.xml" rel="self"/>
  
  <link href="http://decucin.github.io/"/>
  <updated>2022-03-31T15:33:55.449Z</updated>
  <id>http://decucin.github.io/</id>
  
  <author>
    <name>Decucin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试高频</title>
    <link href="http://decucin.github.io/2022/03/31/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91/"/>
    <id>http://decucin.github.io/2022/03/31/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91/</id>
    <published>2022-03-31T15:31:49.000Z</published>
    <updated>2022-03-31T15:33:55.449Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类生命周期"><a href="#类生命周期" class="headerlink" title="类生命周期"></a>类生命周期</h1><p>总共七个阶段：<strong>加载、验证、准备、解析、初始化</strong>、使用、卸载，其中前五个阶段统称为类加载过程。</p><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>加载过程中完成了以下三件事情：</p><ol><li>通过类的全限定类名获取此类的二进制字节流文件</li><li>将此二进制字节流转化为方法区的运行时数据结构</li><li>在java堆中生成一个代表这个类的Class对象，作为方法区这些数据的访问入口</li></ol><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>确保字节流中包含的信息符合当前虚拟机的要求不会危害虚拟机自身安全</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>为类变量（static修饰）分配内存并设置初始值（0值或者final修饰的值）</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>将常量池中的符号引用替换为直接引用的过程（有时候解析会在初始化之后再开始，这是为了支持动态绑定）</p><p><strong>验证、准备、解析统称为链接过程</strong></p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>执行类构造器&lt; clinit &gt; ()方法，其实就是执行类中定义的Java程序代码，对类变量和其它资源进行赋值（这里就会进行真正的赋值操作），执行static代码块等等，这里注意静态语句块中只有定义在它之前的类变量才能被访问，定义在其之后的变量只能赋值不能访问。</p><h4 id="类初始化的时机"><a href="#类初始化的时机" class="headerlink" title="类初始化的时机"></a>类初始化的时机</h4><ul><li>主动引用<ol><li>使用new实例化对象</li><li>读取类的静态字段（注意这里不包括final修饰以及已经被放入常量池的静态字段）</li><li>调用静态方法的时候</li><li>对类进行反射时类还没有初始化的时候</li><li>初始化类时发现其父类还未初始化</li><li>启动时需要先初始化main方法所在的类</li><li>使用反射时方法句柄对应的类没有进行初始化</li></ol></li><li>被动引用：除主动引用之外的场景，常见的有：<ul><li>子类调用父类的静态字段</li><li>数组来定义引用类（这里只是对数组类进行初始化）</li><li>常量–&gt;在编译阶段（准备阶段）就已经存入常量池中</li></ul></li></ul><h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><h2 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h2><p>CMS，Concurrent Mark Sweep：并发标记清除，共有如下四个流程</p><ul><li>初始标记：仅标记GC Roots能直接关联的对象，很快，需要停顿</li><li>并发标记：进行GC Roots Tracing，回收过程中耗时最长，但这里不需要停顿</li><li>重新标记：由于并发标记期间用户程序没有停顿，导致可能会出现对象的标记记录发生改变，这里需要停顿</li><li>并发清除：不需要停顿</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>吞吐量低，CPU利用率不高</li><li>无法处理浮动垃圾，浮动垃圾就是并发清除阶段用户程序继续运行而产生的垃圾，只能等待下次GC再回收–&gt;因此需要预留一部分内存，若是预留的内存无法存放浮动垃圾就会出现Concurrent Mode Failure而使用Serial Old替代CMS</li><li>标记清除算法会导致空间碎片，多次full GC</li></ul><h2 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h2><p>面向服务端应用的垃圾收集器，多CPU和大内存的场景下性能很好。</p><p>其它收集器是将老年代的收集和新生代的收集分开进行，G1则是两者一起进行回收 。</p><ul><li>把堆分成多个大小相等的独立区域，使新生代和老年代不再物理隔离</li><li>记录每个Region垃圾回收时间及回收获得的空间，根据允许的收集时间（用户可以接受的收集时间），优先回收价值最大的Region（过去回收时得到的空间最大的那个）</li><li>Remembered Set中记录该Region对象的引用对象所在的Region，可达性分析时可避免全堆扫描</li></ul><p>不考虑维护Remembered Set，运作过程如下：</p><ul><li><p>初始标记</p></li><li><p>并发标记</p><p>这两个阶段和CMS差不多</p></li><li><p>最终标记：并发标记阶段用户程序继续运作，虚拟机将并发标记阶段对象的变化记录在线程的Remembered Set Logs中，最终标记阶段将其中的数据合并到Remembered Set，需要停顿线程但可以并行执行。</p></li><li><p>筛选回收：对每个Region的回收价值和成本（回收需要的时间）进行排序，根据用户需要的停顿时间来制定回收计划</p></li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>空间整合：不会产生空间碎片（整体上是标记–整理，两个Region间是标记–复制）</li><li>可预测的停顿：可以指定在长度为M的时间片内，消耗在GC上的时间不得超过N</li></ul><h1 id="锁的优化"><a href="#锁的优化" class="headerlink" title="锁的优化"></a>锁的优化</h1><p>共有如下五种方案：自旋锁、锁消除、锁粗化、轻量级锁、偏向锁</p><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>线程在请求数据时若是未获得锁并不会直接进入阻塞状态，而是先自旋一段时间，默认是十次，之后出现了自适应的自旋锁，若是在自旋的时间中获得了锁，那么就能避免进入阻塞状态减少开销，但自旋也需要占用CPU，因此只适用于共享数据锁定状态很短的场景。</p><h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><p>对于不可能存在竞争的共享数据直接进行锁消除（通过逃逸分析实现）。</p><p>逃逸分析：堆上的共享数据不能被其它线程访问到，那么就可以进行锁消除</p><h2 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h2><p>若是一系列操作都对同一个对象反复加锁解锁，那么直接会将加锁范围扩展到整个操作序列的外面。StringBuffer中的每次append()操作都加锁解锁，那么若是存在连续的append()就会将这一些列的加解锁操作合并为一次加解锁操作。</p><h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>锁一共有四种状态：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。</p><p>对象头：</p><ul><li>自身运行时数据Mark Word</li><li>类型指针</li></ul><h3 id="无锁状态"><a href="#无锁状态" class="headerlink" title="无锁状态"></a>无锁状态</h3><p>锁的标志位为01，Mark Word是对象的哈希码以及对象分代年龄。</p><h3 id="偏向锁状态"><a href="#偏向锁状态" class="headerlink" title="偏向锁状态"></a>偏向锁状态</h3><p>标志位为01， Mark Word是偏向线程ID，偏向时间戳，对象分代年龄</p><h3 id="轻量级锁-1"><a href="#轻量级锁-1" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>标志位为00，Mark Word是指向锁记录的指针</p><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>标志位为10，Mark Word是指向重量锁的指针。</p><h3 id="加锁过程"><a href="#加锁过程" class="headerlink" title="加锁过程"></a>加锁过程</h3><ul><li>如果当前锁对象标志位为01，那么先创建一个存储对象目前的Mark Word的拷贝Lock Record</li><li>CAS比较锁对象的Mark Word与拷贝的是否相等</li><li>若是相等则将锁的Mark Word换成指向帧栈中拷贝的指针，此时已经获得了锁并将该对象的锁标志位改为00，此时帧栈Mark Word存取对象的信息，标志位为01，锁对象的Mark Word中指向栈中锁记录所在的指针，标志位为00</li><li>若是不相等判断锁对象的Mark Word是否指向当前线程</li><li>若是则当前线程已经拿到了锁，则可以进入</li><li>若不是则说明锁已被别的线程拿到，此时修改标志位为10，变为重量级锁</li><li>自旋，自旋一定次数仍未拿到锁则进入阻塞状态</li></ul><h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>偏向于第一个获得锁对象的线程，该线程在之后获取该锁是就不需要同步或者CAS，当其它线程尝试获取该锁时偏向状态才结束，并将其恢复至无锁或者轻量级锁的状态。</p><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>对于某个一定不存在的数据进行请求时，一定会穿透缓存而到达数据库。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>对不存在的数据缓存一个空数据</li><li>将此类请求过滤 –&gt;过滤器</li></ul><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>数据没有加载到缓存中，或者是缓存在同一时间大面积失效，或者缓存服务器宕机，导致大量的请求都到达数据库。</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>数据还未加载到缓存中–&gt;缓存预热，先将热点信息加入缓存中</li><li>缓存同一时间大面积失效–&gt;观察用户行为合理设置缓存过期时间</li><li>缓存服务器宕机–&gt;分布式缓存</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;类生命周期&quot;&gt;&lt;a href=&quot;#类生命周期&quot; class=&quot;headerlink&quot; title=&quot;类生命周期&quot;&gt;&lt;/a&gt;类生命周期&lt;/h1&gt;&lt;p&gt;总共七个阶段：&lt;strong&gt;加载、验证、准备、解析、初始化&lt;/strong&gt;、使用、卸载，其中前五个阶段统称为类加</summary>
      
    
    
    
    <category term="后端" scheme="http://decucin.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Java" scheme="http://decucin.github.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
    <category term="面试" scheme="http://decucin.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Java基础" scheme="http://decucin.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="http://decucin.github.io/2022/03/28/Redis/"/>
    <id>http://decucin.github.io/2022/03/28/Redis/</id>
    <published>2022-03-28T12:42:18.000Z</published>
    <updated>2022-03-28T14:55:08.781Z</updated>
    
    <content type="html"><![CDATA[<p>大部分内容取自<a href="https://www.cyc2018.xyz/" target="_blank" rel="noopener">CS-Notes</a>开源项目，这里记录只是为了方便查阅。</p><a id="more"></a><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><ul><li>string: set key value</li><li>list: rpush list_key value</li><li>set: sadd set_key value</li><li>zset: zadd zset_key score value</li><li>hash: hset hash_key key value</li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>字典中有两个Hash表，在扩容是将一个哈希表中的键值对rehash到另一个hash表上，完成之后释放空间并交换两个哈希表的角色（JVM分代也是将Servive分成两个区）。</p><p>rehash采用的是渐进式：并不是一次性完成整个rehash操作，在rehash的过程中，若是当前正在rehash，那么插入元素时只插到dict[1]，每次增删改查操作都需要进行一次rehash，此外每隔一段时间也会触发一次rehash操作。</p><h2 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h2><p>基于多指针有序链表实现，查找时先从上层指针开始找，找到对应区间后到下一层找，与红黑树等平衡树相比，插入快（不需要旋转等复杂操作），更容易实现，支持无锁操作。</p><h1 id="Redis使用场景"><a href="#Redis使用场景" class="headerlink" title="Redis使用场景"></a>Redis使用场景</h1><h2 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h2><p>内存型数据库读写性能高，适合存储频繁读写的计数量</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>设置内存的最大使用量以及淘汰策略保证缓存命中率</p><h2 id="查找表"><a href="#查找表" class="headerlink" title="查找表"></a>查找表</h2><p>与缓存类似，借助其快速的查找特性，但查找表不能丢失内容，缓存可以失效。</p><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>最好使用消息中间件</p><h2 id="会话缓存"><a href="#会话缓存" class="headerlink" title="会话缓存"></a>会话缓存</h2><p>应用服务器无需存储会话信息，不具有状态，一个用户可以请求任意个服务器，实现高可用以及可伸缩性。</p><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>set可以实现集合的交并操作，实现共同好友等功能。</p><p>zset用于实现有序操作，如排行榜等。</p><h1 id="Redis与Memcached"><a href="#Redis与Memcached" class="headerlink" title="Redis与Memcached"></a>Redis与Memcached</h1><p>都是非关系型内存键值数据库。</p><p>Memcached仅支持字符串类型，Redis支持五种</p><p>Redis有两种持久化策略，RDB快照和AOF日志，Memcached不支持。</p><p>Redis Cluster实现了分布式的支持，Memcached不支持，只能在客户端使用一致性哈希实现分布式存储。</p><p>Memcached中的数据一直在内存中，Redis可以将很久不用的value放入磁盘。</p><h1 id="键的过期时间"><a href="#键的过期时间" class="headerlink" title="键的过期时间"></a>键的过期时间</h1><p>Redis可以为每个键设置过期时间，对于散列表则只能为整个散列表设置过期时间。</p><h1 id="数据淘汰策略"><a href="#数据淘汰策略" class="headerlink" title="数据淘汰策略"></a>数据淘汰策略</h1><p>设置内存最大使用量，超出时会施行数据淘汰策略。</p><p>出于对性能的考虑，算法的实现并不是针对所有key，而是抽样小部分并从中选出被淘汰的key。</p><p>做缓存时可以将最大内存使用量设置为热点数据占用的内存量，之后使用allkeys-lfu淘汰策略，将最近最少使用的数据淘汰。</p><h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><ul><li><p>RDB持久化</p><p>将某个时间点的所有数据放到硬盘上。</p><p>好处：可以将快照复制到其它服务器进而创建副本</p><p>坏处：系统发生故障可能会丢失最后一次创建快照之后的数据；数据量大时保存快照时间会很长</p></li><li><p>AOF持久化</p><p>把写命令添加到AOF文件的末尾。设置同步选项（先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘）：always（每次都同步，降低性能）,everysec（每秒一次，合理），no（操作系统决定，实际上并不会带来多大的性能提升，也会增加系统崩溃时流失的数据量）。</p><p>Redis有AOF重写特性，去除文件中冗余的写命令。（重写操作实际上不涉及原AOF文件，而是使用类似遍历数据库，使用set之类的命令保存数据库中所有信息）</p></li></ul><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>使用multi和exec命令将事务操作包围起来。</p><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>Redis：事件驱动程序。</p><ul><li>文件事件：对套接字操作的抽象。使用I/O多路复用程序来同时监听多个套接字，并将到达的事件传送给文件事件分派器，文件事件分派器再根据套接字产生的事件类型调用相应的事件处理器。</li><li>时间事件<ul><li>定时事件：在指定时间之内执行一次</li><li>周期性事件：每隔指定事件就执行一次</li></ul></li></ul><p>将所有执行事件放在一个无序链表中，通过遍历整个链表查找出已到达的事件事件，并调用相应的事件处理器。</p><h1 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h1><p>通过使用slaveof host port将一个服务器转化成另一个服务器的从服务器。</p><p>一个从服务器只能有一个主服务器并且不支持主主复制。</p><h2 id="连接过程"><a href="#连接过程" class="headerlink" title="连接过程"></a>连接过程</h2><ul><li>主服务器创建快照发给从服务器并使用缓冲区记录执行的写命令。快照发送完毕后开始想从服务器发送存储在缓冲区的写命令</li><li>从服务器丢弃所有旧数据，载入主服务器发来的快照文件，开始接受主服务器发来的写命令</li><li>主服务器执行一次写命令就向从服务器发送相同的命令</li></ul><h2 id="主从链"><a href="#主从链" class="headerlink" title="主从链"></a>主从链</h2><p>可以创建中间层</p><h1 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h1><p>哨兵监视主从服务器，并且哨兵之间两两监视，当主服务器宕机时，当多个哨兵同时监听到主服务器宕机时会发起一次投票，进行failover操作，切换成功后通过订阅模式把自己监控的从服务器实现切换主机。</p><h1 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h1><ul><li>范围分片：需要维护一张映射范围表，代价高</li><li>哈希分片：通过哈希函数将键转化成数字并对实例数量求模知道存储的实例。</li></ul><p>根据执行的分片位置可以分为三种方式：</p><ul><li>客户端分片：由客户端决定（一致性哈希算法）</li><li>代理分片：将客户端请求发送到代理上，由代理转发到请求正确的节点上</li><li>服务器分片：Redis Cluster</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;大部分内容取自&lt;a href=&quot;https://www.cyc2018.xyz/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CS-Notes&lt;/a&gt;开源项目，这里记录只是为了方便查阅。&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="http://decucin.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="数据库" scheme="http://decucin.github.io/categories/%E5%90%8E%E7%AB%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="http://decucin.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="Redis" scheme="http://decucin.github.io/tags/Redis/"/>
    
    <category term="面试" scheme="http://decucin.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Mysql</title>
    <link href="http://decucin.github.io/2022/03/28/Mysql/"/>
    <id>http://decucin.github.io/2022/03/28/Mysql/</id>
    <published>2022-03-28T12:42:10.000Z</published>
    <updated>2022-03-31T15:33:19.991Z</updated>
    
    <content type="html"><![CDATA[<p>大部分内容取自<a href="https://www.cyc2018.xyz/" target="_blank" rel="noopener">CS-Notes</a>开源项目，这里记录只是为了方便查阅。</p><a id="more"></a><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="B-树、B-树"><a href="#B-树、B-树" class="headerlink" title="B-树、B+树"></a>B-树、B+树</h2><p>B-树：平衡多路查找树。</p><ol><li>除非B-树只有一个节点，否则根节点至少有两棵子树</li><li>每个中间节点都有k - 1个元素和k棵子树（k大于等于树的高度的一半但小于等于树的高度）</li><li>每个叶子节点都有k - 1个元素</li><li>所有叶节点在同一层</li><li>每个节点中关键字从小到大排列，k - 1个关键字划分出k个范围（k棵子树）</li><li>每个节点包含以下内容：首位是元素的个数，</li></ol><p>B+树：基于B-树和叶子节点顺序访问的指针进行实现，具有B树的平衡性并且通过顺序访问指针提高区间查找的性能。</p><p>以下部分主要介绍B+树。</p><p>查找：首先在根节点进行二分查找，找到了key所在指针，然后递归地在指针所指向的节点进行查找，直到查找到叶子节点，再进行二分查找，找到key对应的数据</p><p>插入：插入后其结构可能被破坏，因此考虑对树进行分裂、合并、旋转等操作来维护平衡性。</p><p>与红黑树的比较：红黑树的查找效率也比较高，但是红黑树本质上是二叉树，但B+树却是多叉树，因此对磁盘的访问速率更高。</p><ol><li>B+树树高更低：一个节点可以存取更多的值（N叉树而非红黑树那样的二叉树）</li><li>磁盘访问原理：内存与磁盘之间实际上是以页为单位进行数据交换的，数据库系统中每个页的大小实际上就是索引中一个节点的大小，每次I/O能够完全载入一个节点，如果数据不在同一个磁盘块上时需要考虑移动制动手臂进行寻道，增加了磁盘读取时间。B+树树高低导致进行寻道的次数少，每个磁盘块上数据多仅仅只是需要进行磁盘旋转，用时较少。</li><li>磁盘并不是严格按需的去而是会进行预读，预读过程中磁盘进行顺序读取，此外相邻的节点也能被预读。</li></ol><h2 id="Mysql索引"><a href="#Mysql索引" class="headerlink" title="Mysql索引"></a>Mysql索引</h2><ul><li>B+索引：大多数存储引擎的默认索引类型，适合于全键值、键值范围和键前缀查找（最左前缀，否则无法使用索引）。InnoDB中分为主索引和辅助索引，主索引的叶子节点记录着完整的数据记录，聚簇索引，每个表只能有一个聚簇索引）；辅助索引叶子节点的data值记录着主键的值，查找到主键值之后再到主索引中进行查找</li><li>哈希索引：以O(1)时间复杂度进行查找，但是失去了有序性，无法用于排序和分组，只支持精确查找，无法用做部分查找和范围查找=&gt;InnoDB中“自适应哈希索引”功能在索引被频繁使用的时候会在B+索引上再建一个哈希索引，使得其具有哈希索引的一些优点（只有在等值查询的时候可以降低逻辑读，但会占用buffer pool，消耗资源）。</li><li>全文索引：MyISAM支持全文索引，用于查找文本关键字，查找条件使用match against，采用倒排索引（从文档到关键字变为关键字到文档）实现，记录着关键字到文档的映射，InnoDB在5.6.4后支持全文索引</li><li>空间数据索引：MyISAM支持，可用于地理数据存储，空间数据索引可以有效的使用任意维度进行组合查询，必须适应GIS相关函数维护数据（R树）。</li></ul><h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><ol><li>单列索引列不能是表达式的部分和函数的参数</li><li>多列索引比多个单列索引性能好</li><li>让选择性（不同记录的个数/记录总数）更强的索引放在前面，选择性越强区分度越高，效率也越高。</li><li>对应blob，text以及varchar类型的列必须使用前缀索引索引其开始的部分字符，长度视情况而定</li><li>覆盖索引中索引包含对应字段的值</li></ol><p>索引优点：</p><ul><li>减少了需要扫描的数据行数</li><li>避免创建临时表</li><li>随机I/O转变为顺序I/O</li></ul><h1 id="查询性能优化"><a href="#查询性能优化" class="headerlink" title="查询性能优化"></a>查询性能优化</h1><ul><li>explain分析</li><li>优化数据访问<ul><li>减少请求的数据量：只要必须的列（最好不使用select * ，只返回必要的行，使用limit限制返回的数据， 缓存重复的数据=&gt;Redis）</li><li>减少服务器扫描的行数：使用索引覆盖查询</li></ul></li><li>重构查询方式<ul><li>切分大查询：将一个大查询切分为多次比较小的查询</li><li>分解大连接查询：将大连接分解为对每一个单表的查询，之后在业务层进行连接</li></ul></li></ul><h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><p>InnoDB （大部分时候使用）和MyISAM（压缩表、空间数据索引，手工执行检查和修复操作，导致一些数据丢失）。</p><p>比较：</p><ul><li>InnoDB支持事务，MyISAM不支持</li><li>InnoDB支持行级锁，MyISAM只支持表级锁</li><li>InnoDB支持在线热备份</li><li>MyISAM崩溃后损坏的概率更大同时恢复速度慢</li><li>MyIASM支持压缩表和空间数据索引</li></ul><h1 id="切分"><a href="#切分" class="headerlink" title="切分"></a>切分</h1><ul><li>垂直切分：将一张表按列切分成多个表，按照列的关系密集程度进行切分</li><li>水平切分：将一个表中的记录拆分到多个结构相同的表中</li></ul><h2 id="切分策略"><a href="#切分策略" class="headerlink" title="切分策略"></a>切分策略</h2><ul><li>哈希取模：hash(key) % N</li><li>范围：ID范围或事时间范围</li><li>映射表：使用一个单独的数据库存储切分后的映射关系</li></ul><h2 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h2><ul><li>事务问题：用分布式事务或者结合业务层解决</li><li>连接问题：将原来的连接分成多个单表查询，在业务层中进行连接</li><li>ID唯一性：全局唯一ID，分片后的区域只能含有该区域ID范围中的ID，分布式ID生产器</li></ul><h1 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h1><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>主数据库维护一个bin log线程，将写入操作全部加入到日志中；</p><p>I/O线程从主服务器上读日志，写入从服务器的中继日志；</p><p>SQL线程读中继日志中读取操作并让从服务器也执行</p><h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>主服务器处理写操作，从服务器处理读操作</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;大部分内容取自&lt;a href=&quot;https://www.cyc2018.xyz/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CS-Notes&lt;/a&gt;开源项目，这里记录只是为了方便查阅。&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="http://decucin.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="数据库" scheme="http://decucin.github.io/categories/%E5%90%8E%E7%AB%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="http://decucin.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="面试" scheme="http://decucin.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Mysql" scheme="http://decucin.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>数据库原理</title>
    <link href="http://decucin.github.io/2022/03/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/"/>
    <id>http://decucin.github.io/2022/03/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/</id>
    <published>2022-03-28T12:41:09.000Z</published>
    <updated>2022-03-28T12:47:54.335Z</updated>
    
    <content type="html"><![CDATA[<p>大部分内容取自<a href="https://www.cyc2018.xyz/" target="_blank" rel="noopener">CS-Notes</a>开源项目，这里记录只是为了方便查阅。</p><a id="more"></a><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><ol><li>A：事务的操作是原子性的，要么都成功，要么都回滚。</li><li>C：事务开始之前和事务提交（回滚）之后，数据库都属于一致性状态，一致性状态是指所有事务对同一个数据的读取操作都是一致的（能得到相同的结果）。</li><li>I：事务之间是相互隔离的，一个事务在提交之前，其对数据进行的操作对其他事务不可见。</li><li>D：事务提交之后对于数据库的修改会永久生效，即使发生系统奔溃，事务的执行结果也不能丢失</li></ol><h1 id="并发会产生的问题"><a href="#并发会产生的问题" class="headerlink" title="并发会产生的问题"></a>并发会产生的问题</h1><h2 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>两个事务对同一个数据进行操作，之后的事务覆盖了原先事务的修改操作。</p><ul><li>第一类丢失更新：事务A撤销时把事务B的更新数据覆盖了</li><li>第二类丢失更新：事务A覆盖了事务B提交的数据，导致事务B操作丢失</li></ul><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>存储一个update字段，每次都将其与原来的进行对比，若是不同则说明有其余事务修改了这个数据，反之相同则没有。</p><h2 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>事务A在对某一数据修改的过程中，事务B读到了事务A修改之后的数据，但事务A有可能发生回滚，此时事务B读到了脏数据。</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>使用隔离级别提交读以及之上的隔离级别，保证只有在事务提交之后才能读取到事务对数据进行的操作，从而避免读到脏数据。</p><h2 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>事务A第一次读取的时候得到数据A的值是20，此时事务B对数据A进行了修改，将其修改为30，事务B提交之后事务A再次对数据A进行读取，此时发现两次读取得到的数据不一致。</p><h3 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h3><p>使用隔离级别可重复读，保证在同一个事务中多次读取同一事务得到的结果是一致的。</p><h2 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h2><h3 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h3><p>事务A得到某一范围的值（假设现在求的是A字段大于5小于10的数量，得到了4-&gt;select count(A) where A &lt; 10 &amp;&amp; A &gt; 5），此时事务B插入（或者删除）了一个或多个字段，之后事务B提交，此时事务A再次读取这一范围的值，发现和之前不一致。</p><h3 id="解决办法-2"><a href="#解决办法-2" class="headerlink" title="解决办法"></a>解决办法</h3><p>使用隔离级别可串行化，强制事务串行执行。</p><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="粒度"><a href="#粒度" class="headerlink" title="粒度"></a>粒度</h2><ol><li>行级锁：只锁定需要修改（读取的一行）</li><li>表级锁：将整个表进行锁定</li></ol><p>很显然行级锁粒度更小，并发量更高，但力度粒度较小的锁系统开销较大。</p><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><ol><li><p>读写锁</p><ul><li>读锁（共享锁）：加锁期间只能读取，其余事务能加读锁，不能加写锁</li><li>写锁（互斥锁）：加锁期间能读能写，其余事务不能加锁</li></ul></li><li><p>意向锁</p><ul><li>IX锁：表示一个事务想对表中的某行数据加X锁</li><li>IS锁：表示一个事务想对表中的某行数据加S锁</li></ul><p>引入的原因：只要要想对表加锁需要全表扫描看是否有锁，开销大。</p><p>引入后：事务想对表中的某行数据加S锁时，只需要获得表的IS锁或者更强的锁；事务想对表中的某行数据加X锁时，必须要获得表的IX锁</p><p>意向锁只是想要对表加锁，因此两者之间是兼容的。</p></li></ol><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><ol><li><p>三级段封锁协议</p><ul><li>一级：修改是必须加X锁，结束才释放=&gt;解决丢失修改问题（两个事务不能同时对同一个数据修改）</li><li>二级：一级的基础上读数据必须加S锁，读完<strong>马上</strong>释放=&gt;解决读脏数据问题（一个事务在修改的过程中已对数据加锁，另一个事务无法加读锁）</li><li>二级的基础上，释放读锁的时间变为事务结束=&gt;解决不可重复读问题（读A时其它事务不能无法加上写锁，只有在事务完成之后释放锁，其余事务才能加上锁）</li></ul></li><li><p>两段锁协议：加锁和解锁是分阶段的。</p><p>一个事务同时对ABC都加了锁，那么加锁阶段不能有锁释放，解锁阶段不能有锁加上。=&gt;满足两段锁协议则一定满足可串行化调度。</p></li></ol><h1 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h1><ul><li>未提交读：修改操作没提交也对其它事务可见。</li><li>提交读：修改操作没提交之前对其它事务是不可见的，只能读取已经提交的事务。</li><li>可重复读：同一事务中多次读取同一数据，结果一致。</li><li>可串行化：强制串行执行</li></ul><h1 id="多版本并发控制MVCC"><a href="#多版本并发控制MVCC" class="headerlink" title="多版本并发控制MVCC"></a>多版本并发控制MVCC</h1><p>mysql中InnoDB实现隔离级别的方式，读未提交要求低，无需使用，用于实现读提交和可重复读，可串行化单纯使用MVCC无法实现，MVCC无法解决写写冲突，需要结合乐观锁或者悲观锁使用。</p><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>读写锁中读写操作之间互斥，而MVCC同时维护数据的多个版本，写操作是更新最新的版本，读操作时读取旧版本，使得读写操作之间也没有了互斥关系。</p><p>写操作（增删改）需要对改行数据新增版本快照，读取时只能读到已经提交的快照。</p><h2 id="在Mysql中的具体实现"><a href="#在Mysql中的具体实现" class="headerlink" title="在Mysql中的具体实现"></a>在Mysql中的具体实现</h2><ul><li>三个隐式字段：DB_TRX_ID（最近修改事务ID）, DB_ROLL_PTR（回滚指针，指向记录的上个版本，配合undo日志使用）, DB_ROW_ID（隐式主键）</li><li>undo日志：多个版本的快照就存储在这里，该日志通过回滚指针把一个数据行的所有快照连接</li><li>Read View：包含了当前系统未提交的事务<strong>列表</strong>TRX_IDs，该列表的最小值TRX_ID_MIN以及TRX_ID_MAX</li></ul><p>在select时通过判断表中隐式字段最近修改事务ID和ReadView中的TRX_ID_MIN以及TRX_ID_MAX来判断是否可用：</p><ol><li>小于TRX_ID_MIN，可见；</li><li>大于TRX_ID_MAX，不可见；</li><li>在中间，判断隔离级别<ul><li>提交读：如果其在事务列表TRX_IDs中证明该行快照对应的事务还未提交，不可见，否则可见</li><li>可重复读：都不可见=&gt;可见则列表中所有事务都能读到并修改，那么导致不可重复读问题</li></ul></li><li>不可见则沿着undo log的ROLL_PTR继续寻找下一个快照并进行判断</li></ol><h1 id="Next-Key-Locks"><a href="#Next-Key-Locks" class="headerlink" title="Next-Key Locks"></a>Next-Key Locks</h1><p>mysql锁的一种实现，可重复读隔离级别下，MVCC + Next-Key Locks可以解决幻读问题。</p><h2 id="Record-Locks"><a href="#Record-Locks" class="headerlink" title="Record Locks"></a>Record Locks</h2><p>锁定一个记录上的索引，而不是记录本身，InnoDB默认主键为聚簇索引（对字段上锁）</p><h2 id="Gap-Locks"><a href="#Gap-Locks" class="headerlink" title="Gap Locks"></a>Gap Locks</h2><p>锁定索引之间的间隙，但不包含索引本身。</p><h2 id="Next-Key-Locks-1"><a href="#Next-Key-Locks-1" class="headerlink" title="Next-Key Locks"></a>Next-Key Locks</h2><p>前两者的结合，锁定记录上的索引，也锁定索引之间的间隔（前开后闭区间）</p><p><strong>INnoDB默认是Next-Key Locks，但查询的索引含有唯一属性（不是范围查找时），会降级为Record Locks。</strong></p><h1 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h1><ol><li>属性不可分：关系数据库都满足</li><li>不能存在联合索引中的一部分决定非主属性，非主属性只能由整个索引决定，而不是索引的一部分（只有联合索引才需要考虑是否不满足第二范式）</li><li>不存在非键字段决定其余非键字段（非键字段只能由主键决定，不能由不是主键的属性决定）</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;大部分内容取自&lt;a href=&quot;https://www.cyc2018.xyz/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CS-Notes&lt;/a&gt;开源项目，这里记录只是为了方便查阅。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="http://decucin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="后端" scheme="http://decucin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="数据库" scheme="http://decucin.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="面试" scheme="http://decucin.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>每日一题</title>
    <link href="http://decucin.github.io/2022/03/22/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    <id>http://decucin.github.io/2022/03/22/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</id>
    <published>2022-03-22T12:45:26.000Z</published>
    <updated>2022-03-22T12:59:59.136Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>牛客TOP101题解</title>
    <link href="http://decucin.github.io/2022/03/13/%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3/"/>
    <id>http://decucin.github.io/2022/03/13/%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3/</id>
    <published>2022-03-13T11:08:37.000Z</published>
    <updated>2022-03-21T06:45:59.100Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="BM1-反转链表"><a href="#BM1-反转链表" class="headerlink" title="BM1 反转链表"></a>BM1 <a href="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=295&tqId=23286&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">反转链表</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个单链表的头结点pHead(该头节点是有值的，比如在下图，它的val是1)，长度为n，反转该链表后，返回新链表的表头。 </p><p>数据范围： 0≤<em>n</em>≤1000</p><p>要求：空间复杂度 O(1) ，时间复杂度 O(n)。 </p><p>如当输入链表{1,2,3}时， </p><p>经反转后，原链表变为{3,2,1}，所以对应的输出为{3,2,1}。 </p><p>以上转换过程如下图所示：</p><p><img src="https://uploadfiles.nowcoder.com/images/20211014/423483716_1634206291971/4A47A0DB6E60853DEDFCFDF08A5CA249" alt="img"></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>反转链表的基本思想就是利用三个指针，pre，cur，nex分别表示当前节点前一个节点、当前节点以及当前节点后面的节点，之后再令cur.next = pre;其实就完成了反转操作，完成反转操作之后将三个指针依次后移即可。</p><h3 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 优先考虑特殊情况，一个节点都没有或是只有一个节点，直接返回即可</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode nex = cur.next;</span><br><span class="line">            <span class="comment">// 这里是反转的核心，令之前在前面的指针挪到后面</span></span><br><span class="line">            cur.next = pre;</span><br><span class="line">            <span class="comment">// 之后依次将各指针后移即可；</span></span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = nex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当退出循环时，其实就是cur == null的情况，这时</span></span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM2-链表内指定区间反转"><a href="#BM2-链表内指定区间反转" class="headerlink" title="BM2 链表内指定区间反转"></a>BM2 <a href="https://www.nowcoder.com/practice/b58434e200a648c589ca2063f1faf58c?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">链表内指定区间反转</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>将一个节点数为 size 链表 m 位置到 n 位置之间的区间反转，要求时间复杂度 O<em>(</em>n<em>)，空间复杂度 *O</em>(1)。<br>例如：<br>给出的链表为 1→2→3→4→5→<em>NULL</em>, m=2,n=4<em>m</em>=2,<em>n</em>=4,<br>返回 1→4→3→2→5→<em>NULL</em>.</p><p><strong>数据范围： 链表长度 0&lt;size≤1000，0&lt;m≤n≤size，链表中每个节点的值满足 |val|≤1000|val|≤1000</strong></p><p><strong>要求：时间复杂度 <em>O</em>(<em>n</em>) ，空间复杂度 <em>O</em>(<em>n</em>)</strong></p><p><strong>进阶：时间复杂度 <em>O</em>(<em>n</em>) ，空间复杂度 <em>O</em>(<em>1</em>)</strong></p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>这题的思想和反转链表实际上是一样的，关键点（与反转整个链表不同之处）在于这里反转的链表只是整个链表中的一部分，故涉及链表的截断(cur.next = null)以及连接(cur.next = head2.next)，考虑方法如下：首先需要将链表的头尾指针进行保存（考虑如下几个指针的保存，原链表截断之前的指针，截断部分的头尾指针以及截断部分之后的头指针），之后将截断部分进行反转，之后再进行链表的拼接即可。</p><p><strong>可用一个虚拟头节点防止头节点各种复杂条件判断</strong></p><h3 id="Java代码实现-1"><a href="#Java代码实现-1" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span> <span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 首先考虑特殊情况，若是m == n即有一个节点需要反转，那直接无需反转</span></span><br><span class="line">        <span class="keyword">if</span>(m == n)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 首先考虑需要的指针，总共有三条链表，用head1-3以及tail1-3分别表示其头尾</span></span><br><span class="line">        ListNode head2 = <span class="keyword">null</span>;</span><br><span class="line">        ListNode head3 = <span class="keyword">null</span>;</span><br><span class="line">        ListNode tail1 = <span class="keyword">null</span>;</span><br><span class="line">        ListNode tail2 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 此外，链表遍历还用到两个指针</span></span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="comment">// 考虑利用虚指针</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        pre = dummy;</span><br><span class="line">        <span class="comment">// 用于标记索引下标</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == m)&#123;</span><br><span class="line">                <span class="comment">//将链表截断</span></span><br><span class="line">                pre.next = <span class="keyword">null</span>;</span><br><span class="line">                tail1 = pre;</span><br><span class="line">                head2 = cur;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == n + <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//将链表截断</span></span><br><span class="line">                pre.next = <span class="keyword">null</span>;</span><br><span class="line">                tail2 = pre;</span><br><span class="line">                pre.next = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 这里可能只有n个节点，但此时到了第i + 1个节点，为null</span></span><br><span class="line">                <span class="keyword">if</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    head3 = cur;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 无论是否需要截断链表都将指针后移</span></span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将其反转拼接第一二段</span></span><br><span class="line">        tail1.next = reverse(head2);</span><br><span class="line">        <span class="comment">// 拼接二三段</span></span><br><span class="line">        head2 = tail1;</span><br><span class="line">        <span class="keyword">while</span>(head2.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            head2 = head2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        head2.next = head3;</span><br><span class="line"><span class="comment">//         这里的拼接过程，我的原本是，没有连接上，若是要连接链表，需要通过next下标</span></span><br><span class="line"><span class="comment">//         while(tail1 != null)&#123;</span></span><br><span class="line"><span class="comment">//             tail1 = tail1.next;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         tail1 = head3;</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里返回反转后的头指针</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode nex = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = nex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM3-链表中的节点每k个一组翻转"><a href="#BM3-链表中的节点每k个一组翻转" class="headerlink" title="BM3 链表中的节点每k个一组翻转"></a>BM3 <a href="https://www.nowcoder.com/practice/b49c3dc907814e9bbfa8437c251b028e?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">链表中的节点每k个一组翻转</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>将给出的链表中的节点每 k 个一组翻转，返回翻转后的链表<br>如果链表中的节点数不是 k 的倍数，将最后剩下的节点保持原样<br>你不能更改节点中的值，只能更改节点本身。</p><p>数据范围：0≤<em>n</em>≤2000 ，1≤<em>k</em>≤2000 ，链表中每个元素都满足 0≤<em>val</em>≤1000</p><p>要求空间复杂度<em>O(1)<em>，时间复杂度、</em>O(n)</em></p><p>例如： </p><p>给定的链表是1→2→3→4→5</p><p>对于<em>k</em>=2 , 你应该返回2→1→4→3→5</p><p>对于<em>k</em>=3 , 你应该返回 3→2→1→4→5</p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>先求出链表的长度，然后判断需要分几组，之后对每组进行反转并连接，过程中需要注意保存以下节点：preStart–&gt;需要反转的节点之前的节点，start–&gt;开始反转的节点，afterStart–&gt;反转结束的下一个节点，end–&gt;反转结束的节点，还有就是反转链表需要的三个节点pre，cur以及nex。</p><p><strong>可用一个虚拟头节点防止头节点各种复杂条件判断</strong></p><p><strong>注意点：每次连接时只连接一端（连接上一个链表和这一个链表），当全部反转都完成之后，再连接这一个链表和下一个链表</strong></p><h3 id="Java代码实现-2"><a href="#Java代码实现-2" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span> <span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 特殊情况，每1个为1组进行反转，直接返回即可</span></span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 长度</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 虚拟头节点</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        <span class="comment">// 反转节点之前的节点</span></span><br><span class="line">        ListNode preStart = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 开始反转的节点（反转之后变成了需要和后面链表进行拼接的节点）</span></span><br><span class="line">        ListNode start = dummy;</span><br><span class="line">        <span class="comment">// 反转结束的节点</span></span><br><span class="line">        ListNode end = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 反转结束节点之后的节点</span></span><br><span class="line">        ListNode afterStart = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 反转过程中需要的节点</span></span><br><span class="line">        ListNode pre = dummy;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        ListNode nex = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ++len;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断需要分几组</span></span><br><span class="line">        <span class="keyword">int</span> group = len / k;</span><br><span class="line">        <span class="comment">// 特殊情况，head为空或为1直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span> || len == <span class="number">1</span> || group &lt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; group; ++i)&#123;</span><br><span class="line">            <span class="comment">// 先记录反转之前的节点以及开始节点</span></span><br><span class="line">            preStart = start;    <span class="comment">// 反转之前的节点实际上是上一反转链表的头（第一次反转，其前一个节点为dummy，故对preStart赋初值应为dummy）</span></span><br><span class="line">            start = cur;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++j)&#123;</span><br><span class="line">                nex = cur.next;</span><br><span class="line">                <span class="comment">// 开始进行反转</span></span><br><span class="line">                cur.next = pre;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = nex;</span><br><span class="line">            &#125;</span><br><span class="line">            end = pre;</span><br><span class="line">            afterStart = cur;</span><br><span class="line">            <span class="comment">// 开始进行连接，注意这里只是连接反转之前的头和这一次的尾</span></span><br><span class="line">            preStart.next = end;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当反转全部完成时，再将这一次反转的尾和反转之后的节点进行连接</span></span><br><span class="line">        start.next = afterStart;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM4-合并两个排序的链表"><a href="#BM4-合并两个排序的链表" class="headerlink" title="BM4 合并两个排序的链表"></a>BM4 <a href="https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">合并两个排序的链表</a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两个递增的链表，单个链表的长度为n，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><p>数据范围： 0≤n≤10000，−1000≤节点值≤1000<br>要求：空间复杂度 O(1)，时间复杂度 O(n)</p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>双指针移动即可，但若是想达到O(1)的时间复杂度，则需要原地修改指针，故选择如下方法：将两个链表中的当前节点标记，标记当前节点的作用是，判断本次应该连接哪一个节点（链表1中的节点或是链表2中的节点），之后再将剩下的链表合并即可。</p><p><strong>可用一个虚拟头节点防止头节点各种复杂条件判断</strong></p><h3 id="Java代码实现-3"><a href="#Java代码实现-3" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 首先考虑特殊情况，即两个链表中一个链表为空时，直接返回另一个链表即可</span></span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="keyword">null</span> || list2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list1 == <span class="keyword">null</span> ? list2 : list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 首先需要两个指针分别记录两个链表走到了哪</span></span><br><span class="line">        ListNode cur1 = list1;</span><br><span class="line">        ListNode cur2 = list2;</span><br><span class="line">        <span class="comment">// 避免考虑头节点，先来个虚拟节点</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode cur = dummy;</span><br><span class="line">        <span class="comment">// 先将两个链表合并</span></span><br><span class="line">        <span class="keyword">while</span>(cur1 != <span class="keyword">null</span> &amp;&amp; cur2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur1.val &lt; cur2.val)&#123;</span><br><span class="line">                cur.next = cur1;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur.next = cur2;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 再合并剩下的部分，此时一个链表已经为空了</span></span><br><span class="line">        cur.next = cur1 == <span class="keyword">null</span> ? cur2 : cur1;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM5-合并k个已排序的链表"><a href="#BM5-合并k个已排序的链表" class="headerlink" title="BM5 合并k个已排序的链表"></a>BM5 <a href="https://www.nowcoder.com/practice/65cfde9e5b9b4cf2b6bafa5f3ef33fa6?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">合并k个已排序的链表</a></h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>合并 k 个升序的链表并将结果作为一个升序的链表返回其头节点。</p><p>数据范围：节点总数 0≤n≤5000，每个节点的val满足 ∣val∣&lt;=100</p><p>要求：时间复杂度 O(nlogn)</p><h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><p>这题只说了要求时间复杂度O(nlogn)，而未要求空间复杂度，我自己的想法是将链表中所有节点的值保存到ArrayList中进行排序，排序之后再依次生成节点即可。</p><h3 id="Java代码实现-4"><a href="#Java代码实现-4" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ArrayList&lt;ListNode&gt; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = lists.size();</span><br><span class="line">        <span class="comment">// 当前节点</span></span><br><span class="line">        ListNode cur = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 存储全部元素所用的集合</span></span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="comment">// 将每个链表的每个节点都存入</span></span><br><span class="line">            cur = lists.get(i);</span><br><span class="line">            <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">                res.add(cur.val);</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(res);</span><br><span class="line">        <span class="comment">// 建一个虚拟头指针已防止头节点的误判</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        cur = dummy;</span><br><span class="line">        <span class="keyword">for</span>(Integer num : res)&#123;</span><br><span class="line">            cur.next = <span class="keyword">new</span> ListNode(num);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是注意以上题解并未使用到一个条件–&gt;这n个链表均为有序链表，因此时间复杂度肯定不是最佳，想到用k个指针进行迭代，但经过k - 1次比较之后才能完成1个数的排序，故其时间复杂度为O(kn)，由此想到维护一个一直有序的数组，每次取出下标为0的位置，并将该数所在链表的后一个节点放入数组中（保证其有序–&gt;这里可以使用二分找到对应的下标），但此时出现矛盾，使用二分进行查找，那数组更合适，但若是涉及插入操作，则链表更合适，，，矛盾，故舍弃此思路。</p><p>但看题解是发现大部分此思路采用的是优先队列来实现，队列自动维护，每次只需取出队头就行。</p><p>看了题解后发现：不是使用k个指针，而是每次合并的时候是两两合并，如有链表1, 2, 3, 4, 5, 6, 7, 8，第一次合并，将12合并，34合并，56合并，78合并，得到四个新链表1, 2, 3, 4，之后再次合并，12合并，34合并，得到链表1, 2，最后再将12合并得到所需的链表，完整题解如下：</p><h3 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h3><p>采用分治法的思想（先分后并），将所给的k个链表分成两份，一直持续地分，分到不能再分为止（k个链表被分为k份），之后再依次将两个链表进行合并，直到合并为最后一个链表为止。</p><h3 id="Java代码实现-5"><a href="#Java代码实现-5" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ArrayList&lt;ListNode&gt; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = lists.size();</span><br><span class="line">        <span class="comment">// 此函数确定需要合并的下标范围0----n-1</span></span><br><span class="line">        <span class="keyword">return</span> merge(lists, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这个函数的作用是从left合并到right</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">merge</span><span class="params">(ArrayList&lt;ListNode&gt; lists, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 若是无法再分，则直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">            <span class="keyword">return</span> lists.get(left);</span><br><span class="line">            <span class="comment">// left &gt; right表示长度为0，即merge(lists, 0, -1)，数组中有任何一个链表为空时都会产生此情况</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 否则考虑合并left， mid为一个链表，mid +1 到right为一个链表</span></span><br><span class="line">            <span class="keyword">return</span> merge2Lists(merge(lists, left, mid), merge(lists, mid + <span class="number">1</span>, right));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这一部分完全就是合并两个链表的代码</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">merge2Lists</span><span class="params">(ListNode list1, ListNode list2)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 首先考虑特殊情况，即两个链表中一个链表为空时，直接返回另一个链表即可</span></span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="keyword">null</span> || list2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list1 == <span class="keyword">null</span> ? list2 : list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 首先需要两个指针分别记录两个链表走到了哪</span></span><br><span class="line">        ListNode cur1 = list1;</span><br><span class="line">        ListNode cur2 = list2;</span><br><span class="line">        <span class="comment">// 避免考虑头节点，先来个虚拟节点</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode cur = dummy;</span><br><span class="line">        <span class="comment">// 先将两个链表合并</span></span><br><span class="line">        <span class="keyword">while</span>(cur1 != <span class="keyword">null</span> &amp;&amp; cur2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur1.val &lt; cur2.val)&#123;</span><br><span class="line">                cur.next = cur1;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur.next = cur2;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 再合并剩下的部分，此时一个链表已经为空了</span></span><br><span class="line">        cur.next = cur1 == <span class="keyword">null</span> ? cur2 : cur1;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM6-判断链表中是否有环"><a href="#BM6-判断链表中是否有环" class="headerlink" title="BM6 判断链表中是否有环"></a>BM6 <a href="https://www.nowcoder.com/practice/650474f313294468a4ded3ce0f7898b9?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">判断链表中是否有环</a></h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>判断给定的链表中是否有环。如果有环则返回true，否则返回false。 </p><p>数据范围：链表长度 0≤n≤10000，链表中任意节点的值满足 ∣val∣&lt;=100000</p><p>要求：空间复杂度 O(1)，时间复杂度 O(n)</p><p>输入分为两部分，第一部分为链表，第二部分代表是否有环，然后将组成的head头结点传入到函数里面。-1代表无环，其它的数字代表有环，这些参数解释仅仅是为了方便读者自测调试。实际在编程时读入的是链表的头节点。</p><p>例如输入{3,2,0,-4},1时，对应的链表结构如下图所示： </p><p><img src="https://uploadfiles.nowcoder.com/images/20220110/423483716_1641800950920/0710DD5D9C4D4B11A8FA0C06189F9E9C" alt="img"></p><p>可以看出环的入口结点为从头结点开始的第1个结点（注：头结点为第0个结点），所以输出true。</p><h3 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h3><p>快慢指针，一个每次走一格，一个每次走两个，若是有环则必会相遇，这里题目中没说任意节点的值均不同，判断两指针是否相遇时最好不只是判断两个节点的val是否相遇而是判断两个指针的地址是否相同</p><h3 id="Java代码实现-6"><a href="#Java代码实现-6" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里注意题目中说0 &lt;= n，故有可能为0，特殊情况优先考虑</span></span><br><span class="line">        <span class="comment">// 由于之后的fast和slow都是先赋值，为了防止对空指针进行操作，需要先进行判断</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head.next;</span><br><span class="line">        ListNode fast = head.next.next;</span><br><span class="line">        <span class="comment">// 快慢指针，若是有一个先遍历完，那必然是快指针</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 这里是先比较后移动，因为第一次移动过了</span></span><br><span class="line">            <span class="keyword">if</span>(slow == fast)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="comment">// 增加这个判断是防止当fast到了最后一个元素时，fast.next.next就对空指针进行了操作</span></span><br><span class="line">            <span class="comment">// 也可以将判断条件加在while循环中，即：while(fast != null &amp;&amp; fast.next != null)</span></span><br><span class="line">            <span class="keyword">if</span>(fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">                fast = fast.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM7-链表中环的入口节点"><a href="#BM7-链表中环的入口节点" class="headerlink" title="BM7 链表中环的入口节点"></a>BM7 <a href="https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">链表中环的入口节点</a></h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><p>给一个长度为n链表，若其中包含环，请找出该链表的环的入口结点，否则，返回null。 </p><p>数据范围： n≤10000，1&lt;=结点值&lt;=10000</p><p>要求：空间复杂度 O(1)，时间复杂度 O(n)</p><p>例如，输入{1,2},{3,4,5}时，对应的环形链表如下图所示：</p><p><img src="https://uploadfiles.nowcoder.com/images/20211025/423483716_1635154005498/DA92C945EF643F1143567935F20D6B46" alt="img"></p><p>可以看到环的入口结点的结点值为3，所以返回结点值为3的结点。</p><h4 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h4><p>输入分为2段，第一段是入环前的链表部分，第二段是链表环的部分，后台会根据第二段是否为空将这两段组装成一个无环或者有环单链表</p><h4 id="返回值描述"><a href="#返回值描述" class="headerlink" title="返回值描述"></a>返回值描述</h4><p>返回链表的环的入口结点即可，我们后台程序会打印这个结点对应的结点值；若没有，则返回对应编程语言的空结点即可。</p><h3 id="题解-7"><a href="#题解-7" class="headerlink" title="题解"></a>题解</h3><p>这题的做法和判断是否有环类似，都是先使用快慢指针找到两个指针重合的位置判定有环，之后注意一个点，此时将其中一个指针移至原链表头并让两个指针以相同的速度移动，那么当两个指针再次相遇时的节点即为入口节点，具体证明如下，图可参考<a href="https://blog.nowcoder.net/n/9d3ffa4b004e43d1aff512141d0d7dac" target="_blank" rel="noopener">官方题解</a>：</p><p>首先假设链表中无环的部分（从头节点到环的入口节点）距离为x，从环的入口到相遇节点的距离为y，从相遇节点再次到环的入口距离为m，则由快慢指针的速度可得如下距离方程：</p><p>(x + y + m + y) / (x + y) = 2</p><p>其中除号左边为快指针走的距离，除号右边为慢指针走的距离，两者走了相同的时间，距离刚好与速度成正比</p><h3 id="Java代码实现-7"><a href="#Java代码实现-7" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况优先考虑</span></span><br><span class="line">        <span class="keyword">if</span>(pHead == <span class="keyword">null</span> || pHead.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode fast = pHead.next.next;</span><br><span class="line">        ListNode slow = pHead.next;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">                <span class="comment">// 此时有环，开始第二轮遍历</span></span><br><span class="line">                fast = pHead;</span><br><span class="line">                <span class="keyword">while</span>(fast != slow)&#123;</span><br><span class="line">                    fast = fast.next;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> fast;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 退出了循环证明无环</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM8-链表中倒数最后k个节点"><a href="#BM8-链表中倒数最后k个节点" class="headerlink" title="BM8 链表中倒数最后k个节点"></a>BM8 <a href="https://www.nowcoder.com/practice/886370fe658f41b498d40fb34ae76ff9?tpId=295&tqId=1377477&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">链表中倒数最后k个节点</a></h2><h3 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个长度为 n 的链表，设链表中的元素的值为 ai ，返回该链表中倒数第k个节点。 </p><p>如果该链表长度小于k，请返回一个长度为 0 的链表。 </p><p>数据范围：0≤n≤105，0≤ai≤109，0≤k≤109</p><p>要求：空间复杂度 O(n)，时间复杂度 O(n)</p><p>进阶：空间复杂度 O(1)，时间复杂度 O(n)</p><p>例如输入{1,2,3,4,5},2时，对应的链表结构如下图所示： </p><p><img src="https://uploadfiles.nowcoder.com/images/20211105/423483716_1636084313645/5407F55227804F31F5C5D73558596F2C" alt="img"></p><p>其中蓝色部分为该链表的最后2个结点，所以返回倒数第2个结点（也即结点值为4的结点）即可，系统会打印后面所有的节点来比较。</p><h3 id="题解-8"><a href="#题解-8" class="headerlink" title="题解"></a>题解</h3><p>两次遍历链表，第一次求出链表长度，第二次直接返回最后k个节点的开始节点</p><h3 id="Java代码实现-8"><a href="#Java代码实现-8" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pHead ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span> <span class="params">(ListNode pHead, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        ListNode cur = pHead;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ++len;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 题目中说若是链表长度小于k则返回空链表，这里已经考虑了链表为空的情况(len = 0)</span></span><br><span class="line">        <span class="keyword">if</span>(len &lt; k)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = pHead;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 这里需要稍微考虑下i++到底应该小于多少</span></span><br><span class="line">        <span class="keyword">while</span>(i++ &lt; len - k)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM9-删除链表的倒数第n个节点"><a href="#BM9-删除链表的倒数第n个节点" class="headerlink" title="BM9 删除链表的倒数第n个节点"></a>BM9 <a href="https://www.nowcoder.com/practice/f95dcdafbde44b22a6d741baf71653f6?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">删除链表的倒数第n个节点</a></h2><h3 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个链表，删除链表的倒数第 n 个节点并返回链表的头指针<br>例如， </p><p>给出的链表为: 1→2→3→4→5, n=2.<br>删除了链表的倒数第 n<em>n</em> 个节点之后,链表变为1→2→3→5.</p><p>数据范围： 链表长度 0≤n≤1000，链表中任意节点的值满足 0≤val≤100</p><p>要求：空间复杂度 O(1)，时间复杂度 O(n)<br>备注： </p><p>题目保证 n 一定是有效的</p><h3 id="题解-9"><a href="#题解-9" class="headerlink" title="题解"></a>题解</h3><p>这里的思路也是两次遍历链表，然后找到需要删除的节点，但要注意保存需要删除的节点之前的节点。</p><p><strong>可用一个虚拟头节点防止各种复杂条件判断</strong></p><h3 id="Java代码实现-9"><a href="#Java代码实现-9" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span> <span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 虚拟头节点</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        <span class="comment">// 遍历需要的两个节点</span></span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        ListNode pre = dummy;</span><br><span class="line">        <span class="comment">// 开始第一次遍历求出链表长度</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ++len;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 题目中说n符合要求，故无需判断，直接二次遍历即可</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//注意这里将cur指针返回head</span></span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span>(i++ &lt; len - n)&#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里将cur节点删除，实际上就是将cur之前的指针与cur之后的指针进行连接即可</span></span><br><span class="line">        pre.next = cur.next;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM10-两个链表的第一个公共结点"><a href="#BM10-两个链表的第一个公共结点" class="headerlink" title="BM10 两个链表的第一个公共结点"></a>BM10 <a href="https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">两个链表的第一个公共结点</a></h2><h3 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两个无环的单向链表，找出它们的第一个公共结点，如果没有公共节点则返回空。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的） </p><p>数据范围： n≤1000<br>要求：空间复杂度 O(1)，时间复杂度 O(n)</p><p>例如，输入{1,2,3},{4,5},{6,7}时，两个无环的单向链表的结构如下图所示：</p><p><img src="https://uploadfiles.nowcoder.com/images/20211104/423483716_1635999204882/394BB7AFD5CEA3DC64D610F62E6647A6" alt="img"></p><p>可以看到它们的第一个公共结点的结点值为6，所以返回结点值为6的结点。</p><h4 id="输入描述："><a href="#输入描述：" class="headerlink" title="输入描述："></a>输入描述：</h4><p>输入分为是3段，第一段是第一个链表的非公共部分，第二段是第二个链表的非公共部分，第三段是第一个链表和第二个链表的公共部分。 后台会将这3个参数组装为两个链表，并将这两个链表对应的头节点传入到函数FindFirstCommonNode里面，用户得到的输入只有pHead1和pHead2。</p><h4 id="返回值描述："><a href="#返回值描述：" class="headerlink" title="返回值描述："></a>返回值描述：</h4><p>返回传入的pHead1和pHead2的第一个公共结点，后台会打印以该节点为头节点的链表。</p><h3 id="题解-10"><a href="#题解-10" class="headerlink" title="题解"></a>题解</h3><p>最简单的方法是先将一个链表中的所有节点放入一个set中，之后对于第二个链表中的每一个节点，若是set中已有，则返回该节点（需要的是第一个公共节点，故只要找到就直接返回），若是遍历完之后仍然没有找到公共节点，那么返回null，但此方法空间复杂度为O(n)，不合题意，若是想要O(1)的时间复杂度可采取如下思路：</p><p>两次遍历链表，第一次遍历记载两个链表的长度，然后找到一个链表比另一个链表长多少(len1 - len2)，较长的链表先走(len1 - len2)格，之后两个链表一起走，若是某时刻两个节点相同，那直接返回，之后若是遍历完仍然未找到相同元素，返回null</p><h3 id="Java代码实现-10"><a href="#Java代码实现-10" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况，若是两个链表某一个为空，那直接返回null</span></span><br><span class="line">        <span class="keyword">if</span>(pHead1 == <span class="keyword">null</span> || pHead2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len2 = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 当前链表1走到了哪</span></span><br><span class="line">        ListNode cur1 = pHead1;</span><br><span class="line">        <span class="comment">// 当前链表2走到了哪</span></span><br><span class="line">        ListNode cur2 = pHead2;</span><br><span class="line">        <span class="keyword">while</span>(cur1 != <span class="keyword">null</span> || cur2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">                ++len1;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">                ++len2;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将指针放回头部</span></span><br><span class="line">        cur1 = pHead1;</span><br><span class="line">        cur2 = pHead2;</span><br><span class="line">        <span class="keyword">if</span>(len1 &gt;= len2)&#123;</span><br><span class="line">            <span class="keyword">return</span> run(cur1, cur2, len1 - len2);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> run(cur2, cur1, len2 - len1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">run</span><span class="params">(ListNode head1, ListNode head2, <span class="keyword">int</span> lenSub)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 先让head1走lenSub格，已经确保head1不比head2短</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i++ &lt; lenSub)&#123;</span><br><span class="line">            head1 = head1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 之后两个一起走</span></span><br><span class="line">        <span class="keyword">while</span>(head1 != <span class="keyword">null</span> &amp;&amp; head2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head1 == head2)&#123;</span><br><span class="line">                <span class="keyword">return</span> head1;</span><br><span class="line">            &#125;</span><br><span class="line">            head1 = head1.next;</span><br><span class="line">            head2 = head2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 要是退出循环（遍历完）还未找到说明不存在</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM11-链表相加（二）"><a href="#BM11-链表相加（二）" class="headerlink" title="BM11 链表相加（二）"></a>BM11 <a href="https://www.nowcoder.com/practice/c56f6c70fb3f4849bc56e33ff2a50b6b?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">链表相加（二）</a></h2><h3 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h3><p>假设链表中每一个节点的值都在 0 - 9 之间，那么链表整体就可以代表一个整数。 </p><p>给定两个这种链表，请生成代表两个整数相加值的结果链表。 </p><p>数据范围：0≤n,m≤1000000，链表任意值 0≤val≤9<br>要求：空间复杂度 O(n)，时间复杂度 O(n)</p><p>例如：链表 1 为 9-&gt;3-&gt;7，链表 2 为 6-&gt;3，最后生成新的结果链表为 1-&gt;0-&gt;0-&gt;0。 </p><p><img src="https://uploadfiles.nowcoder.com/images/20211105/423483716_1636084743981/C2DB572B01B0FDC03C097BE7ABA45114" alt="img"></p><h3 id="题解-11"><a href="#题解-11" class="headerlink" title="题解"></a>题解</h3><p>最简单的方法，将链表中的每一个元素取出来，两个数相加之后再返回，但是注意数据范围是0≤n,m≤1000000，此方法无法保存这么大的数据，故舍弃。</p><p>考虑直接对链表节点进行相加，但涉及两个问题，一是顺序问题（链表是正序的，但是相加时需要逆序），而是考虑进位问题，对于顺序问题，先进后出考虑用栈解决，进位只需多一个节点进行保存即可。</p><h3 id="Java代码实现-11"><a href="#Java代码实现-11" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head1 ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head2 ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addInList</span> <span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 特殊情况优先考虑，若是两个链表一个为空那直接返回另一个即可</span></span><br><span class="line">        <span class="keyword">if</span>(head1 == <span class="keyword">null</span> || head2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head1 == <span class="keyword">null</span> ? head2 : head1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 栈中存节点空间消耗太大，直接存节点中的值即可</span></span><br><span class="line">        <span class="comment">// 保存第一个链表中的数</span></span><br><span class="line">        Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">// 保存第二个链表中的数</span></span><br><span class="line">        Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">// 保存相加之后的结果</span></span><br><span class="line">        Stack&lt;Integer&gt; ans = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        ListNode cur = head1;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack1.push(cur.val);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head2;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack2.push(cur.val);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 进位</span></span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stack1.isEmpty() || !stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> num1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> num2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(!stack1.isEmpty())&#123;</span><br><span class="line">                num1 = stack1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!stack2.isEmpty())&#123;</span><br><span class="line">                num2 = stack2.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> sum = num1 + num2 + carry;</span><br><span class="line">            ans.push(sum % <span class="number">10</span>);</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里最后判断一下进位是否为0，若进位不是0则需要处理</span></span><br><span class="line">        <span class="keyword">if</span>(carry != <span class="number">0</span>)&#123;</span><br><span class="line">            ans.push(carry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 生成链表</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        cur = dummy;</span><br><span class="line">        <span class="keyword">while</span>(!ans.isEmpty())&#123;</span><br><span class="line">            cur.next = <span class="keyword">new</span> ListNode(ans.pop());</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM12-单链表的排序问题"><a href="#BM12-单链表的排序问题" class="headerlink" title="BM12 单链表的排序问题"></a>BM12 <a href="https://www.nowcoder.com/practice/f23604257af94d939848729b1a5cda08?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">单链表的排序问题</a></h2><h3 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个节点数为n的无序单链表，对其按升序排序。</p><p>数据范围：0&lt;n≤100000</p><p>要求：空间复杂度 O(n)，时间复杂度 O(nlogn)</p><h3 id="题解-12"><a href="#题解-12" class="headerlink" title="题解"></a>题解</h3><p>最简单的做法是遍历链表，将链表中每个节点的值放入数组中，对数组进行排序，之后再逐个取出元素并新建链表节点，这里注意将链表的每个节点值存入数组中空间占用更小</p><h3 id="Java代码实现-12"><a href="#Java代码实现-12" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 the head node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortInList</span> <span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 特殊情况，只有一个元素时无需排序（题目中说节点数n &gt; 0）</span></span><br><span class="line">        <span class="keyword">if</span>(head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            list.add(cur.val);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        <span class="comment">// 记得把指针回退</span></span><br><span class="line">        cur = dummy;</span><br><span class="line">        <span class="comment">// 逐一构造</span></span><br><span class="line">        <span class="keyword">for</span>(Integer num : list)&#123;</span><br><span class="line">            cur.next = <span class="keyword">new</span> ListNode(num);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM13-判断一个链表是否是回文结构"><a href="#BM13-判断一个链表是否是回文结构" class="headerlink" title="BM13 判断一个链表是否是回文结构"></a>BM13 <a href="https://www.nowcoder.com/practice/3fed228444e740c8be66232ce8b87c2f?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">判断一个链表是否是回文结构</a></h2><h3 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个链表，请判断该链表是否为回文结构。</p><p>回文是指该字符串正序逆序完全一致。 </p><p>数据范围： 链表节点数 0≤n≤105，链表中每个节点的值满足 ∣val∣≤107</p><h3 id="题解-13"><a href="#题解-13" class="headerlink" title="题解"></a>题解</h3><p>很多实惠，直接对链表进行操作不方便，可以借助数组辅助操作，这里只要将节点中的每个数放入数组中进行比较即可，但这里注意一点，题目中说了回文但是每个节点的值满足|val|&lt;=10^7，那{1, 235, 235, 1}算回文还是{1, 235, 532, 1}算回文，若是第一种的话，只要将每个节点的值放入数组中，两个指针同时移动，判断是否相等即可，若是另一种，则建议将整数转化为字符串进行操作，之后对于字符串中的每个字符进行操作。</p><h3 id="Java代码实现-13"><a href="#Java代码实现-13" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 the head</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPail</span> <span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 特殊情况head为null</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; nums = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            nums.add(cur.val);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="comment">// 注意这里用的是equals而不是==，用==比较的是地址，只有当两个数都在常量池中时才会成功</span></span><br><span class="line">            <span class="keyword">if</span>(!nums.get(i).equals(nums.get(n - i - <span class="number">1</span>)))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码最终是正确的，因此这里所说的回文是第一种，不过需要注意的是在比较Integer的过程中用equals而不是用==，或者就利用自动装箱机制转换为int，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num1 = nums.get(i);</span><br><span class="line"><span class="keyword">int</span> num2 = nums.get(n - i - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(num1 != num2)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM14-链表的奇偶重拍"><a href="#BM14-链表的奇偶重拍" class="headerlink" title="BM14 链表的奇偶重拍"></a>BM14 <a href="https://www.nowcoder.com/practice/02bf49ea45cd486daa031614f9bd6fc3?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">链表的奇偶重拍</a></h2><h3 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个单链表，请设定一个函数，将链表的奇数位节点和偶数位节点分别放在一起，重排后输出。 </p><p>注意是节点的编号而非节点的数值。 </p><p>数据范围：节点数量满足 0≤n≤105，节点中的值都满足 0≤val≤1000</p><p>要求：空间复杂度 O(n)，时间复杂度 O(n)</p><h3 id="题解-14"><a href="#题解-14" class="headerlink" title="题解"></a>题解</h3><p>新建两个链表，一个用于放奇数的节点，一个用于放偶数的节点，再将两个链表连接即可。</p><h3 id="Java代码实现-14"><a href="#Java代码实现-14" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">oddEvenList</span> <span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 特殊情况依旧优先考虑，当链表有012个节点时直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结果链表以及奇偶链表的头节点</span></span><br><span class="line">        ListNode dummy1 = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode dummy2 = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 当前的初始链表以及奇偶链表到达的位置</span></span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        ListNode cur1 = dummy1;</span><br><span class="line">        ListNode cur2 = dummy2;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ++len;</span><br><span class="line">            <span class="comment">// 这里是奇偶判断，只不过位运算更快，故选择位运算</span></span><br><span class="line">            <span class="keyword">if</span>((len &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">                cur1.next = cur;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur2.next = cur;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 防止有粘连，先将链表断开</span></span><br><span class="line">        <span class="comment">// 但思考之后发现只需要断开偶数的即可，因为奇数的后一步操作实际上已经断开了</span></span><br><span class="line">        <span class="keyword">if</span>(cur1.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            cur1.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur2.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            cur2.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将奇链表与偶链表连接，cur1即为奇链表的尾</span></span><br><span class="line">        <span class="comment">// 这里其实已经避免了奇数的粘连</span></span><br><span class="line">        cur1.next = dummy2.next;    <span class="comment">// 注意这里偶链表真正开始的节点为dummy2.next（虚节点）</span></span><br><span class="line">        <span class="keyword">return</span> dummy1.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里有必要提一下我注释中说到的粘连，假设有链表{1, 2, 3, 4, 5, 6}，当进行上述代码的操作之后得到的链表实际是这样的{1, 3, 5, 6} 和{2, 4, 6}，我们需要的只有1 3 5，但6由于在原始链表中是5的next，故也放到了链表中，这对于原链表长度为偶数的时候不影响（因为后面连接的操作实际上已经把粘连部分去除了），但当原链表长度为奇数时就有影响了，假设有链表{1, 2, 3, 4, 5}，操作之后得到的链表是{1, 3, 5}和{2, 4, 5}，此时就无法得到正常结果</strong></p><h2 id="BM15-删除有序链表中重复的元素-I"><a href="#BM15-删除有序链表中重复的元素-I" class="headerlink" title="BM15 删除有序链表中重复的元素-I"></a>BM15 <a href="https://www.nowcoder.com/practice/c087914fae584da886a0091e877f2c79?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">删除有序链表中重复的元素-I</a></h2><h3 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h3><p>删除给出链表中的重复元素（链表中元素从小到大有序），使链表中的所有元素都只出现一次<br>例如：<br>给出的链表为1→1→2,返回1→2.<br>给出的链表为1→1→2→3→3,返回1→2→3. </p><h3 id="题解-15"><a href="#题解-15" class="headerlink" title="题解"></a>题解</h3><p>去重最简单的办法是利用HashSet，每次将节点的值放入HashSet中，又考虑之后还要有序构建，因此考虑LinedHashSet，但此时空间复杂度为O(n)，不合题意。</p><p>想到利用两个指针，一个记录当前位，另一个记录下一位，使用两个指针的目的是，当遇到当前元素与下一位元素相同时，不移动当前位，移动下一位直至当前位与下一位不同时，将当前位与下一位连接，如此遍历数组即可</p><h3 id="Java代码实现-15"><a href="#Java代码实现-15" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span> <span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 特殊情况优先考虑</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        ListNode nex = head.next;</span><br><span class="line">        <span class="comment">// 肯定是后一个先到，但存在一种情况就是后面几个元素都相同时需要显式地令cur.nex = null</span></span><br><span class="line">        <span class="keyword">while</span>(nex != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.val == nex.val)&#123;</span><br><span class="line">                nex = nex.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur.next = nex;</span><br><span class="line">                cur = nex;</span><br><span class="line">                nex = nex.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时cur所在的位置可能有多种</span></span><br><span class="line">        <span class="comment">// 一是倒数第一个元素</span></span><br><span class="line">        <span class="comment">// 二是倒数第k个元素（后面k个元素值都相同）</span></span><br><span class="line">        <span class="comment">// 此时只需比较cur以及其后面第一个元素（前提是其后面有元素），要是相同则显式令其next为null，反之则无需操作</span></span><br><span class="line">        <span class="keyword">if</span>(cur.next != <span class="keyword">null</span> &amp;&amp; cur.val == cur.next.val)&#123;</span><br><span class="line">            cur.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM16-删除有序列表中重复的元素-II"><a href="#BM16-删除有序列表中重复的元素-II" class="headerlink" title="BM16 删除有序列表中重复的元素-II"></a>BM16 <a href="https://www.nowcoder.com/practice/71cef9f8b5564579bf7ed93fbe0b2024?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">删除有序列表中重复的元素-II</a></h2><h3 id="题目描述-15"><a href="#题目描述-15" class="headerlink" title="题目描述"></a>题目描述</h3><p>给出一个升序排序的链表，删除链表中的所有重复出现的元素，只保留原链表中只出现一次的元素。<br>例如：<br>给出的链表为1→2→3→3→4→4→5, 返回1→2→5.<br>给出的链表为1→1→1→2→3, 返回2→3. </p><h3 id="题解-16"><a href="#题解-16" class="headerlink" title="题解"></a>题解</h3><p>第一种思路是使用两个Set加一个数组实现一个set放全部元素，另一个set放重复的元素，数组按序放节点的值，第一次遍历，若是发现放全部元素的Set中已有这个元素，那么将此元素放入放置重复元素的Set中，此外第一次遍历还需要将链表中的全部节点值放入数组中，第二次遍历数组，若是数组中的元素并不属于放重复元素的Set中，那么以此值新建节点并连接到链表中，但此时空间复杂度为O(n)，不合题意。</p><p>正确思路是：使用三个指针，pre表示前一个，cur表示当前，nex表示后一个，若是遇到相同元素，则移动nex指针直到cur与nex值不相同，若是不同则直接pre指向nex，然后三个指针依次后移一位即可</p><h3 id="Java代码实现-16"><a href="#Java代码实现-16" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span> <span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 特殊情况优先考虑</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 防止出现第一个元素就需要删除的情况，用虚拟头节点</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode pre = dummy;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        ListNode nex = head.next;</span><br><span class="line">        <span class="keyword">while</span>(nex != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.val == nex.val)&#123;</span><br><span class="line">                <span class="comment">// 元素相同时不断移动nex指针</span></span><br><span class="line">                <span class="keyword">while</span>(nex != <span class="keyword">null</span> &amp;&amp; cur.val == nex.val)&#123;</span><br><span class="line">                    nex = nex.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//此时以及移动完了，修改指针</span></span><br><span class="line">                pre.next = nex;</span><br><span class="line">                cur = nex;</span><br><span class="line">                <span class="comment">// 退出循环还有一种情况是nex为null了，此时不再后移nex指针</span></span><br><span class="line">                <span class="keyword">if</span>(nex != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    nex = nex.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 元素不同时先连接pre和nex，再移动</span></span><br><span class="line">                pre.next = cur;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = nex;</span><br><span class="line">                nex = nex.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二分查找-排序"><a href="#二分查找-排序" class="headerlink" title="二分查找/排序"></a>二分查找/排序</h1><h2 id="BM17-二分查找-I"><a href="#BM17-二分查找-I" class="headerlink" title="BM17 二分查找-I"></a>BM17 <a href="https://www.nowcoder.com/practice/d3df40bd23594118b57554129cadf47b?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">二分查找-I</a></h2><h3 id="题目描述-16"><a href="#题目描述-16" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现无重复数字的升序数组的二分查找 </p><p>给定一个 元素升序的、无重复数字的整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标（下标从 0 开始），否则返回 -1 </p><p>数据范围：0≤len(nums)≤2×105， 数组中任意值满足 ∣val∣≤109</p><p>进阶：时间复杂度 O(log⁡n)，空间复杂度 O(1)</p><h3 id="题解-17"><a href="#题解-17" class="headerlink" title="题解"></a>题解</h3><p>二分实际上就是把一个数组分为左右两份，每次比较目标值与中间值，若是中间值比较大那证明在左半部分，若是目标值比较大说明在右半部分，若是最后（那部分只有一个数切这个数不为目标值，那证明此数组中没有该目标值）。</p><h3 id="Java代码实现-17"><a href="#Java代码实现-17" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span> <span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">                <span class="comment">// 相等了直接返回</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                <span class="comment">// 比目标值小说明在右半部分</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 否则在左半部分</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM18-二维数组中的查找"><a href="#BM18-二维数组中的查找" class="headerlink" title="BM18 二维数组中的查找"></a>BM18 二维数组中的查找</h2><h3 id="题目描述-17"><a href="#题目描述-17" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个二维数组array中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 </p><p>[ </p><p>[1,2,8,9],<br>[2,4,9,12],<br>[4,7,10,13],<br>[6,8,11,15]</p><p>] </p><p>给定 target = 7，返回 true。 </p><p>给定 target = 3，返回 false。 </p><p>数据范围：矩阵的长宽满足 0≤n,m≤500， 矩阵中的值满足 0≤val≤109<br>进阶：空间复杂度 O(1)，时间复杂度 O(n+m)</p><h3 id="题解-18"><a href="#题解-18" class="headerlink" title="题解"></a>题解</h3><p>这题首先保证目标值和当前值大小关系确定时只需向一个方向移动（比如说当前值小于目标值时是应该向下移动或是向右移动），为了保证这一点，我们可以从数组的右上或是左下开始遍历，从右上遍历保证当前数是这一行最大的，当前这一列最小的，若是需要更大的只需要往下找即可，若是需要更小的只需要往左找即可，从左下开始遍历可以保证每个数都是当前这一行最小的，当前这一列最大的，若是需要更大的就往右走，若是需要更小的就往左走。</p><h3 id="Java代码实现-18"><a href="#Java代码实现-18" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(array == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 确定行列数</span></span><br><span class="line">        <span class="keyword">int</span> m = array.length;</span><br><span class="line">        <span class="keyword">int</span> n = array[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// 从右上开始遍历，行数为0列数为n-1</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= m - <span class="number">1</span> &amp;&amp; j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i][j] == target)&#123;</span><br><span class="line">                <span class="comment">// 相等返回true</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[i][j] &lt; target)&#123;</span><br><span class="line">                <span class="comment">// 小于就往下找</span></span><br><span class="line">                ++i;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 大于就往左找</span></span><br><span class="line">                --j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时仍未找到就返回false；</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM19-寻找峰值"><a href="#BM19-寻找峰值" class="headerlink" title="BM19 寻找峰值"></a>BM19 <a href="https://www.nowcoder.com/practice/fcf87540c4f347bcb4cf720b5b350c76?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">寻找峰值</a></h2><h3 id="题目描述-18"><a href="#题目描述-18" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个长度为n的数组nums，请你找到峰值并返回其索引。数组可能包含多个峰值，在这种情况下，返回任何一个所在位置即可。 </p><p>1.峰值元素是指其值严格大于左右相邻值的元素。严格大于即不能有等于</p><p>2.假设 nums[-1] = nums[n] = −∞</p><p>3.对于所有有效的 i 都有 nums[i] != nums[i + 1] </p><p>4.你可以使用O(logN)的时间复杂度实现此问题吗？ </p><p>数据范围： </p><p>1≤nums.length≤2×105</p><p>−231&lt;=nums[i]&lt;=2^31−1</p><p>如输入[2,4,1,2,7,8,4]时，会形成两个山峰，一个是索引为1，峰值为4的山峰，另一个是索引为5，峰值为8的山峰，如下图所示： </p><p><img src="https://uploadfiles.nowcoder.com/images/20211014/423483716_1634212356346/9EB9CD58B9EA5E04C890326B5C1F471F" alt="img"></p><h3 id="题解-19"><a href="#题解-19" class="headerlink" title="题解"></a>题解</h3><p>题目中已经假定数组之外的部分都为无穷小，那么当发现此时数组是递增的，那么就一定会存在山峰，因为即使递增到数组的边界，那边界值就是山峰（边界之外的部分是无穷小），反之若是递减则不一定存在山峰。</p><p>明确了以上问题之后，可以用二分的方式进行查询，但二分的思想需要一个目标值target，让target与中间值比较，在这里我们选择使用中间值的后一位作为target（这里注意只有当left == right == n - 1中间值才取到最后一位的，但此时实际上right即为波峰），那么当target大于中间值时，从中间值到target必有一部分是递增的，当target小于中间值的时候，我们考虑数组的另一部分。</p><h3 id="Java代码实现-19"><a href="#Java代码实现-19" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span> <span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 特殊情况只有一个元素时是波峰</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 这里的不同之处在于不能取等号，因为最后面返回的值是最大值，即只要一直在上坡，那么right永远大于mid大于left</span></span><br><span class="line">        <span class="comment">// 反之若是发现在下坡，那就寻找另一半</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[mid + <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="comment">// 此时右侧为上坡，继续寻找即可</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 此时右侧为下坡，为了避免当前值为波峰，这里right应为mid而不是mid - 1</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM20-数组中的逆序对"><a href="#BM20-数组中的逆序对" class="headerlink" title="BM20 数组中的逆序对"></a>BM20 <a href="https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">数组中的逆序对</a></h2><h3 id="题目描述-19"><a href="#题目描述-19" class="headerlink" title="题目描述"></a>题目描述</h3><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P mod 1000000007</p><p>数据范围： 对于 50%50% 的数据, size≤104<br>对于 100%100% 的数据, size≤105</p><p>数组中所有数字的值满足 0≤val≤1000000</p><p>要求：空间复杂度 O(n)，时间复杂度 O(nlogn)</p><h2 id="题解-20"><a href="#题解-20" class="headerlink" title="题解"></a>题解</h2><p>这题由于是逆序对（只有两个元素），因此最简单的方法是将数组中所有的数对都表示出来，之后判断是否是逆序对，是的话在逆序对计数的地方加1，如此便能解决问题，但时间复杂度为O(n^2)，题目中要求的是O(nlogn)，不合题意。</p><p>这题看时间复杂度想到用合并排序的思想来解决问题，合并排序中需要对两个有序数组进行合并，此时需要移动元素，若是当前元素比其前一个元素小，那么就需要前移元素，此时，一个前移操作就找到了一个逆序对，计算出每次合并需要的元素个数即为逆序对的数目。</p><h3 id="Java代码实现-20"><a href="#Java代码实现-20" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOD = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(array == <span class="keyword">null</span> || array.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在分治的过程中求出解</span></span><br><span class="line">        mergeSort(array);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分治算法的思想，先将数组分为有限个子序列，先令子序列有序，再合并有序的字序列</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] nums1 = Arrays.copyOfRange(nums, <span class="number">0</span>, n / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">int</span>[] nums2 = Arrays.copyOfRange(nums, n / <span class="number">2</span>, n);</span><br><span class="line">            mergeSort(nums1);</span><br><span class="line">            mergeSort(nums2);</span><br><span class="line">            merge(nums, nums1, nums2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在这里对两个数组进行合并并在每次合并中查找逆序对</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] sorted, <span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> n2 = nums2.length;</span><br><span class="line">        <span class="comment">// 标记当前两个数组走到了哪</span></span><br><span class="line">        <span class="keyword">int</span> cur1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cur2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sorted.length; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur1 == n1)&#123;</span><br><span class="line">                <span class="comment">// 第一个数组遍历完了</span></span><br><span class="line">                sorted[i] = nums2[cur2];</span><br><span class="line">                ++cur2;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur2 == n2)&#123;</span><br><span class="line">                <span class="comment">// 第二个数组遍历完了</span></span><br><span class="line">                sorted[i] = nums1[cur1];</span><br><span class="line">                ++cur1;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 两个数组都没遍历完</span></span><br><span class="line">                <span class="keyword">if</span>(nums1[cur1] &gt; nums2[cur2])&#123;</span><br><span class="line">                    <span class="comment">// 需要先插入后面的元素</span></span><br><span class="line">                    sorted[i] = nums2[cur2];</span><br><span class="line">                  <span class="comment">// 特别注意这里，总共有6个元素，当前下标为3表示是第四个元素（这个元素已经后面的全部元素都是逆序对）</span></span><br><span class="line">                    res += n1 - cur1;</span><br><span class="line">                    res %= MOD;</span><br><span class="line">                    ++cur2;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    sorted[i] = nums1[cur1];</span><br><span class="line">                    ++cur1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这个题解跟大部分的思路不同，采用了最原始的Arrays.copyOfRange()方法，因此res += 部分也与其余题解有所不同，但思路一致。</strong></p><h2 id="BM21-旋转数组的最小数字"><a href="#BM21-旋转数组的最小数字" class="headerlink" title="BM21 旋转数组的最小数字"></a>BM21 <a href="https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">旋转数组的最小数字</a></h2><h3 id="题目描述-20"><a href="#题目描述-20" class="headerlink" title="题目描述"></a>题目描述</h3><p>有一个长度为 n 的非降序数组，比如[1,2,3,4,5]，将它进行旋转，即把一个数组最开始的若干个元素搬到数组的末尾，变成一个旋转数组，比如变成了[3,4,5,1,2]，或者[4,5,1,2,3]这样的。请问，给定这样一个旋转数组，求数组中的最小值。</p><p>数据范围：1≤n≤10000，数组中任意元素的值: 0≤val≤10000</p><p>要求：空间复杂度：O(1)，时间复杂度：O(logn)</p><h3 id="题解-21"><a href="#题解-21" class="headerlink" title="题解"></a>题解</h3><p>最简单的方法是遍历数组找到最小值，但时间复杂度是O(n)，不合题意。由于数组原始是非降序的之后将最开始的几个元素搬到了末尾，那么数组部分是有序的，可以使用二分，以数组的端点作为target值，当中间值小于target时，证明在左半部分（由于原数组非降序，不可能出现大于最大值之后，从最小值开始仍然大于中间值，即不可能出现mid到target是{6, 7, 1, 4, 8}的情况），当中间值大于target时，证明在右半部分，若是特别特殊，两者相等，即原数组为{5, 5, 5, 5, 5, 1, 2, 3, 4, 5}或者{1, 0, 1, 1, 1}时，无法确定属于哪部分，令target = nums[right - 1]，缩小范围后继续，如此循环便能找到。</p><h3 id="Java代码实现-21"><a href="#Java代码实现-21" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(array.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[mid] &lt; array[right])&#123;</span><br><span class="line">                <span class="comment">// 小于表示在左半部分</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[mid] &gt; array[right])&#123;</span><br><span class="line">                <span class="comment">// 大于表示在右半部分</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 等于则缩小范围</span></span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用二分法时，有时题目中没有target，那么需要考虑如何选择target才最优，寻找山峰问题target是中间值的下一位，而这里target是right</strong></p><h2 id="BM22-比较版本号"><a href="#BM22-比较版本号" class="headerlink" title="BM22 比较版本号"></a>BM22 <a href="https://www.nowcoder.com/practice/2b317e02f14247a49ffdbdba315459e7?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">比较版本号</a></h2><h3 id="题目描述-21"><a href="#题目描述-21" class="headerlink" title="题目描述"></a>题目描述</h3><p>牛客项目发布项目版本时会有版本号，比如1.02.11，2.14.4等等 </p><p>现在给你2个版本号version1和version2，请你比较他们的大小</p><p>版本号是由修订号组成，修订号与修订号之间由一个”.”连接。1个修订号可能有多位数字组成，修订号可能包含前导0，且是合法的。例如，1.02.11，0.1，0.2都是合法的版本号</p><p>每个版本号至少包含1个修订号。 </p><p>修订号从左到右编号，下标从0开始，最左边的修订号下标为0，下一个修订号下标为1，以此类推。 </p><p>比较规则： </p><p>一. 比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较忽略任何前导零后的整数值。比如”0.1”和”0.01”的版本号是相等的 </p><p>二. 如果版本号没有指定某个下标处的修订号，则该修订号视为0。例如，”1.1”的版本号小于”1.1.1”。因为”1.1”的版本号相当于”1.1.0”，第3位修订号的下标为0，小于1 </p><p>三. version1 &gt; version2 返回1，如果 version1 &lt; version2 返回-1，不然返回0. </p><p>数据范围： </p><p>1&lt;=version1.length,version2.length&lt;=1000</p><p>version1 和 version2 的修订号不会超过int的表达范围，即不超过 <strong>32 位整数</strong> 的范围</p><p>进阶： 空间复杂度 O(1)， 时间复杂度 O(n)</p><h3 id="题解-22"><a href="#题解-22" class="headerlink" title="题解"></a>题解</h3><p>最简单的方法是利用.将两个字符串分解为字符数组，之后逐个比较，但此方法需要额外开辟空间，空间复杂度为O(n)，不合题意。</p><h3 id="Java代码实现如下"><a href="#Java代码实现如下" class="headerlink" title="Java代码实现如下"></a>Java代码实现如下</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 比较版本号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> version1 string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> version2 string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span> <span class="params">(String version1, String version2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">      <span class="comment">// 这里注意正则表达式的书写，\需要转译</span></span><br><span class="line">        String[] strs1 = version1.split(<span class="string">"\\."</span>);</span><br><span class="line">        String[] strs2 = version2.split(<span class="string">"\\."</span>);</span><br><span class="line">        <span class="keyword">int</span> len1 = strs1.length;</span><br><span class="line">        <span class="keyword">int</span> len2 = strs2.length;</span><br><span class="line">        <span class="keyword">int</span> minLen = len1 &lt; len2 ? len1 : len2;</span><br><span class="line">      <span class="comment">// 匹配两者都有的部分</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; minLen; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> num1 = Integer.parseInt(strs1[i]);</span><br><span class="line">            <span class="keyword">int</span> num2 = Integer.parseInt(strs2[i]);</span><br><span class="line">            <span class="keyword">if</span>(num1 &lt; num2)&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num1 &gt; num2)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// 匹配完了开始判断</span></span><br><span class="line">        <span class="keyword">if</span>(len1 == len2)&#123;</span><br><span class="line">            <span class="comment">// 长度相等直接返回0（之前已经能确定全部匹配）</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len1 &gt; len2)&#123;</span><br><span class="line">            <span class="comment">// version1比较长，多出来的和0比较</span></span><br><span class="line">            <span class="keyword">while</span>(minLen &lt; len1)&#123;</span><br><span class="line">                <span class="keyword">if</span>(Integer.parseInt(strs1[minLen]) != <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ++minLen;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// version2长同理，和0比较</span></span><br><span class="line">            <span class="keyword">while</span>(minLen &lt; len2)&#123;</span><br><span class="line">                <span class="keyword">if</span>(Integer.parseInt(strs2[minLen]) != <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ++minLen;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题解-23"><a href="#题解-23" class="headerlink" title="题解"></a>题解</h3><p>若是想达到O(1)的空间复杂度，可以考虑使用双指针，一个指针用于解析version1，一个指针用于解析version2，对于前导0的处理是不处理（因为每次只用处理一个字符，若是当前字符不是’.’，那么直接用已经解析出的值（当前值前面的值） * 10 + 当前的值），遇到前导0，已经解析出的值为0，0 * 10 + 0 = 0，并无影响，此方法主要是逐个读取字符，即：”103”的解析过程为1，1 * 10 + 0 = 10，10 * 10 + 3 = 103。</p><h3 id="Java代码实现-22"><a href="#Java代码实现-22" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 比较版本号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> version1 string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> version2 string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span> <span class="params">(String version1, String version2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">char</span>[] str1 = version1.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] str2 = version2.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> len1 = str1.length;</span><br><span class="line">        <span class="keyword">int</span> len2 = str2.length;</span><br><span class="line">        <span class="comment">// 两个遍历指针</span></span><br><span class="line">        <span class="keyword">int</span> cur1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cur2 = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 只要两个字符串中任何一个没有解析完，那就继续解析</span></span><br><span class="line">        <span class="keyword">while</span>(cur1 &lt; len1 || cur2 &lt; len2)&#123;</span><br><span class="line">            <span class="comment">// 设置解析出的元素，初始值为0</span></span><br><span class="line">            <span class="keyword">int</span> num1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> num2 = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 只有str1未解析完才解析，否则其为0</span></span><br><span class="line">            <span class="keyword">if</span>(cur1 &lt; len1)&#123;</span><br><span class="line">                <span class="comment">// 这里必须是cur++，否则会导致解析不到.之前的那个数，而且这样也直接跳过了.</span></span><br><span class="line">                <span class="keyword">while</span>(cur1 &lt; len1 &amp;&amp; str1[cur1++] != <span class="string">'.'</span>)&#123;</span><br><span class="line">                    <span class="comment">// 这里为什么是cur-1呢，因为前面已经自增过一次</span></span><br><span class="line">                    num1 = <span class="number">10</span> * num1 + str1[cur1 - <span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 同理只有str2未解析完才解析，否则为初始值0</span></span><br><span class="line">            <span class="keyword">if</span>(cur2 &lt; len2)&#123;</span><br><span class="line">                <span class="comment">// 这里必须是cur++，否则会导致解析不到.之前的那个数，而且这样也直接跳过了.</span></span><br><span class="line">                <span class="keyword">while</span>(cur2 &lt; len2 &amp;&amp; str2[cur2++] != <span class="string">'.'</span>)&#123;</span><br><span class="line">                    <span class="comment">// 这里为什么是cur-1呢，因为前面已经自增过一次</span></span><br><span class="line">                    num2 = <span class="number">10</span> * num2 + str2[cur2 - <span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 通过以上步骤已经将两个都解析了，这里只需要判断就好</span></span><br><span class="line">            <span class="keyword">if</span>(num1 &gt; num2)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num1 &lt; num2)&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h3 id="BM23-二叉树的前序遍历"><a href="#BM23-二叉树的前序遍历" class="headerlink" title="BM23 二叉树的前序遍历"></a>BM23 <a href="https://www.nowcoder.com/practice/5e2135f4d2b14eb8a5b06fab4c938635?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">二叉树的前序遍历</a></h3><h3 id="题目描述-22"><a href="#题目描述-22" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你二叉树的根节点 root ，返回它节点值的 前序 遍历。</p><p>数据范围：二叉树的节点数量满足 1≤n≤100，二叉树节点的值满足 1≤val≤100，树的各节点的值各不相同</p><h3 id="题解-24"><a href="#题解-24" class="headerlink" title="题解"></a>题解</h3><p>二叉树的前序遍历就是先访问根节点，再访问左右子树，即“根左右”。</p><h3 id="Java代码实现-23"><a href="#Java代码实现-23" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] preorderTraversal (TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 用于保存返回结果</span></span><br><span class="line">        ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(root, ans);</span><br><span class="line">        <span class="comment">// 这里这个方法之前没用过，若是不用此方法也可以，如下：</span></span><br><span class="line">        <span class="comment">// int[] res = new int(ans.size());</span></span><br><span class="line">        <span class="comment">// for(int i = 0; i &lt; ans.size(); ++i)&#123;</span></span><br><span class="line">        <span class="comment">//     res[i] = ans.get(i);</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="keyword">return</span> ans.stream().mapToInt(Integer::valueOf).toArray();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; nums)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 可以不用这个cur变量直接在root上操作，但使用这个变量可以保证root不会变化</span></span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            nums.add(root.val);</span><br><span class="line">            dfs(root.left, nums);</span><br><span class="line">            dfs(root.right, nums);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM24-二叉树的中序遍历"><a href="#BM24-二叉树的中序遍历" class="headerlink" title="BM24 二叉树的中序遍历"></a>BM24 <a href="https://www.nowcoder.com/practice/0bf071c135e64ee2a027783b80bf781d?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">二叉树的中序遍历</a></h2><h3 id="题目描述-23"><a href="#题目描述-23" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树的根节点root，返回它的中序遍历结果。 </p><p>数据范围：树上节点数满足 0≤n≤1000，树上每个节点的值满足 0≤val≤1000<br>进阶：空间复杂度 O(n)，时间复杂度 O(n)</p><h3 id="题解-25"><a href="#题解-25" class="headerlink" title="题解"></a>题解</h3><p>二叉树的中序遍历就是先访问左子树，再访问根节点，最后访问右子树，即“左根右”。</p><h3 id="Java代码实现-24"><a href="#Java代码实现-24" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] inorderTraversal (TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 用于保存返回结果</span></span><br><span class="line">        ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(root, ans);</span><br><span class="line">        <span class="keyword">return</span> ans.stream().mapToInt(Integer::valueOf).toArray();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; nums)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 可以不用这个cur变量直接在root上操作，但使用这个变量可以保证root不会变化</span></span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            dfs(root.left, nums);</span><br><span class="line">            nums.add(root.val);</span><br><span class="line">            dfs(root.right, nums);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM25-二叉树的后序遍历"><a href="#BM25-二叉树的后序遍历" class="headerlink" title="BM25 二叉树的后序遍历"></a>BM25 <a href="https://www.nowcoder.com/practice/1291064f4d5d4bdeaefbf0dd47d78541?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">二叉树的后序遍历</a></h2><h3 id="题目描述-24"><a href="#题目描述-24" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树，返回他的后序遍历的序列。 </p><p>后序遍历是值按照 左节点-&gt;右节点-&gt;根节点 的顺序的遍历。 </p><p>数据范围：二叉树的节点数量满足 1≤n≤100，二叉树节点的值满足 1≤val≤100，树的各节点的值各不相同</p><h3 id="题解-26"><a href="#题解-26" class="headerlink" title="题解"></a>题解</h3><p>二叉树的后序遍历就是先访问左右子树，再访问根节点，即“左右根”。</p><h3 id="Java代码实现-25"><a href="#Java代码实现-25" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] postorderTraversal (TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 用于保存返回结果</span></span><br><span class="line">        ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(root, ans);</span><br><span class="line">        <span class="keyword">return</span> ans.stream().mapToInt(Integer::valueOf).toArray();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; nums)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 可以不用这个cur变量直接在root上操作，但使用这个变量可以保证root不会变化</span></span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            dfs(root.left, nums);</span><br><span class="line">            dfs(root.right, nums);</span><br><span class="line">            nums.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>前中后序遍历只有dfs函数的顺序不同，其余操作完全一致</strong></p><h2 id="BM26-求二叉树的层序遍历"><a href="#BM26-求二叉树的层序遍历" class="headerlink" title="BM26 求二叉树的层序遍历"></a>BM26 <a href="https://www.nowcoder.com/practice/04a5560e43e24e9db4595865dc9c63a3?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">求二叉树的层序遍历</a></h2><h3 id="题目描述-25"><a href="#题目描述-25" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树，返回该二叉树层序遍历的结果，（从左到右，一层一层地遍历）<br>例如：<br>给定的二叉树是{3,9,20,#,#,15,7},<br><img src="https://uploadfiles.nowcoder.com/images/20210114/999991351_1610616074120/036DC34FF19FB24652AFFEB00A119A76" alt="img"><br>该二叉树层序遍历的结果是<br>[<br>[3],<br>[9,20],<br>[15,7] </p><p>] </p><p>提示: </p><p>0 &lt;= 二叉树的结点数 &lt;= 1500</p><h3 id="题解-27"><a href="#题解-27" class="headerlink" title="题解"></a>题解</h3><p>层序遍历实际上就是BFS（广度优先搜索），一般情况下，深度优先遍历用栈辅助操作，广度优先遍历用队列辅助操作，具体操作如下：</p><p>首先判断根节点是否为空，若是为空直接返回空，不为空将根节点放入队列中，当队列不为空的时候就不断循环，取出队头，将其左右子树分别插入队尾，直到队列为空时就得到了BFS结果。</p><h3 id="Java代码实现-26"><a href="#Java代码实现-26" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型ArrayList&lt;ArrayList&lt;&gt;&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelOrder (TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 用于返回结果</span></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 特殊情况优先考虑</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用于存放每一层的节点</span></span><br><span class="line">        ArrayList&lt;TreeNode&gt; nodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 链表实际上实现了Queue接口</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 将根节点放入队列中</span></span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; nums = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">// 取出当前层所有节点</span></span><br><span class="line">            <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">                TreeNode cur = queue.poll();</span><br><span class="line">                nums.add(cur.val);</span><br><span class="line">                nodes.add(cur);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对于这一层的所有节点，遍历</span></span><br><span class="line">            <span class="keyword">for</span>(TreeNode cur : nodes)&#123;</span><br><span class="line">                <span class="comment">// 左子树不为空，放入队列</span></span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.offer(cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 右子树不为空，放入队列</span></span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.offer(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(nums);</span><br><span class="line">            <span class="comment">// 注意结束后将nodes置空</span></span><br><span class="line">            nodes.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里的话注意返回的是一个二维数组，故每次都需要将这一层的数据取完，保存在一个中间数组中，之后在每一层新建一个数组用于放置节点值</strong></p><h2 id="BM27-按之字形顺序打印二叉树"><a href="#BM27-按之字形顺序打印二叉树" class="headerlink" title="BM27 按之字形顺序打印二叉树"></a>BM27 <a href="https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">按之字形顺序打印二叉树</a></h2><h3 id="题目描述-26"><a href="#题目描述-26" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树，返回该二叉树的之字形层序遍历，（第一层从左向右，下一层从右向左，一直这样交替） </p><p>数据范围：0≤n≤1500,树上每个节点的val满足 ∣val∣&lt;=150<br>要求：空间复杂度：O(n)<em>O</em>(<em>n</em>)，时间复杂度：O(n)<em>O</em>(<em>n</em>)</p><p>例如：<br>给定的二叉树是{1,2,3,#,#,4,5}<br><img src="https://uploadfiles.nowcoder.com/images/20210717/557336_1626492068888/41FDD435F0BA63A57E274747DE377E05" alt="img"><br>该二叉树之字形层序遍历的结果是 </p><p>[ </p><p>[1], </p><p>[3,2], </p><p>[4,5] </p><p>]</p><h3 id="题解-28"><a href="#题解-28" class="headerlink" title="题解"></a>题解</h3><p>这题也是层序遍历只不过遍历的顺序不一致，这就需要考虑利用辅助变量level外加栈来控制顺序，首先将根节点放入栈中，此时level为1，若是level为奇数则先放左子树后放右子树，因为栈的性质，在下一次遍历时右子树就会优先被输出，若是level为偶数，那么先放右子树后方左子树，那么下次遍历时左子树就会优先被输出，知道栈空位置。</p><h3 id="Java代码实现-27"><a href="#Java代码实现-27" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 特殊情况依旧优先考虑</span></span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用于判断层数（奇数先右后左，偶数先左后右）</span></span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 用于存储某一层的全部节点</span></span><br><span class="line">        ArrayList&lt;TreeNode&gt; nodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 先将根节点入栈</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(pRoot);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// 用于保存这一层所有元素</span></span><br><span class="line">            ArrayList&lt;Integer&gt; nums = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">// 取出这一层所有元素</span></span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">                TreeNode cur = stack.pop();</span><br><span class="line">                nums.add(cur.val);</span><br><span class="line">                nodes.add(cur);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((level &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 奇数层，那么表示下一次是偶数层，需要从右到左，因为栈的性质，先放左子树</span></span><br><span class="line">                <span class="keyword">for</span>(TreeNode node : nodes)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        stack.push(node.left);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        stack.push(node.right);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 偶数层，下一层是奇数层，需要从左到右，因为栈的性质，先放右子树</span></span><br><span class="line">                <span class="keyword">for</span>(TreeNode node : nodes)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        stack.push(node.right);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        stack.push(node.left);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将这一层的结果加入结果集中</span></span><br><span class="line">            res.add(nums);</span><br><span class="line">            <span class="comment">// 增加层数</span></span><br><span class="line">            ++level;</span><br><span class="line">            <span class="comment">// 将nodes集置空</span></span><br><span class="line">            nodes.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对于BFS，一般使用队列，对于这种需要确定顺序的，只需要在偶数层反转队列即可，Java中队列没有自带的reverse方法，故不考虑此做法，这里插一句，利用两个队列可以实现一个栈，利用两个栈也可以实现一个队列，具体做法是，只保证其中一个有数据，插入时只查到有数据的那个，删除时将前n-1个数据移到另一部分，再将最后一个元素取出</strong></p><p><strong>这里判断奇偶性使用的是或运算而不是对2求余，这样会快一些</strong></p><h2 id="BM28-二叉树的最大深度"><a href="#BM28-二叉树的最大深度" class="headerlink" title="BM28 二叉树的最大深度"></a>BM28 <a href="https://www.nowcoder.com/practice/8a2b2bf6c19b4f23a9bdb9b233eefa73?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">二叉树的最大深度</a></h2><h3 id="题目描述-27"><a href="#题目描述-27" class="headerlink" title="题目描述"></a>题目描述</h3><p>求给定二叉树的最大深度， </p><p>深度是指树的根节点到任一叶子节点路径上节点的数量。 </p><p>最大深度是所有叶子节点的深度的最大值。 </p><p>（注：叶子节点是指没有子节点的节点。）</p><p>数据范围：0≤n≤100000，树上每个节点的val满足 ∣val∣≤100<br>要求： 空间复杂度 O(1),时间复杂度 O(n)</p><h3 id="题解-29"><a href="#题解-29" class="headerlink" title="题解"></a>题解</h3><p>两个思路，一是利用栈，栈的最大长度即为二叉树的最大深度，但使用栈会导致空间复杂度为O(n)，不合题意舍弃。</p><p>直接dfs，并在dfs的过程中维护最大深度，但此方法递归调用，空间复杂度也是O(n)，愚以为没有O(1)空间复杂度的方法。</p><h3 id="Java代码实现-28"><a href="#Java代码实现-28" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span> <span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 特殊情况优先考虑</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则就递归求左右子树中比较大的那个 + 1就是答案</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM29-二叉树中和为某一值的路径"><a href="#BM29-二叉树中和为某一值的路径" class="headerlink" title="BM29 二叉树中和为某一值的路径"></a>BM29 <a href="https://www.nowcoder.com/practice/508378c0823c423baa723ce448cbfd0c?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">二叉树中和为某一值的路径</a></h2><h3 id="题目描述-28"><a href="#题目描述-28" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树root和一个值 sum ，判断是否有从根节点到叶子节点的节点值之和等于 sum 的路径。</p><p>1.该题路径定义为从树的根结点开始往下一直到叶子结点所经过的结点</p><p>2.叶子节点是指没有子节点的节点</p><p>3.路径只能从父节点到子节点，不能从子节点到父节点</p><p>4.总节点数目为n</p><p>例如：<br>给出如下的二叉树， sum=22，<br><img src="https://uploadfiles.nowcoder.com/images/20200807/999991351_1596786493913_8BFB3E9513755565DC67D86744BB6159" alt="img"><br>返回true，因为存在一条路径 5→4→11→2的节点值之和为 22 </p><p>数据范围： </p><p>1.树上的节点数满足 0≤n≤10000</p><p>2.每 个节点的值都满足 ∣val∣≤1000</p><p>要求：空间复杂度 O(n)，时间复杂度 O(n)</p><p>进阶：空间复杂度 O(树的高度)，时间复杂度 O(n)</p><h3 id="题解-30"><a href="#题解-30" class="headerlink" title="题解"></a>题解</h3><p>毫无疑问BFS，两种思路，一是直接递归，二是使用栈保存遍历的节点，退出的条件是，当前节点值为需要的值且此节点是叶子节点，若是不是叶子节点那么继续dfs，只不过dfs的变量变为root.left和sum - root.val</p><h3 id="Java代码实现-29"><a href="#Java代码实现-29" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sum int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span> <span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 这里特殊情况先考虑，之后再dfs</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum -= root.val;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; sum == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left, sum) || hasPathSum(root.right, sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里为什么不直接if(root == null &amp;&amp; sum == 0) return true;主要原因是，若是某一个节点左子树或者右子树为null，当遍历到这个节点的时候，sum已经== 0 了但是这不是路径，因此当遍历到它那棵空子树时就会导致此条件成立，但此时并不是路径（考虑用例{1, 2}, sum = 1）</strong></p><h2 id="BM30-二叉搜索树与双向链表"><a href="#BM30-二叉搜索树与双向链表" class="headerlink" title="BM30 二叉搜索树与双向链表"></a>BM30 <a href="https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">二叉搜索树与双向链表</a></h2><h3 id="题目描述-29"><a href="#题目描述-29" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。如下图所示 </p><p><img src="https://uploadfiles.nowcoder.com/images/20210605/557336_1622886924427/E1F1270919D292C9F48F51975FD07CE2" alt="img"></p><p>数据范围：输入二叉树的节点数 0≤n≤1000，二叉树中每个节点的值 0≤val≤1000<br>要求：空间复杂度O(1)（即在原树上操作），时间复杂度 O(n)</p><p>注意: </p><p>1.要求不能创建任何新的结点，只能调整树中结点指针的指向。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继<br>2.返回链表中的第一个节点的指针<br>3.函数返回的TreeNode，有左右指针，其实可以看成一个双向链表的数据结构 </p><p>4.你不用输出双向链表，程序会根据你的返回值自动打印输出</p><h4 id="输入描述：-1"><a href="#输入描述：-1" class="headerlink" title="输入描述："></a>输入描述：</h4><p>二叉树的根节点</p><h4 id="返回值描述：-1"><a href="#返回值描述：-1" class="headerlink" title="返回值描述："></a>返回值描述：</h4><p>双向链表的其中一个头节点。</p><h3 id="题解-31"><a href="#题解-31" class="headerlink" title="题解"></a>题解</h3><p>最简单的方法是二叉树中序遍历得到一个结果数组，再利用数组中的每一个值新建节点构成双向链表，最后返回，但此法需要额外申请空间，空间复杂度为O(n)，不合题意。</p><p>若是需要在原树上进行操作，对于一个节点，其前驱节点（左子树）应为其左子树中序遍历的最后一个值，其后继节点因为其中序遍历的第一个值，而且只有最左的节点没有前驱节点，最右的节点没有后继节点。</p><h3 id="Java代码实现-30"><a href="#Java代码实现-30" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 链表的根</span></span><br><span class="line">    TreeNode root = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 上一次反转得到的链表尾</span></span><br><span class="line">    TreeNode preTail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况优先考虑</span></span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 中序遍历，先左</span></span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            Convert(pRootOfTree.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 保存根节点，这里保存根节点的目的是，每次操作之后就只剩下了当前这课子树的头</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            root = pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 中序遍历，再根，在这里对左右子树进行修改操作</span></span><br><span class="line">        <span class="keyword">if</span>(preTail != <span class="keyword">null</span>)&#123;</span><br><span class="line">            preTail.right = pRootOfTree;</span><br><span class="line">            pRootOfTree.left = preTail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里注意将这个指针移位</span></span><br><span class="line">        preTail = pRootOfTree;</span><br><span class="line">        <span class="comment">// 中序遍历，后右</span></span><br><span class="line">        Convert(pRootOfTree.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了递归版本，那自然也有非递归版本，非递归版本实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况优先考虑</span></span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree == <span class="keyword">null</span> || (pRootOfTree.left == <span class="keyword">null</span> &amp;&amp; pRootOfTree.right == <span class="keyword">null</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">        TreeNode cur = pRootOfTree;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">// 这里一次找到最左边的节点，也就是链表的头</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取出这个最左边的节点并保存，保存的原因是它需要作为头节点</span></span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        pRootOfTree = cur;</span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="comment">// 这里实际上cur = null</span></span><br><span class="line">        cur = cur.right;</span><br><span class="line">        <span class="comment">// 之后将所有的元素一一放入</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// 对于每个节点也是左根右</span></span><br><span class="line">            <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 这里思考一个问题，遍历一次之后其实已经将cur变为cur.right了，因此这里已经将cur.right放入栈中了</span></span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = stack.pop();</span><br><span class="line">            cur.left = pre;</span><br><span class="line">            pre.right = cur;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对于这个栈，先不停地将左节点放入，之后进行根节点的变换(由于第一个元素已经单独拿出来考虑，因此无需担心对pre的空指针操作，也可学习链表，初始时pre是一个虚拟头节点)，最后将当前节点转化为右子树</span></span><br><span class="line">        <span class="keyword">return</span> pRootOfTree;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中序非递归的核心代码是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dfs(TreeNode root)&#123;</span><br><span class="line">  Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span>(root != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">      <span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">          stack.push(root);</span><br><span class="line">          root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//对于根节点进行操作</span></span><br><span class="line">      <span class="keyword">do</span> something;</span><br><span class="line">      root = root.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM31对称的二叉树"><a href="#BM31对称的二叉树" class="headerlink" title="BM31对称的二叉树"></a>BM31<a href="https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">对称的二叉树</a></h2><h3 id="题目描述-30"><a href="#题目描述-30" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一棵二叉树，判断其是否是自身的镜像（即：是否对称）<br>例如：                 下面这棵二叉树是对称的<br><img src="https://uploadfiles.nowcoder.com/images/20210926/382300087_1632642756706/A22A794C036C06431E632F9D5E2E298F" alt="img"><br>下面这棵二叉树不对称。<br><img src="https://uploadfiles.nowcoder.com/images/20210926/382300087_1632642770481/3304ABDD147D8E140B2CEF3201BD8372" alt="img"></p><p>数据范围：节点数满足 0≤n≤1000，节点上的值满足 ∣val∣≤1000</p><p>要求：空间复杂度 O(n)，时间复杂度 O(n)</p><p>备注： </p><p>你可以用递归和迭代两种方法解决这个问题</p><h3 id="题解-32"><a href="#题解-32" class="headerlink" title="题解"></a>题解</h3><p>建立一个辅助函数帮助判断左右子树是否对称。</p><p>当左右子树均为空时返回true，当左右子树有一个为空时返回false；否则判断两个子树根节点的值是否相等以及左子树的左子树是否和右子树的右子树对称以及左子树的右子树是否和右子树的左子树对称。</p><h3 id="Java代码实现-31"><a href="#Java代码实现-31" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(pRoot.left, pRoot.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(TreeNode left, TreeNode right)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 两子树均为空时true</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时已经确定两棵子树不同为空，那么满足条件时只有一棵子树为空</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span> || right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 看当前左右子树根节点是否对称以及左子树的左子树是否和右子树的右子树对称以及左子树的右子树是否和右子树的左子树对称</span></span><br><span class="line">        <span class="keyword">return</span> left.val == right.val &amp;&amp; helper(left.left, right.right) &amp;&amp; helper(left.right, right.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM32-合并二叉树"><a href="#BM32-合并二叉树" class="headerlink" title="BM32 合并二叉树"></a>BM32 <a href="https://www.nowcoder.com/practice/7298353c24cc42e3bd5f0e0bd3d1d759?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">合并二叉树</a></h2><h3 id="题目描述-31"><a href="#题目描述-31" class="headerlink" title="题目描述"></a>题目描述</h3><p>已知两颗二叉树，将它们合并成一颗二叉树。合并规则是：都存在的结点，就将结点值加起来，否则空的位置就由另一个树的结点来代替。例如：<br>两颗二叉树是:<br>                                  Tree 1 </p><p><img src="https://uploadfiles.nowcoder.com/images/20210928/382300087_1632821337680/9E290CFD3730B9B08A5CEFF25799608F" alt="img"></p><p>​                                    Tree 2<br><img src="https://uploadfiles.nowcoder.com/images/20210928/382300087_1632821376266/DD0A63560E770A8510049C5182E6E622" alt="img"><br>​                                  合并后的树为<br><img src="https://uploadfiles.nowcoder.com/images/20210928/382300087_1632821404541/9CB750F8909D5985C0D01D8B71AD58BA" alt="img"></p><p>数据范围：树上节点数量满足 0≤n≤500，树上节点的值一定在32位整型范围内。 </p><p>进阶：空间复杂度 O(1)，时间复杂度 O(n)</p><h3 id="题解-33"><a href="#题解-33" class="headerlink" title="题解"></a>题解</h3><p>对于两个树，都以某种顺序进行遍历，直达左右节点都为null时结束。</p><h3 id="Java代码实现-32"><a href="#Java代码实现-32" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t1 TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t2 TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> TreeNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span> <span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 特殊情况优先考虑</span></span><br><span class="line">        <span class="keyword">if</span>(t1 == <span class="keyword">null</span> || t2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> t1 == <span class="keyword">null</span> ? t2 : t1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时确保两者都不为空</span></span><br><span class="line">        t1.val += t2.val;</span><br><span class="line">      <span class="comment">// t1的左子树为合并t1 t2左子树的结果</span></span><br><span class="line">        t1.left = mergeTrees(t1.left, t2.left);</span><br><span class="line">      <span class="comment">// t1的右子树为合并t1 t2右子树的结果</span></span><br><span class="line">        t1.right = mergeTrees(t1.right, t2.right);</span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM33-二叉树的镜像"><a href="#BM33-二叉树的镜像" class="headerlink" title="BM33 二叉树的镜像"></a>BM33 <a href="https://www.nowcoder.com/practice/a9d0ecbacef9410ca97463e4a5c83be7?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">二叉树的镜像</a></h2><h3 id="题目描述-32"><a href="#题目描述-32" class="headerlink" title="题目描述"></a>题目描述</h3><p>操作给定的二叉树，将其变换为源二叉树的镜像。 </p><p>数据范围：二叉树的节点数 0≤n≤1000， 二叉树每个节点的值 0≤val≤1000</p><p>要求： 空间复杂度 O(n)。本题也有原地操作，即空间复杂度 O(1)的解法，时间复杂度 O(n)</p><p>比如： </p><p>源二叉树</p><p><img src="https://uploadfiles.nowcoder.com/images/20210922/382300087_1632302001586/420B82546CFC9760B45DD65BA9244888" alt="img"></p><p>镜像二叉树 </p><p><img src="https://uploadfiles.nowcoder.com/images/20210922/382300087_1632302036250/AD8C4CC119B15070FA1DBAA1EBE8FC2A" alt="img"></p><h3 id="题解-34"><a href="#题解-34" class="headerlink" title="题解"></a>题解</h3><p>递归实现，先将当前节点的左右子树交换，之后再递归实现左右子树的镜像。</p><h3 id="Java代码实现-33"><a href="#Java代码实现-33" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pRoot TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> TreeNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Mirror</span> <span class="params">(TreeNode pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span> || pRoot.left == <span class="keyword">null</span> &amp;&amp; pRoot.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> pRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode temp = pRoot.left;</span><br><span class="line">        pRoot.left = pRoot.right;</span><br><span class="line">        pRoot.right = temp;</span><br><span class="line">        Mirror(pRoot.left);</span><br><span class="line">        Mirror(pRoot.right);</span><br><span class="line">        <span class="keyword">return</span> pRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM34-判断是不是二叉搜索树"><a href="#BM34-判断是不是二叉搜索树" class="headerlink" title="BM34 判断是不是二叉搜索树"></a>BM34 <a href="https://www.nowcoder.com/practice/a69242b39baf45dea217815c7dedb52b?tpId=295&tqId=2288088&ru=%2Fpractice%2Fa9d0ecbacef9410ca97463e4a5c83be7&qru=%2Fta%2Fformat-top101%2Fquestion-ranking&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">判断是不是二叉搜索树</a></h2><h3 id="题目描述-33"><a href="#题目描述-33" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树根节点，请你判断这棵树是不是二叉搜索树。 </p><p>二叉搜索树满足每个节点的左子树上的所有节点均小于当前节点且右子树上的所有节点均大于当前节点。 </p><p>例： </p><p><img src="https://uploadfiles.nowcoder.com/images/20211109/392807_1636440937987/9C31F319601A5B78D34F62FF77A02A11" alt="img"></p><p>图1 </p><p><img src="https://uploadfiles.nowcoder.com/images/20211109/392807_1636440984427/5E5B576E11CB2C96724680C94755ABCB" alt="img"></p><p>图2 </p><p>数据范围：节点数量满足 1≤n≤104，节点上的值满足 −231≤val≤231−1</p><h3 id="题解-35"><a href="#题解-35" class="headerlink" title="题解"></a>题解</h3><p>最简单的方法是中序遍历二叉树得到数组，看数组中每个元素是否严格小于后一个数</p><h3 id="Java代码实现-34"><a href="#Java代码实现-34" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span> <span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; nums = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(root, nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.size() - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums.get(i) &gt;= nums.get(i + <span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            dfs(root.left, nums);</span><br><span class="line">            nums.add(root.val);</span><br><span class="line">            dfs(root.right, nums);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题解-36"><a href="#题解-36" class="headerlink" title="题解"></a>题解</h3><p>或者就是在中序遍历的过程中直接比较，不使用额外数组</p><h3 id="Java代码实现-35"><a href="#Java代码实现-35" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> pre = Integer.MIN_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span> <span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dfs(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            flag = (flag &amp;&amp; dfs(root.left));</span><br><span class="line">            flag = (flag &amp;&amp; (root.val &gt; pre));</span><br><span class="line">            pre = root.val;</span><br><span class="line">            flag = (flag &amp;&amp; dfs(root.right));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM35-判断是不是完全二叉树"><a href="#BM35-判断是不是完全二叉树" class="headerlink" title="BM35 判断是不是完全二叉树"></a>BM35 <a href="https://www.nowcoder.com/practice/8daa4dff9e36409abba2adbe413d6fae?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">判断是不是完全二叉树</a></h2><h3 id="题目描述-34"><a href="#题目描述-34" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树，确定他是否是一个完全二叉树。 </p><p>完全二叉树的定义：若二叉树的深度为 h，除第 h 层外，其它各层的结点数都达到最大个数，第 h 层所有的叶子结点都连续集中在最左边，这就是完全二叉树。（第 h 层可能包含 [1~2h] 个节点）</p><p>数据范围：节点数满足 1≤n≤100</p><p>样例图1： </p><p><img src="https://uploadfiles.nowcoder.com/images/20211112/392807_1636687704633/3FDF585A954EFF629B41FD21BA20B0C9" alt="img"></p><p>样例图2： </p><p><img src="https://uploadfiles.nowcoder.com/images/20211112/392807_1636687742831/942721EB3583D230F79D69B3097D3416" alt="img"></p><p>样例图3： </p><p><img src="https://uploadfiles.nowcoder.com/images/20211112/392807_1636687774162/1D0ED443BD0A777690EF55BABCD978D5" alt="img"></p><h3 id="题解-37"><a href="#题解-37" class="headerlink" title="题解"></a>题解</h3><p>判断是不是完全二叉树，需要层序遍历二叉树，具体实现方式是，维护一个是否结束的标记，将这一层的所有节点放入一个数组，若是发现了之前已经为空并且现在也为空那直接返回，否则继续遍历。</p><h3 id="Java代码实现-36"><a href="#Java代码实现-36" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCompleteTree</span> <span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 特殊情况，只有一层直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先将根节点放入</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="comment">// 判断是否为空</span></span><br><span class="line">        <span class="keyword">boolean</span> ifEnd = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            <span class="comment">// 这里只有当节点为空时才标记结束</span></span><br><span class="line">            <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">                ifEnd = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 节点不为空</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 若是队列中还有节点但是之前已经标记结束了，那不是完全二叉树</span></span><br><span class="line">                <span class="keyword">if</span>(!queue.isEmpty() &amp;&amp; ifEnd)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将其左右节点放入</span></span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">                <span class="comment">// 这里思考一个问题：</span></span><br><span class="line">                <span class="comment">// 若是左右子树均为空，</span></span><br><span class="line">                <span class="comment">// 那么其实就会不停的将空节点出栈并把isEnd重复置为true</span></span><br><span class="line">                <span class="comment">// 注意队列中放null元素是可以的</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM36-判断是不是平衡二叉树"><a href="#BM36-判断是不是平衡二叉树" class="headerlink" title="BM36 判断是不是平衡二叉树"></a>BM36 <a href="https://www.nowcoder.com/practice/8b3b95850edb4115918ecebdf1b4d222?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">判断是不是平衡二叉树</a></h2><h3 id="题目描述-35"><a href="#题目描述-35" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一棵节点数为 n 二叉树，判断该二叉树是否是平衡二叉树。 </p><p>在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树 </p><p><strong>平衡二叉树</strong>（Balanced Binary Tree），具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p><p>样例解释： </p><p><img src="https://uploadfiles.nowcoder.com/images/20210918/382300087_1631935149594/D55A07912354B3AB7E9F2F5EA27CB7D6" alt="img"></p><p>样例二叉树如图，为一颗平衡二叉树</p><p>注：我们约定空树是平衡二叉树。</p><p>数据范围：n≤100,树上节点的val值满足 0≤n≤1000</p><p>要求：空间复杂度O(1)，时间复杂度 O(n)</p><h4 id="输入描述：-2"><a href="#输入描述：-2" class="headerlink" title="输入描述："></a>输入描述：</h4><p>输入一棵二叉树的根节点</p><h4 id="返回值描述：-2"><a href="#返回值描述：-2" class="headerlink" title="返回值描述："></a>返回值描述：</h4><p>输出一个布尔类型的值</p><h3 id="题解-38"><a href="#题解-38" class="headerlink" title="题解"></a>题解</h3><p>题目中已经介绍了平衡二叉树的判断条件，只需要按照条件进行判断即可，选择递归的思想，以当前节点为根的树是否是平衡二叉树的条件是，是一棵空树或者其左右子树的高度差不超过1，我们可以设一个递归函数用于求树的高度，若是为空则高度为0，否则是左右子树最大值+1，最后判断是否平衡即可。</p><h3 id="Java代码实现-37"><a href="#Java代码实现-37" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Math.abs(len(root.left) - len(root.right)) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> IsBalanced_Solution(root.left) &amp;&amp; IsBalanced_Solution(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">len</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(len(root.left), len(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是观察之后发现这里递归调用的次数太多了，即每次判断树的高度都需要递归调用获取长度的函数，但好多节点之前已经重复计算过，因此考虑将之前记忆过的数据进行保存，即记忆化搜索具体做法如下：</p><p>使用一次dfs函数，计算出全部节点的高度，之后保存在一个HashMap中，每次需要的时候直接从HashMap中取出对应的高度即可。</p><h3 id="Java代码实现-38"><a href="#Java代码实现-38" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    HashMap&lt;TreeNode, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先将map初始化</span></span><br><span class="line">        len(root);</span><br><span class="line">        <span class="keyword">return</span> dfs(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(map.get(root.left) - map.get(root.right)) &lt;= <span class="number">1</span> &amp;&amp; dfs(root.left) &amp;&amp; dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">len</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 每次先观察之前有没有这个key</span></span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(root))&#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            map.put(root, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左子树长度计算</span></span><br><span class="line">        <span class="keyword">int</span> lenLeft = len(root.left);</span><br><span class="line">        <span class="comment">// 右子树长度计算</span></span><br><span class="line">        <span class="keyword">int</span> lenRight = len(root.right);</span><br><span class="line">        <span class="comment">// 判断当前长度</span></span><br><span class="line">        <span class="keyword">int</span> curLen = Math.max(lenLeft, lenRight) + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 插入到map中</span></span><br><span class="line">        map.put(root, curLen);</span><br><span class="line">        <span class="comment">// 返回</span></span><br><span class="line">        <span class="keyword">return</span> curLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM37-二叉搜索树的最近公共祖先"><a href="#BM37-二叉搜索树的最近公共祖先" class="headerlink" title="BM37 二叉搜索树的最近公共祖先"></a>BM37 <a href="https://www.nowcoder.com/practice/d9820119321945f588ed6a26f0a6991f?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">二叉搜索树的最近公共祖先</a></h2><h3 id="题目描述-36"><a href="#题目描述-36" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>1.对于该题的最近的公共祖先定义:对于有根树T的两个节点p、q，最近公共祖先LCA(T,p,q)表示一个节点x，满足x是p和q的祖先且x的深度尽可能大。在这里，一个节点也可以是它自己的祖先.</p><p>2.二叉搜索树是若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值</p><p>3.所有节点的值都是唯一的。</p><p>4.p、q 为不同节点且均存在于给定的二叉搜索树中。</p><p>数据范围:</p><p>3&lt;=节点总数&lt;=10000</p><p>0&lt;=节点值&lt;=10000</p><p>如果给定以下搜索二叉树: {7,1,12,0,4,11,14,#,#,3,5}，如下图:</p><p><img src="https://uploadfiles.nowcoder.com/images/20211110/301499_1636536407371/36404CF45DDCB5834FC8BBFEA318831A" alt="img"></p><h3 id="题解-39"><a href="#题解-39" class="headerlink" title="题解"></a>题解</h3><p>题目中已经说了是二叉搜索树，利用二叉搜索树的性质可以发现，中序遍历二叉搜索树，对于二叉树中的节点来说，若是到了某一个节点，所给的两个节点第一次分别位于它的两侧那么这个就是最近公共祖先，直接返回，由于是二叉搜索树，因此此时公共祖先的值比大的值小，比小的值大。</p><h3 id="Java代码实现-39"><a href="#Java代码实现-39" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> q int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lowestCommonAncestor</span> <span class="params">(TreeNode root, <span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 保证进入dfs函数中的值都是前小后大，题目中已说两个值不同</span></span><br><span class="line">        <span class="keyword">if</span>(p &gt; q)&#123;</span><br><span class="line">            <span class="keyword">return</span> dfs(root, q, p);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> dfs(root, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode cur, <span class="keyword">int</span> small, <span class="keyword">int</span> large)</span></span>&#123;</span><br><span class="line">      <span class="comment">// 找到了直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(cur.val &lt;= large &amp;&amp; cur.val &gt;= small)&#123;</span><br><span class="line">            <span class="keyword">return</span> cur.val;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur.val &lt; small)&#123;</span><br><span class="line">            <span class="comment">// 比小的还小，那么去右半部分着</span></span><br><span class="line">            <span class="keyword">return</span> dfs(cur.right, small, large);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 去左半部分找</span></span><br><span class="line">            <span class="keyword">return</span> dfs(cur.left, small, large);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM38-在二叉树中找到两个节点的最近公共祖先"><a href="#BM38-在二叉树中找到两个节点的最近公共祖先" class="headerlink" title="BM38 在二叉树中找到两个节点的最近公共祖先"></a>BM38 <a href="https://www.nowcoder.com/practice/e0cc33a83afe4530bcec46eba3325116?tpId=295&tqId=1024325&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">在二叉树中找到两个节点的最近公共祖先</a></h2><h3 id="题目描述-37"><a href="#题目描述-37" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一棵二叉树(保证非空)以及这棵树上的两个节点对应的val值 o1 和 o2，请找到 o1 和 o2 的最近公共祖先节点。 </p><p>数据范围：树上节点数满足 1≤n≤105, 节点值val满足区间 [0,n)</p><p>要求：时间复杂度 O(n)</p><p>注：本题保证二叉树中每个节点的val值均不相同。</p><p>如当输入{3,5,1,6,2,0,8,#,#,7,4},5,1时，二叉树{3,5,1,6,2,0,8,#,#,7,4}如下图所示：</p><p><img src="https://uploadfiles.nowcoder.com/images/20211014/423483716_1634206667843/D2B5CA33BD970F64A6301FA75AE2EB22" alt="img"></p><p>所以节点值为5和节点值为1的节点的最近公共祖先节点的节点值为3，所以对应的输出为3。</p><p>节点本身可以视为自己的祖先</p><h3 id="题解-40"><a href="#题解-40" class="headerlink" title="题解"></a>题解</h3><p>递归实现，首先规定此节点为null时返回-1无效值，若是此节点是所给值中的某一个，那么返回此节点的值，若都不满足，则说明所给点在该节点的子树中，分别递归求出是否在左右子树中（-1不在别的在），若不在左子树中就在右子树中，若是不在右子树中就在左子树中，若是即在左子树中又在右子树中则说明此节点即为最近公共祖先。</p><h3 id="Java代码实现-40"><a href="#Java代码实现-40" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o1 int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o2 int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lowestCommonAncestor</span> <span class="params">(TreeNode root, <span class="keyword">int</span> o1, <span class="keyword">int</span> o2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 标记不是路径的节点为-1</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此节点是其中的某一个值，那么此节点即为公共祖先</span></span><br><span class="line">        <span class="keyword">if</span>(root.val == o1 || root.val == o2)&#123;</span><br><span class="line">            <span class="keyword">return</span> root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 看是否在左子树中</span></span><br><span class="line">        <span class="keyword">int</span> left = lowestCommonAncestor(root.left, o1, o2);</span><br><span class="line">        <span class="comment">// 看是否在右子树中</span></span><br><span class="line">        <span class="keyword">int</span> right = lowestCommonAncestor(root.right, o1, o2);</span><br><span class="line">        <span class="comment">// left为-1表示在右子树中</span></span><br><span class="line">        <span class="keyword">if</span>(left == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(right == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 此时left不为-1，right为-1，那么在左侧</span></span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 此时左右子树均不为-1，故一个节点在左侧，一个节点在右侧，那么此时就是祖先</span></span><br><span class="line">            <span class="keyword">return</span> root.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM39-序列化二叉树"><a href="#BM39-序列化二叉树" class="headerlink" title="BM39 序列化二叉树"></a>BM39 <a href="https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">序列化二叉树</a></h2><h3 id="题目描述-38"><a href="#题目描述-38" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现两个函数，分别用来序列化和反序列化二叉树，不对序列化之后的字符串进行约束，但要求能够根据序列化之后的字符串重新构造出一棵与原二叉树相同的树。 </p><p>二叉树的序列化(Serialize)是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树等遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#）</p><p>二叉树的反序列化(Deserialize)是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。</p><p>例如，可以根据层序遍历的方案序列化，如下图:</p><p><img src="https://uploadfiles.nowcoder.com/images/20210910/557336_1631245540483/320409CB186FCD18144519959D510D7E" alt="img"></p><p>层序序列化(即用函数Serialize转化)如上的二叉树转为”{1,2,3,#,#,6,7}”，再能够调用反序列化(Deserialize)将”{1,2,3,#,#,6,7}”构造成如上的二叉树。</p><p>当然你也可以根据满二叉树结点位置的标号规律来序列化，还可以根据先序遍历和中序遍历的结果来序列化。不对序列化之后的字符串进行约束，所以欢迎各种奇思妙想。 </p><p>数据范围：节点数 n≤100<em>n</em>≤100，树上每个节点的值满足 0≤val≤150</p><p>要求：序列化和反序列化都是空间复杂度 O(n)，时间复杂度 O(n)</p><h3 id="题解-41"><a href="#题解-41" class="headerlink" title="题解"></a>题解</h3><p>这题建议使用层序遍历保存节点值，因为这样的遍历方式可以确定每一层的元素，之后构造时也比较方便，即每一层的节点数都是2 ^ (n - 1)，而且除了第一层之外，每一层的节点开始位置都是第2 ^ (n - 1) - 1，这里学习了<a href="https://blog.nowcoder.net/n/0a2e49c8412b45c7b4b2d99ad8a83aeb" target="_blank" rel="noopener">三叶大神</a>的一个思路就是使用一个无效节点来表示空节点。</p><h3 id="Java代码实现-41"><a href="#Java代码实现-41" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里空节点的取值不能和有效值重复，因为val大于0，故选择-1</span></span><br><span class="line">    TreeNode NULL = <span class="keyword">new</span> TreeNode(-<span class="number">1</span>);</span><br><span class="line">    <span class="function">String <span class="title">Serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根节点为空直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用于保存结果</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">// 用于层序遍历</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 先将根节点放入</span></span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// 取出第一个元素</span></span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            <span class="comment">// 先把此节点值放入</span></span><br><span class="line">            sb.append(node.val + <span class="string">","</span>);</span><br><span class="line">            <span class="comment">// 若是此节点是空节点，那么就不继续放此节点的左右子树</span></span><br><span class="line">            <span class="keyword">if</span>(!node.equals(NULL))&#123;</span><br><span class="line">                <span class="comment">// 若是此节点是非空节点，判断左右节点是否是空节点，若是null用空节点表示</span></span><br><span class="line">                queue.offer(node.left == <span class="keyword">null</span> ? NULL : node.left);</span><br><span class="line">                queue.offer(node.right == <span class="keyword">null</span> ? NULL : node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode <span class="title">Deserialize</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 若是序列化字符为空则直接安排</span></span><br><span class="line">       <span class="keyword">if</span>(str.equals(<span class="string">""</span>))&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="comment">// 先把节点分出来</span></span><br><span class="line">        String[] strs = str.split(<span class="string">","</span>);</span><br><span class="line">        <span class="keyword">int</span> n = strs.length;</span><br><span class="line">        <span class="comment">// 先构造根节点</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(strs[<span class="number">0</span>]));</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="comment">// 这里我原本想的是计算出一共有多少层之后再对每一层的节点进行判断</span></span><br><span class="line">        <span class="comment">// 之后发现这个层次数不方便计算，这里是参照三叶大神的思路</span></span><br><span class="line">        <span class="comment">// 每次取出两个值，对当前队列中的节点构造其左右子树</span></span><br><span class="line">        <span class="comment">// 此外这里已经把根节点构建了，因此从第一个节点开始即可</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i += <span class="number">2</span>)&#123;</span><br><span class="line">            TreeNode cur = queue.poll();</span><br><span class="line">            <span class="comment">// 当前节点左子树的值</span></span><br><span class="line">            <span class="keyword">int</span> left = Integer.parseInt(strs[i]);</span><br><span class="line">            <span class="comment">// 当前节点右子树的值</span></span><br><span class="line">            <span class="keyword">int</span> right = Integer.parseInt(strs[i + <span class="number">1</span>]);</span><br><span class="line">            <span class="comment">// 这里注意left若是为-1那么表示当前的左子树其实是空子树</span></span><br><span class="line">            <span class="keyword">if</span>(left != -<span class="number">1</span>)&#123;</span><br><span class="line">                cur.left = <span class="keyword">new</span> TreeNode(left);</span><br><span class="line">                <span class="comment">// 注意构造节点之后要将其放入队列中防止找不到</span></span><br><span class="line">                queue.offer(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(right != -<span class="number">1</span>)&#123;</span><br><span class="line">                cur.right = <span class="keyword">new</span> TreeNode(right);</span><br><span class="line">                queue.offer(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 构建完之后返回即可</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM40-重建二叉树"><a href="#BM40-重建二叉树" class="headerlink" title="BM40 重建二叉树"></a>BM40 <a href="https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">重建二叉树</a></h2><h3 id="题目描述-39"><a href="#题目描述-39" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定节点数为 n 的二叉树的前序遍历和中序遍历结果，请重建出该二叉树并返回它的头结点。</p><p>例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建出如下图所示。 </p><p><img src="https://uploadfiles.nowcoder.com/images/20210717/557336_1626504921458/776B0E5E0FAD11A6F15004B29DA5E628" alt="img"></p><p>提示: </p><p>1.vin.length == pre.length</p><p>2.pre 和 vin 均无重复元素</p><p>3.vin出现的元素均出现在 pre里</p><p>4.只需要返回根结点，系统会自动输出整颗树做答案对比</p><p>数据范围：n≤2000，节点的值 −10000≤val≤10000</p><p>要求：空间复杂度 O(n)，时间复杂度 O(n)</p><h3 id="题解-42"><a href="#题解-42" class="headerlink" title="题解"></a>题解</h3><p>这题抓住谦虚遍历和中序遍历的性质，前序遍历序列中第一个必是根节点，从前序遍历序列中找到这棵子树的根节点，之后中序序列中在根节点左侧的是左子树，在根节点右侧的是右子树，再求左右子树的根节点，如此递归解决便可。</p><h3 id="Java代码实现-42"><a href="#Java代码实现-42" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] vin)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 为空树时直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(pre.length == <span class="number">0</span> || vin.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到当前pre的第一个序列就是根节点</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 在中序序列中找到根节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vin.length; ++i)&#123;</span><br><span class="line">            <span class="comment">// 注意这里每次copy之后需要的都是pre的第一个元素</span></span><br><span class="line">            <span class="keyword">if</span>(vin[i] == pre[<span class="number">0</span>])&#123;</span><br><span class="line"> <span class="comment">// 这里对于范围的选择，其实关键因素是vin的范围，pre只要和vin长度一致即可</span></span><br><span class="line">                <span class="comment">// 从vin数组的开头到根节点之前的一部分是左子树</span></span><br><span class="line">                <span class="comment">// vin根节点之后到最后的部分是右子树</span></span><br><span class="line">                <span class="comment">// 递归构造左子树</span></span><br><span class="line">                root.left = reConstructBinaryTree(Arrays.copyOfRange(pre, <span class="number">1</span>, i + <span class="number">1</span>), Arrays.copyOfRange(vin, <span class="number">0</span>, i));</span><br><span class="line">                <span class="comment">// 递归构造右子树</span></span><br><span class="line">                root.right = reConstructBinaryTree(Arrays.copyOfRange(pre, i + <span class="number">1</span>, pre.length), Arrays.copyOfRange(vin, i + <span class="number">1</span>, vin.length));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM41-输出二叉树的右试图"><a href="#BM41-输出二叉树的右试图" class="headerlink" title="BM41 输出二叉树的右试图"></a>BM41 <a href="https://www.nowcoder.com/practice/c9480213597e45f4807880c763ddd5f0?tpId=295&tqId=1073834&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">输出二叉树的右试图</a></h2><h3 id="题目描述-40"><a href="#题目描述-40" class="headerlink" title="题目描述"></a>题目描述</h3><p>请根据二叉树的前序遍历，中序遍历恢复二叉树，并打印出二叉树的右视图</p><p>数据范围： 0≤n≤10000<br>要求： 空间复杂度 O(n)，时间复杂度 O(n)</p><p>如输入[1,2,4,5,3],[4,2,5,1,3]时，通过前序遍历的结果[1,2,4,5,3]和中序遍历的结果[4,2,5,1,3]可重建出以下二叉树：</p><p><img src="https://uploadfiles.nowcoder.com/images/20211014/423483716_1634208293748/10FB15C77258A991B0028080A64FB42D" alt="img"></p><p>所以对应的输出为[1,3,5]。</p><h3 id="题解-43"><a href="#题解-43" class="headerlink" title="题解"></a>题解</h3><p>首先需要明确的是什么树二叉树的右试图，物体的三视图表示物体从三个不同的方向所能看到的物体的样子，在这里二叉树的右试图其实就是每一层的最后一个（最右边）的节点，明白了这一点之后就可以进行操作了。</p><p>首先先根据二叉树的先序和中序遍历构造出二叉树，对于这棵二叉树使用层序遍历，遍历完成之后输出每一层最后的节点即为所需的答案。</p><h3 id="Java代码实现-43"><a href="#Java代码实现-43" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="comment">//     class TreeNode&#123;</span></span><br><span class="line"><span class="comment">//         int val;</span></span><br><span class="line"><span class="comment">//         TreeNode left;</span></span><br><span class="line"><span class="comment">//         TreeNode right;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     * 求二叉树的右视图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> xianxu int整型一维数组 先序遍历</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> zhongxu int整型一维数组 中序遍历</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] solve (<span class="keyword">int</span>[] xianxu, <span class="keyword">int</span>[] zhongxu) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 首先判断特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(xianxu.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> xianxu;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 保存结果</span></span><br><span class="line">        ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;(); </span><br><span class="line">        <span class="comment">// 构造出二叉树</span></span><br><span class="line">        TreeNode root = dfs(xianxu, zhongxu);</span><br><span class="line">        <span class="comment">// 层序遍历</span></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; nums = levelOrder(root);</span><br><span class="line">        <span class="comment">// 输出每一层的最后一个节点</span></span><br><span class="line">        <span class="keyword">for</span>(ArrayList&lt;Integer&gt; num : nums)&#123;</span><br><span class="line">            ans.add(num.get(num.size() - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.stream().mapToInt(Integer::valueOf).toArray();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] vin)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(vin.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = vin.length;</span><br><span class="line">        <span class="keyword">int</span> num = pre[<span class="number">0</span>];</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(num);</span><br><span class="line">        <span class="comment">// 这里看看这个值对应的位置在vin的什么位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num == vin[i])&#123;</span><br><span class="line">                root.left = dfs(Arrays.copyOfRange(pre, <span class="number">1</span>, i + <span class="number">1</span>), Arrays.copyOfRange(vin, <span class="number">0</span>, i));</span><br><span class="line">                root.right = dfs(Arrays.copyOfRange(pre, i+<span class="number">1</span>, n), Arrays.copyOfRange(vin, i + <span class="number">1</span>, n));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelOrder(TreeNode root)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后的结果</span></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 存放每一层的数据</span></span><br><span class="line">        ArrayList&lt;TreeNode&gt; nodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// 存放每一层中的数据</span></span><br><span class="line">            ArrayList&lt;Integer&gt; nums = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">// 将这一层的节点全部取出放到一个数组中</span></span><br><span class="line">            <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">                nodes.add(queue.poll());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将这一层所有节点数据保存并将其左右子树放入队列中</span></span><br><span class="line">            <span class="keyword">for</span>(TreeNode node : nodes)&#123;</span><br><span class="line">                nums.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(nums);</span><br><span class="line">            <span class="comment">// 记得遍历每一层之后将数组清空</span></span><br><span class="line">            nodes.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是考虑此方法需要先构建出二叉树，再对二叉树进行遍历，实在过于冗长，由于题目中给的是前序遍历和中序遍历的结果，根据两次遍历的性质应该能推出右试图，故考虑出以下题解。</p><h3 id="题解-44"><a href="#题解-44" class="headerlink" title="题解"></a>题解</h3><p>首先无论是前序遍历或是中序遍历，其本质上都是深度优先算法，之前在考虑的过程中我们考虑的是右视图其实就是全部层序遍历（广度优先搜索）的最后一个节点，现在考虑右试图如何由深度优先算法得到。</p><p>考虑中序遍历是左根右，若是倒过来变成右根左，那实际上就是需要的右试图，换言之，右试图实际上就是中序遍历中从后往前的n个树，这里n为树的深度，因此这里只需要在前序遍历和中序遍历中求出树的深度n，之后逆序返回树的中序遍历的后n位即可。但之后发现如此做法无法确保返回的视图是从上到下的，因此舍弃，但对于题目不要求顺序只需要层序遍历最右端的节点时此法不失为一个好办法。</p><p>之后看了部分题解，思路都是一致的不过在构建二叉树的过程中直接将每一层的最后一个节点进行保存，之后只要取出各个节点即可。</p><h3 id="Java代码实现-44"><a href="#Java代码实现-44" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="comment">//     class TreeNode&#123;</span></span><br><span class="line"><span class="comment">//         int val;</span></span><br><span class="line"><span class="comment">//         TreeNode left;</span></span><br><span class="line"><span class="comment">//         TreeNode right;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     * 求二叉树的右视图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> xianxu int整型一维数组 先序遍历</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> zhongxu int整型一维数组 中序遍历</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 存放中序中对应元素的下标</span></span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 存放答案</span></span><br><span class="line">    Map&lt;Integer, Integer&gt; ans = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 用于获取level层的根节点</span></span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] solve (<span class="keyword">int</span>[] xianxu, <span class="keyword">int</span>[] zhongxu) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 首先判断特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(xianxu.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> xianxu;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; zhongxu.length; ++i)&#123;</span><br><span class="line">            map.put(zhongxu[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        buildTree(xianxu, zhongxu, <span class="number">0</span>, zhongxu.length - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[ans.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.size(); ++i)&#123;</span><br><span class="line">            res[i] = ans.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里只是虚假的构建，因此实际上只需要那个构建的过程而不需要真正构建，故为void</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] vin, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="comment">// 获取level层根节点所在中序遍历的下标</span></span><br><span class="line">            <span class="keyword">int</span> index = map.get(pre[level++]);</span><br><span class="line">            <span class="comment">// 构建左子树</span></span><br><span class="line">            buildTree(pre, vin, left, index - <span class="number">1</span>, i +<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 构建右子树</span></span><br><span class="line">            buildTree(pre, vin, index + <span class="number">1</span>, right, i +<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 将这一层最右边的节点（所需右试图中的节点）保存</span></span><br><span class="line">            <span class="comment">// 这里为什么vin[index]就是这一层最右边的节点呢，因为构建树的过程中，右树会覆盖子树的结果</span></span><br><span class="line">            <span class="comment">// 对于同一层的左右子树都进行了put操作，但是后面的（右子树）会覆盖前面的（左子树）的操作，因为i相同</span></span><br><span class="line">            ans.put(i, vin[index]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="堆-栈-队列"><a href="#堆-栈-队列" class="headerlink" title="堆/栈/队列"></a>堆/栈/队列</h1><h2 id="BM42-用两个栈实现队列"><a href="#BM42-用两个栈实现队列" class="headerlink" title="BM42 用两个栈实现队列"></a>BM42 <a href="https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">用两个栈实现队列</a></h2><h3 id="题目描述-41"><a href="#题目描述-41" class="headerlink" title="题目描述"></a>题目描述</h3><p>用两个栈来实现一个队列，使用n个元素来完成 n 次在队列尾部插入整数(push)和n次在队列头部删除整数(pop)的功能。 队列中的元素为int类型。保证操作合法，即保证pop操作时队列内已有元素。 </p><p>数据范围： n≤1000</p><p>要求：存储n个元素的空间复杂度为 O(n) ，插入与删除的时间复杂度都是 O(1)</p><h3 id="题解-45"><a href="#题解-45" class="headerlink" title="题解"></a>题解</h3><p>用两个栈实现队列的主要思路是，两个栈中每次只有一个栈中拥有数据，每次移动时将一个栈中的除最后一个元素之外移动到另一个栈中，并将最后一个元素移出，但如此会导致时间复杂度为O(n)，不合题意。</p><p>考虑是否需要每次都要将1中的元素转移到2，首先假定stack1只进，stack2只出，那么入栈操作就是直接往stack1里面push即可，对于出操作，若是此时stack2为空，那么需要将stack1中的元素移动到stack2中，不为空则直接将stack2中的元素pop出即可（因为经过两次栈的操作，已经将之前最先放入的元素进行了二次反转，若是stack2中有元素，那必定是在stack1中所有元素之前放入的，因此当stack2中有元素时直接pop即可）。</p><h3 id="Java代码实现-45"><a href="#Java代码实现-45" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 只用来存数据</span></span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    <span class="comment">// 只用来取数据</span></span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM43-包含min函数的栈"><a href="#BM43-包含min函数的栈" class="headerlink" title="BM43 包含min函数的栈"></a>BM43 <a href="https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">包含min函数的栈</a></h2><h3 id="题目描述-42"><a href="#题目描述-42" class="headerlink" title="题目描述"></a>题目描述</h3><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的 min 函数，输入操作时保证 pop、top 和 min 函数操作时，栈中一定有元素。</p><p>此栈包含的方法有： </p><p>push(value):将value压入栈中 </p><p>pop():弹出栈顶元素 </p><p>top():获取栈顶元素 </p><p>min():获取栈中最小元素 </p><p>数据范围：操作数量满足 0≤n≤300，输入的元素满足 ∣val∣≤10000<br>进阶：栈的各个操作的时间复杂度是 O(1)，空间复杂度是 O(n)</p><p>示例: </p><p>输入:  [“PSH-1”,”PSH2”,”MIN”,”TOP”,”POP”,”PSH1”,”TOP”,”MIN”] </p><p>输出:  -1,2,1,-1 </p><p>解析: </p><p>“PSH-1”表示将-1压入栈中，栈中元素为-1</p><p>“PSH2”表示将2压入栈中，栈中元素为2，-1</p><p>“MIN”表示获取此时栈中最小元素==&gt;返回-1 </p><p>“TOP”表示获取栈顶元素==&gt;返回2</p><p>“POP”表示弹出栈顶元素，弹出2，栈中元素为-1 </p><p>“PSH1”表示将1压入栈中，栈中元素为1，-1</p><p>“TOP”表示获取栈顶元素==&gt;返回1</p><p>“MIN”表示获取此时栈中最小元素==&gt;返回-1</p><h3 id="题解-46"><a href="#题解-46" class="headerlink" title="题解"></a>题解</h3><p>直接在栈中实现min函数即可，对于min函数的实现也只需维护一个min栈用于维护每次操作的min，每次push操作判断是否小于最小值，小于的话将这个值同步更新到最小值栈中，pop时判断是否是最小元素若是是最小元素的话将这个pop操作在最小值栈进行同步pop即可。</p><h3 id="Java代码实现-46"><a href="#Java代码实现-46" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用于存放数据</span></span><br><span class="line">    Stack&lt;Integer&gt; nums = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="comment">// 用于实现每次的最小值</span></span><br><span class="line">    Stack&lt;Integer&gt; min = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 加入元素</span></span><br><span class="line">        nums.push(node);</span><br><span class="line">        <span class="comment">// 维护最小值</span></span><br><span class="line">        <span class="keyword">if</span>(!min.isEmpty() &amp;&amp; min.peek() &gt;= node)&#123;</span><br><span class="line">            min.push(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里对min栈记得判空</span></span><br><span class="line">        <span class="keyword">if</span>(min.isEmpty())&#123;</span><br><span class="line">            min.push(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = nums.pop();</span><br><span class="line">        <span class="keyword">if</span>(num == min.peek())&#123;</span><br><span class="line">            min.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nums.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM44-有效括号序列"><a href="#BM44-有效括号序列" class="headerlink" title="BM44 有效括号序列"></a>BM44 <a href="https://www.nowcoder.com/practice/37548e94a270412c8b9fb85643c8ccc2?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">有效括号序列</a></h2><h3 id="题目描述-43"><a href="#题目描述-43" class="headerlink" title="题目描述"></a>题目描述</h3><p>给出一个仅包含字符’(‘,’)’,’{‘,’}’,’[‘和’]’,的字符串，判断给出的字符串是否是合法的括号序列<br>括号必须以正确的顺序关闭，”()”和”()[]{}”都是合法的括号序列，但”(]”和”([)]”不合法。</p><p>数据范围：字符串长度 0≤n≤100000≤<em>n</em>≤10000</p><p>要求：空间复杂度 O(n)，时间复杂度 O(n)</p><h3 id="题解-47"><a href="#题解-47" class="headerlink" title="题解"></a>题解</h3><p>对于匹配问题，一般的选择是使用栈进行匹配，每次遇到左括号就入栈，遇到右括号，首先判断是否是相匹配的括号（”(“ –&gt; “)”, “[“ –&gt; “]”, “{“ –&gt; “}”），若是不匹配直接返回false，若是匹配就继续，直到最后返回true。</p><h3 id="Java代码实现-47"><a href="#Java代码实现-47" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span> <span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(s.equals(<span class="string">""</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="comment">// 逐个匹配</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : chars)&#123;</span><br><span class="line">            <span class="comment">// 若是左括号则入栈</span></span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'('</span> || c == <span class="string">'['</span> || c == <span class="string">'&#123;'</span>)&#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">                <span class="comment">// 对右括号进行匹配</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">')'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty() || stack.pop() != <span class="string">'('</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">']'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty() || stack.pop() != <span class="string">'['</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty() || stack.pop() != <span class="string">'&#123;'</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 为空表示所有左括号已被匹配</span></span><br><span class="line">        <span class="comment">// 反之表示有剩余的左括号不匹配</span></span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里防止if else太多也可以选择使用switch–case，但记得使用break。</p><h2 id="BM45-滑动窗口的最大值"><a href="#BM45-滑动窗口的最大值" class="headerlink" title="BM45 滑动窗口的最大值"></a>BM45 <a href="https://www.nowcoder.com/practice/1624bc35a45c42c0bc17d17fa0cba788?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">滑动窗口的最大值</a></h2><h3 id="题目描述-44"><a href="#题目描述-44" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个长度为 n 的数组 num 和滑动窗口的大小 size ，找出所有滑动窗口里数值的最大值。 </p><p>例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。 </p><p>窗口大于数组长度或窗口长度为0的时候，返回空。</p><p>数据范围： 1≤n≤10000，0≤size≤10000，数组中每个元素的值满足 ∣val∣≤10000</p><p>要求：空间复杂度 O(n)，时间复杂度 O(n)</p><h3 id="题解-48"><a href="#题解-48" class="headerlink" title="题解"></a>题解</h3><p>实际上每次滑动窗口在活动的过程中只是做了如下改变，首先是舍弃了之前滑动窗口中的第一个元素，之后又将滑动窗口的后一个元素放入，因此想到如下思路</p><p>因此在维护滑动窗口的时候可以考虑如下做法，首先将前size个元素入栈，标记出此时的最大值（最大值数组中第一个元素），之后对剩下的元素做如下操作，把当前值减掉出栈元素，加上入栈元素，判断是否更新最大值以及最大值数组，如此直到没有元素。</p><p>对每个元素进行如下操作，需要两个东西进行辅助，一个是栈用来保存这个滑动窗口中的每个值，一个是优先队列用于保存当前的最大值，每次操作需要进行如下行为，先将栈中的元素出栈，再入栈，之后将优先队列中的元素取出，再放入下一个元素，之后返回优先队列中的头元素。</p><h3 id="Java代码实现-48"><a href="#Java代码实现-48" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span> [] num, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num.length &lt; size || size &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2)-&gt;o2 - o1);</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(; index &lt; size; ++index)&#123;</span><br><span class="line">            queue.offer(num[index]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(index &lt; num.length)&#123;</span><br><span class="line">            res.add(queue.peek());</span><br><span class="line">            queue.offer(num[index]);</span><br><span class="line">            queue.remove(num[index - size]);</span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里最后一次的还没加入</span></span><br><span class="line">        res.add(queue.peek());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM46-最小的K个树"><a href="#BM46-最小的K个树" class="headerlink" title="BM46 最小的K个树"></a>BM46 <a href="https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">最小的K个树</a></h2><h3 id="题目描述-45"><a href="#题目描述-45" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个长度为 n 的可能有重复值的数组，找出其中不去重的最小的 k 个数。例如数组元素是4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4(任意顺序皆可)。 </p><p>数据范围：0≤k,n≤10000，数组中每个数的大小0≤val≤1000</p><p>要求：空间复杂度 O(n)，时间复杂度 O(nlogn)</p><h3 id="题解-49"><a href="#题解-49" class="headerlink" title="题解"></a>题解</h3><p>先将所给的数组进行排序，排序之后输出前k个即可。</p><h3 id="Java代码实现-49"><a href="#Java代码实现-49" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 保存返回结果</span></span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(input.length == <span class="number">0</span> || k == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(input);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">            res.add(input[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题解-50"><a href="#题解-50" class="headerlink" title="题解"></a>题解</h3><p>既然属于队列中的，那就利用队列，创建一个优先队列，值大的在队首，先将前k个值放入，开始遍历之后的元素，若是当前元素大于队首则将队首移除将当前元素放入，循环到最后的元素，将其放入需要的数组中返回即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 保存返回结果</span></span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(input.length &lt; k || k == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 构建优先队列</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);</span><br><span class="line">        <span class="comment">// 先将前k个元素放入</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">            queue.offer(input[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对后面的元素，若是比队首大，那么移除队首并将当前元素入队</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt; input.length; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(input[i] &lt; queue.peek())&#123;</span><br><span class="line">                queue.poll();</span><br><span class="line">                queue.offer(input[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            res.add(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM47-寻找第k大"><a href="#BM47-寻找第k大" class="headerlink" title="BM47 寻找第k大"></a>BM47 <a href="https://www.nowcoder.com/practice/e016ad9b7f0b45048c58a9f27ba618bf?tpId=295&tqId=44581&ru=%2Fpractice%2F8daa4dff9e36409abba2adbe413d6fae&qru=%2Fta%2Fformat-top101%2Fquestion-ranking&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">寻找第k大</a></h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>有一个整数数组，请你根据快速排序的思路，找出数组中第 k 大的数。 </p><p>给定一个整数数组 a ,同时给定它的大小n和要找的 k ，请返回第 k 大的数(包括重复的元素，不用去重)，保证答案存在。 </p><p>要求：时间复杂度 O(nlogn)，空间复杂度 O(1)</p><p>数据范围：0≤n≤1000， 1≤K≤n，数组中每个元素满足 0≤val≤10000000</p><h3 id="题解-51"><a href="#题解-51" class="headerlink" title="题解"></a>题解</h3><p>需要的是第k大的数，直接排序并返回即可。</p><p>但题目中说是按照快排的思路，首先考虑什么是快排，快速排序使用分治的思想，通过一趟排序将待排序列分割成两部分，其中一部分记录的关键字均比另一部分记录的关键字小。之后分别对这两部分记录继续进行排序，以达到整个序列有序的目的。</p><p>具体操作是：</p><ol><li><p>选择基准：在待排序列中，按照某种方式挑出一个元素，作为 “基准”（pivot），可以利用随机数</p></li><li><p>分割操作：以该基准在序列中的实际位置，把序列分成两个子序列。此时，在基准左边的元素都比该基准小，在基准右边的元素都比基准大</p></li><li><p>递归地对两个序列进行快速排序，直到序列为空或者只有一个元素。</p></li></ol><h3 id="Java代码实现-50"><a href="#Java代码实现-50" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKth</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        sortNums(a, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> a[n - K];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sortNums</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="comment">// 初始值为low下标所在的位置（基准）</span></span><br><span class="line">            <span class="keyword">int</span> temp = nums[low];</span><br><span class="line">            <span class="keyword">int</span> i = low;</span><br><span class="line">            <span class="keyword">int</span> j = high;</span><br><span class="line">            <span class="comment">// 移动，某一侧全是小于基准值的，另一侧是大于等于基准值的</span></span><br><span class="line">            <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">                <span class="comment">// 从右到左，位置对了（比temp大）就直接继续</span></span><br><span class="line">                <span class="keyword">while</span>(temp &lt; nums[j] &amp;&amp; i &lt; j)&#123;</span><br><span class="line">                    --j;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 此时发现了小的值（不满足），将其放到左边</span></span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                <span class="comment">// 从左到右，位置对了（小于等于temp）就继续</span></span><br><span class="line">                <span class="keyword">while</span>(temp &gt;= nums[i] &amp;&amp; i &lt; j)&#123;</span><br><span class="line">                    ++i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 此时发现了大的值（不满足），将其放到右边</span></span><br><span class="line">                nums[j] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这里最后是i = j，i,j都可以，因为值被覆盖了，实际上最后的序列中没有temp了，考虑将其放回</span></span><br><span class="line">            nums[i] = temp;</span><br><span class="line">            sortNums(nums, low, i - <span class="number">1</span>);</span><br><span class="line">            sortNums(nums, i + <span class="number">1</span>, high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM48-数据流中的中位数"><a href="#BM48-数据流中的中位数" class="headerlink" title="BM48 数据流中的中位数"></a>BM48 <a href="https://www.nowcoder.com/practice/9be0172896bd43948f8a32fb954e1be1?tpId=295&tqId=23457&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">数据流中的中位数</a></h2><h3 id="题目描述-46"><a href="#题目描述-46" class="headerlink" title="题目描述"></a>题目描述</h3><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。 </p><p>数据范围：数据流中数个数满足 1≤n≤1000，大小满足 1≤val≤1000</p><p>进阶： 空间复杂度 O(n)， 时间复杂度 O(nlogn)</p><h3 id="题解-52"><a href="#题解-52" class="headerlink" title="题解"></a>题解</h3><p>借助一个数组保存数据流，插入时只对数组进行插入操作，获取中位数操作时先排序再获取即可。</p><h3 id="Java代码实现-51"><a href="#Java代码实现-51" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; nums = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line">        nums.add(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Collections.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span>((n &amp; <span class="number">1</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 偶数</span></span><br><span class="line">            <span class="keyword">return</span> (nums.get(n / <span class="number">2</span>) + nums.get(n / <span class="number">2</span> - <span class="number">1</span>)) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (nums.get(n / <span class="number">2</span>)) / <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题解-53"><a href="#题解-53" class="headerlink" title="题解"></a>题解</h3><p>考虑什么是中位数，中位数实际上将数据分为了两部分，一部分是比中位数小的，一部分是比中位数大的，求中位数时只需要判断是奇数还是偶数，奇数直接从一边取，偶数则取出比中位数小的部分的最大值和比中位数大的部分的最小值求平均值即可。</p><h3 id="Java代码实现-52"><a href="#Java代码实现-52" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保存两个队列中共有多少个元素</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 比中位数小的元素</span></span><br><span class="line">    PriorityQueue&lt;Integer&gt; lessMid = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">    <span class="comment">// 比中位数大的元素</span></span><br><span class="line">    PriorityQueue&lt;Integer&gt; moreMid = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((count &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 若是当前是奇数，那需要放入右边，因此先将放入左边，再把左边的弹到右边</span></span><br><span class="line">            <span class="comment">// 这里为什么是这样，是因为规定了奇数时左边多一个元素，也可另作规定</span></span><br><span class="line">            lessMid.offer(num);</span><br><span class="line">            <span class="keyword">int</span> cur = lessMid.poll();</span><br><span class="line">            moreMid.offer(cur);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 反之若是当前为偶数，那么插入到左边，因此先放右边，再弹一个元素到左边</span></span><br><span class="line">            moreMid.offer(num);</span><br><span class="line">            <span class="keyword">int</span> cur = moreMid.poll();</span><br><span class="line">            lessMid.offer(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((count &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 奇数，直接将左边的元素取出</span></span><br><span class="line">            <span class="keyword">return</span> lessMid.peek() / <span class="number">1.0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (lessMid.peek() + moreMid.peek()) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM49-表达式求值"><a href="#BM49-表达式求值" class="headerlink" title="BM49 表达式求值"></a>BM49 <a href="https://www.nowcoder.com/practice/c215ba61c8b1443b996351df929dc4d4?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">表达式求值</a></h2><h3 id="题目描述-47"><a href="#题目描述-47" class="headerlink" title="题目描述"></a>题目描述</h3><p>请写一个整数计算器，支持加减乘三种运算和括号。 </p><p>数据范围：0≤∣s∣≤100，保证计算结果始终在整型范围内</p><p>要求：空间复杂度：O(n)，时间复杂度 O(n)</p><h3 id="题解-54"><a href="#题解-54" class="headerlink" title="题解"></a>题解</h3><p>对于设计运算符优先性问题，可以考虑用栈处理，首先确定一点，使用两个表达式完成，第一个是nums用于存放数字，ops存放数字之外的操作符，对于字符可能出现下列各种情况，首先是括号，左括号直接入栈ops，等待匹配的右括号，右括号使用现在栈中的nums和ops进行计算，直到遇到左边最近的一个左括号位置，结果放到nums中，之后若是遇到了数字，那么就继续往后遍历直到取出完整字符，存入nums中，+-*号则是放入ops中，在放入栈之前可以先将栈内可以算的都算掉，但是只有运算符更高或是同级的才能计算，知道没有操作或是遇到了左括号，之后将计算结果放到nums中。</p><p>这一部分参照了三叶大神的思想，完整版<a href="https://blog.nowcoder.net/n/c8c1ff4ecfb44ca4958b1ecbdcbf2021" target="_blank" rel="noopener">在这里</a></p><h3 id="Java代码实现-53"><a href="#Java代码实现-53" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 map 维护一个运算符优先级（其中加减法优先级相同，乘法有着更高的优先级）</span></span><br><span class="line">    Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;()&#123;&#123;</span><br><span class="line">        put(<span class="string">'-'</span>, <span class="number">1</span>);</span><br><span class="line">        put(<span class="string">'+'</span>, <span class="number">1</span>);</span><br><span class="line">        put(<span class="string">'*'</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将所有的空格去掉</span></span><br><span class="line">        s = s.replaceAll(<span class="string">" "</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] cs = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存放所有的数字</span></span><br><span class="line">        Deque&lt;Integer&gt; nums = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="comment">// 为了防止第一个数为负数，先往 nums 加个 0</span></span><br><span class="line">        nums.addLast(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 存放所有「非数字以外」的操作</span></span><br><span class="line">        Deque&lt;Character&gt; ops = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = cs[i];</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'('</span>) &#123;</span><br><span class="line">                ops.addLast(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">')'</span>) &#123;</span><br><span class="line">                <span class="comment">// 计算到最近一个左括号为止</span></span><br><span class="line">                <span class="keyword">while</span> (!ops.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ops.peekLast() != <span class="string">'('</span>) &#123;</span><br><span class="line">                        calc(nums, ops);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        ops.pollLast();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (isNumber(c)) &#123;</span><br><span class="line">                    <span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">int</span> j = i;</span><br><span class="line">                    <span class="comment">// 将从 i 位置开始后面的连续数字整体取出，加入 nums</span></span><br><span class="line">                    <span class="keyword">while</span> (j &lt; n &amp;&amp; isNumber(cs[j])) u = u * <span class="number">10</span> + (cs[j++] - <span class="string">'0'</span>);</span><br><span class="line">                    nums.addLast(u);</span><br><span class="line">                    i = j - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; (cs[i - <span class="number">1</span>] == <span class="string">'('</span> || cs[i - <span class="number">1</span>] == <span class="string">'+'</span> || cs[i - <span class="number">1</span>] == <span class="string">'-'</span>)) &#123;</span><br><span class="line">                        nums.addLast(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 有一个新操作要入栈时，先把栈内可以算的都算了 </span></span><br><span class="line">                    <span class="comment">// 只有满足「栈内运算符」比「当前运算符」优先级高/同等，才进行运算</span></span><br><span class="line">                    <span class="keyword">while</span> (!ops.isEmpty() &amp;&amp; ops.peekLast() != <span class="string">'('</span>) &#123;</span><br><span class="line">                        <span class="keyword">char</span> prev = ops.peekLast();</span><br><span class="line">                        <span class="keyword">if</span> (map.get(prev) &gt;= map.get(c)) &#123;</span><br><span class="line">                            calc(nums, ops);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ops.addLast(c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将剩余的计算完</span></span><br><span class="line">        <span class="keyword">while</span> (!ops.isEmpty() &amp;&amp; ops.peekLast() != <span class="string">'('</span>) calc(nums, ops);</span><br><span class="line">        <span class="keyword">return</span> nums.peekLast();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算逻辑：从 nums 中取出两个操作数，从 ops 中取出运算符，然后根据运算符进行计算即可</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(Deque&lt;Integer&gt; nums, Deque&lt;Character&gt; ops)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.isEmpty() || nums.size() &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (ops.isEmpty()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> b = nums.pollLast(), a = nums.pollLast();</span><br><span class="line">        <span class="keyword">char</span> op = ops.pollLast();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">'+'</span>) ans = a + b;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">'-'</span>) ans = a - b;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">'*'</span>) ans = a * b;    </span><br><span class="line">        nums.addLast(ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Character.isDigit(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h1><h2 id="BM50-两数之和"><a href="#BM50-两数之和" class="headerlink" title="BM50 两数之和"></a>BM50 <a href="https://www.nowcoder.com/practice/20ef0972485e41019e39543e8e895b7f?tpId=295&tqId=745&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">两数之和</a></h2><h3 id="题目描述-48"><a href="#题目描述-48" class="headerlink" title="题目描述"></a>题目描述</h3><p>给出一个整型数组 numbers 和一个目标值 target，请在数组中找出两个加起来等于目标值的数的下标，返回的下标按升序排列。 </p><p>（注：<strong>返回</strong>的数组下标从1开始算起，保证target一定可以由数组里面2个数字相加得到） </p><p>数据范围：2≤len(numbers)≤10^5，−10≤numbersi≤10^9，0≤target≤10^9</p><p>要求：空间复杂度 O(n)，时间复杂度 O(nlogn)</p><h3 id="题解-55"><a href="#题解-55" class="headerlink" title="题解"></a>题解</h3><p>这题最简单的做法是两个for循环遍历所有可能的情况，最终找到结果，但此时不满足题目要求的时间复杂度。</p><p>这里关键是两个for循环耗费了很多时间，试考虑如下情况，若是有一个数据结构中存着集合中所有的元素，那么在第二次遍历时只需要判断数组中是否有target - nums[i]即可，更优化一些，对于每个元素做如下操作，若是target - nums[i]在这个集合中，那么就返回这两个数的下标，若是target - nums[i]不在这个集合中那么就将这个值和下标放入这个集合中，帮助之后的元素能获取到结果。</p><h3 id="Java代码实现-54"><a href="#Java代码实现-54" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> numbers int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum (<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 返回最终结果</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 保存元素及其下标</span></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; ++i)&#123;</span><br><span class="line">            <span class="comment">// 若是已有target - 当前元素，那么这两个元素已能构成结果返回</span></span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target - numbers[i]))&#123;</span><br><span class="line">                <span class="comment">// 这里注意 + 1操作</span></span><br><span class="line">                res[<span class="number">0</span>] = map.get(target - numbers[i]) + <span class="number">1</span>;</span><br><span class="line">                res[<span class="number">1</span>] = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 不是结果或者说暂时不是结果，放入map中等待查询</span></span><br><span class="line">                map.put(numbers[i], i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM51-数组中出现次数超过一半的数字"><a href="#BM51-数组中出现次数超过一半的数字" class="headerlink" title="BM51 数组中出现次数超过一半的数字"></a>BM51 <a href="https://www.nowcoder.com/practice/e8a1b01a2df14cb2b228b30ee6a92163?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">数组中出现次数超过一半的数字</a></h2><h3 id="题目描述-49"><a href="#题目描述-49" class="headerlink" title="题目描述"></a>题目描述</h3><p>给一个长度为 n 的数组，数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。 </p><p>例如输入一个长度为9的数组[1,2,3,2,2,2,5,4,2]。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。 </p><p>数据范围：n≤50000，数组中元素的值 0≤val≤10000</p><p>要求：空间复杂度：O(1)，时间复杂度 O(n)</p><h4 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述"></a>输入描述</h4><p>保证数组输入非空，且保证有解</p><h3 id="题解-56"><a href="#题解-56" class="headerlink" title="题解"></a>题解</h3><p>需要使用一个HashMap保存元素以及其出现的次数，之后遍历数组，对每个元素进行如下操作：将每个元素放入并将次数进行加1（之前没有此元素默认为0），若是当前元素的key大于数字的一半，那么直接返回，否则一直到所有元素完成遍历。</p><h3 id="Java代码实现-55"><a href="#Java代码实现-55" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 题目中说了有解股无需判断</span></span><br><span class="line">        <span class="comment">// 保存元素以及其出现的次数</span></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = array.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : array)&#123;</span><br><span class="line">            <span class="comment">// 初始值为0</span></span><br><span class="line">            map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(map.get(num) &gt; n / <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM52-数组中只出现一次的两个数字"><a href="#BM52-数组中只出现一次的两个数字" class="headerlink" title="BM52 数组中只出现一次的两个数字"></a>BM52 <a href="https://www.nowcoder.com/practice/389fc1c3d3be4479a154f63f495abff8?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">数组中只出现一次的两个数字</a></h2><h3 id="题目描述-50"><a href="#题目描述-50" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个整型数组里除了两个数字只出现一次，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。 </p><p>数据范围：数组长度 2≤n≤1000，数组中每个数的大小 0&lt;val≤1000000<br>要求：空间复杂度 O(1)，时间复杂度 O(n)</p><p>提示：输出时按非降序排列。</p><h3 id="题解-57"><a href="#题解-57" class="headerlink" title="题解"></a>题解</h3><p>可以首先遍历数组中的全部元素，并保存其出现的次数，之后遍历map中的元素，找到只出现了一次的两个元素，使其非降序排序并返回。</p><h3 id="Java代码实现-56"><a href="#Java代码实现-56" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] FindNumsAppearOnce (<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 保存数组下标以及其出现的次序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : array)&#123;</span><br><span class="line">            map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : map.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(num) == <span class="number">1</span>)&#123;</span><br><span class="line">                res[index++] = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 排序后输出</span></span><br><span class="line">        <span class="keyword">if</span>(res[<span class="number">0</span>] &lt;= res[<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;res[<span class="number">1</span>], res[<span class="number">0</span>]&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题解-58"><a href="#题解-58" class="headerlink" title="题解"></a>题解</h3><p>但这一题其实存在更好的解法，因为题目中说其余元素都出现了两次，那么你对相同的两个数进行异或运算，得到的是0，你对数组中的全部元素进行按位异或操作，最终得到的数就是两个只出现一次的数的异或结果。现在问题转化为如何从a^b的结果中反推出ab，这显然不现实，但若是只有一个元素出现一次，那只需对所有数据异或即可得到这个数，那有两个元素只出现一次，那直接分成两组即可，但这里出现了一个问题，如何进行分组才能确保两个数在不同的组呢。首先考虑分组对其余元素是没有影响的，无论按何种分法，最终相同的元素异或都会得到0，因此分组只需要将两个只出现一次的不同的元素分开即可，异或运算恰能找到这个不同的元素，使用按位异或的结果分组后分别对两个组按位异或就能得到两个值，分组也比较简单，直接&amp;操作即可。</p><h3 id="Java代码实现-57"><a href="#Java代码实现-57" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] FindNumsAppearOnce (<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 分组的标准</span></span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : array)&#123;</span><br><span class="line">            level ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里level是不能直接当作分组标准的，因为有一位为1时才能分组</span></span><br><span class="line">        <span class="comment">// 因此需要找到分组标准</span></span><br><span class="line">        <span class="keyword">int</span> mask = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 若是其和level相与之后的结果是0，证明level该位为0，不符合，继续找</span></span><br><span class="line">        <span class="keyword">while</span>((level &amp; mask) == <span class="number">0</span>)&#123;</span><br><span class="line">            mask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时的mask即为分类标准</span></span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : array)&#123;</span><br><span class="line">            <span class="comment">// 这里注意是0，因为会出现为和不为0（不一定是1）的情况</span></span><br><span class="line">            <span class="keyword">if</span>((num &amp; mask) == <span class="number">0</span>)&#123;</span><br><span class="line">                num1 ^= num;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                num2 ^= num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num1 &lt;= num2)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;num1, num2&#125;;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;num2, num1&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM53-缺失的第一个正整数"><a href="#BM53-缺失的第一个正整数" class="headerlink" title="BM53 缺失的第一个正整数"></a>BM53 <a href="https://www.nowcoder.com/practice/50ec6a5b0e4e45348544348278cdcee5?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">缺失的第一个正整数</a></h2><h3 id="题目描述-51"><a href="#题目描述-51" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个无重复元素的整数数组nums，请你找出其中没有出现的最小的正整数 </p><p>进阶： 空间复杂度 O(1)，时间复杂度 O(n)</p><p>数据范围: </p><p>-2^31&lt;=nums[i]&lt;=^31-1 </p><p>0&lt;=len(nums)&lt;=5*105</p><h3 id="题解-59"><a href="#题解-59" class="headerlink" title="题解"></a>题解</h3><p>将nums中的数据保存到一个HashSet中，之后从0遍历到nums.length，若是没有此元素就输出。</p><h3 id="Java代码实现-58"><a href="#Java代码实现-58" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberDisappeared</span> <span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.contains(i))&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里判断是否包含n是因为可能是由于某个非正数导致前面全部满足，也可能是包含了n导致满足</span></span><br><span class="line">        <span class="keyword">return</span> set.contains(nums.length) ? nums.length + <span class="number">1</span> : nums.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM54-三数之和"><a href="#BM54-三数之和" class="headerlink" title="BM54 三数之和"></a>BM54 <a href="https://www.nowcoder.com/practice/345e2ed5f81d4017bbb8cc6055b0b711?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">三数之和</a></h2><h3 id="题目描述-52"><a href="#题目描述-52" class="headerlink" title="题目描述"></a>题目描述</h3><p>给出一个有n个元素的数组S，S中是否有元素a,b,c满足a+b+c=0？找出数组S中所有满足条件的三元组。 </p><p>数据范围：0≤n≤1000，数组中各个元素值满足 ∣val∣≤100</p><p>空间复杂度：O(n^2)，时间复杂度 O(n^2)</p><p>注意：</p><ol><li>三元组（a、b、c）中的元素必须按非降序排列。（即a≤b≤c） </li><li>解集中不能包含重复的三元组。 </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如，给定的数组 S &#x3D; &#123;-10 0 10 20 -10 -40&#125;,解集为(-10, -10, 20),(-10, 0, 10)</span><br></pre></td></tr></table></figure><h3 id="题解-60"><a href="#题解-60" class="headerlink" title="题解"></a>题解</h3><p>最简单的做法是三个for循环，但时间复杂度太高了，因此考虑减少其中的复杂度，首先进行一次遍历，将数组中的全部元素放到一个HashMap中，key为元素，value为出现的次数，之后使用两个for循环计算出两个元素的值，再做判断，若是map中有这两个数的相反数，那么就保存这个序列并输出，反之则继续遍历，直到两个for循环结束，时间复杂度为O(n ^2)</p><h3 id="Java代码实现-59"><a href="#Java代码实现-59" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt; <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(num))&#123;</span><br><span class="line">                map.put(num, map.get(num) + <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(num, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先把三个0单独考虑，看0出现了几次</span></span><br><span class="line">        <span class="keyword">int</span> times = map.getOrDefault(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(times &gt;= <span class="number">3</span>)&#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            lists.add(<span class="number">0</span>);</span><br><span class="line">            lists.add(<span class="number">0</span>);</span><br><span class="line">            lists.add(<span class="number">0</span>);</span><br><span class="line">            res.add(lists);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length - <span class="number">1</span>; ++j)&#123;</span><br><span class="line">                ArrayList&lt;Integer&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">int</span> num1 = nums[i];</span><br><span class="line">                <span class="keyword">int</span> num2 = nums[j];</span><br><span class="line">                <span class="comment">// 这个已经计算过了</span></span><br><span class="line">                <span class="keyword">if</span>(num1 == <span class="number">0</span> &amp;&amp; num2 == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> target = <span class="number">0</span> - (num1 + num2);</span><br><span class="line">                <span class="comment">// 计算出的值和两个已给值中任意一个相同</span></span><br><span class="line">                <span class="keyword">if</span>(target == num1 || target == num2)&#123;</span><br><span class="line">                    <span class="comment">// 看是否大于1</span></span><br><span class="line">                    <span class="keyword">if</span>(map.getOrDefault(target, <span class="number">0</span>) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                        lists.add(num2);</span><br><span class="line">                        lists.add(num1);</span><br><span class="line">                        lists.add(target);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 不等于任意数</span></span><br><span class="line">                    <span class="keyword">if</span>(map.containsKey(target))&#123;</span><br><span class="line">                        lists.add(num1);</span><br><span class="line">                        lists.add(num2);</span><br><span class="line">                        lists.add(target);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 只有数组中有元素时才排序后放入最终结果集</span></span><br><span class="line">                <span class="keyword">if</span>(lists.size() == <span class="number">3</span>)&#123;</span><br><span class="line">                    Collections.sort(lists);</span><br><span class="line">                    <span class="keyword">if</span>(res.size() == <span class="number">0</span> || (res.size() &gt; <span class="number">0</span> &amp;&amp; !res.contains(lists)))&#123;</span><br><span class="line">                        res.add(lists);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但此做法会导致如下问题：<img src="%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3.png" alt="image-20220316112412395"></p><p>我自己是觉得没问题的（题目只说了三元组中元素非降序，没说三元组间也需要有序），但是用例中需要排序，因此考虑是否最后对数组进行排序或是其他做法。</p><p>最后改为这样形式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt; <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(num))&#123;</span><br><span class="line">                map.put(num, map.get(num) + <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(num, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先把三个0单独考虑，看0出现了几次</span></span><br><span class="line">        <span class="keyword">int</span> times = map.getOrDefault(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(times &gt;= <span class="number">3</span>)&#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            lists.add(<span class="number">0</span>);</span><br><span class="line">            lists.add(<span class="number">0</span>);</span><br><span class="line">            lists.add(<span class="number">0</span>);</span><br><span class="line">            res.add(lists);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length - <span class="number">1</span>; ++j)&#123;</span><br><span class="line">                ArrayList&lt;Integer&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">int</span> num1 = nums[i];</span><br><span class="line">                <span class="keyword">int</span> num2 = nums[j];</span><br><span class="line">                <span class="comment">// 这个已经计算过了</span></span><br><span class="line">                <span class="keyword">if</span>(num1 == <span class="number">0</span> &amp;&amp; num2 == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> target = <span class="number">0</span> - (num1 + num2);</span><br><span class="line">                <span class="comment">// 计算出的值和两个已给值中任意一个相同</span></span><br><span class="line">                <span class="keyword">if</span>(target == num1 || target == num2)&#123;</span><br><span class="line">                    <span class="comment">// 看是否大于1</span></span><br><span class="line">                    <span class="keyword">if</span>(map.getOrDefault(target, <span class="number">0</span>) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                        lists.add(num2);</span><br><span class="line">                        lists.add(num1);</span><br><span class="line">                        lists.add(target);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 不等于任意数</span></span><br><span class="line">                    <span class="keyword">if</span>(map.containsKey(target))&#123;</span><br><span class="line">                        lists.add(num1);</span><br><span class="line">                        lists.add(num2);</span><br><span class="line">                        lists.add(target);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 只有数组中有元素时才排序后放入最终结果集</span></span><br><span class="line">                <span class="keyword">if</span>(lists.size() == <span class="number">3</span>)&#123;</span><br><span class="line">                    Collections.sort(lists);</span><br><span class="line">                    <span class="keyword">if</span>(res.size() == <span class="number">0</span> || (res.size() &gt; <span class="number">0</span> &amp;&amp; !res.contains(lists)))&#123;</span><br><span class="line">                        res.add(lists);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里这个很不合理</span></span><br><span class="line">        Collections.sort(res, <span class="keyword">new</span> Comparator&lt;ArrayList&lt;Integer&gt;&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(ArrayList&lt;Integer&gt; list1, ArrayList&lt;Integer&gt; list2)</span></span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(list1.get(<span class="number">0</span>) == list2.get(<span class="number">0</span>))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(list1.get(<span class="number">1</span>) == list2.get(<span class="number">1</span>))&#123;</span><br><span class="line">                        <span class="keyword">return</span> list1.get(<span class="number">2</span>) - list2.get(<span class="number">2</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> list1.get(<span class="number">1</span>) - list2.get(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> list1.get(<span class="number">0</span>) - list2.get(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者也可以先对数组进行排序，之后就不会出现此情况了，这里推荐一份<a href="https://blog.nowcoder.net/n/0f57681a03894fe8a2324cf41f22330f" target="_blank" rel="noopener">题解</a>，里面还有如何使用双指针解决此问题。</p><h1 id="递归-回溯"><a href="#递归-回溯" class="headerlink" title="递归/回溯"></a>递归/回溯</h1><h2 id="BM55-没有重复数字的全排列"><a href="#BM55-没有重复数字的全排列" class="headerlink" title="BM55 没有重复数字的全排列"></a>BM55 <a href="https://www.nowcoder.com/practice/4bcf3081067a4d028f95acee3ddcd2b1?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">没有重复数字的全排列</a></h2><h3 id="题目描述-53"><a href="#题目描述-53" class="headerlink" title="题目描述"></a>题目描述</h3><p>给出一组数字，返回该组数字的所有排列 </p><p>例如： </p><p>[1,2,3]的所有排列如下<br>[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2], [3,2,1].<br>（以数字在数组中的位置靠前为优先级，按字典序排列输出。） </p><p>数据范围：数字个数 0&lt;n≤6</p><p>要求：空间复杂度 O(n!)，时间复杂度 O(n!）</p><h3 id="题解-61"><a href="#题解-61" class="headerlink" title="题解"></a>题解</h3><p>全排列问题，直接回溯求解即可。</p><h3 id="Java代码实现-60"><a href="#Java代码实现-60" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 存取全部结果</span></span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] num) &#123;</span><br><span class="line">        <span class="comment">// 确保符合题意</span></span><br><span class="line">        Arrays.sort(num);</span><br><span class="line">        LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 直接递归回溯</span></span><br><span class="line">        backTrack(num, list);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="keyword">int</span>[] nums, LinkedList&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 相等表示找到了一种排列</span></span><br><span class="line">        <span class="keyword">if</span>(list.size() == nums.length)&#123;</span><br><span class="line">            <span class="comment">// 加入结果集</span></span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i)&#123;</span><br><span class="line">            <span class="comment">// 包含当前元素就继续向下</span></span><br><span class="line">            <span class="keyword">if</span>(list.contains(nums[i]))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            list.add(nums[i]);</span><br><span class="line">            backTrack(nums, list);</span><br><span class="line">            list.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM56-有重复项数字的全排列"><a href="#BM56-有重复项数字的全排列" class="headerlink" title="BM56 有重复项数字的全排列"></a>BM56 <a href="https://www.nowcoder.com/practice/a43a2b986ef34843ac4fdd9159b69863?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">有重复项数字的全排列</a></h2><h3 id="题目描述-54"><a href="#题目描述-54" class="headerlink" title="题目描述"></a>题目描述</h3><p>给出一组可能包含重复项的数字，返回该组数字的所有排列。结果以字典序升序排列。 </p><p>数据范围： 0&lt;n≤8，数组中的值满足 −1≤val≤5</p><p>要求：空间复杂度 O(n!)<em>O</em>(<em>n</em>!)，时间复杂度 O(n!)<em>O</em>(<em>n</em>!)</p><h3 id="题解-62"><a href="#题解-62" class="headerlink" title="题解"></a>题解</h3><p>递归，每次加入数据时判断是否已有此排列方式即可，此外维护一个数组表示元素是否被标记过，只有没有被标记过才继续。</p><h3 id="Java代码实现-61"><a href="#Java代码实现-61" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 存放是否被访问过的数组</span></span><br><span class="line">    <span class="keyword">boolean</span>[] mark;</span><br><span class="line">    <span class="comment">// 存放结果的数组</span></span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] num) &#123;</span><br><span class="line">        <span class="comment">// 先排列数组</span></span><br><span class="line">        Arrays.sort(num);</span><br><span class="line">        <span class="comment">// 存放每一层的元素，都是加入一个或者移除最后一个，直接用LinkedList</span></span><br><span class="line">        LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        mark = <span class="keyword">new</span> <span class="keyword">boolean</span>[num.length];</span><br><span class="line">        backTrace(num, list, mark);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backTrace</span><span class="params">(<span class="keyword">int</span>[] nums, LinkedList&lt;Integer&gt; list, <span class="keyword">boolean</span>[] mark)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 退出递归的条件</span></span><br><span class="line">        <span class="keyword">if</span>(list.size() == nums.length)&#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; num = <span class="keyword">new</span> ArrayList&lt;&gt;(list);</span><br><span class="line">            <span class="keyword">if</span>(!res.contains(num))&#123;</span><br><span class="line">                res.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有退出就继续递归</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i)&#123;</span><br><span class="line">            <span class="comment">// 如果当前位置已访问过直接退出</span></span><br><span class="line">            <span class="keyword">if</span>(mark[i])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            list.add(nums[i]);</span><br><span class="line">            <span class="comment">// 标记其为已访问过</span></span><br><span class="line">            mark[i] = <span class="keyword">true</span>;</span><br><span class="line">            backTrace(nums, list, mark);</span><br><span class="line">            list.removeLast();</span><br><span class="line">            <span class="comment">// 标记其还未访问过</span></span><br><span class="line">            mark[i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM57-岛屿数量"><a href="#BM57-岛屿数量" class="headerlink" title="BM57 岛屿数量"></a>BM57 <a href="https://www.nowcoder.com/practice/0c9664d1554e466aa107d899418e814e?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">岛屿数量</a></h2><h3 id="题目描述-55"><a href="#题目描述-55" class="headerlink" title="题目描述"></a>题目描述</h3><p>给一个01矩阵，1代表是陆地，0代表海洋， 如果两个1相邻，那么这两个1属于同一个岛。我们只考虑上下左右为相邻。</p><p>岛屿: 相邻陆地可以组成一个岛屿（相邻:上下左右） 判断岛屿个数。 </p><p>例如： </p><p>输入 </p><p>[ </p><p>[1,1,0,0,0], </p><p>[0,1,0,1,1], </p><p>[0,0,0,1,1], </p><p>[0,0,0,0,0], </p><p>[0,0,1,1,1] </p><p>] </p><p>对应的输出为3</p><p>(注：存储的01数据其实是字符’0’,’1’)</p><h3 id="题解-63"><a href="#题解-63" class="headerlink" title="题解"></a>题解</h3><p>维护一个二维数组mark表示是否被标记过，遍历回溯，若是找到了1，先判断是否有标记过，标记过就直接跳过继续搜，若是没有标记过，分析其前后左右是否有1，并将所有1所在的位置进行标记并令岛屿数自增1，最终返回岛屿数。</p><h3 id="Java代码实现-62"><a href="#Java代码实现-62" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断岛屿数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> grid char字符型二维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span> <span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 岛屿m行n列</span></span><br><span class="line">        <span class="keyword">int</span> m = grid.length;</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">boolean</span>[][] mark = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="comment">// 标记有多少个岛屿</span></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span> &amp;&amp; !mark[i][j])&#123;</span><br><span class="line">                    ++num;</span><br><span class="line">                    <span class="comment">// 每次向上下左右搜索，直到没有为止</span></span><br><span class="line">                    dfs(grid, i, j, mark);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 回溯，使上下左右的1变为true</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">boolean</span>[][] mark)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 若是超出边界值或是当前元素已被标记过就返回</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= grid.length || j &lt; <span class="number">0</span> || j &gt;= grid[<span class="number">0</span>].length || grid[i][j] == <span class="string">'0'</span> || mark[i][j])&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mark[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        dfs(grid, i, j + <span class="number">1</span>, mark);</span><br><span class="line">        dfs(grid, i - <span class="number">1</span>, j, mark);</span><br><span class="line">        dfs(grid, i, j - <span class="number">1</span>, mark);</span><br><span class="line">        dfs(grid, i + <span class="number">1</span>, j, mark);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM58-字符串的排列"><a href="#BM58-字符串的排列" class="headerlink" title="BM58 字符串的排列"></a>BM58 <a href="https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">字符串的排列</a></h2><h3 id="题目描述-56"><a href="#题目描述-56" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个长度为 n 字符串，打印出该字符串中字符的所有排列，你可以以任意顺序返回这个字符串数组。 </p><p>例如输入字符串ABC,则输出由字符A,B,C所能排列出来的所有字符串ABC,ACB,BAC,BCA,CBA和CAB。 </p><p><img src="https://uploadfiles.nowcoder.com/images/20211008/557336_1633676660853/6226390B4185DB132AFFDB10F09F8BEB" alt="img"></p><p>数据范围：n&lt;10<br>要求：空间复杂度 O(n!)，时间复杂度 O(n!)</p><h4 id="输入描述-2"><a href="#输入描述-2" class="headerlink" title="输入描述"></a>输入描述</h4><p>输入一个字符串,长度不超过10,字符只包括大小写字母。</p><h3 id="题解-64"><a href="#题解-64" class="headerlink" title="题解"></a>题解</h3><p>将字符串直接进行全排即可，和<a href="https://www.nowcoder.com/practice/a43a2b986ef34843ac4fdd9159b69863?tpId=295&tqId=700&ru=%2Fpractice%2Ffe6b651b66ae47d7acce78ffdd9a96c7&qru=%2Fta%2Fformat-top101%2Fquestion-ranking&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">有重复数字全排</a>是一样的。</p><h3 id="Java代码实现-63"><a href="#Java代码实现-63" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">Permutation</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 先进行判空</span></span><br><span class="line">        <span class="keyword">if</span>(str.equals(<span class="string">""</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用于保存每次排列出的字符串</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">        <span class="comment">// 用于判断当前字符是否被遍历过</span></span><br><span class="line">        <span class="keyword">boolean</span>[] mask = <span class="keyword">new</span> <span class="keyword">boolean</span>[chars.length];</span><br><span class="line">        backTrace(res, chars, sb, mask);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backTrace</span><span class="params">(ArrayList&lt;String&gt; res, <span class="keyword">char</span>[] chars, StringBuilder sb, <span class="keyword">boolean</span>[] mask)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 退出条件</span></span><br><span class="line">        <span class="keyword">if</span>(sb.length() == chars.length)&#123;</span><br><span class="line">            <span class="comment">// 去重</span></span><br><span class="line">            <span class="keyword">if</span>(!res.contains(sb.toString()))&#123;</span><br><span class="line">                res.add(sb.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; ++i)&#123;</span><br><span class="line">            <span class="comment">// 只有没有遍历过这个元素才继续</span></span><br><span class="line">            <span class="keyword">if</span>(!mask[i])&#123;</span><br><span class="line">                mask[i] = <span class="keyword">true</span>;</span><br><span class="line">                sb.append(chars[i]);</span><br><span class="line">                backTrace(res, chars, sb, mask);</span><br><span class="line">                sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">                mask[i] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM59-N皇后问题"><a href="#BM59-N皇后问题" class="headerlink" title="BM59 N皇后问题"></a>BM59 <a href="https://www.nowcoder.com/practice/c76408782512486d91eea181107293b6?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">N皇后问题</a></h2><h3 id="题目描述-57"><a href="#题目描述-57" class="headerlink" title="题目描述"></a>题目描述</h3><p>N 皇后问题是指在 n * n 的棋盘上要摆 n 个皇后，<br>要求：任何两个皇后不同行，不同列也不在同一条斜线上，<br>求给一个整数 n ，返回 n 皇后的摆法数。</p><p>数据范围: 1≤n≤9</p><p>要求：空间复杂度 O(1)，时间复杂度 O(n!)</p><p>例如当输入4时，对应的返回值为2， </p><p>对应的两种四皇后摆位如下图所示： </p><p><img src="https://uploadfiles.nowcoder.com/images/20211204/423483716_1638606211798/CFE342EBEEFB9E6839E6ED216B889F16" alt="img"></p><h3 id="题解-65"><a href="#题解-65" class="headerlink" title="题解"></a>题解</h3><p>回溯法的经典实例，N皇后问题，对于每个位置进行判断，若是发现了不合题意（任何皇后不能在相同行，相同列或是一条斜线上）的直接放弃这个解（剪枝），若是符合题意继续，直到遍历完。</p><p>对于n皇后问题，需要一个辅助函数判断当前的元素是否合法，需要的是二维字符数组chess（需要判断棋局是否合法），返回的结果集List&lt;List &lt; String &gt;&gt; res（需要往其中添加元素），以及当前列数（看到此列为止是否符合题意），判断时需要考虑同一行不能有皇后（每一行只放一个元素故天然满足此条件），同一列不能有皇后，只要看上面有无皇后即可，同一斜线不能有皇后（左上右上分开看，左上横纵坐标减1，右上横坐标加1纵坐标减1），三个条件有一个不满足即不合法，全满足则可以进行下一次遍历。</p><h3 id="Java代码实现-64"><a href="#Java代码实现-64" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n int整型 the n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Nqueen</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">return</span> solveNQueens(n).size();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">char</span>[][] chess = <span class="keyword">new</span> <span class="keyword">char</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                chess[i][j] = <span class="string">'.'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        solve(res, chess, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 求解过程</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(List&lt;List&lt;String&gt;&gt; res, <span class="keyword">char</span>[][] chess, <span class="keyword">int</span> row)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 若是满足直接退出</span></span><br><span class="line">        <span class="keyword">if</span>(row == chess.length)&#123;</span><br><span class="line">            res.add(construct(chess));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 之后判断当前位置是否合法，合法则将当前位置变为Q，继续，不合法直接下一个元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; chess.length; ++col)&#123;</span><br><span class="line">            <span class="keyword">if</span>(valid(chess, row, col))&#123;</span><br><span class="line">                chess[row][col] = <span class="string">'Q'</span>;</span><br><span class="line">                solve(res, chess, row + <span class="number">1</span>);</span><br><span class="line">                chess[row][col] = <span class="string">'.'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断当前位置是否合法</span></span><br><span class="line">    <span class="comment">// 天然不在同一行</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">valid</span><span class="params">(<span class="keyword">char</span>[][] chess, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 两个皇后不能在同一列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(chess[i][col] == <span class="string">'Q'</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 两个皇后不能在同一条斜线</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 确保右上角没有</span></span><br><span class="line">        <span class="comment">// 每次就往右上角移一位，判断是否有皇后</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; chess.length; --i, ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(chess[i][j] == <span class="string">'Q'</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 确保左上角没有</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; --i, --j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(chess[i][j] == <span class="string">'Q'</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 都满足的话就证明是合法的</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回棋局</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">construct</span><span class="params">(<span class="keyword">char</span>[][] chess)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chess.length; ++i)&#123;</span><br><span class="line">            path.add(<span class="keyword">new</span> String(chess[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM60-括号生成"><a href="#BM60-括号生成" class="headerlink" title="BM60 括号生成"></a>BM60 <a href="https://www.nowcoder.com/practice/c9addb265cdf4cdd92c092c655d164ca?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">括号生成</a></h2><h3 id="题目描述-58"><a href="#题目描述-58" class="headerlink" title="题目描述"></a>题目描述</h3><p>给出n对括号，请编写一个函数来生成所有的由n对括号组成的合法组合。</p><p>例如，给出n=3，解集为： </p><p>“((()))”, “(()())”, “(())()”, “()()()”, “()(())”</p><p>数据范围：0≤n≤10</p><p>要求：空间复杂度 O(n!)，时间复杂度 O(n!)</p><h3 id="题解-66"><a href="#题解-66" class="headerlink" title="题解"></a>题解</h3><p>对于每次选择，只有如下几种情况，若是左括号仍有剩余就可以放左括号，但只有当左括号有剩余的同时左括号数量比右括号多才能放右括号，明白了合法性的原理之后只需要递归回溯即可。</p><h3 id="Java代码实现-65"><a href="#Java代码实现-65" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串ArrayList</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">generateParenthesis</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 用于保存结果的数组</span></span><br><span class="line">        ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        traceBack(res, n, sb, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里left和right分别是左括号数和右括号数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traceBack</span><span class="params">(ArrayList&lt;String&gt; res, <span class="keyword">int</span> n, StringBuilder sb, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 递归退出条件</span></span><br><span class="line">        <span class="keyword">if</span>(left == n &amp;&amp; right == n)&#123;</span><br><span class="line">            <span class="comment">// 先进行合法性判断</span></span><br><span class="line">            <span class="keyword">if</span>(!res.contains(sb.toString()))</span><br><span class="line">                res.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只要还有左括号就可以一直放</span></span><br><span class="line">        <span class="keyword">if</span>(left &lt; n)&#123;</span><br><span class="line">            sb.append(<span class="string">"("</span>);</span><br><span class="line">            traceBack(res, n, sb, left + <span class="number">1</span>, right);</span><br><span class="line">            <span class="comment">// 记得把放入的元素删除</span></span><br><span class="line">            sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右括号只有在剩余以及左括号数量比右括号数量多时才能放</span></span><br><span class="line">        <span class="keyword">if</span>(right &lt; n &amp;&amp; left &gt; right)&#123;</span><br><span class="line">            sb.append(<span class="string">")"</span>);</span><br><span class="line">            traceBack(res, n, sb, left, right + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 记得把放入的元素删除</span></span><br><span class="line">            sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM61-矩阵最长递增路径"><a href="#BM61-矩阵最长递增路径" class="headerlink" title="BM61 矩阵最长递增路径"></a>BM61 <a href="https://www.nowcoder.com/practice/7a71a88cdf294ce6bdf54c899be967a2?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">矩阵最长递增路径</a></h2><h3 id="题目描述-59"><a href="#题目描述-59" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个 n 行 m 列矩阵 matrix ，矩阵内所有数均为非负整数。 你需要在矩阵中找到一条最长路径，使这条路径上的元素是递增的。并输出这条最长路径的长度。 </p><p>这个路径必须满足以下条件：</p><ol><li><p>对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外。</p></li><li><p>你不能走重复的单元格。即每个格子最多只能走一次。</p></li></ol><p>数据范围：1≤n,m≤1000，0≤matrix[i][j]≤1000</p><p>进阶：空间复杂度 O(nm) ，时间复杂度 O(nm)</p><p>例如：当输入为[[1,2,3],[4,5,6],[7,8,9]]时，对应的输出为5， </p><p>其中的一条最长递增路径如下图所示： </p><p><img src="https://uploadfiles.nowcoder.com/images/20211201/423483716_1638350164758/A6B05D015D3BE3C77C34DDF224044A1F" alt="img"></p><h3 id="题解-67"><a href="#题解-67" class="headerlink" title="题解"></a>题解</h3><p>遍历所有值，每次判断是否更新最大长度，继续走（继续走的前提是下一个节点可以走），可以规定先向右走，再向上走，之后向左走，最后向下走。</p><h3 id="Java代码实现-66"><a href="#Java代码实现-66" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     * 递增路径的最大长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> matrix int整型二维数组 描述矩阵的每个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 数组n行m列</span></span><br><span class="line">    <span class="keyword">int</span> m,n;</span><br><span class="line">    <span class="comment">// 该往哪走</span></span><br><span class="line">    <span class="keyword">int</span>[][] directions = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span> <span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        n = matrix.length;</span><br><span class="line">        m = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// 对每个元素dfs</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)&#123;</span><br><span class="line">                solveRec(i, j, <span class="number">0</span>, matrix);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">solveRec</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> len, <span class="keyword">int</span>[][] matrix)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 大于就更新全局变量</span></span><br><span class="line">        <span class="comment">// 这里已经将len自增1了</span></span><br><span class="line">        <span class="keyword">if</span>(++len &gt; max)&#123;</span><br><span class="line">            max = len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] dir : directions)&#123;</span><br><span class="line">            <span class="comment">// 看下一个dfs的横纵坐标</span></span><br><span class="line">            <span class="keyword">int</span> rowNext = i + dir[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> colNext = j + dir[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 坐标不符合</span></span><br><span class="line">            <span class="keyword">if</span>(rowNext &lt; <span class="number">0</span> || rowNext &gt;= n || colNext &lt; <span class="number">0</span> || colNext &gt;= m)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 值不符合</span></span><br><span class="line">            <span class="keyword">if</span>(matrix[rowNext][colNext] &lt;= matrix[i][j])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            solveRec(rowNext, colNext, len, matrix);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="BM62-斐波那契数列"><a href="#BM62-斐波那契数列" class="headerlink" title="BM62 斐波那契数列"></a>BM62 <a href="https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">斐波那契数列</a></h2><h3 id="题目描述-60"><a href="#题目描述-60" class="headerlink" title="题目描述"></a>题目描述</h3><p>大家都知道斐波那契数列，现在要求输入一个正整数 n ，请你输出斐波那契数列的第 n 项。 </p><p>斐波那契数列是一个满足 fib(x)={1x=1,2fib(x−1)+fib(x−2)x&gt;2<em>f<strong>i</strong>b</em>(<em>x</em>)={1<em>f<strong>i</strong>b</em>(<em>x</em>−1)+<em>f<strong>i</strong>b</em>(<em>x</em>−2)<em>x</em>=1,2<em>x</em>&gt;2 的数列 </p><p>数据范围：1≤n≤40</p><p>要求：空间复杂度 O(1)，时间复杂度 O(n)，本题也有时间复杂度 O(logn)的解法 </p><h4 id="输入描述：-3"><a href="#输入描述：-3" class="headerlink" title="输入描述："></a>输入描述：</h4><p>一个正整数n</p><h4 id="返回值描述：-3"><a href="#返回值描述：-3" class="headerlink" title="返回值描述："></a>返回值描述：</h4><p>输出一个正整数。</p><h3 id="题解-68"><a href="#题解-68" class="headerlink" title="题解"></a>题解</h3><p>初始化一个用于保存斐波那契数列前n项和的数组，每次求下一个值时只需将前面的值拿出计算即可。也可使用递归函数进行实现。</p><h3 id="Java代码实现-67"><a href="#Java代码实现-67" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ublic <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Fibonacci(n - <span class="number">1</span>) + Fibonacci(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但通过此方法，时间复杂度其实已经不是O(n)，这里可以考虑使用动态规划来优化时间。</p><h3 id="题解-69"><a href="#题解-69" class="headerlink" title="题解"></a>题解</h3><p>动态规划的核心思想是将大问题分解为小问题解决并保存结果，之后大问题的解决依赖于小问题的解。</p><h3 id="Java代码实现-68"><a href="#Java代码实现-68" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 这里dp[2]其实也等于0 +1 = 1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用动态规划的空间压缩技巧（发现这里其实并不需要一整个数组，只需要三个变量分别保存当前元素以及当前元素之前的两个元素即可），空间压缩后代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pre1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> pre2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            cur = pre1 + pre2;</span><br><span class="line">            pre2 = pre1;</span><br><span class="line">            pre1 = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间压缩技巧实际上就是将一组数据不断后移，若是一维动态规划，这组数据是有限的几个变量，若是二维动态规划，这组数据是一个数组。</p><p><strong>对于O(logn)的算法，涉及到矩阵的运算，可以参考网上的一些博客。</strong></p><h2 id="BM63-跳台阶"><a href="#BM63-跳台阶" class="headerlink" title="BM63 跳台阶"></a>BM63 <a href="https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">跳台阶</a></h2><h3 id="题目描述-61"><a href="#题目描述-61" class="headerlink" title="题目描述"></a>题目描述</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 </p><p>数据范围：1≤n≤40</p><p>要求：时间复杂度：O(n) ，空间复杂度： O(1)</p><h3 id="题解-70"><a href="#题解-70" class="headerlink" title="题解"></a>题解</h3><p>这题也是动态规划的典型题目，青蛙每次可以选择跳一阶台阶或是两阶台阶，那么对于第n阶，跳法一共有f(n) = f(n - 2) + f(n - 1)（跳到n - 1阶或是n - 2阶），和斐波那契数列一致，至于题目要求O(1)的空间复杂度，那就进行一维动态规划的空间压缩即可。</p><h3 id="Java代码实现-69"><a href="#Java代码实现-69" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 上0阶台阶有0种上法</span></span><br><span class="line">        <span class="keyword">int</span> pre0 = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 上一阶台阶只有一种上法</span></span><br><span class="line">        <span class="keyword">int</span> pre1 = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 当前有几种上法</span></span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= target; ++i)&#123;</span><br><span class="line">            cur = pre1 + pre0;</span><br><span class="line">            pre0 = pre1;</span><br><span class="line">            pre1 = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM64-最小花费爬楼梯"><a href="#BM64-最小花费爬楼梯" class="headerlink" title="BM64 最小花费爬楼梯"></a>BM64 <a href="https://www.nowcoder.com/practice/6fe0302a058a4e4a834ee44af88435c7?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">最小花费爬楼梯</a></h2><h3 id="题目描述-62"><a href="#题目描述-62" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个整数数组 cost，其中 cost[i]是从楼梯第i个台阶向上爬需要支付的费用，下标从0开始。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p><p>你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。</p><p>请你计算并返回达到楼梯顶部的最低花费。<br>数据范围：数组长度满足 1≤n≤10^5，数组中的值满足 1≤costi≤10^4</p><h3 id="题解-71"><a href="#题解-71" class="headerlink" title="题解"></a>题解</h3><p>根据题目描述，很容易想到第n层的话费其实是f(n) = min(cost[n - 3] + f(n - 2), cost[n - 3] + f(n - 1))，因此直接动态规划求解并压缩空间即可</p><h3 id="Java代码实现-70"><a href="#Java代码实现-70" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cost int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs</span> <span class="params">(<span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 第0阶的花费</span></span><br><span class="line">        <span class="keyword">int</span> pre0 = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 第一阶的花费</span></span><br><span class="line">        <span class="keyword">int</span> pre1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= cost.length; ++i)&#123;</span><br><span class="line">            <span class="comment">// 本次爬楼梯的花费可以选择两阶前的花费（这次爬两阶）加上爬到两阶前的花费</span></span><br><span class="line">            <span class="comment">// 或者是一阶前的花费（这次爬一阶）加上爬到一阶前的花费</span></span><br><span class="line">            <span class="comment">// 然后二者取最小值</span></span><br><span class="line">            cur = Math.min(pre0 + cost[i - <span class="number">2</span>], pre1 + cost[i - <span class="number">1</span>]);</span><br><span class="line">            pre0 = pre1;</span><br><span class="line">            pre1 = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM65-最长公共子序列（二）"><a href="#BM65-最长公共子序列（二）" class="headerlink" title="BM65 最长公共子序列（二）"></a>BM65 <a href="https://www.nowcoder.com/practice/6d29638c85bb4ffd80c020fe244baf11?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">最长公共子序列（二）</a></h2><h3 id="题目描述-63"><a href="#题目描述-63" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定两个字符串str1和str2，输出两个字符串的最长公共子序列。如果最长公共子序列为空，则返回”-1”。目前给出的数据，仅仅会存在一个最长的公共子序列</p><p>数据范围：0≤∣str1∣,∣str2∣≤2000</p><p>要求：空间复杂度 O(n^2) ，时间复杂度 O(n^2)</p><h3 id="题解-72"><a href="#题解-72" class="headerlink" title="题解"></a>题解</h3><p>假定字符串str1和str2的长度分别为n1和n2，那么令dp[i] [j]表示前str1的前i个字符到str2的前j个字符到最长公共子序列，那么当str1.charAt(i - 1) == str2.charAt(j - 1)时dp[i] [j] = dp[i - 1] [j - 1] + 1；不等时dp[i] [j] = max(dp[i - 1] [j], dp[i] [j - 1])，如此就能找到最大子序列的长度，由于需要最长公共子序列字符串，所以这里从后往前遍历（从前往后遍历可能会出现需要跳过此相同值的情况），若是两个字符相等，就将其加到字符串上，若是两个字符不相等，那么判断后移左指针还是后移右指针能获得最大收益（判断哪个dp大），一直往收益大的地方走即能找到最优解。</p><h3 id="Java代码实现-71"><a href="#Java代码实现-71" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * longest common subsequence</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s1 string字符串 the string</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s2 string字符串 the string</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">LCS</span> <span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(s1.equals(<span class="string">""</span>) || s2.equals(<span class="string">""</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"-1"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> str1[] = s1.toCharArray();</span><br><span class="line">        <span class="keyword">char</span> str2[] = s2.toCharArray();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> n1 = str1.length;</span><br><span class="line">        <span class="keyword">int</span> n2 = str2.length;</span><br><span class="line">        String[][] res = <span class="keyword">new</span> String[n1 + <span class="number">1</span>][n2 + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// dp[i][j]表示str1的前i个字符以及str2的前j个字符中最长子序列的长度</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n1 + <span class="number">1</span>][n2 + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 先初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n1; ++i)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            res[i][<span class="number">0</span>] = <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n2; ++i)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">            res[<span class="number">0</span>][i] = <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 之后依次遍历填充dp数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n2; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(str1[i - <span class="number">1</span>] == str2[j - <span class="number">1</span>])&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 填充好数组之后从后往前遍历找到最长公共子序列</span></span><br><span class="line">        <span class="keyword">int</span> cur1 = n1;</span><br><span class="line">        <span class="keyword">int</span> cur2 = n2;</span><br><span class="line">        <span class="comment">// 结果的保存</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span>(cur1 != <span class="number">0</span> &amp;&amp; cur2 != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 若是两者相等则证明是公共序列直接加到sb中，因为是从后往前走，所以此时不需要判断是否跳过</span></span><br><span class="line">            <span class="keyword">if</span>(str1[cur1 - <span class="number">1</span>] == str2[cur2 - <span class="number">1</span>])&#123;</span><br><span class="line">                sb.append(str1[cur1 - <span class="number">1</span>]);</span><br><span class="line">                --cur2;</span><br><span class="line">                --cur1;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 此时两个下标所在的字符不相等</span></span><br><span class="line">                <span class="keyword">if</span>(dp[cur1 - <span class="number">1</span>][cur2] &lt; dp[cur1][cur2 - <span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="comment">// 此时表示左移指针2能得到不差的解</span></span><br><span class="line">                    --cur2;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    --cur1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 看是否是空</span></span><br><span class="line">        <span class="keyword">if</span>(sb.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"-1"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为是从后往前的，因此记得反转</span></span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM66-最长公共子串"><a href="#BM66-最长公共子串" class="headerlink" title="BM66 最长公共子串"></a>BM66 <a href="https://www.nowcoder.com/practice/f33f5adc55f444baa0e0ca87ad8a6aac?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">最长公共子串</a></h2><h3 id="题目描述-64"><a href="#题目描述-64" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定两个字符串str1和str2,输出两个字符串的最长公共子串</p><p>题目保证str1和str2的最长公共子串存在且唯一。 </p><p>数据范围： 1≤∣str1∣,∣str2∣≤5000<br>要求： 空间复杂度 O(n^2)，时间复杂度 O(n^2)</p><h3 id="题解-73"><a href="#题解-73" class="headerlink" title="题解"></a>题解</h3><p>判断最长子串问题，其实就是二维动态规划问题，考虑用dp[i] [j]表示str1前i个字符和str2前j个字符的最长公共子串（这里必须要以str1.charAt(i - 1)结尾），那么状态转移方程即为：dp[i] [j] = dp[i - 1] [j - 1] + 1（当str1.charAt(i - 1) == str2.charAt(j - 1)时），dp[i] [j] = 0，之后就是已知最大子串的长度求最大子串，也可以直接在遍历的过程中存储最长子串。</p><h3 id="Java代码实现-72"><a href="#Java代码实现-72" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * longest common substring</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str1 string字符串 the string</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str2 string字符串 the string</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">LCS</span> <span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">char</span>[] chars1 = str1.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] chars2 = str2.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> n1 = chars1.length;</span><br><span class="line">        <span class="keyword">int</span> n2 = chars2.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n1 + <span class="number">1</span>][n2 + <span class="number">1</span>];</span><br><span class="line">        String[][] res = <span class="keyword">new</span> String[n1 + <span class="number">1</span>][n2 + <span class="number">1</span>];</span><br><span class="line">        String max = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n1; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n2; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                    res[i][j] = <span class="string">""</span>;</span><br><span class="line">                    <span class="comment">// 这些肯定不是最长子串无需判断</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(chars1[i - <span class="number">1</span>] == chars2[j - <span class="number">1</span>])&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    res[i][j] = res[i - <span class="number">1</span>][j - <span class="number">1</span>] + chars1[i - <span class="number">1</span>];</span><br><span class="line">                    <span class="comment">// 这里若是增加的话有可能是最长子串</span></span><br><span class="line">                    <span class="keyword">if</span>(dp[i][j] &gt; max.length())&#123;</span><br><span class="line">                        max = res[i][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                    res[i][j] = <span class="string">""</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * longest common substring</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str1 string字符串 the string</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str2 string字符串 the string</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">LCS</span> <span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">char</span>[] chars1 = str1.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] chars2 = str2.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> n1 = chars1.length;</span><br><span class="line">        <span class="keyword">int</span> n2 = chars2.length;</span><br><span class="line">        String[][] res = <span class="keyword">new</span> String[n1 + <span class="number">1</span>][n2 + <span class="number">1</span>];</span><br><span class="line">        String max = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n1; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n2; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>)&#123;</span><br><span class="line">                    res[i][j] = <span class="string">""</span>;</span><br><span class="line">                    <span class="comment">// 这些肯定不是最长子串无需判断</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(chars1[i - <span class="number">1</span>] == chars2[j - <span class="number">1</span>])&#123;</span><br><span class="line">                    res[i][j] = res[i - <span class="number">1</span>][j - <span class="number">1</span>] + chars1[i - <span class="number">1</span>];</span><br><span class="line">                    <span class="comment">// 这里若是增加的话有可能是最长子串</span></span><br><span class="line">                    <span class="keyword">if</span>(res[i][j].length() &gt; max.length())&#123;</span><br><span class="line">                        max = res[i][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    res[i][j] = <span class="string">""</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM67-不同路径的数目（一）"><a href="#BM67-不同路径的数目（一）" class="headerlink" title="BM67 不同路径的数目（一）"></a>BM67 <a href="https://www.nowcoder.com/practice/166eaff8439d4cd898e3ba933fbc6358?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">不同路径的数目（一）</a></h2><h3 id="题目描述-65"><a href="#题目描述-65" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个机器人在m×n大小的地图的左上角（起点）。 </p><p>机器人每次可以向下或向右移动。机器人要到达地图的右下角（终点）。</p><p>可以有多少种不同的路径从起点走到终点？ </p><p><img src="https://uploadfiles.nowcoder.com/images/20201210/999991351_1607596327517/873CB1F2327F70DA0CA0FDC797F894A7" alt="img"></p><p>备注：m和n小于等于100,并保证计算结果在int范围内 </p><p>数据范围：0&lt;n,m≤100，保证计算结果在32位整型范围内 </p><p>要求：空间复杂度 O(nm)，时间复杂度 O(nm)</p><p>进阶：空间复杂度 O(1)，时间复杂度 O(min(n,m))</p><h3 id="题解-74"><a href="#题解-74" class="headerlink" title="题解"></a>题解</h3><p>对于其中任何一个点来说，到达这个点的路径即为到达其左侧点的路径加上到达其上方点的路径。</p><h3 id="Java代码实现-73"><a href="#Java代码实现-73" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span> <span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时时间复杂度和空间复杂度都是O(nm)达到了要求但不满足进阶要求，进阶要求需要空间复杂度为O(1)，时间复杂度为O(min(n, m))。</p><h3 id="题解-75"><a href="#题解-75" class="headerlink" title="题解"></a>题解</h3><p>考虑到达位置(m, n)实际上就是先向右走n-1格，再向下走m - 1格，一共需要走m + n - 2格，其实就是从 m + n - 2格中选出向右n - 1格，就是一个组合问题，直接求解组合数即可。</p><h3 id="Java代码实现-74"><a href="#Java代码实现-74" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span> <span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = n, y = <span class="number">1</span>; y &lt; m; ++x, ++y)&#123;</span><br><span class="line">            res = res * x / y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM68-矩阵的最小路径和"><a href="#BM68-矩阵的最小路径和" class="headerlink" title="BM68 矩阵的最小路径和"></a>BM68 <a href="https://www.nowcoder.com/practice/7d21b6be4c6b429bb92d219341c4f8bb?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">矩阵的最小路径和</a></h2><h3 id="题目描述-66"><a href="#题目描述-66" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个 n * m 的矩阵 a，从左上角开始每次只能向右或者向下走，最后到达右下角的位置，路径上所有的数字累加起来就是路径和，输出所有的路径中最小的路径和。</p><p>数据范围: 1≤n,m≤500，矩阵中任意值都满足 0≤ai,j≤100</p><p>要求：时间复杂度 O(nm)</p><p>例如：当输入[[1,3,5,9],[8,1,3,4],[5,0,6,1],[8,8,4,0]]时，对应的返回值为12， </p><p>所选择的最小累加和路径如下图所示： </p><p><img src="https://uploadfiles.nowcoder.com/images/20220122/423483716_1642823916509/06EB123C153852AF55ED51448BEAD1BA" alt="img"></p><h3 id="题解-76"><a href="#题解-76" class="headerlink" title="题解"></a>题解</h3><p>对于任意一个位置，其可以由两个位置到达，其正上方或是其正左方，因此到达这个位置的最小路径就是其正上方的路径和跟其正左方的路径和的最小值再加上当前位置的值。</p><h3 id="Java代码实现-75"><a href="#Java代码实现-75" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> matrix int整型二维数组 the matrix</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span> <span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="comment">// 先初始化</span></span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="comment">// dp[0][0] = matrix[0][0];</span></span><br><span class="line">                        dp[i][j] = matrix[i][j];</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="comment">// 第一行就是左边总的加上现在的</span></span><br><span class="line">                        dp[i][j] = dp[i][j - <span class="number">1</span>] + matrix[i][j];</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">// 第一列就是上边总的加上现在的</span></span><br><span class="line">                        dp[i][j] = dp[i - <span class="number">1</span>][j] + matrix[i][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 当前的格子就是左边总的和上边总的两者取最小再加上现在的</span></span><br><span class="line">                dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + matrix[i][j]; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM69-把数字翻译成字符串"><a href="#BM69-把数字翻译成字符串" class="headerlink" title="BM69 把数字翻译成字符串"></a>BM69 <a href="https://www.nowcoder.com/practice/046a55e6cd274cffb88fc32dba695668?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">把数字翻译成字符串</a></h2><h3 id="题目描述-67"><a href="#题目描述-67" class="headerlink" title="题目描述"></a>题目描述</h3><p>有一种将字母编码成数字的方式：’a’-&gt;1, ‘b-&gt;2’, … , ‘z-&gt;26’。 </p><p>现在给一串数字，返回有多少种可能的译码结果</p><p>数据范围：字符串长度满足 0&lt;n≤90</p><p>进阶：空间复杂度 O(n)，时间复杂度 O(n)</p><h3 id="题解-77"><a href="#题解-77" class="headerlink" title="题解"></a>题解</h3><p>考虑使用动态规划求解此问题，那么当这个元素的值小于7且上一个元素小于3时可以和前面的值结合为一个字母（如26可解析为z），若是前一个数字为1，那么这个数可以是0-9的任意数（16可以解析为p），也可以这个字母单独求解，若是不满足以上任意一个条件，那么就只能单独解析为0-9的一个字母。综上，设dp[i]表示前i个字母可能的译码结果，对于任意一个字符，若是其上一个字符为1，那么不管这个字符是几，都会有dp[i] = dp[i - 1] + dp[i - 2]；其中dp[i - 1]是前i - 1个字符可能的结果（把这个字符单独解析为0 - 9），dp[i - 2]则是前 i - 2个字符可能的结果；此外若是其上一个字符小于3且这一个字符小于6，那么也可以和前一个字符解析，也是dp[i] = dp[i - 1] + dp[i - 2]，否则dp[i] = dp[i - 1]。</p><h3 id="Java代码实现-76"><a href="#Java代码实现-76" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums string字符串 数字串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span> <span class="params">(String nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 长度不合法或是存在前导0</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length() == <span class="number">0</span> || nums.charAt(<span class="number">0</span>) == <span class="string">'0'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length()];</span><br><span class="line">        <span class="comment">// 第一个字符只有一种解析方式</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.length; i++)&#123;</span><br><span class="line">            <span class="comment">// 若不是0，那肯定能自己解析，先加上</span></span><br><span class="line">            <span class="keyword">if</span>(nums.charAt(i) != <span class="string">'0'</span>)&#123;</span><br><span class="line">                dp[i] = dp[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 看是否能和前面的一起解析</span></span><br><span class="line">            <span class="keyword">int</span> num = (nums.charAt(i-<span class="number">1</span>)-<span class="string">'0'</span>)*<span class="number">10</span> + (nums.charAt(i)-<span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">if</span>(num &gt;= <span class="number">10</span> &amp;&amp; num &lt;= <span class="number">26</span>)&#123;</span><br><span class="line">                <span class="comment">// 此时能和前面的解析</span></span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">// 若是第一个的话就加一（没有dp[-1]，或者假设dp[-1] = 1）</span></span><br><span class="line">                    dp[i] += <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 反之加上dp[-1]即可</span></span><br><span class="line">                    dp[i] += dp[i-<span class="number">2</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.length()-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里一开始我写了一种<strong>错误代码</strong>但未找到原因，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums string字符串 数字串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span> <span class="params">(String nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 特殊情况优先考虑</span></span><br><span class="line">        <span class="keyword">if</span>(nums.equals(<span class="string">"0"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] str = nums.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> n = str.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 0个字符有一种解法</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 1个字符有一种解法</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="comment">// 有不合法的0</span></span><br><span class="line">            <span class="keyword">if</span>((str[i - <span class="number">2</span>] == <span class="string">'0'</span> || str[i - <span class="number">2</span>] - <span class="string">'0'</span> &gt; <span class="number">2</span>) &amp;&amp; str[i - <span class="number">1</span>] == <span class="string">'0'</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 有合法的0，0只能和前面的一起解析</span></span><br><span class="line">            <span class="keyword">if</span>(str[i - <span class="number">1</span>] == <span class="string">'0'</span>)&#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">2</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[i - <span class="number">2</span>] == <span class="string">'1'</span> || str[i - <span class="number">2</span>] - <span class="string">'0'</span> &lt; <span class="number">3</span> &amp;&amp; str[i - <span class="number">1</span>] - <span class="string">'0'</span> &lt; <span class="number">7</span>)&#123;</span><br><span class="line">                <span class="comment">// 此时能和前面的一起解析</span></span><br><span class="line">                dp[i] = dp[i - <span class="number">2</span>] + dp[i - <span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 否则只能自己解析</span></span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM70-兑换零钱（一）"><a href="#BM70-兑换零钱（一）" class="headerlink" title="BM70 兑换零钱（一）"></a>BM70 <a href="https://www.nowcoder.com/practice/3911a20b3f8743058214ceaa099eeb45?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">兑换零钱（一）</a></h2><h3 id="题目描述-68"><a href="#题目描述-68" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定数组arr，arr中所有的值都为正整数且不重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，再给定一个aim，代表要找的钱数，求组成aim的最少货币数。</p><p>如果无解，请返回-1.</p><p>数据范围：数组大小满足 0≤n≤10000， 数组中每个数字都满足 0&lt;val≤10000，0≤aim≤5000</p><p>要求：时间复杂度 O(n×aim)，空间复杂度 O(aim)。</p><h3 id="题解-78"><a href="#题解-78" class="headerlink" title="题解"></a>题解</h3><p>设dp[i]为组成i的最少货币数，那么对于数组中的每个数j，dp[i] += dp[i - j]，当货币数比最小值小时为0。</p><h3 id="Java代码实现-77"><a href="#Java代码实现-77" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最少货币数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr int整型一维数组 the array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> aim int整型 the target</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMoney</span> <span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> aim)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(aim == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里需要一个标记，但是不能用Integer.MAX_VALUE，因为+1后会变为负数导致min函数能取到</span></span><br><span class="line">        <span class="keyword">int</span> max = aim + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[aim + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 初始值全为最大值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= aim; ++i)&#123;</span><br><span class="line">            dp[i] = max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找0种钱一共需要0张钱</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= aim; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> currency : arr)&#123;</span><br><span class="line">                <span class="comment">// 只有货币面值小于等于需要找的钱时才有可能能找钱</span></span><br><span class="line">                <span class="keyword">if</span>(currency &lt;= i)&#123;</span><br><span class="line">                    <span class="comment">// 就是当前值和i - currency + 1的最小值（加一是因为要增加一张cureency）</span></span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[i - currency] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 大于aim（max = aim + 1，初始不能补的值）</span></span><br><span class="line">        <span class="keyword">return</span> dp[aim] &gt; aim ? -<span class="number">1</span> : dp[aim];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM71-最长上升子序列（一）"><a href="#BM71-最长上升子序列（一）" class="headerlink" title="BM71 最长上升子序列（一）"></a>BM71 <a href="https://www.nowcoder.com/practice/5164f38b67f846fb8699e9352695cd2f?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">最长上升子序列（一）</a></h2><h3 id="题目描述-69"><a href="#题目描述-69" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个长度为 n 的数组 arr，求它的最长严格上升子序列的长度。 </p><p>所谓子序列，指一个数组删掉一些数（也可以不删）之后，形成的新数组。例如 [1,5,3,7,3] 数组，其子序列有：[1,3,3]、[7] 等。但 [1,6]、[1,3,5] 则不是它的子序列。 </p><p>我们定义一个序列是 <strong>严格上升</strong> 的，当且仅当该序列<strong>不存在</strong>两个下标 i和 j满足 i&lt;j且 arri≥arrj。</p><p>数据范围： 0≤n≤1000</p><p>要求：时间复杂度 O(n^2)， 空间复杂度 O(n)</p><h3 id="题解-79"><a href="#题解-79" class="headerlink" title="题解"></a>题解</h3><p>使用dp[i]表示前i个字符以i结尾的字序列长度，至于状态转移方程，dp[i] = max(dp[j] + 1, dp[i])，这里dp[i]初始值为0同时num[j]必须小于num[i]同时j &lt; i，即：当前的最长上升子序列是前i - 1个字符最长上升子序列中最大的那个加1（前提是满足上升条件，即只能在小于当前值的值中取最大值），若是没有则初始值为1。</p><h3 id="Java代码实现-78"><a href="#Java代码实现-78" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 给定数组的最长严格上升子序列的长度。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr int整型一维数组 给定的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LIS</span> <span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(arr.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(arr.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        <span class="comment">// 用1填充</span></span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j)&#123;</span><br><span class="line">                <span class="comment">// 这里是上升子序列因此不能取=</span></span><br><span class="line">                <span class="keyword">if</span>(arr[j] &lt; arr[i])&#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后需要遍历一次找到最大值（最后一个不一定是最大的，最后一个只是以最后一个数为尾的最长上升字序列）</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(dp).max().getAsInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM72-连续子数组的最大和"><a href="#BM72-连续子数组的最大和" class="headerlink" title="BM72 连续子数组的最大和"></a>BM72 <a href="https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">连续子数组的最大和</a></h2><h3 id="题目描述-70"><a href="#题目描述-70" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个长度为n的整型数组array，数组中的一个或连续多个整数组成一个子数组，子数组最小长度为1。求所有子数组的和的最大值。 </p><p>数据范围: </p><p>1&lt;=n&lt;=2×10^5</p><p>−100&lt;=a[i]&lt;=100</p><p>要求:时间复杂度为 O(n)，空间复杂度为 O(n)</p><p>进阶:时间复杂度为 O(n)，空间复杂度为 O(1)</p><h3 id="题解-80"><a href="#题解-80" class="headerlink" title="题解"></a>题解</h3><p>用dp[i]表示以i结尾的子数组的和，那么若是这个数大于0，那么放入就完全没有影响，直接增大即可，若是这个数是负数就需要考虑，若是当前的数字大于以第i - 1个数字结尾的子数组的和，那么这个就能放入。</p><h3 id="Java代码实现-79"><a href="#Java代码实现-79" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = array.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 以第0个字符结尾的子数组不存在，值为0</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">1</span>] + array[i - <span class="number">1</span>], array[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            max = Math.max(max, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM73-最长回文子串"><a href="#BM73-最长回文子串" class="headerlink" title="BM73 最长回文子串"></a>BM73 <a href="https://www.nowcoder.com/practice/b4525d1d84934cf280439aeecc36f4af?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">最长回文子串</a></h2><h3 id="题目描述-71"><a href="#题目描述-71" class="headerlink" title="题目描述"></a>题目描述</h3><p>对于长度为n的一个字符串A（仅包含数字，大小写英文字母），请设计一个高效算法，计算其中最长回文子串的长度。 </p><p>数据范围： 1≤n≤1000</p><p>要求：空间复杂度 O(1)，时间复杂度 O(n^2)</p><p>进阶: 空间复杂度 O(n)，时间复杂度 O(n)</p><h3 id="题解-81"><a href="#题解-81" class="headerlink" title="题解"></a>题解</h3><p>首先是暴力解法，两个循环判断从i到j的子串是否是回文子串，若是返回其长度，同时更新最长回文子串长度，若不是则返回1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> A string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLongestPalindrome</span> <span class="params">(String A)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> n = A.length();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j)&#123;</span><br><span class="line">                String cur = A.substring(i, j);</span><br><span class="line">                <span class="keyword">if</span>(isPalSubString(cur))&#123;</span><br><span class="line">                    max = Math.max(max, cur.length());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalSubString</span><span class="params">(String cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] str = cur.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> n = str.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] != str[n - i - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但此时时间复杂度过高，考虑题目中要求的时间复杂度O(n^2)或是O(n)。</p><h3 id="题解-82"><a href="#题解-82" class="headerlink" title="题解"></a>题解</h3><p>若是已知子串(i, j)不为回文串，那么即使str[i - 1] == str[j + 1]也构不成回文串，同时若是str[i - 1] != str[j + 1]，那么必然构成不了回文串。，由此可以将其转化为动态规划。</p><h3 id="Java代码实现-80"><a href="#Java代码实现-80" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> A string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLongestPalindrome</span> <span class="params">(String A)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> n = A.length();</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 保存最大长度</span></span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="comment">// 保存从i到j的子串能否构成回文串</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">        <span class="keyword">char</span>[] str = A.toCharArray();</span><br><span class="line">        <span class="comment">// 这里为啥先right后left呢，因为left需要由right约束</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> right = <span class="number">1</span>; right &lt; n; ++right)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> left = <span class="number">0</span>; left &lt;= right; ++left)&#123;</span><br><span class="line">                <span class="comment">// 此时两者无法构成回文串</span></span><br><span class="line">                <span class="keyword">if</span>(str[left] != str[right])&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 此时两者有可能能构成回文串</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 子串长度(right - left + 1)小于4，"a", "aa", "aba"，必是回文串</span></span><br><span class="line">                <span class="keyword">if</span>(right - left &lt; <span class="number">3</span>)&#123;</span><br><span class="line">                    dp[left][right] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 此时子串长度大于三，那么就看前面的是否是回文串</span></span><br><span class="line">                    dp[left][right] = dp[left + <span class="number">1</span>][right - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> len = right - left + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 若是构成了回文子串则判断是否更新长度</span></span><br><span class="line">                <span class="keyword">if</span>(dp[left][right] &amp;&amp; len &gt; max)&#123;</span><br><span class="line">                    max = len;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>两个for循环中先right再left的原因是保证更新dp[left] [right]时用到的dp[left + 1] [right - 1]在之前已经求出。先循环left的话其实left + 1是全部项都没有求出的，但是先right那么right - 1的全部项都已经被求出了</strong></p><h3 id="题解-83"><a href="#题解-83" class="headerlink" title="题解"></a>题解</h3><p>可以采用中心扩散的方法，对于任意一个点，使用两个指针向其两边扩散，若是两个指针所指的值相同就继续扩散直到到达了数组的一端或者是两个指针的数值不同了，输出此时的长度判断是否需要更新最大长度即可，这里存在一个问题就是若是以当前数值和其后一个数字共同作为子串的中心（后一个数值与当前的相等），那么就以两个为中心再次判断最长回文串一次，最终输出两种不同方式所得的回文串长度，取其大值即可。</p><h3 id="Java代码实现-81"><a href="#Java代码实现-81" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> A string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLongestPalindrome</span> <span class="params">(String A)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> n = A.length();</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] str = A.toCharArray();</span><br><span class="line">        <span class="comment">// 保存最大长度</span></span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="comment">// 以当前元素为中心的回文串长度</span></span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 此时才需要判断是否和后一个是回文串(最后一个元素没有后一个元素)</span></span><br><span class="line">            <span class="keyword">if</span>(i &lt; n - <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 若是此字符和后一个字符相等</span></span><br><span class="line">                <span class="keyword">if</span>(str[i] == str[i + <span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="comment">// 计算出奇数串的长度</span></span><br><span class="line">                    <span class="keyword">int</span> len1 = cal(str, i, i);</span><br><span class="line">                    <span class="comment">// 计算出偶数串的长度</span></span><br><span class="line">                    <span class="keyword">int</span> len2 = cal(str, i, i + <span class="number">1</span>);</span><br><span class="line">                    len = len1 &gt; len2 ? len1 : len2;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 若是不等</span></span><br><span class="line">                    len = cal(str, i, i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这里为啥没有else呢，因为此时只有最后一个字符了，那么其回文串长度只可能是1（初始值）</span></span><br><span class="line">            <span class="keyword">if</span>(len &gt; max)&#123;</span><br><span class="line">                max = len;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算以left right为中心的回文串长度</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt; str.length)&#123;</span><br><span class="line">            <span class="comment">// 相等了继续判断</span></span><br><span class="line">            <span class="keyword">if</span>(str[left] == str[right])&#123;</span><br><span class="line">                ++right;</span><br><span class="line">                --left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 否则就退出循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时leftright已经不相等了，那么left + 1和right - 1才相等</span></span><br><span class="line">        <span class="comment">// 长度是(right - 1) - (left + 1) + 1</span></span><br><span class="line">        <span class="keyword">return</span> right - left - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM74-数字字符串转化成IP地址"><a href="#BM74-数字字符串转化成IP地址" class="headerlink" title="BM74 数字字符串转化成IP地址"></a>BM74 <a href="https://www.nowcoder.com/practice/ce73540d47374dbe85b3125f57727e1e?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">数字字符串转化成IP地址</a></h2><h3 id="题目描述-72"><a href="#题目描述-72" class="headerlink" title="题目描述"></a>题目描述</h3><p>现在有一个只包含数字的字符串，将该字符串转化成IP地址的形式，返回所有可能的情况。</p><p>例如：</p><p>给出的字符串为”25525522135”,</p><p>返回[“255.255.22.135”, “255.255.221.35”]. (顺序没有关系)</p><p>数据范围：字符串长度 0≤n≤12</p><p>要求：空间复杂度 O(n!),时间复杂度 O(n!)</p><p>注意：ip地址是由四段数字组成的数字序列，格式如 “x.x.x.x”，其中 x 的范围应当是 [0,255]。</p><h3 id="题解-84"><a href="#题解-84" class="headerlink" title="题解"></a>题解</h3><p>实际上就是一个排列问题，给出的n个字符，求将n个字符分成四组数据的排列数，前提是每个组中的数据都要在[0, 255]，若是其中有任何一个数据不满足则直接剪枝退出。</p><p>直接回溯，若是此时还可插入点的个数为0（没有0可以插入了），那么就开始合法性判断，若是还有0可以插入，就继续插入后分析，小数点可以插入的位置是后面一位，后面两位后面三位，由此继续递归。</p><h3 id="Java代码实现-82"><a href="#Java代码实现-82" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串ArrayList</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">restoreIpAddresses</span> <span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 用于存放最终的返回结果</span></span><br><span class="line">        ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(s.equals(<span class="string">""</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        backTrace(res, s, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// res存储最终结果</span></span><br><span class="line">    <span class="comment">// s是字符串</span></span><br><span class="line">    <span class="comment">// sb是之前构造的字符串</span></span><br><span class="line">    <span class="comment">// startIndex是本次可以插入点的位置</span></span><br><span class="line">    <span class="comment">// canAdd是还可以加多少个小数点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backTrace</span><span class="params">(ArrayList&lt;String&gt; res, String s, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> canAdd)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 递归退出条件，没有点可以添加了</span></span><br><span class="line">        <span class="keyword">if</span>(canAdd == <span class="number">0</span>)&#123;</span><br><span class="line">            String[] strs = s.split(<span class="string">"\\."</span>);</span><br><span class="line">            <span class="comment">// 不正确的插入</span></span><br><span class="line">            <span class="keyword">if</span>(strs.length != <span class="number">4</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 此时插入倒是正确了，需要判断值是否正确</span></span><br><span class="line">            <span class="keyword">for</span>(String str : strs)&#123;</span><br><span class="line">                <span class="comment">// 大于255或是有前导0且此时不为0直接排除</span></span><br><span class="line">                <span class="keyword">if</span>(Integer.valueOf(str) &gt; <span class="number">255</span> || str.length() &gt; <span class="number">1</span> &amp;&amp; str.charAt(<span class="number">0</span>) == <span class="string">'0'</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 执行到这里说明正确，可以添加到解集中</span></span><br><span class="line">            res.add(s.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="comment">// 此时还有剩余的小数点可以添加，直接递归添加即可(添加在starIndex后一位，后两位和后三位的地方)</span></span><br><span class="line">        <span class="comment">// 多了个点要考虑，所有后面的startIndex需要多加1</span></span><br><span class="line">        <span class="keyword">if</span>(startIndex &lt; n - <span class="number">1</span>)</span><br><span class="line">            backTrace(res, s.substring(<span class="number">0</span>, startIndex + <span class="number">1</span>) + <span class="string">"."</span> + s.substring(startIndex + <span class="number">1</span>, s.length()), startIndex + <span class="number">2</span>, canAdd - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(startIndex &lt; n - <span class="number">2</span>)</span><br><span class="line">            backTrace(res, s.substring(<span class="number">0</span>, startIndex + <span class="number">2</span>) + <span class="string">"."</span> + s.substring(startIndex + <span class="number">2</span>, s.length()), startIndex + <span class="number">3</span>, canAdd - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(startIndex &lt; n - <span class="number">3</span>)</span><br><span class="line">            backTrace(res, s.substring(<span class="number">0</span>, startIndex + <span class="number">3</span>) + <span class="string">"."</span> + s.substring(startIndex + <span class="number">3</span>, s.length()), startIndex + <span class="number">4</span>, canAdd - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM75-编辑距离（一）"><a href="#BM75-编辑距离（一）" class="headerlink" title="BM75 编辑距离（一）"></a>BM75 <a href="https://www.nowcoder.com/practice/6a1483b5be1547b1acd7940f867be0da?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">编辑距离（一）</a></h2><h3 id="题目描述-73"><a href="#题目描述-73" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定两个字符串 str1 和 str2 ，请你算出将 str1 转为 str2 的最少操作数。 </p><p>你可以对字符串进行3种操作： </p><p>1.插入一个字符 </p><p>2.删除一个字符 </p><p>3.修改一个字符。 </p><p>字符串长度满足 1≤n≤1000，保证字符串中只出现小写英文字母。</p><h3 id="题解-85"><a href="#题解-85" class="headerlink" title="题解"></a>题解</h3><p>首先，dp[i] [j]表示str1的第i位变化到str2的第j位所进行的操作数，那么当str1[i] == str2[j]时，dp[i] [j] = dp[i - 1] [j - 1]，若是str1的第i位和str2的第j位不等，那么如何才能将其化等呢，存在三种操作，添加，那么就是考虑在str1[i]后面加一位和str2[j]相同的字符（即添加之前str1[i] 已经和str2[j - 1]匹配了），那么此时dp[i] [j] = dp[i] [j - 1] + 1，修改，那么将当前str1[i]的值变为str2[j]，此时dp[i] [j] = dp[ i - 1] [j - 1] + 1，删除，那么此时将str1[i]删除（即删除之前str[i - 1]已经和str[j]匹配了），此时dp[i] [j] = dp[i - 1] [j] + 1，其中每个转移方程中的+1都指代增删改操作。</p><h3 id="Java代码实现-83"><a href="#Java代码实现-83" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str1 string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str2 string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">editDistance</span> <span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">char</span>[] chars1 = str1.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] chars2 = str2.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> n1 = chars1.length;</span><br><span class="line">        <span class="keyword">int</span> n2 = chars2.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n1 + <span class="number">1</span>][n2 + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 记得数组需要初始化</span></span><br><span class="line">        <span class="comment">// dp[i][0]和dp[0][j]分别表示一个是空串</span></span><br><span class="line">        <span class="comment">// 另一个是有非空串时需要的更改次数</span></span><br><span class="line">        <span class="comment">// 第一个字符串有i个字符，str1需要全部删除</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; ++i)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第二个字符串有i个字符，str1需要全部添加</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n2; ++i)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开始填充dp表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n2; ++j)&#123;</span><br><span class="line">                <span class="comment">// 相等直接不需要操作</span></span><br><span class="line">                <span class="keyword">if</span>(chars1[i - <span class="number">1</span>] == chars2[j - <span class="number">1</span>])&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 不相等返回增删改中最小的消耗并加上这次的消耗</span></span><br><span class="line">                    dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], Math.min(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j])) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM76-正则表达式匹配"><a href="#BM76-正则表达式匹配" class="headerlink" title="BM76 正则表达式匹配"></a>BM76 <a href="https://www.nowcoder.com/practice/28970c15befb4ff3a264189087b99ad4?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">正则表达式匹配</a></h2><h3 id="题目描述-74"><a href="#题目描述-74" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数用来匹配包括’.’和’*’的正则表达式。 </p><p>1.模式中的字符’.’表示任意一个字符 </p><p>2.模式中的字符’*’表示它前面的字符可以出现任意次（包含0次）。 </p><p>在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但是与”aa.a”和”ab*a”均不匹配 </p><p>数据范围: </p><ol><li><p>str 只包含从 a-z 的小写字母。</p></li><li><p>pattern 只包含从 a-z 的小写字母以及字符 . 和 * ，无连续的 ‘*’。</p></li><li><p>0≤str.length≤26</p></li><li><p>0≤pattern.length≤26</p></li></ol><h3 id="题解-86"><a href="#题解-86" class="headerlink" title="题解"></a>题解</h3><p>首先利用dp[i] [j]表示字符串str前i个字符和正则表达式前j个字符匹配的情况，那么当str[i]==pattern[j]相同时或者说当前j为’.’时，dp[i] [j] = dp[i - 1] [j - 1]，若是当前j为’*’，注意其前面的字符只有一个和 * 连接后匹配，那么此时存在两种情况，一是这个模式匹配完之后直接丢弃，那么实际上就是假设其出现了0次，此时dp[i] [j] = dp[i] [j - 2]，若是继续使用的话就往前进行匹配，即dp[i] [j] = dp[i - 1] [j]，当然这个操作的前提是必须能够匹配上一次（str[i]和pattern[j - 1]匹配）。</p><p>这里比较特殊的就是遇到’ * ‘的情况，此时需要和前面的一起进行考虑，而且会考虑匹配零次或多次的问题，那么当匹配零次时，就相当于将这两个丢弃再匹配，就是dp[i] [j - 2]，若是匹配一次或多次，那么前提是本次能匹配，之后就是考虑和后一个位置进行匹配，即dp[i] [j] = dp[i - 1] [j]，别的普通字符直接匹配，点直接算匹配成功。</p><h3 id="Java代码实现-84"><a href="#Java代码实现-84" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pattern string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span> <span class="params">(String str, String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> n1 = str.length();</span><br><span class="line">        <span class="keyword">int</span> n2 = pattern.length();</span><br><span class="line">        <span class="comment">// 可以在两者之前都加入空格来使dp[0][0]为true且得到以下标1开始的字符数组</span></span><br><span class="line">        <span class="comment">// 和三叶大神学的</span></span><br><span class="line">        str = <span class="string">" "</span> + str;</span><br><span class="line">        pattern = <span class="string">" "</span> + pattern;</span><br><span class="line">        <span class="keyword">char</span>[] strs = str.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] patterns = pattern.toCharArray();</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n1 + <span class="number">1</span>][n2 + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n1; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n2; ++j)&#123;</span><br><span class="line">                <span class="comment">// 如果下一个字符是*，则此字符不能单独匹配，跳过</span></span><br><span class="line">                <span class="keyword">if</span>(j + <span class="number">1</span> &lt;= n2 &amp;&amp; patterns[j + <span class="number">1</span>] == <span class="string">'*'</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 否则就开始匹配</span></span><br><span class="line">                <span class="comment">// 考虑不是*的情况（大于等于1才有下一位）</span></span><br><span class="line">                <span class="keyword">if</span>(i &gt;= <span class="number">1</span> &amp;&amp; patterns[j] != <span class="string">'*'</span>)&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; (strs[i] == patterns[j] || patterns[j] == <span class="string">'.'</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(patterns[j] == <span class="string">'*'</span>)&#123;</span><br><span class="line">                    <span class="comment">// 题目说了*不在开头</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// j &gt; 2这串表示匹配0次</span></span><br><span class="line">                    <span class="comment">// j &gt; 1这串表示匹配一次（前提是能匹配）</span></span><br><span class="line">                    dp[i][j] = (dp[i][j - <span class="number">2</span>] &amp;&amp; j &gt;= <span class="number">2</span>) || (i &gt;= <span class="number">1</span> &amp;&amp; dp[i - <span class="number">1</span>][j] &amp;&amp; (strs[i] == patterns[j - <span class="number">1</span>] || patterns[j - <span class="number">1</span>] == <span class="string">'.'</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM77-最长的括号子串"><a href="#BM77-最长的括号子串" class="headerlink" title="BM77 最长的括号子串"></a>BM77 <a href="https://www.nowcoder.com/practice/45fd68024a4c4e97a8d6c45fc61dc6ad?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">最长的括号子串</a></h2><h3 id="题目描述-75"><a href="#题目描述-75" class="headerlink" title="题目描述"></a>题目描述</h3><p>给出一个长度为 n 的，仅包含字符 ‘(‘ 和 ‘)’ 的字符串，计算最长的格式正确的括号子串的长度。 </p><p>例1: 对于字符串 “(()” 来说，最长的格式正确的子串是 “()” ，长度为 2 .</p><p>例2：对于字符串 “)()())” , 来说, 最长的格式正确的子串是 “()()” ，长度为 4 .</p><p>字符串长度：0≤n≤5∗105</p><p>要求时间复杂度 O(n),空间复杂度 O(n).</p><h3 id="题解-87"><a href="#题解-87" class="headerlink" title="题解"></a>题解</h3><p>使用dp[i]表示前i个字符中以第i个字符结尾的括号子串的长度，对于任意位置，若是该位置为左括号，那么dp[i]=0，因为合法字符不可能以左括号结尾，对于右括号，若是其前一位字符是左括号，那么当前已经多了一对已经匹配的括号，即dp[i] = dp[i - 2] + 2；若是其前一位字符是右括号，那么需要找到以前一个字符为尾的合法字符串之前的那个位置是否是左括号，而当前位置为i，那么以前一个字符为尾的合法字符串之前的那个位置就是i - dp[i - 1] - 1，其中dp[i - 1]表示前面有多少个字符是匹配的，需要全部排除</p><h3 id="Java代码实现-85"><a href="#Java代码实现-85" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span> <span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 长度小于2肯定没有</span></span><br><span class="line">        <span class="keyword">if</span>(s.length() &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> n = str.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="comment">// 第一个字符无论是左括号还是右括号都不会有有效的括号子串</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 最长子串长度</span></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="comment">// 注意这里i是从1开始的，因此dp[i - 1]和str[i - 1]肯定存在</span></span><br><span class="line">            <span class="comment">// 只有右括号时才考虑</span></span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">')'</span>)&#123;</span><br><span class="line">                <span class="comment">// 若是前一位是左括号，那么直接匹配成功一对</span></span><br><span class="line">                <span class="keyword">if</span>(str[i - <span class="number">1</span>] == <span class="string">'('</span>)&#123;</span><br><span class="line">                    <span class="comment">// 只有i &gt; 1，从2开始时i - 2才有效</span></span><br><span class="line">                    dp[i] = (i &gt; <span class="number">1</span> ? dp[i - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 此时前面是右括号</span></span><br><span class="line">                    <span class="comment">// 找到前面的未匹配完的那个下标</span></span><br><span class="line">                    <span class="keyword">int</span> noMarry = i - dp[i - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// 若是此下标合法</span></span><br><span class="line">                    <span class="keyword">if</span>(noMarry &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="comment">// 如果是左括号那直接匹配上了</span></span><br><span class="line">                        <span class="keyword">if</span>(str[noMarry] == <span class="string">'('</span>)&#123;</span><br><span class="line">                            <span class="comment">// 三部分组成，现在从noMarry到i已全部匹配</span></span><br><span class="line">                            <span class="comment">// noMarry - 1是noMarray之前的</span></span><br><span class="line">                            <span class="comment">// dp[i - 1]是noMarry + 1到str[i - 1]之前的</span></span><br><span class="line">                            <span class="comment">// 还有就是现在noMarray和i新组成的括号数2</span></span><br><span class="line">                            dp[i] = (noMarry &gt; <span class="number">0</span> ? dp[noMarry - <span class="number">1</span>] : <span class="number">0</span>) + dp[i - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 否则就是没匹配上（naMarry - 1是右括号），此时为0</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 此时是下标不合法，也是0</span></span><br><span class="line">                &#125;</span><br><span class="line">                max = max &lt; dp[i] ? dp[i] : max;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM78-打家劫舍（一）"><a href="#BM78-打家劫舍（一）" class="headerlink" title="BM78 打家劫舍（一）"></a>BM78 <a href="https://www.nowcoder.com/practice/c5fbf7325fbd4c0ea3d0c3ea6bc6cc79?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">打家劫舍（一）</a></h2><h3 id="题目描述-76"><a href="#题目描述-76" class="headerlink" title="题目描述"></a>题目描述</h3><p>你是一个经验丰富的小偷，准备偷沿街的一排房间，每个房间都存有一定的现金，为了防止被发现，你不能偷相邻的两家，即，如果偷了第一家，就不能再偷第二家；如果偷了第二家，那么就不能偷第一家和第三家。 </p><p>给定一个整数数组nums，数组中的元素表示每个房间存有的现金数额，请你计算在不被发现的前提下最多的偷窃金额。</p><p>数据范围：数组长度满足 1≤n≤2×10^5，数组中每个值满足 1≤num[i]≤5000</p><h3 id="题解-88"><a href="#题解-88" class="headerlink" title="题解"></a>题解</h3><p>使用dp[i]表示前i家中能够偷取的最大金额，那么对于第i家，存在下列两种情况，一是不偷这一家，那么能获得的金额就是前i - 1家所能获取的最大金额，即此时dp[i] = dp[i - 1]，二是偷这一家，那么此时前一家就无法偷取，那么此时能获得的最大金额就是前i - 2家获得的最大金额加上这一家的最大金额，对于每间房间，分别使用两种操作判断，两者取最大值即可。</p><h3 id="Java代码实现-86"><a href="#Java代码实现-86" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span> <span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="comment">// dp[i]表示前i家（下标以1开始）所能获得的最大金额</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 第0家能获得0</span></span><br><span class="line">        <span class="comment">// 第一家能获得的就是他们家有的</span></span><br><span class="line">        dp[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM79-打家劫舍（二）"><a href="#BM79-打家劫舍（二）" class="headerlink" title="BM79 打家劫舍（二）"></a>BM79 <a href="https://www.nowcoder.com/practice/a5c127769dd74a63ada7bff37d9c5815?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">打家劫舍（二）</a></h2><h3 id="题目描述-77"><a href="#题目描述-77" class="headerlink" title="题目描述"></a>题目描述</h3><p>你是一个经验丰富的小偷，准备偷沿湖的一排房间，每个房间都存有一定的现金，为了防止被发现，你不能偷相邻的两家，即，如果偷了第一家，就不能再偷第二家，如果偷了第二家，那么就不能偷第一家和第三家。沿湖的房间组成一个闭合的圆形，即第一个房间和最后一个房间视为相邻。 </p><p>给定一个长度为n的整数数组nums，数组中的元素表示每个房间存有的现金数额，请你计算在不被发现的前提下最多的偷窃金额。 </p><p>数据范围：数组长度满足 1≤n≤2×10^5，数组中每个值满足 1≤nums[i]≤5000</p><h3 id="题解-89"><a href="#题解-89" class="headerlink" title="题解"></a>题解</h3><p>这一题和<a href="https://www.nowcoder.com/practice/c5fbf7325fbd4c0ea3d0c3ea6bc6cc79?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">上一题</a>相比需要多考虑的一点是房间围成了一个圆形，那么偷了第一家就不能偷最后一家，可以分别考虑偷不偷第一家，若是偷的话，那么将最后一家排除得到最值，若是不偷的话那么将第一家排除得到最值，两者取最大值即可。</p><h3 id="Java代码实现-87"><a href="#Java代码实现-87" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span> <span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="comment">// 表示偷第一家能获得的最大金额</span></span><br><span class="line">        <span class="keyword">int</span>[] stole1 = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        stole1[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 表示不偷第一家能获得的最大金额</span></span><br><span class="line">        <span class="keyword">int</span>[] noStole1 = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        noStole1[<span class="number">1</span>] = nums[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 这个和原来一样，不过只考虑前n - 1间房</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            stole1[i] = Math.max(stole1[i - <span class="number">1</span>], stole1[i - <span class="number">2</span>] + nums[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里从第2间房开始考虑，不偷就是noStole1[i - 1]，偷就是noStole1[i - 2] + nums[i]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            noStole1[i] = Math.max(noStole1[i - <span class="number">1</span>], noStole1[i - <span class="number">2</span>] + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 然后二者返回最大值即可。</span></span><br><span class="line">        <span class="keyword">return</span> stole1[n - <span class="number">1</span>] &gt; noStole1[n - <span class="number">1</span>] ? stole1[n - <span class="number">1</span>] : noStole1[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM80-买卖股票的最好时机（一）"><a href="#BM80-买卖股票的最好时机（一）" class="headerlink" title="BM80 买卖股票的最好时机（一）"></a>BM80 <a href="https://www.nowcoder.com/practice/64b4262d4e6d4f6181cd45446a5821ec?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">买卖股票的最好时机（一）</a></h2><h3 id="题目描述-78"><a href="#题目描述-78" class="headerlink" title="题目描述"></a>题目描述</h3><p>假设你有一个数组prices，长度为n，其中prices[i]是股票在第i天的价格，请根据这个价格数组，返回买卖股票能获得的最大收益 </p><p>1.你可以买入一次股票和卖出一次股票，并非每天都可以买入或卖出一次，总共只能买入和卖出一次，且买入必须在卖出的前面的某一天 </p><p>2.如果不能获取到任何利润，请返回0 </p><p>3.假设买入卖出均无手续费</p><p>数据范围： 0≤n≤10^5,0≤val≤10^4</p><p>要求：空间复杂度 O(1)，时间复杂度 O(n)</p><h3 id="题解-90"><a href="#题解-90" class="headerlink" title="题解"></a>题解</h3><p>最简单的解法，两个for循环遍历完买入和卖出的利润取最大值。</p><p>其次就是贪心的思想，若是想取得最大利润，那么就在价格最低的时候买入，价格最高的时候卖出，那么遍历数组，维护一个变量表示最大收益和最低价格，每次用今天的价格减去之前的最低价得到今日卖出可得的最大收益，不断更新变量即可。</p><h3 id="Java代码实现-88"><a href="#Java代码实现-88" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> prices int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span> <span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 存储前i天的最低价</span></span><br><span class="line">        <span class="keyword">int</span> minPrice = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 存储最大收益</span></span><br><span class="line">        <span class="keyword">int</span> maxPro = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            dp[i] = prices[i] - minPrice;</span><br><span class="line">            <span class="keyword">if</span>(maxPro &lt; dp[i])&#123;</span><br><span class="line">                maxPro = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &lt; minPrice)&#123;</span><br><span class="line">                minPrice = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxPro;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题解-91"><a href="#题解-91" class="headerlink" title="题解"></a>题解</h3><p>考虑使用二维数组dp[i] [j]表示第i天持有股票状态为j时所能够获得的最大收入，其中j只有两个取值，0表示第j天未持有股票（自然也无法卖出），1表示第j天持有股票，两者取最大值即可。若是未持有股票，那么dp[i] [0] = max(dp[i - 1] [0], dp[i - 1] [1] + price[i])，其中dp[i - 1] [0]表示第i - 1天就未持有股票，不进行任何操作，dp[i - 1] [1] + price[i]则是表示第i - 1天持有了股票但是第i天卖出，若是持有股票，那么dp[i] [1] = max(dp[i- 1] [1], -prices[i])，其中dp[i - 1] [1]表示第i - 1天持有股票且不进行任何操作，- price[i]则表示在第i天买入 (因为只能买卖一次，那么只能这次买入)。</p><h3 id="Java代码实现-89"><a href="#Java代码实现-89" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> prices int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span> <span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 第一天未持有股票收益为0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 第一天持有股票收益为负（今天卖不了，只能买入）</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="comment">// 第i天未持有股票就取第i - 1天未持有股票的收益以及第i - 1持有股票但在第i天卖出的收益</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            <span class="comment">// 第i天持有股票就取第i - 1天持有股票的收益以及第i天买出的收益</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], -prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 贪心可知最后一天不持有股票收益高</span></span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM81-买卖股票的最好时机（二）"><a href="#BM81-买卖股票的最好时机（二）" class="headerlink" title="BM81 买卖股票的最好时机（二）"></a>BM81 <a href="https://www.nowcoder.com/practice/9e5e3c2603064829b0a0bbfca10594e9?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">买卖股票的最好时机（二）</a></h2><h3 id="题目描述-79"><a href="#题目描述-79" class="headerlink" title="题目描述"></a>题目描述</h3><p>假设你有一个数组prices，长度为n，其中prices[i]是某只股票在第i天的价格，请根据这个价格数组，返回买卖股票能获得的最大收益 </p><ol><li><p>你可以多次买卖该只股票，但是再次购买前必须卖出之前的股票 </p></li><li><p>如果不能获取收益，请返回0 </p></li><li><p>假设买入卖出均无手续费 </p></li></ol><p>数据范围： 1≤n≤1×1^5， 1≤prices[i]≤10^4</p><p>要求：空间复杂度 O(n)，时间复杂度 O(n)</p><p>进阶：空间复杂度 O(1)，时间复杂度 O(n)</p><h3 id="题解-92"><a href="#题解-92" class="headerlink" title="题解"></a>题解</h3><p>这题与上一题的不同之处在于这题能对股票多次买入，因此考虑动态规划的状态转移方程的变化。</p><p>依旧考虑使用二维数组dp[i] [j]表示第i天持有股票状态为j时所能够获得的最大收入，其中j只有两个取值，0表示第j天未持有股票（自然也无法卖出），1表示第j天持有股票，两者取最大值即可。若是未持有股票，那么dp[i] [0] = max(dp[i - 1] [0], dp[i - 1] [1] + price[i])，其中dp[i - 1] [0]表示第i - 1天就未持有股票，不进行任何操作，dp[i - 1] [1] + price[i]则是表示第i - 1天持有了股票但是第i天卖出，若是持有股票，那么dp[i] [1] = max(dp[i- 1] [1], dp[i - 1] [0] - prices[i])，其中dp[i - 1] [1]表示第i - 1天持有股票且不进行任何操作，dp[i - 1] [0] - prices[i]则表示在第i - 1天未持有股票而在第i天买入，最终的收益肯定是不持有股票获得的收益较高。</p><h3 id="Java代码实现-90"><a href="#Java代码实现-90" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     * 计算最大收益</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> prices int整型一维数组 股票每一天的价格</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span> <span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 只有一天那么当天买当天卖，没有的话就直接0</span></span><br><span class="line">        <span class="keyword">if</span>(prices.length &lt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 不持有收益为0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 买入收益为负</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="comment">// 第i天不持有的收益就是第i - 1天也不持有的收益和在第i天卖出的收益的最大值</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            <span class="comment">// 第i天持有的收益就是第i - 1天也持有的收益和在第i天才买入的收益的最大值</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后肯定是最后一天不持有收益比较高</span></span><br><span class="line">        <span class="keyword">return</span> dp[n -<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题解-93"><a href="#题解-93" class="headerlink" title="题解"></a>题解</h3><p>这里也可以使用贪心，主要思想是，只要有收益了就获得（若是此次价格高于上一次价格，那么此次将股票卖出，若是下一次比这次高那么再买入这次的股票即可，因此收益就是所有次交易的收益之和）。</p><h3 id="Java代码实现-91"><a href="#Java代码实现-91" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     * 计算最大收益</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> prices int整型一维数组 股票每一天的价格</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span> <span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="comment">// 只有一天那么当天买当天卖，没有的话就直接0</span></span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 保存全部收益</span></span><br><span class="line">        <span class="keyword">int</span> profile = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="comment">// 只要有收益就进行交易</span></span><br><span class="line">            <span class="keyword">if</span>(prices[i] &gt; prices[i - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="comment">// 加上这次交易获得的利润</span></span><br><span class="line">                profile += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profile;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM82-买卖股票的最好时机（三）"><a href="#BM82-买卖股票的最好时机（三）" class="headerlink" title="BM82 买卖股票的最好时机（三）"></a>BM82 <a href="https://www.nowcoder.com/practice/4892d3ff304a4880b7a89ba01f48daf9?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">买卖股票的最好时机（三）</a></h2><h3 id="题目描述-80"><a href="#题目描述-80" class="headerlink" title="题目描述"></a>题目描述</h3><p>假设你有一个数组prices，长度为n，其中prices[i]是某只股票在第i天的价格，请根据这个价格数组，返回买卖股票能获得的最大收益</p><ol><li>你最多可以对该股票有两笔交易操作，一笔交易代表着一次买入与一次卖出，但是再次购买前必须卖出之前的股票</li><li>如果不能获取收益，请返回0</li><li>假设买入卖出均无手续费</li></ol><p>数据范围：1≤n≤10^5，股票的价格满足 1≤val≤10^4</p><p>要求: 空间复杂度 O(n)，时间复杂度 O(n)</p><p>进阶：空间复杂度 O(1)，时间复杂度 O(n)</p><h3 id="题解-94"><a href="#题解-94" class="headerlink" title="题解"></a>题解</h3><p>这里的不同之处在于每次只能对股票有最多两笔交易，那么一共有如下状态:</p><ul><li>此时未交易过且受伤没有股票</li><li>此时只进行了一次买入操作</li><li>此时进行了一次交易后手上没有股票</li><li>此时进行了一次交易之外手上还有股票</li><li>此时进行了两次交易且手上没有股票</li></ul><p>考虑以上状态分别用0 - 4表示，那么dp[i] [0] 永远是0；dp[i] [1] = max(dp[i - 1] [1], - price[i])，dp[i - 1] [1]表示今天不进行操作，- price[i]，表示买入今天的股票；dp[i] [2] = max(dp[i - 1] [2], dp[i - 1] [1] + price[i])，dp[i - 1] [2]表示今天不进行操作，dp[i - 1] [1] + price[i]表示昨天持有股票，今天卖出；dp[i] [3] = max(dp[i - 1] [3], dp[i - 1] [2] - price[i])，dp[i - 1] [3]表示今天不进行操作，dp[i - 1] [2] - price[i]，表示买入今天的股票；dp[i] [4] = max(dp[i - 1] [4], dp[i -1] [3] + price[i - 1] [3] + price[i] )，dp[i - 1] [4]表示今天不进行操作，dp[i - 1] [3]表示卖出了股票，最后记得保存过程中的最大值。</p><h3 id="Java代码实现-92"><a href="#Java代码实现-92" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     * 两次交易所能获得的最大收益</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> prices int整型一维数组 股票每一天的价格</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span> <span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> profile = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">5</span>];</span><br><span class="line">        <span class="comment">// 这天买入的收益是-price[0]</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 这天也可以又买又卖再卖，收益也是-price[0]</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">3</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], -prices[i]);</span><br><span class="line">            dp[i][<span class="number">2</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">2</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            profile = Math.max(profile, dp[i][<span class="number">2</span>]);</span><br><span class="line">            dp[i][<span class="number">3</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">3</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">4</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">4</span>], dp[i - <span class="number">1</span>][<span class="number">3</span>] + prices[i]);</span><br><span class="line">            profile = Math.max(profile, dp[i][<span class="number">4</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profile;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="BM83-字符串变形"><a href="#BM83-字符串变形" class="headerlink" title="BM83 字符串变形"></a>BM83 <a href="https://www.nowcoder.com/practice/c3120c1c1bc44ad986259c0cf0f0b80e?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">字符串变形</a></h2><h3 id="题目描述-81"><a href="#题目描述-81" class="headerlink" title="题目描述"></a>题目描述</h3><p>对于一个长度为 n 字符串，我们需要对它做一些变形。 </p><p>首先这个字符串中包含着一些空格，就像”Hello World”一样，然后我们要做的是把这个字符串中由空格隔开的单词反序，同时反转每个字符的大小写。 </p><p>比如”Hello World”变形后就变成了”wORLD hELLO”。 </p><p>数据范围: 1≤n≤1061≤<em>n</em>≤106 , 字符串中包括大写英文字母、小写英文字母、空格。</p><p>进阶：空间复杂度 O(n)， 时间复杂度 O(n)</p><h4 id="输入描述：-4"><a href="#输入描述：-4" class="headerlink" title="输入描述："></a>输入描述：</h4><p>给定一个字符串s以及它的长度n(1 ≤ n ≤ 10^6)</p><h4 id="返回值描述：-4"><a href="#返回值描述：-4" class="headerlink" title="返回值描述："></a>返回值描述：</h4><p>请返回变形后的字符串。题目保证给定的字符串均由大小写字母和空格构成。</p><h3 id="题解-95"><a href="#题解-95" class="headerlink" title="题解"></a>题解</h3><p>先通过空格对字符串进行拆分，之后对每个字符串倒叙并改变大小写即可。</p><h3 id="Java代码实现-93"><a href="#Java代码实现-93" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">trans</span><span class="params">(String s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">// 这里必须要使用这个-1，否则最后一个字符为空的时候无法得到正确结果</span></span><br><span class="line">        <span class="comment">// 如用例"h i ",4</span></span><br><span class="line">        String[] ss = s.split(<span class="string">" "</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = ss.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            sb.append(reverseAndChange(ss[i]));</span><br><span class="line">            <span class="comment">// 只添n - 1个空格，最后一个不加空格，直接退出</span></span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">reverseAndChange</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Character.isLowerCase(str[i]))&#123;</span><br><span class="line">                sb.append(Character.toUpperCase(str[i]));</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(Character.isUpperCase(str[i]))&#123;</span><br><span class="line">                sb.append(Character.toLowerCase(str[i]));</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM84-最长公共前缀"><a href="#BM84-最长公共前缀" class="headerlink" title="BM84 最长公共前缀"></a>BM84 <a href="https://www.nowcoder.com/practice/28eb3175488f4434a4a6207f6f484f47?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">最长公共前缀</a></h2><h3 id="题目描述-82"><a href="#题目描述-82" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个大小为 n 的字符串数组 strs ，其中包含n个字符串 , 编写一个函数来查找字符串数组中的最长公共前缀，返回这个公共前缀。 </p><p>数据范围： 0≤n≤5000， 0≤len(strsi)≤5000</p><p>进阶：空间复杂度 O(n)，时间复杂度 O(n)</p><h3 id="题解-96"><a href="#题解-96" class="headerlink" title="题解"></a>题解</h3><p>遍历这n个字符串，若是发现当前位置所有字符串都是相等的，那么将这个字符添加到公共前缀中并继续直到字符串的边界，否则退出并返回之前的最长公共前缀。</p><h3 id="Java代码实现-94"><a href="#Java代码实现-94" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> strs string字符串一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span> <span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> n = strs.length;</span><br><span class="line">        <span class="comment">// 数组为空返回空</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 数组中任意一个字符串为空返回空</span></span><br><span class="line">        <span class="keyword">for</span>(String str : strs)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.equals(<span class="string">""</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 这里必须确保还没过界</span></span><br><span class="line">            <span class="keyword">if</span>(index &gt;= strs[<span class="number">0</span>].length())&#123;</span><br><span class="line">                <span class="keyword">return</span> sb.toString();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> c = strs[<span class="number">0</span>].charAt(index);</span><br><span class="line">            <span class="keyword">for</span>(String str : strs)&#123;</span><br><span class="line">                <span class="comment">// 这里也要确保不过界</span></span><br><span class="line">                <span class="keyword">if</span>(index &gt;= str.length() || str.charAt(index) != c)&#123;</span><br><span class="line">                    <span class="keyword">return</span> sb.toString();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 每个都一样就添加进来</span></span><br><span class="line">            sb.append(c);</span><br><span class="line">            <span class="comment">// 同时索引后移一位</span></span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样写不美观，稍微优化一下，得到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> strs string字符串一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span> <span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> n = strs.length;</span><br><span class="line">        <span class="comment">// 数组为空返回空</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> m = strs[<span class="number">0</span>].length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = strs[<span class="number">0</span>].charAt(j);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= strs[i].length() || strs[i].charAt(j) != c)&#123;</span><br><span class="line">                    <span class="keyword">return</span> sb.toString();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM85-验证IP地址"><a href="#BM85-验证IP地址" class="headerlink" title="BM85 验证IP地址"></a>BM85 <a href="https://www.nowcoder.com/practice/55fb3c68d08d46119f76ae2df7566880?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">验证IP地址</a></h2><h3 id="题目描述-83"><a href="#题目描述-83" class="headerlink" title="题目描述"></a>题目描述</h3><p>编写一个函数来验证输入的字符串是否是有效的 IPv4 或 IPv6 地址</p><p>IPv4 地址由十进制数和点来表示，每个地址包含4个十进制数，其范围为 0 - 255， 用(“.”)分割。比如，172.16.254.1；<br>同时，IPv4 地址内的数不会以 0 开头。比如，地址 172.16.254.01 是不合法的。</p><p>IPv6 地址由8组16进制的数字来表示，每组表示 16 比特。这些组数字通过 (“:”)分割。比如, 2001:0db8:85a3:0000:0000:8a2e:0370:7334 是一个有效的地址。而且，我们可以加入一些以 0 开头的数字，字母可以使用大写，也可以是小写。所以， 2001:db8:85a3:0:0:8A2E:0370:7334 也是一个有效的 IPv6 address地址 (即，忽略 0 开头，忽略大小写)。</p><p>然而，我们不能因为某个组的值为 0，而使用一个空的组，以至于出现 (::) 的情况。 比如， 2001:0db8:85a3::8A2E:0370:7334 是无效的 IPv6 地址。<br>同时，在 IPv6 地址中，多余的 0 也是不被允许的。比如， 02001:0db8:85a3:0000:0000:8a2e:0370:7334 是无效的。</p><p>说明: 你可以认为给定的字符串里没有空格或者其他特殊字符。 </p><p>数据范围：字符串长度满足 5≤n≤50</p><p>进阶：空间复杂度 O(n)，时间复杂度 O(n)</p><h3 id="题解-97"><a href="#题解-97" class="headerlink" title="题解"></a>题解</h3><p>这题首先需要判断出改地址可能是IPv4地址或是IPv6地址，之后根据规则进行判断，若两者都不是，最终返回Neither。</p><p>这里我们假设其是IPv4地址，那么我们先用.将其分割，若是没有得到长度为4的数组，那么说明它是错误的，之后逐个进行解析，若是含有前导0那么其只能是0（长度为1），同时数据的范围是0-255，都满足说明是合法的IPv4地址。</p><p>若其不是IPv4地址，那么我们判断是否是IPv6地址，前用:分割，长度必须为8，其次对于任何字符串，长度必须小于等于8，若是含有前导0那么其只能是0（长度为1），同时对于每个字符串，不能出现比’f’还大的字母（十六进制中f最大），可以先将其全部转换为大写字母后比较，同时字符串不能为空。</p><h3 id="Java代码实现-95"><a href="#Java代码实现-95" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证IP地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> IP string字符串 一个IP地址字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">solve</span> <span class="params">(String IP)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 这里注意要使用 -1，否则最后的符号会判断错误</span></span><br><span class="line">        <span class="keyword">if</span>(IP.split(<span class="string">"\\."</span>, -<span class="number">1</span>).length == <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isValidIPv4(IP.split(<span class="string">"\\."</span>, -<span class="number">1</span>)))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"IPv4"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(IP.split(<span class="string">":"</span>, -<span class="number">1</span>).length == <span class="number">8</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isValidIPv6(IP.split(<span class="string">":"</span>, -<span class="number">1</span>)))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"IPv6"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Neither"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidIPv4</span><span class="params">(String[] ips)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 对于每个ip地址</span></span><br><span class="line">        <span class="keyword">for</span>(String ip : ips)&#123;</span><br><span class="line">            <span class="comment">// IPv4地址不能为空或是前导0</span></span><br><span class="line">            <span class="keyword">if</span>(ip.equals(<span class="string">""</span>) || ip.charAt(<span class="number">0</span>) == <span class="string">'0'</span> &amp;&amp; ip.length() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 每个字符必须都是数字</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> c : ip.toCharArray())&#123;</span><br><span class="line">                <span class="keyword">if</span>(!Character.isDigit(c))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 解析出的数字范围必须再0-255</span></span><br><span class="line">            <span class="keyword">int</span> num = Integer.parseInt(ip);</span><br><span class="line">            <span class="keyword">if</span>(num &gt; <span class="number">255</span> || num &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidIPv6</span><span class="params">(String[] ips)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(String ip : ips)&#123;</span><br><span class="line">            <span class="comment">// IPv6地址不能为空</span></span><br><span class="line">            <span class="keyword">if</span>(ip.equals(<span class="string">""</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 单独有0是可以的</span></span><br><span class="line">            <span class="keyword">if</span>(ip.charAt(<span class="number">0</span>) == <span class="string">'0'</span> &amp;&amp; ip.length() == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 不能有多余的0</span></span><br><span class="line">            <span class="keyword">if</span>(ip.charAt(<span class="number">0</span>) == <span class="string">'0'</span> &amp;&amp; ip.charAt(<span class="number">1</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 每个地址最多只能有4位</span></span><br><span class="line">            <span class="keyword">if</span>(ip.length() &gt; <span class="number">4</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将其全部转换为大写</span></span><br><span class="line">            String upper = ip.toUpperCase();</span><br><span class="line">            <span class="comment">// 十六进制数不能大于f</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> c : upper.toCharArray())&#123;</span><br><span class="line">                <span class="keyword">if</span>(c &gt; <span class="string">'F'</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看了题解后发现有一种比较<a href="https://blog.nowcoder.net/n/a0dd33afccf44555997621c4be25bd73" target="_blank" rel="noopener">优雅的做法</a>就是使用parseInt进行解析，若是捕获到异常则返回false，此外对于IPv6地址使用16进制进行解析。—&gt;   <strong>强推</strong></p><h2 id="BM86-大数加法"><a href="#BM86-大数加法" class="headerlink" title="BM86 大数加法"></a>BM86 <a href="https://www.nowcoder.com/practice/11ae12e8c6fe48f883cad618c2e81475?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">大数加法</a></h2><h3 id="题目描述-84"><a href="#题目描述-84" class="headerlink" title="题目描述"></a>题目描述</h3><p>以字符串的形式读入两个数字，编写一个函数计算它们的和，以字符串形式返回。 </p><p>数据范围：s.length,t.length≤10000，字符串仅由’0’~‘9’构成 </p><p>要求：时间复杂度 O(n)</p><h3 id="题解-98"><a href="#题解-98" class="headerlink" title="题解"></a>题解</h3><p>将所给的两个字符串反转，之后相加即可（注意进位的保存），最后将相加的结果反转后返回。</p><h3 id="Java代码实现-96"><a href="#Java代码实现-96" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     * 计算两个数之和</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s string字符串 表示第一个整数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t string字符串 表示第二个整数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">solve</span> <span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">// 反转两个字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : s.toCharArray())&#123;</span><br><span class="line">            sb.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] ss = sb.reverse().toString().toCharArray();</span><br><span class="line">        <span class="comment">// 记得每次操作之后将sb情况</span></span><br><span class="line">        sb.delete(<span class="number">0</span>, sb.length());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : t.toCharArray())&#123;</span><br><span class="line">            sb.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] ts = sb.reverse().toString().toCharArray();</span><br><span class="line">        <span class="comment">// 记得每次操作之后将sb情况</span></span><br><span class="line">        sb.delete(<span class="number">0</span>, sb.length());</span><br><span class="line">        <span class="keyword">int</span> n1 = ss.length;</span><br><span class="line">        <span class="keyword">int</span> n2 = ts.length;</span><br><span class="line">        <span class="keyword">int</span> maxLen = n1 &gt; n2 ? n1 : n2;</span><br><span class="line">        <span class="comment">// 进位</span></span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxLen; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> num1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> num2 = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 有的话就更改，没有就使用初始值0</span></span><br><span class="line">            <span class="keyword">if</span>(i &lt; n1)&#123;</span><br><span class="line">                num1 = ss[i] - <span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; n2)&#123;</span><br><span class="line">                num2 = ts[i] - <span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> sum = num1 + num2 + carry;</span><br><span class="line">            <span class="comment">// 将这一位添加</span></span><br><span class="line">            sb.append(sum % <span class="number">10</span>);</span><br><span class="line">            <span class="comment">// 更新进位</span></span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若是最后进位不为0（其实就是1），那么也要加入</span></span><br><span class="line">        <span class="keyword">if</span>(carry != <span class="number">0</span>)&#123;</span><br><span class="line">            sb.append(carry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><h2 id="BM87-合并两个有序的数组"><a href="#BM87-合并两个有序的数组" class="headerlink" title="BM87 合并两个有序的数组"></a>BM87 <a href="https://www.nowcoder.com/practice/89865d4375634fc484f3a24b7fe65665?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">合并两个有序的数组</a></h2><h3 id="题目描述-85"><a href="#题目描述-85" class="headerlink" title="题目描述"></a>题目描述</h3><p>给出一个有序的整数数组 A 和有序的整数数组 B ，请将数组 B 合并到数组 A 中，变成一个有序的升序数组 </p><p>数据范围： 0≤n,m≤100，∣Ai∣&lt;=100， ∣Bi∣&lt;=100</p><p>注意：</p><ol><li><p>保证 A 数组有足够的空间存放 B 数组的元素， A 和 B 中初始的元素数目分别为 m 和 n，A的数组空间大小为 m+n </p></li><li><p>不要返回合并的数组，将数组 B 的数据合并到 A 里面就好了，且后台会自动将合并后的数组 A 的内容打印出来，所以也不需要自己打印 </p></li><li><p>A 数组在[0,m-1]的范围也是有序的</p></li></ol><h3 id="题解-99"><a href="#题解-99" class="headerlink" title="题解"></a>题解</h3><p>这里题目要求将结果保存到数组A中，那么若是从前往后遍历，那么就不方便了，因此考虑从后往前遍历，使用两个指针cur1, cur2标识AB两个数组当前走到的位置，那么需要放到的位置就是A[cur1 + cur2 +1]，哪个大放哪个即可。</p><h3 id="Java代码实现-97"><a href="#Java代码实现-97" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> m, <span class="keyword">int</span> B[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cur1 = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cur2 = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = m + n -<span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="comment">// 给一个初值</span></span><br><span class="line">            <span class="keyword">int</span> num1 = Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">int</span> num2 = Integer.MIN_VALUE;</span><br><span class="line">            <span class="comment">// 可以再这里加一个判断</span></span><br><span class="line">            <span class="comment">// 若是cur1 == i，那么说明B中的元素已全部放入</span></span><br><span class="line">            <span class="comment">// 直接退出即可，快了很多</span></span><br><span class="line">            <span class="keyword">if</span>(cur1 == i)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 表示当前A数组的元素还没取完</span></span><br><span class="line">            <span class="keyword">if</span>(cur1 &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                num1 = A[cur1];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 表示当前B数组的元素还有剩余</span></span><br><span class="line">            <span class="keyword">if</span>(cur2 &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                num2 = B[cur2];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将小的插入</span></span><br><span class="line">            <span class="keyword">if</span>(num1 &lt; num2)&#123;</span><br><span class="line">                A[i] = num2;</span><br><span class="line">                --cur2;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                A[i] = num1;</span><br><span class="line">                --cur1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM88-判断是否为回文字符串"><a href="#BM88-判断是否为回文字符串" class="headerlink" title="BM88 判断是否为回文字符串"></a>BM88 <a href="https://www.nowcoder.com/practice/e297fdd8e9f543059b0b5f05f3a7f3b2?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">判断是否为回文字符串</a></h2><h3 id="题目描述-86"><a href="#题目描述-86" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个长度为 n 的字符串，请编写一个函数判断该字符串是否回文。如果是回文请返回true，否则返回false。 </p><p>字符串回文指该字符串正序与其逆序逐字符一致。 </p><p>数据范围：0&lt;n≤1000000</p><p>要求：空间复杂度 O(1)，时间复杂度 O(n)</p><h3 id="题解-100"><a href="#题解-100" class="headerlink" title="题解"></a>题解</h3><p>直接判断正反字符是否相等即可。</p><h3 id="Java代码实现-98"><a href="#Java代码实现-98" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str string字符串 待判断的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judge</span> <span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">char</span>[] strs = str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> n = strs.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span> + <span class="number">1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(strs[i] != strs[n - i - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里若是想让空间复杂度为O(1)就不把字符串转换成字符数组直接对str进行charAt()操作并判断即可。</p><h2 id="BM89-合并区间"><a href="#BM89-合并区间" class="headerlink" title="BM89 合并区间"></a>BM89 <a href="https://www.nowcoder.com/practice/69f4e5b7ad284a478777cb2a17fb5e6a?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">合并区间</a></h2><h3 id="题目描述-87"><a href="#题目描述-87" class="headerlink" title="题目描述"></a>题目描述</h3><p>给出一组区间，请合并所有重叠的区间。 </p><p>请保证合并后的区间按区间起点升序排列。 </p><p>数据范围：区间组数 0≤n≤2×10^5，区间内的值都满足 0≤val≤2×10^5</p><p>要求：空间复杂度 O(n)，时间复杂度 O(nlogn)</p><p>进阶：空间复杂度 O(val)，时间复杂度O(val)</p><h3 id="题解-101"><a href="#题解-101" class="headerlink" title="题解"></a>题解</h3><p>最简单的方法将数组先排序，之后判断当前区间是否可以被前一个区间合并，可以被前一个区间合并的条件是此区间和前一个区间存在重复的部分，即此区间的左边界小于或等于上一区间的右边界，那么此时可以合并，合并后的边界的右边界是两个边界中较大的那个，左边界是前一个边界的左边界。</p><h3 id="Java代码实现-99"><a href="#Java代码实现-99" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Interval&gt; <span class="title">merge</span><span class="params">(ArrayList&lt;Interval&gt; intervals)</span> </span>&#123;</span><br><span class="line">        Collections.sort(intervals, (o1, o2) -&gt; o1.start - o2.start);</span><br><span class="line">        ArrayList&lt;Interval&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 第几个数组</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 总共有几个区间</span></span><br><span class="line">        <span class="keyword">int</span> len = intervals.size();</span><br><span class="line">        <span class="keyword">while</span>(index &lt; len)&#123;</span><br><span class="line">            <span class="keyword">int</span> left = intervals.get(index).start;</span><br><span class="line">            <span class="keyword">int</span> right = intervals.get(index).end;</span><br><span class="line">            <span class="comment">// 表示之后还有区间且能够合并</span></span><br><span class="line">            <span class="keyword">while</span>(index &lt; len - <span class="number">1</span> &amp;&amp; intervals.get(index + <span class="number">1</span>).start &lt;= right)&#123;</span><br><span class="line">                <span class="comment">// 更新右边界为当前区间和下一个区间中较大的那个</span></span><br><span class="line">                right = Math.max(right, intervals.get(index + <span class="number">1</span>).end);</span><br><span class="line">                <span class="comment">// 更新index值，表示这个区间搜索过了</span></span><br><span class="line">                ++index;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将此区间放入</span></span><br><span class="line">            res.add(<span class="keyword">new</span> Interval(left, right));</span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时时间复杂度是O(nlogn)，至于进阶要求的O(val)的时间复杂度，目前暂未想到改如何做。</p><h2 id="BM90-最小覆盖子串"><a href="#BM90-最小覆盖子串" class="headerlink" title="BM90 最小覆盖子串"></a>BM90 <a href="https://www.nowcoder.com/practice/c466d480d20c4c7c9d322d12ca7955ac?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">最小覆盖子串</a></h2><h3 id="题目描述-88"><a href="#题目描述-88" class="headerlink" title="题目描述"></a>题目描述</h3><p>给出两个字符串 s 和 t，要求在 s 中找出最短的包含 t 中所有字符的连续子串。 </p><p>数据范围：0≤∣S∣,∣T∣≤10000，保证s和t字符串中仅包含大小写英文字母 </p><p>要求：进阶：空间复杂度 O(n)， 时间复杂度 O(n)</p><p>例如：</p><p>S=”XDOYEZODEYXNZ”<br>T=”XYZ”<br>找出的最短子串为”YXNZ”. </p><p>注意：<br>如果 s 中没有包含 t 中所有字符的子串，返回空字符串 “”；<br>满足条件的子串可能有很多，但是题目保证满足条件的最短的子串唯一。</p><h3 id="题解-102"><a href="#题解-102" class="headerlink" title="题解"></a>题解</h3><p>最简单的解法是直接枚举出所有可能出现的子串结果，看是否满足，若是满足则可以考虑吧，若是不满足则继续，最终返回可能结果中最小的那一个即可。</p><p>但此时时间复杂度较高，不合题意。</p><p>可以考虑使用双指针 + 滑动窗口来实现，首先确定一个思想，当不匹配时需要一直增大滑动窗口的大小，当且仅当匹配的时候可以缩小滑动窗口的大小，以左右指针维护滑动窗口大小，维护一个变量表示当前滑动窗口中的匹配的字符，若是已经匹配的字符小于T的长度时，右指针继续后移（直到越界为止），若是已经匹配的字符长度达到了T的长度，那么可以后移左指针来缩小滑动窗口的范围，过程中记得维护表示当前滑动窗口中匹配的字符长度的变量。</p><h3 id="Java代码实现-100"><a href="#Java代码实现-100" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> S string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> T string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span> <span class="params">(String S, String T)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">char</span>[] ss = S.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] ts = T.toCharArray();</span><br><span class="line">        <span class="comment">// 子串的长度</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">10001</span>;</span><br><span class="line">        <span class="comment">// 子串开始的下标</span></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(ss.length &lt; ts.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用于保存ts中的元素出现的次数</span></span><br><span class="line">        <span class="comment">// 这里为什么取128呢</span></span><br><span class="line">        <span class="comment">// 因为题目只说了包含大小写字符，其对应的int最大就是128</span></span><br><span class="line">        <span class="keyword">int</span>[] frequency = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="comment">// 统计出现的次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ts.length; ++i)&#123;</span><br><span class="line">            ++frequency[ts[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// left表示窗口左指针</span></span><br><span class="line">        <span class="comment">// right表示窗口右指针</span></span><br><span class="line">        <span class="comment">// count表示已经匹配完的字符数</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; ss.length)&#123;</span><br><span class="line">            <span class="comment">// 大于0表示还没有消完,frequency中对应的位置自减1同时right后移</span></span><br><span class="line">            <span class="keyword">if</span>(frequency[ss[right++]]-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 已匹配字符的个数加一</span></span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(count == ts.length)&#123;</span><br><span class="line">                <span class="comment">// 此时找到了匹配的字符串，看是否需要更新</span></span><br><span class="line">                <span class="keyword">if</span>(len &gt; right - left)&#123;</span><br><span class="line">                    len = right - left;</span><br><span class="line">                    start = left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 之后可以考虑后移左指针</span></span><br><span class="line">                <span class="comment">// 后移左指针的条件是左指针字符出现的次数为0</span></span><br><span class="line">                <span class="comment">// 而不需要的字符来说，他们的值其实已经小于0了</span></span><br><span class="line">                <span class="comment">// 因此等于0的就是需要的</span></span><br><span class="line">                <span class="keyword">if</span>(frequency[ss[left++]]++ == <span class="number">0</span>)&#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len == <span class="number">10001</span> ? <span class="string">""</span> : S.substring(start, start + len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM91-反转字符串"><a href="#BM91-反转字符串" class="headerlink" title="BM91 反转字符串"></a>BM91 <a href="https://www.nowcoder.com/practice/c3a6afee325e472386a1c4eb1ef987f3?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">反转字符串</a></h2><h3 id="题目描述-89"><a href="#题目描述-89" class="headerlink" title="题目描述"></a>题目描述</h3><p>写出一个程序，接受一个字符串，然后输出该字符串反转后的字符串。（字符串长度不超过1000）</p><p>数据范围： 0≤n≤1000</p><p>要求：空间复杂度 O(n)，时间复杂度 O(n)</p><h3 id="题解-103"><a href="#题解-103" class="headerlink" title="题解"></a>题解</h3><p>各种方式反转即可。</p><h3 id="Java代码实现-101"><a href="#Java代码实现-101" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反转字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">solve</span> <span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> n = str.length();</span><br><span class="line">        <span class="keyword">char</span>[] strs = str.toCharArray();</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            sb.append(strs[n - i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM92-最长无重复子数组"><a href="#BM92-最长无重复子数组" class="headerlink" title="BM92 最长无重复子数组"></a>BM92 <a href="https://www.nowcoder.com/practice/b56799ebfd684fb394bd315e89324fb4?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">最长无重复子数组</a></h2><h3 id="题目描述-90"><a href="#题目描述-90" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个长度为n的数组arr，返回arr的最长无重复元素子数组的长度，无重复指的是所有数字都不相同。</p><p>子数组是连续的，比如[1,3,5,7,9]的子数组有[1,3]，[3,5,7]等等，但是[1,3,7]不是子数组</p><p>数据范围：0≤arr.length≤10^5，0&lt;arr[i]≤10^5</p><h3 id="题解-104"><a href="#题解-104" class="headerlink" title="题解"></a>题解</h3><p>使用双指针left和right表示子数组的左右边界，若是right和right + 1对应的值不等，那么right指针后移，若是两者相等，此时的right - left值就是长度，判断是否更新最大长度即可，若是两者相等，将左右指针移到右指针的后一位继续遍历，直到遍历完。</p><h3 id="Java代码实现-102"><a href="#Java代码实现-102" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr int整型一维数组 the array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxLength</span> <span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 长度小于2时不可能重复</span></span><br><span class="line">        <span class="keyword">if</span>(arr.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> arr.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左右指针分别从0和1开始</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 初始时最大长度为0</span></span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 用于保存滑动窗口中已有的元素</span></span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">// 先将左值加入</span></span><br><span class="line">        set.add(arr[left]);</span><br><span class="line">        <span class="keyword">while</span>(right &lt; arr.length &amp;&amp; left &lt; arr.length)&#123;</span><br><span class="line">            <span class="comment">// 当前右值未被包含，加入集合中并且右指针后移</span></span><br><span class="line">            <span class="keyword">if</span>(!set.contains(arr[right]))&#123;</span><br><span class="line">                set.add(arr[right]);</span><br><span class="line">                ++right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 此时右值已被包含</span></span><br><span class="line">                <span class="comment">// 判断是否需要更新最长子数组长度</span></span><br><span class="line">                <span class="keyword">if</span>(right - left&gt; maxLen)&#123;</span><br><span class="line">                    maxLen = right - left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 改变左右指针</span></span><br><span class="line">                <span class="comment">// 左指针首先后移（需要将集合中的元素也删除）</span></span><br><span class="line">                set.remove(arr[left]);</span><br><span class="line">                <span class="comment">// 右移左指针</span></span><br><span class="line">                left = left + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 若是右移后左右指针位置相同则需要后移右指针。</span></span><br><span class="line">                <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">                    ++right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 没有越界就把这个值加入到set中（这里不用担心已经有这个元素，Set能去重）</span></span><br><span class="line">                <span class="keyword">if</span>(left &lt; arr.length)&#123;</span><br><span class="line">                    set.add(arr[left]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> maxLen;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后一次还未比较</span></span><br><span class="line">        <span class="comment">// 即若是最后两个数值不相等那其实已经直接退出了while循环</span></span><br><span class="line">        <span class="keyword">return</span> right - left&gt; maxLen ? right - left: maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM93-盛水最多的容器"><a href="#BM93-盛水最多的容器" class="headerlink" title="BM93 盛水最多的容器"></a>BM93 <a href="https://www.nowcoder.com/practice/3d8d6a8e516e4633a2244d2934e5aa47?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">盛水最多的容器</a></h2><h3 id="题目描述-91"><a href="#题目描述-91" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个数组height，长度为n，每个数代表坐标轴中的一个点的高度，height[i]是在第i点的高度，请问，从中选2个高度与x轴组成的容器最多能容纳多少水 </p><p>1.你不能倾斜容器 </p><p>2.当n小于2时，视为不能形成容器，请返回0 </p><p>3.数据保证能容纳最多的水不会超过整形范围，即不会超过2^31-1 </p><p>数据范围: </p><p>0&lt;=height.length&lt;=10^5</p><p>0&lt;=height[i]&lt;=10^4</p><p>如输入的height为[1,7,3,2,4,5,8,2,7]，那么如下图:</p><p><img src="https://uploadfiles.nowcoder.com/images/20211105/301499_1636104759021/B9F3EB6BBC1EE9A63532E7EB494A11A7" alt="img"></p><h3 id="题解-105"><a href="#题解-105" class="headerlink" title="题解"></a>题解</h3><p>首先最简单的就是暴力解法，两个for循环遍历出所有可能的容器，取最大值即可。</p><p>其次类似接雨水问题都可以通过双指针操作进行实现，但双指针需要考虑移动的是左指针还是移动右指针，首先我们先将两个板子之间的范围取到最大值，即左指针为0，右指针为n - 1，那么每次操作就是左移右指针或者右移左指针，这两个操作都有可能取到比原来更优的解，那么何时才能找到两个解中较优的那一个呢，我们每次贪心的选择移动值较小的那个指针（木桶原理，容器盛水由较低的板决定，你移动较大的指针，容量不可能变大），之后考虑是否更新最值，最好将最值返回即可。</p><h3 id="Java代码实现-103"><a href="#Java代码实现-103" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> height int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span> <span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> n = height.length;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left != right)&#123;</span><br><span class="line">            <span class="keyword">int</span> area;</span><br><span class="line">            <span class="comment">// 若是左指针的值较小，则面积就是左指针的值 * 左右指针之差，此时需要移动左指针</span></span><br><span class="line">            <span class="keyword">if</span>(height[left] &lt; height[right])&#123;</span><br><span class="line">                area = (right - left) * height[left];</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 反之则面积是右指针的值 * 左右指针之差，此时移动右指针</span></span><br><span class="line">                area = (right - left) * height[right];</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新最值</span></span><br><span class="line">            max = Math.max(max, area);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM94-接雨水问题"><a href="#BM94-接雨水问题" class="headerlink" title="BM94 接雨水问题"></a>BM94 <a href="https://www.nowcoder.com/practice/31c1aed01b394f0b8b7734de0324e00f?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">接雨水问题</a></h2><h3 id="题目描述-92"><a href="#题目描述-92" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个整形数组arr，已知其中所有的值都是非负的，将这个数组看作一个柱子高度图，计算按此排列的柱子，下雨之后能接多少雨水。(数组以外的区域高度视为0) </p><p><img src="https://uploadfiles.nowcoder.com/images/20210416/999991351_1618541247169/26A2E295DEE51749C45B5E8DD671E879" alt="img"></p><p>数据范围：数组长度 0≤n≤2×10^5，数组中每个值满足 0&lt;val≤10^9，保证返回结果满足 0≤val≤10^9</p><p>要求：时间复杂度 O(n)</p><h3 id="题解-106"><a href="#题解-106" class="headerlink" title="题解"></a>题解</h3><p>这一题主要就是要找到有多少个地方能盛水，第一次遍历首先找到盛水边界，方向有两种，一是从左往右，二是从右往左，我们每次找到比当前边界值更大的值我们就将其放入集合中并更新边界，两次的结果求出来之后再求并集，之后再次遍历数组，若是当前的下标是边界值，那么需要将之前的容量算出来(当前容器能装的水 - 容器自身消耗的面积)，求出之后将其加到总雨水中即可。</p><h3 id="Java代码实现-104"><a href="#Java代码实现-104" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * max water</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr int整型一维数组 the array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> long长整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">maxWater</span> <span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 存放从左往右找到的边界</span></span><br><span class="line">        HashSet&lt;Integer&gt; leftToRight = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">// 找到左边界的值</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 存放从右往左找到的边界</span></span><br><span class="line">        HashSet&lt;Integer&gt; rightToLeft = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">// 找到右边界的值</span></span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="comment">// 找到了一个边界</span></span><br><span class="line">            <span class="keyword">if</span>(left &lt;= arr[i])&#123;</span><br><span class="line">                leftToRight.add(i);</span><br><span class="line">                left = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; --i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(right &lt;= arr[i])&#123;</span><br><span class="line">                rightToLeft.add(i);</span><br><span class="line">                right = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        leftToRight.addAll(rightToLeft);</span><br><span class="line">        <span class="comment">// 总的可以装的雨水</span></span><br><span class="line">        <span class="keyword">long</span> sumWater = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 当前容器装的雨水（假设其内部为空的情况）</span></span><br><span class="line">        <span class="keyword">int</span> curWater = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 当前容器内部占的体积</span></span><br><span class="line">        <span class="keyword">int</span> curArea = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 容器开始的下标</span></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 第一个和最后一个肯定是边界，不考虑</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">            <span class="comment">// 若当前是边界，那么将当前能容纳的雨水加到总雨水中</span></span><br><span class="line">            <span class="keyword">if</span>(leftToRight.contains(i))&#123;</span><br><span class="line">                <span class="comment">// 计算当前容器可以装的雨水</span></span><br><span class="line">                curWater = (i - start - <span class="number">1</span>) * Math.min(arr[i], arr[start]);</span><br><span class="line">                <span class="comment">// 总共能装的雨水就是之前的加上当前容器能装的再减去当前容器内部的空间</span></span><br><span class="line">                sumWater += curWater - curArea;</span><br><span class="line">                <span class="comment">// 更新curArea</span></span><br><span class="line">                curArea = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 开始下标改变</span></span><br><span class="line">                start = i;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 若当前不是边界，更新内部容量</span></span><br><span class="line">                curArea += arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后一个容器能装的雨水还没算</span></span><br><span class="line">        sumWater += (n - start - <span class="number">2</span>) * Math.min(arr[n - <span class="number">1</span>], arr[start]) - curArea;</span><br><span class="line">        <span class="keyword">return</span> sumWater;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题解-107"><a href="#题解-107" class="headerlink" title="题解"></a>题解</h3><p>这题也可以使用双指针，初始时为左右边边界（假设这个桶是左右边界构成的桶），之后选择两者的较小值作为当前桶的高度，之后一直更新桶高同时更新雨水值以及左右指针位置即可，就是在更新指针的过程中需要防止越界。</p><h3 id="Java代码实现-105"><a href="#Java代码实现-105" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * max water</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr int整型一维数组 the array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> long长整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">maxWater</span> <span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 存放结果</span></span><br><span class="line">        <span class="keyword">long</span> sumWater = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> border = Math.min(arr[left], arr[right]);</span><br><span class="line">            <span class="comment">// 更新时记得防止越界</span></span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; arr[left] &lt;= border)&#123;</span><br><span class="line">                <span class="comment">// 此时left能放水</span></span><br><span class="line">                sumWater += border - arr[left];</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; arr[right] &lt;= border)&#123;</span><br><span class="line">                <span class="comment">// 此时right能放水</span></span><br><span class="line">                sumWater += border - arr[right];</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sumWater;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h2 id="BM95-分糖果问题"><a href="#BM95-分糖果问题" class="headerlink" title="BM95 分糖果问题"></a>BM95 <a href="https://www.nowcoder.com/practice/76039109dd0b47e994c08d8319faa352?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">分糖果问题</a></h2><h3 id="题目描述-93"><a href="#题目描述-93" class="headerlink" title="题目描述"></a>题目描述</h3><p>一群孩子做游戏，现在请你根据游戏得分来发糖果，要求如下： </p><ol><li><p>每个孩子不管得分多少，起码分到一个糖果。</p></li><li><p>任意两个相邻的孩子之间，得分较多的孩子必须拿多一些糖果。(若相同则无此限制)</p></li></ol><p>给定一个数组 arr代表得分数组，请返回最少需要多少糖果。 </p><p>要求: 时间复杂度为 O(n)空间复杂度为 O(n)</p><p>数据范围： 1≤n≤100000，1≤ai≤1000</p><h3 id="题解-108"><a href="#题解-108" class="headerlink" title="题解"></a>题解</h3><p>贪心的核心：首先给第全部孩子分一个糖，之后从第1个孩子开始遍历，若是得分比前一个孩子多，那么糖果数多1，否则给他一个糖果。这次遍历满足了从前到后的合法性，但从后往前的合法性仍未满足，考虑再次从后往前遍历，若是发现不满足条件的值，就修改其值为当前值 + 1以及原来取最大值。</p><h3 id="Java代码实现-106"><a href="#Java代码实现-106" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * pick candy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr int整型一维数组 the array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">candy</span> <span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] everyCandy = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="comment">// 先用1填充</span></span><br><span class="line">        Arrays.fill(everyCandy, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; arr[i - <span class="number">1</span>])&#123;</span><br><span class="line">                everyCandy[i] = everyCandy[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; arr[i + <span class="number">1</span>])&#123;</span><br><span class="line">                everyCandy[i] = Math.max(everyCandy[i], everyCandy[i + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(everyCandy).sum();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM96-主持人调度（二）"><a href="#BM96-主持人调度（二）" class="headerlink" title="BM96 主持人调度（二）"></a>BM96 <a href="https://www.nowcoder.com/practice/4edf6e6d01554870a12f218c94e8a299?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">主持人调度（二）</a></h2><h3 id="题目描述-94"><a href="#题目描述-94" class="headerlink" title="题目描述"></a>题目描述</h3><p>有 n 个活动即将举办，每个活动都有开始时间与活动的结束时间，第 i 个活动的开始时间是 starti ,第 i 个活动的结束时间是 endi ,举办某个活动就需要为该活动准备一个活动主持人。</p><p>一位活动主持人在同一时间只能参与一个活动。并且活动主持人需要全程参与活动，换句话说，一个主持人参与了第 i 个活动，那么该主持人在 (starti,endi) 这个时间段不能参与其他任何活动。求为了成功举办这 n 个活动，最少需要多少名主持人。</p><p>数据范围: 1≤n≤10^5， −2^32≤starti,endi≤2^31−1</p><p>复杂度要求：时间复杂度 O(nlog⁡n)，空间复杂度 O(n)</p><h3 id="题解-109"><a href="#题解-109" class="headerlink" title="题解"></a>题解</h3><p>先按开始时间进行排序，之后维护一个队列（队列中存放活动的结束时间），对于每个活动，若是其开始时间在队首（最小的–&gt;结束最早的）的活动之前，那么说明活动还未结束，必须多一个主持人，若是其开始时间在队首活动之后，说明此时活动已经结束，无需再添加主持人。</p><h3 id="Java代码实现-107"><a href="#Java代码实现-107" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     * 计算成功举办活动需要多少名主持人</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n int整型 有n个活动</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startEnd int整型二维数组 startEnd[i][0]用于表示第i个活动的开始时间，startEnd[i][1]表示第i个活动的结束时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minmumNumberOfHost</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] startEnd)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先排序</span></span><br><span class="line">        Arrays.sort(startEnd, (o1, o2) -&gt; o1[<span class="number">0</span>] &gt; o2[<span class="number">0</span>] ? <span class="number">1</span>: o1[<span class="number">0</span>] &lt; o2[<span class="number">0</span>] ? -<span class="number">1</span> : o1[<span class="number">1</span>] &gt;= o2[<span class="number">1</span>] ? <span class="number">1</span>: -<span class="number">1</span>);</span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] active : startEnd)&#123;</span><br><span class="line">            <span class="comment">// 把这个活动放到队列中</span></span><br><span class="line">            queue.offer(active[<span class="number">1</span>]);</span><br><span class="line">            <span class="comment">// 若是当前活动开始的时间大于之前的活动结束的时间</span></span><br><span class="line">            <span class="keyword">if</span>(!queue.isEmpty() &amp;&amp; queue.peek() &lt;= active[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="comment">// 继续用上一个主持人</span></span><br><span class="line">                <span class="comment">// 把那个主持人拿掉</span></span><br><span class="line">                queue.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h1><h2 id="BM97-旋转数组"><a href="#BM97-旋转数组" class="headerlink" title="BM97 旋转数组"></a>BM97 <a href="https://www.nowcoder.com/practice/e19927a8fd5d477794dac67096862042?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">旋转数组</a></h2><h3 id="题目描述-95"><a href="#题目描述-95" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个数组A中存有 n 个整数，在不允许使用另外数组的前提下，将每个整数循环向右移 M（ M &gt;=0）个位置，即将A中的数据由（A0 A1 ……AN-1 ）变换为（AN-M …… AN-1 A0A1 ……AN-M-1 ）（最后 M 个数循环移至最前面的 M 个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？ </p><p>数据范围：0&lt;n≤100，0≤m≤1000</p><p>进阶：空间复杂度 O(1)，时间复杂度 O(n)</p><h3 id="题解-110"><a href="#题解-110" class="headerlink" title="题解"></a>题解</h3><p>首先分析问题，要求我们将后面的m个数据放到最前面，可以选择旋转数组的方式，即将数组完全导致过来，这样的话后面的m个元素已经到了前m个位置，大致上满足，但此时顺序不对，因此再分别对m之前的元素及其之后的元素进行反转就得到了题目要求的结果。例如{0, 1, ,2, 3, 4, 5, 6, 7, 8, 9}，m = 3，应得的结果是{7, 8, 9, 0, 1, 2, 3, 4, 5, 6}，按照算法思想，先将数组反转，得到{9, 8, 7, 6, 5, 4, 3, 2, 1, 0}，之后对前三个元素反转，得到{7, 8, 9, 6, 5, 4, 3, 2, 1, 0}，之后对后面的元素进行反转，得到{7, 8, 9, 0, 1, 2, 3, 4, 5, 6}。</p><h3 id="Java代码实现-108"><a href="#Java代码实现-108" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 旋转数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n int整型 数组长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m int整型 右移距离</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a int整型一维数组 给定数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] solve (<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span>[] a) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 防止太大了</span></span><br><span class="line">        m %= n;</span><br><span class="line">        <span class="comment">// 首先反转全部</span></span><br><span class="line">        reverse(a, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 之后反转前m个</span></span><br><span class="line">        reverse(a, <span class="number">0</span>, m - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 再反转后面的</span></span><br><span class="line">        reverse(a, m, n -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = num[end];</span><br><span class="line">            num[end] = num[start];</span><br><span class="line">            num[start] = temp;</span><br><span class="line">            ++start;</span><br><span class="line">            --end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对于旋转数组时使用到的反转链表的思想，我只能说女少口阿</strong></p><h2 id="BM98-螺旋矩阵"><a href="#BM98-螺旋矩阵" class="headerlink" title="BM98 螺旋矩阵"></a>BM98 <a href="https://www.nowcoder.com/practice/7edf70f2d29c4b599693dc3aaeea1d31?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">螺旋矩阵</a></h2><h3 id="题目描述-96"><a href="#题目描述-96" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个m x n大小的矩阵（m行，n列），按螺旋的顺序返回矩阵中的所有元素。</p><p>数据范围：0≤n,m≤10，矩阵中任意元素都满足 ∣val∣≤100</p><p>要求：空间复杂度 O(nm)，时间复杂度 O(nm)</p><h3 id="题解-111"><a href="#题解-111" class="headerlink" title="题解"></a>题解</h3><p>实际模拟我们大脑求解的过程即可，设立四个边界值，若是未达到边界就进行如下方式遍历先从左往右，再从上到下，之后从右到左，最后从下往上，此四个过程为一个循环，循环结束后更新边界值。</p><h3 id="Java代码实现-109"><a href="#Java代码实现-109" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先初始化边界</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> bottom = matrix.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 未到达边界</span></span><br><span class="line">        <span class="keyword">while</span>(top &lt;= bottom &amp;&amp; left &lt;= right)&#123;</span><br><span class="line">            <span class="comment">// 先从左到右(上边界)</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right; ++i)&#123;</span><br><span class="line">                res.add(matrix[top][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 再从上到下(右边界)，注意这里第一个元素已经被访问了</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = top + <span class="number">1</span>; i &lt;= bottom; ++i)&#123;</span><br><span class="line">                res.add(matrix[i][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 再从右往左(下边界)，注意这里第一个元素已经被访问了</span></span><br><span class="line">            <span class="comment">// 若是top = bottom那么就没有从右往左的必要了</span></span><br><span class="line">            <span class="comment">// 只有一行，在从左往右的时候遍历过了</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = right - <span class="number">1</span>; i &gt;= left &amp;&amp; top != bottom; --i)&#123;</span><br><span class="line">                res.add(matrix[bottom][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 再从下往上(左边界)，注意这里第一个元素已经被访问了</span></span><br><span class="line">            <span class="comment">// left = right那么就没有从右往左的必要了</span></span><br><span class="line">            <span class="comment">// 只有一列，在从上往下的时候遍历过了</span></span><br><span class="line">            <span class="comment">// 还有就是注意这里只遍历到了top下面的一行（top这一行已经遍历过了）</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = bottom - <span class="number">1</span>; i &gt;= top + <span class="number">1</span> &amp;&amp; left != right; --i)&#123;</span><br><span class="line">                res.add(matrix[i][left]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 改变边界值</span></span><br><span class="line">            ++left;</span><br><span class="line">            --right;</span><br><span class="line">            ++top;</span><br><span class="line">            --bottom;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM99-顺时针旋转矩阵"><a href="#BM99-顺时针旋转矩阵" class="headerlink" title="BM99 顺时针旋转矩阵"></a>BM99 <a href="https://www.nowcoder.com/practice/2e95333fbdd4451395066957e24909cc?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">顺时针旋转矩阵</a></h2><h3 id="题目描述-97"><a href="#题目描述-97" class="headerlink" title="题目描述"></a>题目描述</h3><p>有一个NxN整数矩阵，请编写一个算法，将矩阵顺时针旋转90度。 </p><p>给定一个NxN的矩阵，和矩阵的阶数N,请返回旋转后的NxN矩阵。 </p><p>数据范围：0&lt;n&lt;300，矩阵中的值满足 0≤val≤1000</p><p>要求：空间复杂度 O(N^2)，时间复杂度 O(N^2)</p><p>进阶：空间复杂度 O(1)，时间复杂度 O(N^2)</p><h3 id="题解-112"><a href="#题解-112" class="headerlink" title="题解"></a>题解</h3><p>若是想达到O(n^2)的时间复杂度，只需新建一个数组，把反转后的数组修改到新数组上即可。而旋转的过程也比较简单，一开始是从左往右从上往下遍历，那么旋转之后就是从上往下，从右往左遍历，逐个填满数组即可。</p><h3 id="java代码实现"><a href="#java代码实现" class="headerlink" title="java代码实现"></a>java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] rotateMatrix(<span class="keyword">int</span>[][] mat, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="comment">// 这里新数组的行和原数组的列对应</span></span><br><span class="line">                <span class="comment">// 新数组的列就是原数组的行反过来</span></span><br><span class="line">                res[j][n - i - <span class="number">1</span>] = mat[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题解-113"><a href="#题解-113" class="headerlink" title="题解"></a>题解</h3><p>若是想达到O(1)的空间复杂度，则必须原地修改指针，考虑矩阵是如何进行旋转的，就是先通过矩阵的对称轴上下交换，再通过矩阵的对角线（左上到右下的对角线）左右交换，通过两次交换就得到了需要的矩阵。</p><h3 id="Java代码实现-110"><a href="#Java代码实现-110" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] rotateMatrix(<span class="keyword">int</span>[][] mat, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 先以从左到右的在水平方向的对称轴交换，这里注意i的取值[0, n / 2)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                swap(mat, i, j, n - i - <span class="number">1</span>, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 再以从左上到右下的对称轴交换,注意这里只交换一半</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n; ++j)&#123;</span><br><span class="line">                swap(mat, i, j, j, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mat;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将二维矩阵(i1, j1)的数和(i2, j2)的数交换</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[][] num, <span class="keyword">int</span> i1, <span class="keyword">int</span> j1, <span class="keyword">int</span> i2, <span class="keyword">int</span> j2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = num[i1][j1];</span><br><span class="line">        num[i1][j1] = num[i2][j2];</span><br><span class="line">        num[i2][j2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM100-设计LRU缓存结构"><a href="#BM100-设计LRU缓存结构" class="headerlink" title="BM100 设计LRU缓存结构"></a>BM100 <a href="https://www.nowcoder.com/practice/5dfded165916435d9defb053c63f1e84?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">设计LRU缓存结构</a></h2><h3 id="题目描述-98"><a href="#题目描述-98" class="headerlink" title="题目描述"></a>题目描述</h3><p>设计LRU(最近最少使用)缓存结构，该结构在构造时确定大小，假设大小为 capacity ，操作次数是 n ，并有如下功能:</p><ol><li>Solution(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存</li><li>get(key)：如果关键字 key 存在于缓存中，则返回key对应的value值，否则返回 -1 。</li><li>set(key, value)：将记录(key, value)插入该结构，如果关键字 key 已经存在，则变更其数据值 value，如果不存在，则向缓存中插入该组 key-value ，如果key-value的数量超过capacity，弹出最久未使用的key-value</li></ol><p>提示:<br>1.某个key的set或get操作一旦发生，则认为这个key的记录成了最常使用的，然后都会刷新缓存。<br>2.当缓存的大小超过capacity时，移除最不经常使用的记录。<br>4.返回的value都以字符串形式表达，如果是set，则会返回”null”来表示，方便观察<br>5.函数set和get必须以O(1)的方式运行<br>6.为了方便区分缓存里key与value，下面说明的缓存里key用””号包裹 </p><p>数据范围: </p><p>1≤capacity&lt;=10^5<br>0≤key,val≤2×10^9<br>1≤n≤10^5</p><h3 id="题解-114"><a href="#题解-114" class="headerlink" title="题解"></a>题解</h3><p>这题很显然有key-value对，需要使用HashMap，这是第一个数据结构，此外需要存储优先级，但这里可以使用队列来保存数据，每次get和set操作就将其删除并重新插入到尾部，若是容量过大就将链表头删除。</p><h3 id="Java代码实现-111"><a href="#Java代码实现-111" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    LinkedHashMap&lt;Integer, Integer&gt; map;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">         <span class="comment">// write code here</span></span><br><span class="line">        map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">         <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(key))&#123;</span><br><span class="line">            Integer value = map.get(key);</span><br><span class="line">            <span class="comment">// 从头删除</span></span><br><span class="line">            map.remove(key);</span><br><span class="line">            <span class="comment">// 插入到尾</span></span><br><span class="line">            map.put(key, value);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">         <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 先判断是否已经有这个元素了</span></span><br><span class="line">        <span class="comment">// 有的话修改然后更新队列即可</span></span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(key))&#123;</span><br><span class="line">            map.remove(key);</span><br><span class="line">            map.put(key, value);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 原来没有这个元素</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 满了，此时需要移除元素</span></span><br><span class="line">            <span class="keyword">if</span>(capacity == map.size())&#123;</span><br><span class="line">                Integer removeKey = map.keySet().iterator().next();</span><br><span class="line">                map.remove(removeKey);</span><br><span class="line">                map.put(key, value);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 此时直接插入即可</span></span><br><span class="line">                map.put(key, value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM101-设计LFU缓存结构"><a href="#BM101-设计LFU缓存结构" class="headerlink" title="BM101 设计LFU缓存结构"></a>BM101 <a href="https://www.nowcoder.com/practice/93aacb4a887b46d897b00823f30bfea1?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">设计LFU缓存结构</a></h2><h3 id="题目描述-99"><a href="#题目描述-99" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个缓存结构需要实现如下功能。 </p><ul><li>set(key, value)：将记录(key, value)插入该结构 </li><li>get(key)：返回key对应的value值 </li></ul><p>但是缓存结构中最多放K条记录，如果新的第K+1条记录要加入，就需要根据策略删掉一条记录，然后才能把新记录加入。这个策略为：在缓存结构的K条记录中，哪一个key从进入缓存结构的时刻开始，被调用set或者get的次数最少，就删掉这个key的记录； </p><p>如果调用次数最少的key有多个，上次调用发生最早的key被删除 </p><p>这就是LFU缓存替换算法。实现这个结构，K作为参数给出</p><p>数据范围：0&lt;k≤10^5，∣val∣≤2×10^9</p><p>要求：get和set的时间复杂度都是 O(logn)，空间复杂度是 O(n)</p><p>若opt=1，接下来两个整数x, y，表示set(x, y)<br>若opt=2，接下来一个整数x，表示get(x)，若x未出现过或已被移除，则返回-1</p><p>对于每个操作2，返回一个答案</p><h3 id="题解-115"><a href="#题解-115" class="headerlink" title="题解"></a>题解</h3><p>参考了<a href="https://blog.nowcoder.net/n/4ed8a609169e4cdda974d59546e376f5" target="_blank" rel="noopener">别人的题解</a>。</p><h3 id="Java代码实现-112"><a href="#Java代码实现-112" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * lfu design</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> operators int整型二维数组 ops</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k int整型 the k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] LFU (<span class="keyword">int</span>[][] operators, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="comment">//记录get调用的次数</span></span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] opera:operators)&#123;</span><br><span class="line">            <span class="keyword">if</span>(opera[<span class="number">0</span>]==<span class="number">2</span>)&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据cnt新建结果数组</span></span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[cnt];</span><br><span class="line">        <span class="keyword">int</span> id=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//新建缓存结构</span></span><br><span class="line">        LFUCache lfu=<span class="keyword">new</span> LFUCache(k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] opera:operators)&#123;</span><br><span class="line">            <span class="comment">//执行set操作</span></span><br><span class="line">            <span class="keyword">if</span>(opera[<span class="number">0</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">                lfu.set(opera[<span class="number">1</span>],opera[<span class="number">2</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//执行get操作</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> value=lfu.get(opera[<span class="number">1</span>]);</span><br><span class="line">                res[id++]=value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义Node结构，包含一个key和一个value，并初始化调用次数freq为1</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">int</span> freq=<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        Node(<span class="keyword">int</span> key,<span class="keyword">int</span> value)&#123;</span><br><span class="line">            <span class="keyword">this</span>.key=key;</span><br><span class="line">            <span class="keyword">this</span>.value=value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用于存储缓存，键为缓存的键，值为key、value组成的Node</span></span><br><span class="line">    Map&lt;Integer,Node&gt; cache;</span><br><span class="line">    <span class="comment">//用于存储频次，键为某个Node调用次数，值为对应频次的双向链表</span></span><br><span class="line">    Map&lt;Integer,LinkedHashSet&lt;Node&gt;&gt; freqMap;</span><br><span class="line">    <span class="comment">//缓存的容量</span></span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="comment">//记录最小调用次数</span></span><br><span class="line">    <span class="keyword">int</span> min;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LFUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity=capacity;</span><br><span class="line">        cache=<span class="keyword">new</span> HashMap&lt;&gt;(capacity);</span><br><span class="line">        freqMap=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回key对应的value值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果缓存中不存在key，直接返回-1</span></span><br><span class="line">        <span class="keyword">if</span>(!cache.containsKey(key))&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到对应的node</span></span><br><span class="line">        Node node=cache.get(key);</span><br><span class="line">        <span class="comment">//更新调用频次</span></span><br><span class="line">        freqInc(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将记录(key,value)插入缓存结构</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> key,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果缓存中已经存在这个key</span></span><br><span class="line">        <span class="keyword">if</span>(cache.containsKey(key))&#123;</span><br><span class="line">            <span class="comment">//找到对应的node，设置值为value，更新频次</span></span><br><span class="line">            Node node=cache.get(key);</span><br><span class="line">            node.value=value;</span><br><span class="line">            freqInc(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果缓存中不存在这个key</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//如果缓存的大小达到了容量capacity</span></span><br><span class="line">            <span class="keyword">if</span>(cache.size()==capacity)&#123;</span><br><span class="line">                <span class="comment">//根据策略从双向链表删掉对应的节点</span></span><br><span class="line">                Node deadNode=removeNode();</span><br><span class="line">                <span class="comment">//从缓存中移除对应的key</span></span><br><span class="line">                cache.remove(deadNode.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//新建一个Node，将其放入缓存，并在双向链表添加该Node</span></span><br><span class="line">            Node newNode=<span class="keyword">new</span> Node(key,value);</span><br><span class="line">            cache.put(key,newNode);</span><br><span class="line">            addNode(newNode);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//更新频次</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">freqInc</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="comment">//找到对应的双向链表，移除掉node</span></span><br><span class="line">        <span class="keyword">int</span> freq=node.freq;</span><br><span class="line">        LinkedHashSet&lt;Node&gt; set=freqMap.get(freq);</span><br><span class="line">        set.remove(node);</span><br><span class="line">        <span class="comment">//如果删掉的刚好是最小频次，并且只存在一个这样的node，需要更新min</span></span><br><span class="line">        <span class="keyword">if</span>(freq==min&amp;&amp;set.size()==<span class="number">0</span>)&#123;</span><br><span class="line">            min=freq+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//node对应的频次加1</span></span><br><span class="line">        node.freq++;</span><br><span class="line">        <span class="comment">//找到node新的频次对应的双向链表</span></span><br><span class="line">        LinkedHashSet&lt;Node&gt; newSet=freqMap.get(node.freq);</span><br><span class="line">        <span class="keyword">if</span>(newSet==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果为空，新建一个，并放到缓存</span></span><br><span class="line">            newSet=<span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">            freqMap.put(node.freq,newSet);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在新的频次对应的双向链表中添加node</span></span><br><span class="line">        newSet.add(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据策略从双向链表删掉对应的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">removeNode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//找到最小频次对应的双向链表</span></span><br><span class="line">        LinkedHashSet&lt;Node&gt; set=freqMap.get(min);</span><br><span class="line">        <span class="comment">//找到该链表中最早进来的node</span></span><br><span class="line">        Node deadNode=set.iterator().next();</span><br><span class="line">        <span class="comment">//移除掉这个node</span></span><br><span class="line">        set.remove(deadNode);</span><br><span class="line">        <span class="keyword">return</span> deadNode;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在频次为1的链表中添加新的node</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNode</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="comment">//找到频次为1的链表</span></span><br><span class="line">        LinkedHashSet&lt;Node&gt; set=freqMap.get(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(set==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果为空，新建一个并放入频次map</span></span><br><span class="line">            set=<span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">            freqMap.put(<span class="number">1</span>,set);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加node，并设置min为1</span></span><br><span class="line">        set.add(node);</span><br><span class="line">        min=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">这是牛客TOP101的题解。</summary>
    
    
    
    <category term="solution" scheme="http://decucin.github.io/categories/solution/"/>
    
    
    <category term="牛客" scheme="http://decucin.github.io/tags/%E7%89%9B%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>2022年leetcode每日一题</title>
    <link href="http://decucin.github.io/2022/01/01/2022%E5%B9%B41%E6%9C%88/"/>
    <id>http://decucin.github.io/2022/01/01/2022%E5%B9%B41%E6%9C%88/</id>
    <published>2022-01-01T11:08:37.000Z</published>
    <updated>2022-03-21T06:43:42.012Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="2022年1月"><a href="#2022年1月" class="headerlink" title="2022年1月"></a>2022年1月</h1><h2 id="1-1-将一维数组转变成二维数组"><a href="#1-1-将一维数组转变成二维数组" class="headerlink" title="1/1 将一维数组转变成二维数组"></a>1/1 <a href="https://leetcode-cn.com/problems/convert-1d-array-into-2d-array/" target="_blank" rel="noopener">将一维数组转变成二维数组</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个下标从 0 开始的一维整数数组 original 和两个整数 m 和  n 。你需要使用 original 中 所有 元素创建一个 m 行 n 列的二维数组。</p><p>original 中下标从 0 到 n - 1 （都 包含 ）的元素构成二维数组的第一行，下标从 n 到 2 * n - 1 （都 包含 ）的元素构成二维数组的第二行，依此类推。</p><p>请你根据上述过程返回一个 m x n 的二维数组。如果无法构成这样的二维数组，请你返回一个空的二维数组。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：original &#x3D; [1,2,3,4], m &#x3D; 2, n &#x3D; 2</span><br><span class="line">输出：[[1,2],[3,4]]</span><br><span class="line">解释：</span><br><span class="line">构造出的二维数组应该包含 2 行 2 列。</span><br><span class="line">original 中第一个 n&#x3D;2 的部分为 [1,2] ，构成二维数组的第一行。</span><br><span class="line">original 中第二个 n&#x3D;2 的部分为 [3,4] ，构成二维数组的第二行。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：original &#x3D; [1,2,3], m &#x3D; 1, n &#x3D; 3</span><br><span class="line">输出：[[1,2,3]]</span><br><span class="line">解释：</span><br><span class="line">构造出的二维数组应该包含 1 行 3 列。</span><br><span class="line">将 original 中所有三个元素放入第一行中，构成要求的二维数组。</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：original &#x3D; [1,2], m &#x3D; 1, n &#x3D; 1</span><br><span class="line">输出：[]</span><br><span class="line">解释：</span><br><span class="line">original 中有 2 个元素。</span><br><span class="line">无法将 2 个元素放入到一个 1x1 的二维数组中，所以返回一个空的二维数组。</span><br></pre></td></tr></table></figure><p>示例 4：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：original &#x3D; [3], m &#x3D; 1, n &#x3D; 2</span><br><span class="line">输出：[]</span><br><span class="line">解释：</span><br><span class="line">original 中只有 1 个元素。</span><br><span class="line">无法将 1 个元素放满一个 1x2 的二维数组，所以返回一个空的二维数组。</span><br></pre></td></tr></table></figure><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><ul><li><p><code>1 &lt;= original.length &lt;= 5 * 104</code></p></li><li><p><code>1 &lt;= original[i] &lt;= 105</code></p></li><li><p><code>1 &lt;= m, n &lt;= 4 * 104</code></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>2022年，从快乐的简单题开始，这题很简单，就是将一个一位数组按照给定的行列数转换为二维数组，首先需要考虑的就是此一位数组能否被重构为一个二维数组，直接判断一维数组中的元素个数与要求构造的数组的元素个数是否相等即可，之后便是遍历一维数组，每个列数个元素就另起一行即可，总的时间复杂度是O(m * n)，详细题解如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] construct2DArray(<span class="keyword">int</span>[] original, <span class="keyword">int</span> m, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(original.length != m * n)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">int</span> curIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                res[i][j] = original[curIndex++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h4><p>开始写的时候忘记了如何构造一个空数组，看题解发现只需根据数组的维数，利用new int[0]即可，只要第一个维度的大小为0即可，之后的维度大小不用填。</p></li></ul>]]></content>
    
    
    <summary type="html">这是2022年一月的部分leetcode题解。</summary>
    
    
    
    <category term="solution" scheme="http://decucin.github.io/categories/solution/"/>
    
    
    <category term="leetcode" scheme="http://decucin.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>小程序后端部署时遇到的问题</title>
    <link href="http://decucin.github.io/2021/06/09/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%B0%86%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://decucin.github.io/2021/06/09/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%B0%86%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2021-06-09T11:08:37.000Z</published>
    <updated>2022-03-21T06:45:29.942Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="找不到jar包"><a href="#找不到jar包" class="headerlink" title="找不到jar包"></a>找不到jar包</h1><p>首先是Linux下没有tesseract，报错xxx.io在jar包中找不到</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>首先就是在Linux服务器下安装tesseract，按照网上的教程安装即可（可参照这两篇博客：<a href="https://www.cnblogs.com/dajianshi/p/4932882.html" target="_blank" rel="noopener">https://www.cnblogs.com/dajianshi/p/4932882.html</a> ，<a href="https://blog.csdn.net/qq_40907977/article/details/103913057），但之后发现依旧报错，找了好久最终找到了解决方案。" target="_blank" rel="noopener">https://blog.csdn.net/qq_40907977/article/details/103913057），但之后发现依旧报错，找了好久最终找到了解决方案。</a></p><p>我选择的解决方法说是讲所需的（即错误提示中显示没有的.io文件拷贝到项目中的resource目录下的linux-x86-64（新建的）再次进行打包），此时问题得到解决。</p><h2 id="上面的问题解决后又报错"><a href="#上面的问题解决后又报错" class="headerlink" title="上面的问题解决后又报错"></a>上面的问题解决后又报错</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Error opening data file &#x2F;tesseract-3.04.00&#x2F;tessdata&#x2F;eng.traineddata</span><br><span class="line">Please make sure the TESSDATA_PREFIX environment variable is set to the parent directory of your &quot;tessdata&quot; directory.</span><br><span class="line">Failed loading language &#39;eng&#39;</span><br><span class="line">Tesseract couldn&#39;t load any languages!</span><br></pre></td></tr></table></figure><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>按照错误的提示内容，这很显然是没有英文识别库，因此到对应目录下下载好英文识别库即可，英文、中文简体、中文繁体的下载文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate https:&#x2F;&#x2F;github.com&#x2F;tesseract-ocr&#x2F;tessdata&#x2F;raw&#x2F;master&#x2F;eng.traineddata</span><br><span class="line">wget --no-check-certificate https:&#x2F;&#x2F;github.com&#x2F;tesseract-ocr&#x2F;tessdata&#x2F;raw&#x2F;master&#x2F;chi_sim.traineddata </span><br><span class="line">wget --no-check-certificate https:&#x2F;&#x2F;github.com&#x2F;tesseract-ocr&#x2F;tessdata&#x2F;raw&#x2F;master&#x2F;chi_tra.traineddata</span><br></pre></td></tr></table></figure><p>至此，问题得到解决！</p><h1 id="部署后发现关闭shell应用立即停止"><a href="#部署后发现关闭shell应用立即停止" class="headerlink" title="部署后发现关闭shell应用立即停止"></a>部署后发现关闭shell应用立即停止</h1><h2 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h2><p>使用screen</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -S yourname</span><br></pre></td></tr></table></figure><h2 id="再次报错"><a href="#再次报错" class="headerlink" title="再次报错"></a>再次报错</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Suppressed: java.lang.UnsatisfiedLinkError: libxxx.so: 无法打开共享对象文件: 没有那个文件或目录</span><br></pre></td></tr></table></figure><h2 id="解决办法-2"><a href="#解决办法-2" class="headerlink" title="解决办法"></a>解决办法</h2><p>1）、直接将路径/usr/local/lib路径加入到文件/etc/ld.so.conf文件的中。在文件/etc/ld.so.conf中末尾直接添加：/usr/local/lib；</p><p>2）、再次运行ldconfig，使所有的库文件都被缓存到文件/etc/ld.so.cache中。</p><h1 id="关闭screen"><a href="#关闭screen" class="headerlink" title="关闭screen"></a>关闭screen</h1><h2 id="解决办法-3"><a href="#解决办法-3" class="headerlink" title="解决办法"></a>解决办法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -S session_name -X quit</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">第一次将小程序后端部署到服务器遇到很多让人头大的问题（因为用到了tesseract），项目是部署在Linux服务器，而Linux下又没有对应的环境。网上的教程大多一致（而且尝试之后并没用），因此记录一下出现的问题以及解决的方案。</summary>
    
    
    
    <category term="项目" scheme="http://decucin.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="问题" scheme="http://decucin.github.io/tags/%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>早期每日一题</title>
    <link href="http://decucin.github.io/2021/04/13/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    <id>http://decucin.github.io/2021/04/13/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</id>
    <published>2021-04-13T11:08:37.000Z</published>
    <updated>2022-03-21T06:44:49.996Z</updated>
    
    <content type="html"><![CDATA[<p>此处记录我leetcode的每日一题题解，由于是初学，因此很多地方可能会解释不清，所给题解也不一定是最优解（大部分是引用了官方题解）！</p><a id="more"></a><h2 id="2021-4-13"><a href="#2021-4-13" class="headerlink" title="2021/4/13"></a>2021/4/13</h2><h3 id="题目：二叉搜索树节点最小距离"><a href="#题目：二叉搜索树节点最小距离" class="headerlink" title="题目：二叉搜索树节点最小距离"></a>题目：<a href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/" target="_blank" rel="noopener">二叉搜索树节点最小距离</a></h3><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给你一个二叉搜索树的根节点 <code>root</code> ，返回 <strong>树中任意两不同节点值之间的最小差值</strong> 。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>首先应该明白的一点，什么是二叉搜索树，其具有什么特性，这些特性中哪些是能帮助解题的。</p><p>接下来只要回答上面的问题即可。</p><p>首先什么是二叉搜索树：</p><p><a href="https://baike.baidu.com/item/二叉查找树/7077965" target="_blank" rel="noopener">二叉查找树</a>（Binary Search Tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的<a href="https://baike.baidu.com/item/二叉树/1602879" target="_blank" rel="noopener">二叉树</a>： 若它的左子树不空，则左子树上所有结点的值均小于它的<a href="https://baike.baidu.com/item/根结点/9795570" target="_blank" rel="noopener">根结点</a>的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为<a href="https://baike.baidu.com/item/二叉排序树/10905079" target="_blank" rel="noopener">二叉排序树</a>。二叉搜索树作为一种经典的数据结构，它既有链表的快速插入与删除操作的特点，又有数组快速查找的优势；所以应用十分广泛，例如在文件系统和数据库系统一般会采用这种数据结构进行高效率的排序与检索操作。</p><p>之后是其具有的性质：</p><p>1.若任意结点的左子树不空，则左子树上所有结点的值均不大于它的根结点的值。</p><p>2.若任意结点的右子树不空，则右子树上所有结点的值均不小于它的根结点的值。</p><p>3.任意结点的左、右子树也分别为二叉搜索树。</p><p>其中能帮助我们解题的部分：</p><p>由二叉搜索树的性质可知，将二叉搜索树中序遍历能得到一个有序数组，由此相邻两个元素之间差值的最小值即为题目所求。</p><p>经此分析已得到解题方法，现在考虑对其进行优化，若是将遍历结果放到数组中无疑会增加空间，除此之外遍历时也比较繁琐，但如果增加pre指针指向前一个元素，那便可在遍历的同时直接更新相邻元素的最小值，即题目所求。但此方法切记pre的值最初应该设为一个负值，之后更新为节点的数据。</p><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pre;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDiffInBST</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        pre = -<span class="number">1</span>;</span><br><span class="line">        ans = Integer.MAX_VALUE;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        <span class="keyword">if</span>(pre == -<span class="number">1</span>)&#123;</span><br><span class="line">            pre = root.val;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans = Math.min(ans, root.val - pre);</span><br><span class="line">            pre = root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2021-4-14"><a href="#2021-4-14" class="headerlink" title="2021/4/14"></a>2021/4/14</h2><h3 id="题目：实现-Trie-前缀树"><a href="#题目：实现-Trie-前缀树" class="headerlink" title="题目：实现 Trie (前缀树)"></a>题目：<a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/" target="_blank" rel="noopener">实现 Trie (前缀树)</a></h3><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>Trie（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p><p>请你实现 Trie 类：</p><p>Trie() 初始化前缀树对象。<br>void insert(String word) 向前缀树中插入字符串 word 。<br>boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。<br>boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>什么是前缀树？</p><p><a href="https://baike.baidu.com/item/%E5%AD%97%E5%85%B8%E6%A0%91/9825209?fromtitle=%E5%89%8D%E7%BC%80%E6%A0%91&fromid=2501595&fr=aladdin" target="_blank" rel="noopener">字典树</a>，又称单词查找树，<a href="https://baike.baidu.com/item/Trie树" target="_blank" rel="noopener">Trie树</a>，是一种<a href="https://baike.baidu.com/item/树形结构/9663807" target="_blank" rel="noopener">树形结构</a>，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的<a href="https://baike.baidu.com/item/字符" target="_blank" rel="noopener">字符</a>串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。</p><p>前缀树的性质：</p><p>根节点不包含字符，除根节点外每一个节点都只包含一个字符； 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串； 每个节点的所有子节点包含的字符都不相同。</p><p>综上，前缀树的每个节点用于表示单词的一个字母，从根节点开始，每个节点至多有26个节点（26个小写字母），所以得到前缀树应该具有的元素，一个标志其是否为词尾元素的标记符，用于保存子节点的节点数组。</p><p>至于初始化操作，只需要分别初始化标志符（置为false）和节点数组（置为null）。</p><p>插入操作只需将需要插入的字符一个一个放入前缀树中，每放入一个字符，二叉树的节点就向下移动到插入的位置即可，在插入完成后记得将此节点的标志符置为true，表示某个词的结束。</p><p>检索单词是否在前缀树中：按照单词中每个字母出现的顺序探索前缀树，若能一直向下探索并且最后的节点是某个词的结束（标识符为true），那么单词便在前缀树中，反之则不在。</p><p>检索前缀是否为插入的字符串的前缀：与检索单词类似，也是一直向下探索，但最后无需分辨是否是某个词的结束，即能够向下遍历便说明前缀存在，反之不存在。</p><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isEnd;</span><br><span class="line">    <span class="keyword">private</span> Trie[] next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isEnd = <span class="keyword">false</span>;</span><br><span class="line">        next = <span class="keyword">new</span> Trie[<span class="number">26</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        Trie node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.next[word.charAt(i) - <span class="string">'a'</span>] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                node.next[word.charAt(i) - <span class="string">'a'</span>] = <span class="keyword">new</span> Trie();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.next[word.charAt(i)- <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        node.isEnd = <span class="keyword">true</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        Trie node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.next[word.charAt(i) - <span class="string">'a'</span>] != <span class="keyword">null</span>)&#123;</span><br><span class="line">                node = node.next[word.charAt(i) - <span class="string">'a'</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.isEnd == <span class="keyword">true</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        Trie node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.next[prefix.charAt(i) - <span class="string">'a'</span>] != <span class="keyword">null</span>)&#123;</span><br><span class="line">                node = node.next[prefix.charAt(i) - <span class="string">'a'</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2021-4-15"><a href="#2021-4-15" class="headerlink" title="2021/4/15"></a>2021/4/15</h2><h3 id="题目：打家劫舍-II"><a href="#题目：打家劫舍-II" class="headerlink" title="题目：打家劫舍 II"></a>题目：<a href="https://leetcode-cn.com/problems/house-robber-ii/" target="_blank" rel="noopener">打家劫舍 II</a></h3><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，能够偷窃到的最高金额。</p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>首先不考虑房子是否围成一圈，那么这题的情形可分为以下几类：</p><p>1、一间房子都没有，那么很显然小偷啥也偷不到；</p><p>2、只有一间房子，那么小偷只能偷这件房子；</p><p>3、只有两间房子，小偷偷这两件房子中存钱较多的那间；</p><p>4、当房子数上升到三间及以上，不妨设其为k，那就有意思了，你有了两个选择，即是否偷盗最后一间k，如果偷的话，那所求的就是前k-2个房间的可盗窃的最大金额再加上最后一间房的金额，如果不偷的话，那所求的就是前k-1个房间的可盗窃的最大金额</p><p>很显然，这是一个动态规划的问题，若dp[i]表示前i间房的可盗窃的最大金额，那么转移方程为：dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])，由此这个问题就得到解决。</p><p>下面考虑房子围成一圈的情况：前几类并没有什么不同，只是当房间数大于或等于三时，也需要考虑是否偷窃最后一间房，若是偷窃的话，那第一间房就不能偷窃，即偷窃范围是[1, k-1]，若是不偷窃最后一间，那偷窃范围为[0, k-2]，再将此两种情形分别按照房子不围成一圈的情况去讨论，得到两者的最大值，就是题目所求。</p><p>完整题解如下（这里只是参照官方题解，将动态规划单独作为函数，使代码更规范）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums.length==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> Math.max(robPd(nums, <span class="number">0</span>, nums.length - <span class="number">2</span>), robPd(nums, <span class="number">1</span>, nums.length - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">robPd</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> first = nums[start], second = Math.max(nums[start], nums[start + <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start + <span class="number">2</span>; i &lt;= end; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = second;</span><br><span class="line">            second = Math.max(temp, first + nums[ i]);</span><br><span class="line">            first = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2021-4-16"><a href="#2021-4-16" class="headerlink" title="2021/4/16"></a>2021/4/16</h2><h3 id="题目：扰乱字符串"><a href="#题目：扰乱字符串" class="headerlink" title="题目：扰乱字符串"></a>题目：<a href="https://leetcode-cn.com/problems/scramble-string/" target="_blank" rel="noopener">扰乱字符串</a></h3><h3 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h3><p>使用下面描述的算法可以扰乱字符串 s 得到字符串 t ：<br>如果字符串的长度为 1 ，算法停止<br>如果字符串的长度 &gt; 1 ，执行下述步骤：<br>在一个随机下标处将字符串分割成两个非空的子字符串。即，如果已知字符串 s ，则可以将其分成两个子字符串 x 和 y ，且满足 s = x + y 。<br>随机 决定是要「交换两个子字符串」还是要「保持这两个子字符串的顺序不变」。即，在执行这一步骤之后，s 可能是 s = x + y 或者 s = y + x 。<br>在 x 和 y 这两个子字符串上继续从步骤 1 开始递归执行此算法。<br>给你两个 长度相等 的字符串 s1 和 s2，判断 s2 是否是 s1 的扰乱字符串。如果是，返回 true ；否则，返回 false 。</p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>这题完全是一脸懵逼，看到题目的时候完全没有思路，官方给出的题解也是没怎么看懂，这里先照搬<a href="https://leetcode-cn.com/problems/scramble-string/solution/rao-luan-zi-fu-chuan-by-leetcode-solutio-8r9t/" target="_blank" rel="noopener">官方题解</a>，以后若是有思路再回来重写题解。</p><p>完整代码如下（也是来自官方）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记忆化搜索存储状态的数组</span></span><br><span class="line">    <span class="comment">// -1 表示 false，1 表示 true，0 表示未计算</span></span><br><span class="line">    <span class="keyword">int</span>[][][] memo;</span><br><span class="line">    String s1, s2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isScramble</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = s1.length();</span><br><span class="line">        <span class="keyword">this</span>.memo = <span class="keyword">new</span> <span class="keyword">int</span>[length][length][length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">this</span>.s1 = s1;</span><br><span class="line">        <span class="keyword">this</span>.s2 = s2;</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个字符串从 i1 开始，第二个字符串从 i2 开始，子串的长度为 length，是否和谐</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i1, <span class="keyword">int</span> i2, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (memo[i1][i2][length] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[i1][i2][length] == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断两个子串是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (s1.substring(i1, i1 + length).equals(s2.substring(i2, i2 + length))) &#123;</span><br><span class="line">            memo[i1][i2][length] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否存在字符 c 在两个子串中出现的次数不同</span></span><br><span class="line">        <span class="keyword">if</span> (!checkIfSimilar(i1, i2, length)) &#123;</span><br><span class="line">            memo[i1][i2][length] = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 枚举分割位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; ++i) &#123;</span><br><span class="line">            <span class="comment">// 不交换的情况</span></span><br><span class="line">            <span class="keyword">if</span> (dfs(i1, i2, i) &amp;&amp; dfs(i1 + i, i2 + i, length - i)) &#123;</span><br><span class="line">                memo[i1][i2][length] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 交换的情况</span></span><br><span class="line">            <span class="keyword">if</span> (dfs(i1, i2 + length - i, i) &amp;&amp; dfs(i1 + i, i2, length - i)) &#123;</span><br><span class="line">                memo[i1][i2][length] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        memo[i1][i2][length] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkIfSimilar</span><span class="params">(<span class="keyword">int</span> i1, <span class="keyword">int</span> i2, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; freq = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = i1; i &lt; i1 + length; ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s1.charAt(i);</span><br><span class="line">            freq.put(c, freq.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = i2; i &lt; i2 + length; ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s2.charAt(i);</span><br><span class="line">            freq.put(c, freq.getOrDefault(c, <span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : freq.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">int</span> value = entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (value != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2021-4-17"><a href="#2021-4-17" class="headerlink" title="2021/4/17"></a>2021/4/17</h2><h3 id="题目：存在重复元素-III"><a href="#题目：存在重复元素-III" class="headerlink" title="题目：存在重复元素 III"></a>题目：<a href="https://leetcode-cn.com/problems/contains-duplicate-iii/" target="_blank" rel="noopener">存在重复元素 III</a></h3><h3 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h3><p>给你一个整数数组 nums 和两个整数 k 和 t 。请你判断是否存在 两个不同下标 i 和 j，使得 abs(nums[i] - nums[j]) &lt;= t ，同时又满足 abs(i - j) &lt;= k 。</p><p>如果存在则返回 true，不存在返回 false。</p><h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><p>两种思路，一种是滑动窗口，一种是桶排序。</p><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>首先判断是否满足abs(i - j) &lt;= k，若某元素元素下标为i，则满足此条件的下标范围为[i - k, i + k]，其次判断是否满足abs(nums[i] - nums[j]) &lt;= t，满足此条件的元素取值为[nums[i] - t, nums[i] + t]（集合表示，即包含等于），接下来只需进行判断即可。</p><p>完整代码如下（TreeSet中的ceiling()函数返回TreeSet中符合条件的最小值）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line"></span><br><span class="line">        TreeSet&lt;Long&gt; set = <span class="keyword">new</span> TreeSet&lt;Long&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            Long ceiling = set.ceiling((<span class="keyword">long</span>)nums[i] - (<span class="keyword">long</span>)t);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(ceiling != <span class="keyword">null</span> &amp;&amp; ceiling &lt;= (<span class="keyword">long</span>)nums[i] + (<span class="keyword">long</span>)t)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            set.add((<span class="keyword">long</span>)nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k)</span><br><span class="line">                set.remove((<span class="keyword">long</span>)nums[i - k]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><p>按元素的大小进行分桶，假设桶的大小为t + 1，如果两个元素属于一个桶，那这两个元素必然符合条件，若两个元素处于相邻桶，则进一步进行判断，若是不属于相邻桶也不属于一个桶，那必然不符合条件。</p><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        Map&lt;Long, Long&gt; map = <span class="keyword">new</span> HashMap&lt;Long, Long&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> w = (<span class="keyword">long</span>) t + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">long</span> id = getId(nums[i], w);</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(id))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(id - <span class="number">1</span>) &amp;&amp; Math.abs(nums[i] - map.get(id - <span class="number">1</span>)) &lt; w)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(id + <span class="number">1</span>) &amp;&amp; Math.abs(nums[i] - map.get(id + <span class="number">1</span>)) &lt; w)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            map.put(id, (<span class="keyword">long</span>) nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k)</span><br><span class="line">                map.remove(getId(nums[i - k], w));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">long</span> w)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> x/w;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> (x + <span class="number">1</span>)/w - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2021-4-18"><a href="#2021-4-18" class="headerlink" title="2021/4/18"></a>2021/4/18</h2><h3 id="题目：删除有序数组中的重复项"><a href="#题目：删除有序数组中的重复项" class="headerlink" title="题目：删除有序数组中的重复项"></a>题目：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">删除有序数组中的重复项</a></h3><h3 id="描述-5"><a href="#描述-5" class="headerlink" title="描述"></a>描述</h3><p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><p>说明:</p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="line">int len &#x3D; removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">&#x2F;&#x2F; 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span><br><span class="line">for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h3><p>这题使用双指针进行解决，快指针表示遍历数组到达的下标位置，慢指针表示下一个不同元素要填入的下标位置，如果数组长度为0，直接返回0，第一个元素是必须保留的，因此两个指针都从下标1开始。如若快指针和其前一位不相等，那慢指针所在的位置填充快指针所指的内容。</p><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> fast = <span class="number">1</span>, slow = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fast] != nums[fast - <span class="number">1</span>]) &#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                ++slow;</span><br><span class="line">            &#125;</span><br><span class="line">            ++fast;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2021-4-19"><a href="#2021-4-19" class="headerlink" title="2021/4/19"></a>2021/4/19</h2><h3 id="题目：移除元素"><a href="#题目：移除元素" class="headerlink" title="题目：移除元素"></a>题目：<a href="https://leetcode-cn.com/problems/remove-element/" target="_blank" rel="noopener">移除元素</a></h3><h3 id="描述-6"><a href="#描述-6" class="headerlink" title="描述"></a>描述</h3><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><h3 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h3><p>这题和前一天的题是一样的，都可以通过双指针进行解决，左指针表示下一个将要赋值的位置，右指针表示遍历数组到达的下标位置，若是右指针所指的值不为val，那左指针赋值所在的位置赋值右指针的值。</p><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != val)&#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                ++slow;</span><br><span class="line">            &#125;</span><br><span class="line">            ++fast;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>考虑右指针从数组末尾开始向前遍历，若是左指针值为val，那赋值右指针，右指针减一，这样当左右指针相遇时就完成了遍历。</p><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left] == val)</span><br><span class="line">                nums[left] = nums[--right];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ++left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2021-4-20"><a href="#2021-4-20" class="headerlink" title="2021/4/20"></a>2021/4/20</h2><h3 id="题目：实现-strStr"><a href="#题目：实现-strStr" class="headerlink" title="题目：实现 strStr()"></a>题目：<a href="https://leetcode-cn.com/problems/implement-strstr/" target="_blank" rel="noopener">实现 strStr()</a></h3><h3 id="描述-7"><a href="#描述-7" class="headerlink" title="描述"></a>描述</h3><p>实现 strStr() 函数。</p><p>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。</p><p>说明：</p><p>当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p><p>对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。</p><h3 id="题解-7"><a href="#题解-7" class="headerlink" title="题解"></a>题解</h3><p>经典字符串匹配问题，常见的方法有暴力匹配以及KMP算法两种。</p><h4 id="暴力匹配"><a href="#暴力匹配" class="headerlink" title="暴力匹配"></a>暴力匹配</h4><p>这个就比较简单了，逐个查询，找到和所需查找字符串相等的第一个字符所在位置，进行第二层查找，向后进行查找，若是每个都匹配，则将第一个字符所在位置置为true，遍历时只需判断其为true时返回</p><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = haystack.length(), m = needle.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + m &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (haystack.charAt(i + j) != needle.charAt(j)) &#123;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h4><p>这个算法没怎么弄懂，对于字串的处理没理解，这里建议参照<a href="https://leetcode-cn.com/problems/implement-strstr/solution/shi-xian-strstr-by-leetcode-solution-ds6y/" target="_blank" rel="noopener">官方题解</a></p><p>完整代码如下（来自官方）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = haystack.length(), m = needle.length();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] pi = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; needle.charAt(i) != needle.charAt(j)) &#123;</span><br><span class="line">                j = pi[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (needle.charAt(i) == needle.charAt(j)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            pi[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; haystack.charAt(i) != needle.charAt(j)) &#123;</span><br><span class="line">                j = pi[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (haystack.charAt(i) == needle.charAt(j)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2021-4-21"><a href="#2021-4-21" class="headerlink" title="2021/4/21"></a>2021/4/21</h2><h3 id="题目：解码方法"><a href="#题目：解码方法" class="headerlink" title="题目：解码方法"></a>题目：<a href="https://leetcode-cn.com/problems/decode-ways/" target="_blank" rel="noopener">解码方法</a></h3><h3 id="描述-8"><a href="#描述-8" class="headerlink" title="描述"></a>描述</h3><p>一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#39;A&#39; -&gt; 1</span><br><span class="line">&#39;B&#39; -&gt; 2</span><br><span class="line">...</span><br><span class="line">&#39;Z&#39; -&gt; 26</span><br></pre></td></tr></table></figure><p>要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，”11106” 可以映射为：</p><p>“AAJF” ，将消息分组为 (1 1 10 6)<br>“KJF” ，将消息分组为 (11 10 6)<br>注意，消息不能分组为  (1 11 06) ，因为 “06” 不能映射为 “F” ，这是由于 “6” 和 “06” 在映射中并不等价。</p><p>给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。</p><p>题目数据保证答案肯定是一个 32 位 的整数。</p><h3 id="题解-8"><a href="#题解-8" class="headerlink" title="题解"></a>题解</h3><p>这题采用动态规划的思想进行求解，设字符串s前i个字符的解码方法为fi，进行状态转移时需考虑最后一个字符所采用的解码方式，若是仅用了一个字符进行解码，那只要s[i]不为0，即可被解码为A~I中的任何一个，此时前i个字符的解码方式与前i-1个字符的解码方式相同；若是用了两个字符进行解析，那最后一个字符需满足几个要求：首先s[i]不为0，其次s[i - 2]也不能为0，否则无法选择s[i - 2] s[i - 1]两个字符进行解析，最后应满足s[i - 2]与s[i - 1]两个字符拼接而成的字符不大于26，即s[i - 2] * 10 + s[i - 1] &lt;= 26。</p><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> []f = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i - <span class="number">1</span>) != <span class="string">'0'</span>)&#123;</span><br><span class="line">                f[i] += f[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">1</span> &amp;&amp; s.charAt(i - <span class="number">2</span>) != <span class="string">'0'</span> &amp;&amp; (s.charAt(i - <span class="number">2</span>) - <span class="string">'0'</span>) * <span class="number">10</span> + s.charAt(i - <span class="number">1</span>) - <span class="string">'0'</span> &lt;= <span class="number">26</span>)&#123;</span><br><span class="line">                f[i] += f[i - <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h4><p>注意到在状态转移方程中，前i个字符的解码方式仅与前i -2个字符的解码方式以及前i - 1个字符的解码方式有关，因此我们可以使用三个变量进行状态转移，省去数组的空间。</p><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="comment">// a = f[i-2], b = f[i-1], c=f[i]</span></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>, c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            c = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) != <span class="string">'0'</span>) &#123;</span><br><span class="line">                c += b;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">1</span> &amp;&amp; s.charAt(i - <span class="number">2</span>) != <span class="string">'0'</span> &amp;&amp; ((s.charAt(i - <span class="number">2</span>) - <span class="string">'0'</span>) * <span class="number">10</span> + (s.charAt(i - <span class="number">1</span>) - <span class="string">'0'</span>) &lt;= <span class="number">26</span>)) &#123;</span><br><span class="line">                c += a;</span><br><span class="line">            &#125;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2021-4-22"><a href="#2021-4-22" class="headerlink" title="2021/4/22"></a>2021/4/22</h2><h3 id="题目：矩形区域不超过-K-的最大数值和"><a href="#题目：矩形区域不超过-K-的最大数值和" class="headerlink" title="题目：矩形区域不超过 K 的最大数值和"></a>题目：<a href="https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/" target="_blank" rel="noopener">矩形区域不超过 K 的最大数值和</a></h3><h3 id="描述-9"><a href="#描述-9" class="headerlink" title="描述"></a>描述</h3><p>给你一个 m x n 的矩阵 matrix 和一个整数 k ，找出并返回矩阵内部矩形区域的不超过 k 的最大数值和。</p><p>题目数据保证总会存在一个数值和不超过 k 的矩形区域。</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2021/03/18/sum-grid.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,0,1],[0,-2,3]], k &#x3D; 2</span><br><span class="line">输出：2</span><br><span class="line">解释：蓝色边框圈出来的矩形区域 [[0, 1], [-2, 3]] 的数值和是 2，且 2 是不超过 k 的最大数字（k &#x3D; 2）。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix &#x3D; [[2,2,-1]], k &#x3D; 3</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><h3 id="题解-9"><a href="#题解-9" class="headerlink" title="题解"></a>题解</h3><p>来不及解释了，上<a href="https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/solution/" target="_blank" rel="noopener">官方题解</a></p><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSumSubmatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123; <span class="comment">// 枚举上边界</span></span><br><span class="line">            <span class="keyword">int</span>[] sum = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; m; ++j) &#123; <span class="comment">// 枚举下边界</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; n; ++c) &#123;</span><br><span class="line">                    sum[c] += matrix[j][c]; <span class="comment">// 更新每列的元素和</span></span><br><span class="line">                &#125;</span><br><span class="line">                TreeSet&lt;Integer&gt; sumSet = <span class="keyword">new</span> TreeSet&lt;Integer&gt;();</span><br><span class="line">                sumSet.add(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> v : sum) &#123;</span><br><span class="line">                    s += v;</span><br><span class="line">                    Integer ceil = sumSet.ceiling(s - k);</span><br><span class="line">                    <span class="keyword">if</span> (ceil != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        ans = Math.max(ans, s - ceil);</span><br><span class="line">                    &#125;</span><br><span class="line">                    sumSet.add(s);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2021-4-23"><a href="#2021-4-23" class="headerlink" title="2021/4/23"></a>2021/4/23</h2><h3 id="题目：最大整除子集"><a href="#题目：最大整除子集" class="headerlink" title="题目：最大整除子集"></a>题目：<a href="https://leetcode-cn.com/problems/largest-divisible-subset/" target="_blank" rel="noopener">最大整除子集</a></h3><h3 id="描述-10"><a href="#描述-10" class="headerlink" title="描述"></a>描述</h3><p>给你一个由 无重复 正整数组成的集合 nums ，请你找出并返回其中最大的整除子集 answer ，子集中每一元素对 (answer[i], answer[j]) 都应当满足：<br>answer[i] % answer[j] == 0 ，或<br>answer[j] % answer[i] == 0<br>如果存在多个有效解子集，返回其中任何一个均可。</p><h3 id="题解-10"><a href="#题解-10" class="headerlink" title="题解"></a>题解</h3><p><a href="https://leetcode-cn.com/problems/largest-divisible-subset/solution/zui-da-zheng-chu-zi-ji-by-leetcode-solut-t4pz/" target="_blank" rel="noopener">官方题解</a></p><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">largestDivisibleSubset</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 1 步：动态规划找出最大子集的个数、最大子集中的最大整数</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> maxSize = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxVal = dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="comment">// 题目中说「没有重复元素」很重要</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] % nums[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dp[i] &gt; maxSize) &#123;</span><br><span class="line">                maxSize = dp[i];</span><br><span class="line">                maxVal = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 2 步：倒推获得最大子集</span></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span> (maxSize == <span class="number">1</span>) &#123;</span><br><span class="line">            res.add(nums[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; maxSize &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == maxSize &amp;&amp; maxVal % nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                res.add(nums[i]);</span><br><span class="line">                maxVal = nums[i];</span><br><span class="line">                maxSize--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2021-4-24"><a href="#2021-4-24" class="headerlink" title="2021/4/24"></a>2021/4/24</h2><h3 id="题目：组合总和-Ⅳ"><a href="#题目：组合总和-Ⅳ" class="headerlink" title="题目：组合总和 Ⅳ"></a>题目：<a href="https://leetcode-cn.com/problems/combination-sum-iv/" target="_blank" rel="noopener">组合总和 Ⅳ</a></h3><h3 id="描述-11"><a href="#描述-11" class="headerlink" title="描述"></a>描述</h3><p>给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。</p><p>题目数据保证答案符合 32 位整数范围。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3], target &#x3D; 4</span><br><span class="line">输出：7</span><br><span class="line">解释：</span><br><span class="line">所有可能的组合为：</span><br><span class="line">(1, 1, 1, 1)</span><br><span class="line">(1, 1, 2)</span><br><span class="line">(1, 2, 1)</span><br><span class="line">(1, 3)</span><br><span class="line">(2, 1, 1)</span><br><span class="line">(2, 2)</span><br><span class="line">(3, 1)</span><br><span class="line">请注意，顺序不同的序列被视作不同的组合。</span><br></pre></td></tr></table></figure><h3 id="题解-11"><a href="#题解-11" class="headerlink" title="题解"></a>题解</h3><p>首先考虑一个问题，如果用dp[i]表示和为i的组合数，那基准条件应该为dp[0] = 1，因为只有不选取任何元素时和才为0（题目说了nums中的数据全为正数），当1 &lt;= i &lt;= target时，组合中最后一个数num必然小于或等于i，此时dp[i]与dp[i - num]应该是相等的，因为对于任何和为 i - num的组合只要在最后加上num和便为i，由此可得到动态规划的做法：</p><p>首先初始化dp[0] = 1；</p><p>遍历i从1到target，对于每个i，遍历数组nums，对于每个num，判断是否小于等于i，若是小于等于i，则将dp[i - num]的值加到dp[i]；</p><p>最终得到的dp[target]即为答案。</p><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">                <span class="keyword">if</span>(num &lt;= i)&#123;</span><br><span class="line">                    dp[i] += dp[i - num];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2021-4-25"><a href="#2021-4-25" class="headerlink" title="2021/4/25"></a>2021/4/25</h2><h3 id="题目：递增顺序搜索树"><a href="#题目：递增顺序搜索树" class="headerlink" title="题目：递增顺序搜索树"></a>题目：<a href="https://leetcode-cn.com/problems/increasing-order-search-tree/" target="_blank" rel="noopener">递增顺序搜索树</a></h3><h3 id="描述-12"><a href="#描述-12" class="headerlink" title="描述"></a>描述</h3><p>给你一棵二叉搜索树，请你 <strong>按中序遍历</strong> 将其重新排列为一棵递增顺序搜索树，使树中最左边的节点成为树的根节点，并且每个节点没有左子节点，只有一个右子节点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/17/ex1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [5,3,6,2,4,null,8,1,null,null,null,7,9]</span><br><span class="line">输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/17/ex2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [5,1,7]</span><br><span class="line">输出：[1,null,5,null,7]</span><br></pre></td></tr></table></figure><h3 id="题解-12"><a href="#题解-12" class="headerlink" title="题解"></a>题解</h3><p>这题题目都说了是二叉搜索树，因此其中序遍历后必然是递增的，对于递增的序列构造没有左节点的顺序搜索树类似于链表（因为只需要考虑一端）。因此此题的思路便是先中序遍历二叉搜索树，并可将遍历结果存至列表中，之后再根据列表中的数据构造顺序搜索树即可（注意在构造顺序搜索树时每次只需对其右子树申请节点即可）。</p><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">increasingBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        inorderBST(root, res);</span><br><span class="line">        TreeNode headNode = <span class="keyword">new</span> TreeNode(-<span class="number">1</span>);</span><br><span class="line">        TreeNode curNode = headNode;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> val  : res)&#123;</span><br><span class="line">            curNode.right = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">            curNode = curNode.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> headNode.right;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorderBST</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorderBST(root.left, res);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        inorderBST(root.right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">2021年4月13日至4月25日leetcode每日一题题解。</summary>
    
    
    
    <category term="solution" scheme="http://decucin.github.io/categories/solution/"/>
    
    
    <category term="leetcode" scheme="http://decucin.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>复数加法器</title>
    <link href="http://decucin.github.io/2021/04/02/%E7%94%A8C%E6%88%96C++%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E5%B9%B6%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8F%AF%E8%BF%9B%E8%A1%8C%E5%A4%8D%E6%95%B0%E8%BF%90%E7%AE%97%E7%9A%84%E6%BC%94%E7%A4%BA%E7%A8%8B%E5%BA%8F/"/>
    <id>http://decucin.github.io/2021/04/02/%E7%94%A8C%E6%88%96C++%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E5%B9%B6%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8F%AF%E8%BF%9B%E8%A1%8C%E5%A4%8D%E6%95%B0%E8%BF%90%E7%AE%97%E7%9A%84%E6%BC%94%E7%A4%BA%E7%A8%8B%E5%BA%8F/</id>
    <published>2021-04-02T11:08:37.000Z</published>
    <updated>2022-03-21T06:47:17.614Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>第一个程序便是复数运算。首先进行科普（不过我相信能看到这篇博客的人不至于连什么是复数都不知道）：</p><p><strong>我们把形如z=a+bi（a,b均为实数）的数称为复数，其中a称为<a href="https://baike.baidu.com/item/实部/53626919" target="_blank" rel="noopener">实部</a>，b称为虚部，i称为<a href="https://baike.baidu.com/item/虚数" target="_blank" rel="noopener">虚数</a>单位。当z的虚部等于零时，常称z为实数；当z的<a href="https://baike.baidu.com/item/虚部/5231815" target="_blank" rel="noopener">虚部</a>不等于零时，实部等于零时，常称z为<a href="https://baike.baidu.com/item/纯虚数/3386848" target="_blank" rel="noopener">纯虚数</a>。复数域是实数域的代数闭包，即任何复系数多项式在复数域中总有根。</strong></p><p>接下来便是真正的进入程序的分析：</p><h1 id="复数的构造"><a href="#复数的构造" class="headerlink" title="复数的构造"></a>复数的构造</h1><p>在c++中，这便是复数类的构造函数。从复数定义中不难看出，复数分为两部分，实部和虚部，一旦确定了实部和虚部，那复数也就唯一确定了。因此构造函数代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cpxNum(double ral, double imag)&#123;</span><br><span class="line">c_ral &#x3D; ral;</span><br><span class="line">c_imag &#x3D; imag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于构造函数中并未进行内存申请，因此不必考虑重新撰写析构函数。</p><h1 id="复数的四则运算"><a href="#复数的四则运算" class="headerlink" title="复数的四则运算"></a>复数的四则运算</h1><p>最先考虑到的便是c++四则运算符的重载，实现起来也比较简单，参照复数四则运算的公式很容易得出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">cpxNum operator+(const cpxNum&amp; c2) &#123;</span><br><span class="line">cpxNum result;</span><br><span class="line">result.c_ral &#x3D; this-&gt;c_ral + c2.c_ral;</span><br><span class="line">result.c_imag &#x3D; this-&gt;c_imag + c2.c_imag;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cpxNum operator-(const cpxNum&amp; c2) &#123;</span><br><span class="line">cpxNum result;</span><br><span class="line">result.c_ral &#x3D; this-&gt;c_ral - c2.c_ral;</span><br><span class="line">result.c_imag &#x3D; this-&gt;c_imag - c2.c_imag;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cpxNum operator*(const cpxNum&amp; c2) &#123;</span><br><span class="line">cpxNum result;</span><br><span class="line">result.c_ral &#x3D; this-&gt;c_ral * c2.c_ral - this-&gt;c_imag * c2.c_imag;</span><br><span class="line">result.c_imag &#x3D; this-&gt;c_ral * c2.c_imag + this-&gt;c_imag * c2.c_ral;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cpxNum operator&#x2F;(const cpxNum&amp; c2) &#123;</span><br><span class="line">cpxNum result;</span><br><span class="line">result.c_ral &#x3D; 0;</span><br><span class="line">result.c_imag &#x3D; (this-&gt;c_ral * c2.c_ral + this-&gt;c_imag * c2.c_imag) * (this-&gt;c_imag * c2.c_ral - this-&gt;c_ral * c2.c_ral) &#x2F; (c2.c_ral * c2.c_ral + c2.c_imag * c2.c_imag);</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="复数的打印"><a href="#复数的打印" class="headerlink" title="复数的打印"></a>复数的打印</h1><p>需要考虑以下几种情况，首先是0（实部虚部均为0），此时直接打印0即可；之后是纯虚数（实部为0），此时不需要打印实部，直接打印虚部即可；再然后是实数（虚部为0），此时不需打印虚部，之后的话再把虚部为负数的情况单独讨论即可，也比较简单，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void print() &#123;</span><br><span class="line">if (c_ral &#x3D;&#x3D; 0.0 &amp;&amp; c_imag &#x3D;&#x3D; 0)</span><br><span class="line">cout &lt;&lt; &#39;0&#39;;</span><br><span class="line">else if (c_imag &#x3D;&#x3D; 0)</span><br><span class="line">cout &lt;&lt; c_ral;</span><br><span class="line">else if (c_ral &#x3D;&#x3D; 0)</span><br><span class="line">cout &lt;&lt; c_imag &lt;&lt; &#39;i&#39;;</span><br><span class="line">else if (c_imag &lt; 0)</span><br><span class="line">cout &lt;&lt; c_ral &lt;&lt; c_imag &lt;&lt; &#39;i&#39;;</span><br><span class="line">else</span><br><span class="line">cout &lt;&lt; c_ral &lt;&lt; &#39;+&#39; &lt;&lt; c_imag &lt;&lt; &#39;i&#39;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>此实验较为简单，毕竟是编程实践1中的第一个实验，主要是为了抽象数据类型ADT的实现，在c++中便是类的体现，算法部分基本没有障碍，只是打印部分需要略微进行考虑。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p>完整代码参考我的<a href="https://github.com/Decucin/-1/tree/main/%E5%A4%8D%E6%95%B0%E8%BF%90%E7%AE%97" target="_blank" rel="noopener">github</a>。</p>]]></content>
    
    
    <summary type="html">上学期的编程实践，觉得很有意思，然后这学期新学了c++，便想到利用c++对上学期的编程实践项目进行复原。</summary>
    
    
    
    <category term="项目" scheme="http://decucin.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="c" scheme="http://decucin.github.io/tags/c/"/>
    
    <category term="c++" scheme="http://decucin.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>第22次ccf-csp</title>
    <link href="http://decucin.github.io/2021/03/21/22%E6%AC%A1CCF-CSP%E8%AE%A4%E8%AF%81%E8%80%83%E8%AF%95/"/>
    <id>http://decucin.github.io/2021/03/21/22%E6%AC%A1CCF-CSP%E8%AE%A4%E8%AF%81%E8%80%83%E8%AF%95/</id>
    <published>2021-03-21T11:08:37.000Z</published>
    <updated>2022-03-21T06:43:04.583Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="灰度直方图"><a href="#灰度直方图" class="headerlink" title="灰度直方图"></a>灰度直方图</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>一幅长宽分别为 n 个像素和 m 个像素的灰度图像可以表示为一个 n×m 大小的矩阵 A。<br>其中每个元素 Aij（0≤i&lt;n、0≤j&lt;m）是一个 [0,L) 范围内的整数，表示对应位置像素的灰度值。<br>具体来说，一个 8 比特的灰度图像中每个像素的灰度范围是 [0,128)。</p><p>一副灰度图像的灰度统计直方图（以下简称“直方图”）可以表示为一个长度为 L 的数组 h，其中 h[x]（0≤x&lt;L）表示该图像中灰度值为 x 的像素个数。显然，h[0] 到 h[L−1] 的总和应等于图像中的像素总数 n⋅m。</p><p>已知一副图像的灰度矩阵 A，试计算其灰度直方图 h[0],h[1],⋯,h[L−1]。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入共 n+1 行。</p><p>输入的第一行包含三个用空格分隔的正整数 n、m 和 L，含义如前文所述。</p><p>第二到第 n+1 行输入矩阵 A。<br>第 i+2（0≤i&lt;n）行包含用空格分隔的 m 个整数，依次为 Ai0,Ai1,⋯,Ai(m−1)。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出仅一行，包含用空格分隔的 L 个整数 h[0],h[1],⋯,h[L−1]，表示输入图像的灰度直方图。</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 4 16</span><br><span class="line">0 1 2 3</span><br><span class="line">4 5 6 7</span><br><span class="line">8 9 10 11</span><br><span class="line">12 13 14 15</span><br></pre></td></tr></table></figure><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1</span><br></pre></td></tr></table></figure><h2 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">7 11 8</span><br><span class="line">0 7 0 0 0 7 0 0 7 7 0</span><br><span class="line">7 0 7 0 7 0 7 0 7 0 7</span><br><span class="line">7 0 0 0 7 0 0 0 7 0 7</span><br><span class="line">7 0 0 0 0 7 0 0 7 7 0</span><br><span class="line">7 0 0 0 0 0 7 0 7 0 0</span><br><span class="line">7 0 7 0 7 0 7 0 7 0 0</span><br><span class="line">0 7 0 0 0 7 0 0 7 0 0</span><br></pre></td></tr></table></figure><h2 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">48 0 0 0 0 0 0 29</span><br></pre></td></tr></table></figure><h2 id="评测用例规模与约定"><a href="#评测用例规模与约定" class="headerlink" title="评测用例规模与约定"></a>评测用例规模与约定</h2><p>全部的测试数据满足 0&lt;n,m≤500 且 4≤L≤256。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> decucin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/9/21 8:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = in.nextInt();</span><br><span class="line">        <span class="keyword">int</span> m = in.nextInt();</span><br><span class="line">        <span class="keyword">int</span> l = in.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] ps = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">260</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = in.nextInt();</span><br><span class="line">                ps[x]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; ++i)&#123;</span><br><span class="line">            System.out.print(ps[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>此题实际需要的是将各个像素对应的频率输出即可，题目中的测试数据L满足4&lt;=l&lt;=256，故考虑额外生成一个N=260的数组，以此数组中的每个位置对应的值作为其出现的次数，之后只需将每个数进行读取，若读到的数字为x，那将新生成矩阵中位置x的值自增1即可，最后进行输出。</p><h1 id="邻域均值"><a href="#邻域均值" class="headerlink" title="邻域均值"></a>邻域均值</h1><h2 id="试题背景"><a href="#试题背景" class="headerlink" title="试题背景"></a>试题背景</h2><p>顿顿在学习了数字图像处理后，想要对手上的一副灰度图像进行降噪处理。不过该图像仅在较暗区域有很多噪点，如果贸然对全图进行降噪，会在抹去噪点的同时也模糊了原有图像。因此顿顿打算先使用<strong>邻域均值</strong>来判断一个像素是否处于<strong>较暗区域</strong>，然后仅对处于<strong>较暗区域</strong>的像素进行降噪处理。</p><h2 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h2><p>待处理的灰度图像长宽皆为 n 个像素，可以表示为一个 n×n 大小的矩阵 A，其中每个元素是一个 [0,L) 范围内的整数，表示对应位置像素的灰度值。<br>对于矩阵中任意一个元素 Aij（0≤i,j&lt;n），其<strong>邻域</strong>定义为附近若干元素的集和：</p><p>Neighbor(i,j,r)={Axy|0≤x,y&lt;n and |x−i|≤r and |y−j|≤r}</p><p>这里使用了一个额外的参数 r 来指明 Aij 附近元素的具体范围。根据定义，易知 Neighbor(i,j,r) 最多有 (2r+1)2 个元素。</p><p>如果元素 Aij <strong>邻域</strong>中所有元素的<strong>平均值</strong>小于或等于一个给定的阈值 t，我们就认为该元素对应位置的像素处于<strong>较暗区域</strong>。<br>下图给出了两个例子，左侧图像的较暗区域在右侧图像中展示为黑色，其余区域展示为白色。</p><p><img src="http://118.190.20.162/RequireFile.do?fid=9GqFey2d" alt="example.jpg"></p><p>现给定邻域参数 r 和阈值 t，试统计输入灰度图像中有多少像素处于<strong>较暗区域</strong>。</p><h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入共 n+1 行。</p><p>输入的第一行包含四个用空格分隔的正整数 n、L、r 和 t，含义如前文所述。</p><p>第二到第 n+1 行输入矩阵 A。</p><p>第 i+2（0≤i&lt;n）行包含用空格分隔的 n 个整数，依次为 Ai0,Ai1,⋯,Ai(n−1)。</p><h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个整数，表示输入灰度图像中处于较暗区域的像素总数。</p><h2 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 16 1 6</span><br><span class="line">0 1 2 3</span><br><span class="line">4 5 6 7</span><br><span class="line">8 9 10 11</span><br><span class="line">12 13 14 15</span><br></pre></td></tr></table></figure><h2 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><h2 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">11 8 2 2</span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0</span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0</span><br><span class="line">0 7 0 0 0 7 0 0 7 7 0</span><br><span class="line">7 0 7 0 7 0 7 0 7 0 7</span><br><span class="line">7 0 0 0 7 0 0 0 7 0 7</span><br><span class="line">7 0 0 0 0 7 0 0 7 7 0</span><br><span class="line">7 0 0 0 0 0 7 0 7 0 0</span><br><span class="line">7 0 7 0 7 0 7 0 7 0 0</span><br><span class="line">0 7 0 0 0 7 0 0 7 0 0</span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0</span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0</span><br></pre></td></tr></table></figure><h2 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">83</span><br></pre></td></tr></table></figure><h2 id="评测用例规模与约定-1"><a href="#评测用例规模与约定-1" class="headerlink" title="评测用例规模与约定"></a>评测用例规模与约定</h2><p>70% 的测试数据满足 n≤100、r≤10。</p><p>全部的测试数据满足 0&lt;n≤600、0&lt;r≤100 且 2≤t&lt;L≤256。</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> decucin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/9/21 8:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = in.nextInt();</span><br><span class="line">        <span class="keyword">int</span> l = in.nextInt();</span><br><span class="line">        <span class="keyword">int</span> r = in.nextInt();</span><br><span class="line">        <span class="keyword">int</span> t = in.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] s = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">610</span>][<span class="number">610</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = in.nextInt();</span><br><span class="line">                s[i][j] = x + s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)&#123;</span><br><span class="line">                <span class="keyword">int</span> x1 = Math.max(<span class="number">1</span>, i - r), y1 = Math.max(<span class="number">1</span>, j - r);</span><br><span class="line">                <span class="keyword">int</span> x2 = Math.min(n, i + r), y2 = Math.min(n, j + r);</span><br><span class="line">                <span class="keyword">if</span>((s[x2][y2] - s[x2][y1 - <span class="number">1</span>] - s[x1 - <span class="number">1</span>][y2] + s[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>]) &lt;= t * ((x2 - x1 + <span class="number">1</span>) * (y2 - y1 + <span class="number">1</span>)))&#123;</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>这里涉及到邻域均值，即数组内矩形的均值，考虑使用二维前缀和进行解决，以此便可遍历一次数组就得到所有位置的前缀和，之后便是遍历数组中的每一个元素，以其作为矩形中心，根据题意求均值，但需要注意的是数组越界问题，因此在坐标选择时可考虑利用最值防止其越界。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>此处由于涉及到前一元素的值，故下标需从1开始，索引为0的位置默认也是0。求前缀和是数组元素从1开始，那么在计算均值时数组也要从1开始数据方为有效数据。</p><h1 id="DHCP服务器"><a href="#DHCP服务器" class="headerlink" title="DHCP服务器"></a>DHCP服务器</h1><h2 id="试题背景-1"><a href="#试题背景-1" class="headerlink" title="试题背景"></a>试题背景</h2><p><strong>动态主机配置协议</strong>（Dynamic Host Configuration Protocol, DHCP）是一种自动为网络客户端分配 IP 地址的网络协议。当支持该协议的计算机刚刚接入网络时，它可以启动一个 DHCP 客户端程序。后者可以通过一定的网络报文交互，从 DHCP 服务器上获得 IP 地址等网络配置参数，从而能够在用户不干预的情况下，自动完成对计算机的网络设置，方便用户连接网络。DHCP 协议的工作过程如下：</p><ol><li>当 DHCP 协议启动的时候，DHCP 客户端向网络中广播发送 Discover 报文，请求 IP 地址配置；</li><li>当 DHCP 服务器收到 Discover 报文时，DHCP 服务器根据报文中的参数选择一个尚未分配的 IP 地址，分配给该客户端。DHCP 服务器用 Offer 报文将这个信息传达给客户端；</li><li>客户端收集收到的 Offer 报文。由于网络中可能存在多于一个 DHCP 服务器，因此客户端可能收集到多个 Offer 报文。客户端从这些报文中选择一个，并向网络中广播 Request 报文，表示选择这个 DHCP 服务器发送的配置；</li><li>DHCP 服务器收到 Request 报文后，首先判断该客户端是否选择本服务器分配的地址：如果不是，则在本服务器上解除对那个 IP 地址的占用；否则则再次确认分配的地址有效，并向客户端发送 Ack 报文，表示确认配置有效，Ack 报文中包括配置的有效时间。如果 DHCP 发现分配的地址无效，则返回 Nak 报文；</li><li>客户端收到 Ack 报文后，确认服务器分配的地址有效，即确认服务器分配的地址未被其它客户端占用，则完成网络配置，同时记录配置的有效时间，出于简化的目的，我们不考虑被占用的情况。若客户端收到 Nak 报文，则从步骤 1 重新开始；</li><li>客户端在到达配置的有效时间前，再次向 DHCP 服务器发送 Request 报文，表示希望延长 IP 地址的有效期。DHCP 服务器按照步骤 4 确定是否延长，客户端按照步骤 5 处理后续的配置；</li></ol><p>在本题目中，你需要理解 DHCP 协议的工作过程，并按照题目的要求实现一个简单的 DHCP 服务器。</p><h2 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h2><h2 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h2><p>为了便于实现，我们简化地规定 DHCP 数据报文的格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;发送主机&gt; &lt;接收主机&gt; &lt;报文类型&gt; &lt;IP 地址&gt; &lt;过期时刻&gt;</span><br></pre></td></tr></table></figure><p>None</p><p>DHCP 数据报文的各个部分由空格分隔，其各个部分的定义如下：</p><ul><li>发送主机：是发送报文的主机名，<strong>主机名</strong>是由小写字母、数字组成的字符串，唯一地表示了一个主机；</li><li>接收主机：当有特定的接收主机时，是接收报文的主机名；当没有特定的接收主机时，为一个星号（<code>*</code>）；</li><li>报文类型：是三个大写字母，取值如下：<ul><li><code>DIS</code>：表示 Discover 报文；</li><li><code>OFR</code>：表示 Offer 报文；</li><li><code>REQ</code>：表示 Request 报文；</li><li><code>ACK</code>：表示 Ack 报文；</li><li><code>NAK</code>：表示 Nak 报文；</li></ul></li><li>IP 地址，是一个非负整数：<ul><li>对于 Discover 报文，该部分在发送的时候为 0，在接收的时候忽略；</li><li>对于其它报文，为正整数，表示一个 IP 地址；</li></ul></li><li>过期时刻，是一个非负整数：<ul><li>对于 Offer、Ack 报文，是一个正整数，表示服务器授予客户端的 IP 地址的过期时刻；</li><li>对于 Discover、Request 报文，若为正整数，表示客户端期望服务器授予的过期时刻；</li><li>对于其它报文，该部分在发送的时候为 0，在接收的时候忽略。</li></ul></li></ul><p>例如下列都是合法的 DHCP 数据报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a * DIS 0 0</span><br><span class="line">d a ACK 50 1000</span><br></pre></td></tr></table></figure><h2 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h2><p>为了 DHCP 服务器能够正确分配 IP 地址，DHCP 需要接受如下配置：</p><ul><li>地址池大小 N：表示能够分配给客户端的 IP 地址的数目，且能分配的 IP 地址是 1,2,…,N；</li><li>默认过期时间 Tdef：表示分配给客户端的 IP 地址的默认的过期时间长度；</li><li>过期时间的上限和下限 Tmax、Tmin：表示分配给客户端的 IP 地址的最长过期时间长度和最短过期时间长度，客户端不能请求比这个更长或更短的过期时间；</li><li>本机名称 H：表示运行 DHCP 服务器的主机名。</li></ul><h3 id="分配策略"><a href="#分配策略" class="headerlink" title="分配策略"></a>分配策略</h3><p>当客户端请求 IP 地址时，首先检查此前是否给该客户端分配过 IP 地址，且该 IP 地址在此后没有被分配给其它客户端。如果是这样的情况，则直接将 IP 地址分配给它，否则，<br>总是分配给它最小的尚未占用过的那个 IP 地址。如果这样的地址不存在，则分配给它最小的此时未被占用的那个 IP 地址。如果这样的地址也不存在，说明地址池已经分配完毕，因此拒绝分配地址。</p><h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h3><p>在 DHCP 启动时，首先初始化 IP 地址池，将所有地址设置状态为未分配，占用者为空，并清零过期时刻。<br>其中地址的状态有未分配、待分配、占用、过期四种。<br>处于未分配状态的 IP 地址没有占用者，而其余三种状态的 IP 地址均有一名占用者。<br>处于待分配和占用状态的 IP 地址拥有一个大于零的过期时刻。在到达该过期时刻时，若该地址的状态是待分配，则该地址的状态会自动变为未分配，且占用者清空，过期时刻清零；否则该地址的状态会由占用自动变为过期，且过期时刻清零。处于未分配和过期状态的 IP 地址过期时刻为零，即没有过期时刻。</p><p>对于收到的报文，设其收到的时刻为 t。处理细节如下：</p><ol><li>判断接收主机是否为本机，或者为 <code>*</code>，若不是，则判断类型是否为 Request，若不是，则不处理；</li><li>若类型不是 Discover、Request 之一，则不处理；</li><li>若接收主机为 <code>*</code>，但类型不是 Discover，或接收主机是本机，但类型是 Discover，则不处理。</li></ol><p>对于 Discover 报文，按照下述方法处理：</p><ol><li>检查是否有占用者为发送主机的 IP 地址：<ul><li>若有，则选取该 IP 地址；</li><li>若没有，则选取最小的状态为未分配的 IP 地址；</li><li>若没有，则选取最小的状态为过期的 IP 地址；</li><li>若没有，则不处理该报文，处理结束；</li></ul></li><li>将该 IP 地址状态设置为待分配，占用者设置为发送主机；</li><li>若报文中过期时刻为 0 ，则设置过期时刻为 t+Tdef；否则根据报文中的过期时刻和收到报文的时刻计算过期时间，判断是否超过上下限：若没有超过，则设置过期时刻为报文中的过期时刻；否则则根据超限情况设置为允许的最早或最晚的过期时刻；</li><li>向发送主机发送 Offer 报文，其中，IP 地址为选定的 IP 地址，过期时刻为所设定的过期时刻。</li></ol><p>对于 Request 报文，按照下述方法处理：</p><ol><li>检查接收主机是否为本机：<ul><li>若不是，则找到占用者为发送主机的所有 IP 地址，对于其中状态为待分配的，将其状态设置为未分配，并清空其占用者，清零其过期时刻，处理结束；</li></ul></li><li>检查报文中的 IP 地址是否在地址池内，且其占用者为发送主机，若不是，则向发送主机发送 Nak 报文，处理结束；</li><li>无论该 IP 地址的状态为何，将该 IP 地址的状态设置为占用；</li><li>与 Discover 报文相同的方法，设置 IP 地址的过期时刻；</li><li>向发送主机发送 Ack 报文。</li></ol><p>上述处理过程中，地址池中地址的状态的变化可以概括为如下图所示的状态转移图。为了简洁，该图中没有涵盖需要回复 Nak 报文的情况。</p><p><img src="http://118.190.20.162/RequireFile.do?fid=qUtXBjol" alt="state_h.jpg"></p><h2 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入的第一行包含用空格分隔的四个正整数和一个字符串，分别是：N、Tdef、Tmax、Tmin 和 H，保证 Tmin≤Tdef≤Tmax。</p><p>输入的第二行是一个正整数 n，表示收到了 n 个报文。</p><p>输入接下来有 n 行，第 (i+2) 行有空格分隔的正整数 ti 和约定格式的报文 Pi。表示收到的第 i 个报文是在 ti 时刻收到的，报文内容是 Pi。保证 ti&lt;ti+1。</p><h2 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出有若干行，每行是一个约定格式的报文。依次输出 DHCP 服务器发送的报文。</p><h2 id="样例输入-4"><a href="#样例输入-4" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">4 5 10 5 dhcp</span><br><span class="line">16</span><br><span class="line">1 a * DIS 0 0</span><br><span class="line">2 a dhcp REQ 1 0</span><br><span class="line">3 b a DIS 0 0</span><br><span class="line">4 b * DIS 3 0</span><br><span class="line">5 b * REQ 2 12</span><br><span class="line">6 b dhcp REQ 2 12</span><br><span class="line">7 c * DIS 0 11</span><br><span class="line">8 c dhcp REQ 3 11</span><br><span class="line">9 d * DIS 0 0</span><br><span class="line">10 d dhcp REQ 4 20</span><br><span class="line">11 a dhcp REQ 1 20</span><br><span class="line">12 c dhcp REQ 3 20</span><br><span class="line">13 e * DIS 0 0</span><br><span class="line">14 e dhcp REQ 2 0</span><br><span class="line">15 b dhcp REQ 2 25</span><br><span class="line">16 b * DIS 0 0</span><br></pre></td></tr></table></figure><h2 id="样例输出-4"><a href="#样例输出-4" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dhcp a OFR 1 6</span><br><span class="line">dhcp a ACK 1 7</span><br><span class="line">dhcp b OFR 2 9</span><br><span class="line">dhcp b ACK 2 12</span><br><span class="line">dhcp c OFR 3 12</span><br><span class="line">dhcp c ACK 3 13</span><br><span class="line">dhcp d OFR 4 14</span><br><span class="line">dhcp d ACK 4 20</span><br><span class="line">dhcp a ACK 1 20</span><br><span class="line">dhcp c ACK 3 20</span><br><span class="line">dhcp e OFR 2 18</span><br><span class="line">dhcp e ACK 2 19</span><br><span class="line">dhcp b NAK 2 0</span><br></pre></td></tr></table></figure><h2 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h2><p>输入第一行，分别设置了 DHCP 的相关参数，并收到了 16 个报文。</p><p>第 1 个报文和第 2 个报文是客户端 <code>a</code> 正常请求地址，服务器为其分配了地址 1，相应地设置了过期时刻是 7（即当前时刻 2 加上默认过期时间 5）。</p><p>第 3 个报文不符合 Discover 报文的要求，不做任何处理。</p><p>第 4 个报文 <code>b</code> 发送的 Discover 报文虽然有 IP 地址 3，但是按照处理规则，这个字段被忽略，因此服务器返回 Offer 报文，过期时刻是 9。</p><p>第 5 个报文中，Request 报文不符合接收主机是 DHCP 服务器本机的要求，因此不做任何处理。</p><p>第 6 个报文是 <code>b</code> 发送的 Request 报文，其中设置了过期时刻是 12，没有超过最长过期时间，因此返回的 Ack 报文中过期时刻也是 12。</p><p>第 7 个报文中，过期时刻 11 小于最短过期时间，因此返回的过期时刻是 12。虽然此时为 <code>a</code> 分配的地址 1 过期，但是由于还有状态为未分配的地址 3，因此为 <code>c</code> 分配地址 3。第 8 个报文同理，为 <code>c</code> 分配的地址过期时刻是 13。</p><p>第 9、10 两个报文中，为 <code>d</code> 分配了地址 4，过期时刻是 20。</p><p>第 11 个报文中，<code>a</code> 请求重新获取此前为其分配的地址 1，虽然为其分配的地址过期，但是由于尚未分配给其它客户端，因此 DHCP 服务器可以直接为其重新分配该地址，并重新设置过期时刻为 20。</p><p>第 12 个报文中，<code>c</code> 请求延长其地址的过期时刻为 20。DHCP 正常向其回复 Ack 报文。</p><p>第 13、14 个报文中，<code>e</code> 试图请求地址。此时地址池中已经没有处于“未分配”状态的地址了，但是有此前分配给 <code>b</code> 的地址 2 的状态是“过期”，因此把该地址重新分配给 <code>e</code>。</p><p>第 15 个报文中，<code>b</code> 试图重新获取此前为其分配的地址 2，但是此时该地址已经被分配给 <code>e</code>，因此返回 Nak 报文。</p><p>第 16 个报文中，<code>b</code> 试图重新请求分配一个 IP 地址，但是此时地址池中已经没有可用的地址了，因此忽略该请求。</p><h2 id="样例输入-5"><a href="#样例输入-5" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">4 70 100 50 dhcp</span><br><span class="line">6</span><br><span class="line">5 a * OFR 2 100</span><br><span class="line">10 b * DIS 0 70</span><br><span class="line">15 b dhcp2 REQ 4 60</span><br><span class="line">20 c * DIS 0 70</span><br><span class="line">70 d * DIS 0 120</span><br><span class="line">75 d dhcp REQ 1 125</span><br></pre></td></tr></table></figure><h2 id="样例输出-5"><a href="#样例输出-5" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dhcp b OFR 1 70</span><br><span class="line">dhcp c OFR 1 70</span><br><span class="line">dhcp d OFR 1 120</span><br><span class="line">dhcp d ACK 1 125</span><br></pre></td></tr></table></figure><h2 id="样例说明-1"><a href="#样例说明-1" class="headerlink" title="样例说明"></a>样例说明</h2><p>在本样例中，DHCP 服务器一共收到了 6 个报文，处理情况如下：</p><p>第 1 个报文不是 DHCP 服务器需要处理的报文，因此不回复任何报文。</p><p>第 2 个报文中，<code>b</code> 请求分配 IP 地址，因此 DHCP 服务器将地址 1 分配给 <code>b</code>，此时，地址 1 进入待分配状态，DHCP 服务器向 <code>b</code> 发送 Offer 报文。</p><p>第 3 个报文中，<code>b</code> 发送的 REQ 报文是发给非本服务器的，因此需要将地址池中所有拥有者是 <code>b</code> 的待分配状态的地址修改为未分配。</p><p>第 4 个报文中，<code>c</code> 请求分配 IP 地址。由于地址 1 此时是未分配状态，因此将该地址分配给它，向它发送 Offer 报文，地址 1 进入待分配状态。</p><p>第 5、6 个报文中，<code>d</code> 请求分配 IP 地址。注意到在收到第 5 个报文时，已经是时刻 70，地址 1 的过期时刻已到，它的状态已经被修改为了未分配，因此 DHCP 服务器仍然将地址 1 分配给 <code>d</code>。</p><h2 id="评测用例规模与约定-2"><a href="#评测用例规模与约定-2" class="headerlink" title="评测用例规模与约定"></a>评测用例规模与约定</h2><p>对于 20% 的数据，有 N≤200，且 n≤N，且输入仅含 Discover 报文，且 t&lt;Tmin；</p><p>对于 50% 的数据，有 N≤200，且 n≤N，且 t&lt;Tmin，且报文的接收主机或为本机，或为 <code>*</code>；</p><p>对于 70% 的数据，有 N≤1000，且 n≤N，且报文的接收主机或为本机，或为 <code>*</code>；</p><p>对于 100% 的数据，有 N≤10000，且 n≤10000，主机名的长度不超过 20，且 t,Tmin,Tdefault,Tmax≤109，输入的报文格式符合题目要求，且数字不超过 109。</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2>]]></content>
    
    
    <summary type="html">第22次CCF-CSP认证考试部分题目</summary>
    
    
    
    <category term="solution" scheme="http://decucin.github.io/categories/solution/"/>
    
    
    <category term="ccf" scheme="http://decucin.github.io/tags/ccf/"/>
    
  </entry>
  
  <entry>
    <title>数据结构算法合集</title>
    <link href="http://decucin.github.io/2020/09/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%EF%BC%88C%E8%AF%AD%E8%A8%80%E7%89%88%EF%BC%89/"/>
    <id>http://decucin.github.io/2020/09/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%EF%BC%88C%E8%AF%AD%E8%A8%80%E7%89%88%EF%BC%89/</id>
    <published>2020-09-27T11:08:37.000Z</published>
    <updated>2022-03-21T06:46:47.327Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p><strong>注：以&amp;开头的参数为引用参数。</strong></p><h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><p>定义抽象数据类型的格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ADT 抽象数据类型名&#123;</span><br><span class="line">数据对象：&lt;数据对象的定义&gt;</span><br><span class="line">数据关系：&lt;数据关系的定义&gt;</span><br><span class="line">基本操作：&lt;基本操作的定义&gt;</span><br><span class="line">&#125;ADT 抽象数据类型名</span><br></pre></td></tr></table></figure><p>操作的定义格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">基本操作名（参数表）</span><br><span class="line">初始条件:&lt;初始条件描述&gt;</span><br><span class="line">操作结果:&lt;操作结果描述&gt;</span><br></pre></td></tr></table></figure><p>预定义常量和类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;函数结果状态代码</span><br><span class="line">#defineTRUE1</span><br><span class="line">#defineFALSE0</span><br><span class="line">#defineOK1</span><br><span class="line">#defineERROR0</span><br><span class="line">#defineINFEASIBLE-1</span><br><span class="line">#defineOVERFLOW-2</span><br><span class="line">&#x2F;&#x2F;Status是函数的类型，其值是函数结果的状态代码</span><br><span class="line">typedefintStatus;</span><br></pre></td></tr></table></figure><p>基本操作的算法的函数描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">函数类型函数名（函数参数表）&#123;</span><br><span class="line">&#x2F;&#x2F;算法说明</span><br><span class="line">语句序列</span><br><span class="line">&#125;&#x2F;&#x2F;函数名</span><br></pre></td></tr></table></figure><h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><p>扩大线性表LA，将存在于线性表LB中而不存在于线性表LA中的数据元素插入到线性表LA中去：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void union(List &amp;La, List)&#123;</span><br><span class="line">&#x2F;&#x2F;将所有在线性表Lb中但不在La中的数据元素插入到La中</span><br><span class="line">La_len &#x3D; ListLenth(La);&#x2F;&#x2F;求线性表长度</span><br><span class="line">Lb_len &#x3D; ListLenth(Lb);&#x2F;&#x2F;求线性表长度</span><br><span class="line">for(i &#x3D; 1; i &lt;&#x3D; Lb_len; i++)&#123;</span><br><span class="line">GetElem(Lb,i,e);</span><br><span class="line">if(!LocateElem(La, e, equal))</span><br><span class="line">ListInsert(La, ++La_len, e);&#x2F;&#x2F;La中不存在和e相同的数据元素，则插入之</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F; union</span><br></pre></td></tr></table></figure><p>已知线性表LA，LB中数据元素均按值非递减有序排列，现需将LA，LB归并为新的线性表LC，且LC中的数据元素仍按值非递减有序排列：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void MergeList(List La, List Lb, List &amp;Lc)&#123;</span><br><span class="line">&#x2F;&#x2F;已知线性表La和Lb中的数据元素按值非递减排列</span><br><span class="line">&#x2F;&#x2F;归并La和Lb得到新的线性表Lc，Lc的数据元素也按值非递减排列</span><br><span class="line">InitList(Lc);</span><br><span class="line">i &#x3D; j &#x3D; 1;</span><br><span class="line">k &#x3D; 0;</span><br><span class="line">La_len &#x3D; ListLenth(La);</span><br><span class="line">Lb_len &#x3D; ListLenth(Lb);</span><br><span class="line">while((i &lt;&#x3D; La_len) &amp;&amp; (j &lt;&#x3D; Lb_len))&#123;&#x2F;&#x2F;La与Lb均非空</span><br><span class="line">GetElem(La, i, ai);</span><br><span class="line">GetElem(Lb, j, bj);</span><br><span class="line">if(ai &lt;&#x3D; bj)&#123;</span><br><span class="line">ListInsert(Lc, ++k;, ai);</span><br><span class="line">++i;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">ListInsert(Lc, ++k, bj);</span><br><span class="line">++j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">while(i &lt;&#x3D; La_len)&#123;</span><br><span class="line">GetElem(La, i++, ai);</span><br><span class="line">ListInsert(Lc, ++k, ai);</span><br><span class="line">&#125;</span><br><span class="line">while(j &lt;&#x3D; Lb_len)&#123;</span><br><span class="line">GetElem(Lb, j++, bj);</span><br><span class="line">ListInsert(Lc, ++k,bj);</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;MergeList</span><br></pre></td></tr></table></figure><p>用数组来描述顺序存储结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;-----线性表的动态分配顺序存储结构-----</span><br><span class="line">#define LIST_INIT_SIZE 100  &#x2F;&#x2F;线性表存储空间的初始分配量</span><br><span class="line">#define LISTINCREMENT 10    &#x2F;&#x2F;线性表存储空间的分配增量</span><br><span class="line">typedef struct&#123;</span><br><span class="line">ElemType *elem;   &#x2F;&#x2F;存储空间基址</span><br><span class="line">int lenth;        &#x2F;&#x2F;当前长度</span><br><span class="line">int listsize;     &#x2F;&#x2F;当前分配的存储容量（以sizeof(ElemType)为单位</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure><p>顺序表的初始化（分配一个预定义大小的数组空间，并将线性表的当前长度设为“0”）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Status InitList_Sq(SqList &amp;L)&#123;</span><br><span class="line">&#x2F;&#x2F;构造一个空的线性表L</span><br><span class="line">L.elem &#x3D; (ElemType *)malloc(LIST_INIT_SIZE * sizeof(ElemType));</span><br><span class="line">if(!L.elem)</span><br><span class="line">exit(OVERFLOW);</span><br><span class="line">L.lenth &#x3D; 0;</span><br><span class="line">L.listsize &#x3D; LIST_INIT_SIZE;</span><br><span class="line">return OK;</span><br><span class="line">&#125;&#x2F;&#x2F;InitList_Sq</span><br></pre></td></tr></table></figure><p>线性表的插入（在第i个元素之前插入一个元素）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Status ListInsert_Sq(SqList &amp;L, int i, ElemType e)&#123;</span><br><span class="line">&#x2F;&#x2F;在顺序线性表L中第i个位置之前插入新的元素e</span><br><span class="line">if(i &lt; 1 || i &gt; L.lenth + 1)</span><br><span class="line">retur ERROR;&#x2F;&#x2F;i值不合法</span><br><span class="line">if(L.lenth &gt;&#x3D; L.listsize)&#123;&#x2F;&#x2F;当前存储空间已满，增加分配</span><br><span class="line">newbase &#x3D; (ElemType *)realloc(L.elem, (L.Listsize + LISTINCREMENT) * sizeof(ElemType));</span><br><span class="line">if(!newbase)</span><br><span class="line">exit(OVERFLOW);         &#x2F;&#x2F;存储分配失败</span><br><span class="line">L.elm &#x3D; newbase;            &#x2F;&#x2F;新基址</span><br><span class="line">L.listsize +&#x3D; LISTINCREMENT;&#x2F;&#x2F;增加存储容量</span><br><span class="line">&#125;</span><br><span class="line">q &#x3D; &amp;(L.elem[i-1]);&#x2F;&#x2F;q为插入位置</span><br><span class="line">for(p &#x3D; &amp;(L.elem[L.lenth-1]);</span><br><span class="line">p &gt;&#x3D; q; --p) * (p+1) &#x3D; *p;</span><br><span class="line">&#x2F;&#x2F;插入位置及之后的元素右移</span><br><span class="line">*q &#x3D; e;       &#x2F;&#x2F;插入e</span><br><span class="line">++L.lenth;    &#x2F;&#x2F;表长增1</span><br><span class="line">return OK;</span><br><span class="line">&#125;&#x2F;&#x2F;ListInsert_Sq</span><br><span class="line">&#x2F;&#x2F;先操作地址再操作值，否则无法确定后一数的具体位置</span><br></pre></td></tr></table></figure><p>线性表的删除（删除第i个元素，并用e返回其值）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Status ListDelete_Sq(SqList &amp;L, int i, ElemType &amp;e)&#123;</span><br><span class="line">&#x2F;&#x2F;在顺序线性表L中删除第i个元素，并用e返回其值</span><br><span class="line">if((i &lt; 1) || (i &gt; L.lenth))  &#x2F;&#x2F;i值不合法</span><br><span class="line">return ERROR;    </span><br><span class="line">p &#x3D; &amp;(L.elem[i-1]);  &#x2F;&#x2F;p为被删除元素的位置</span><br><span class="line">e &#x3D; *p;       &#x2F;&#x2F;被删除元素赋值给e</span><br><span class="line">q &#x3D; L.elem + L.lenth - 1;  &#x2F;&#x2F;表尾元素的位置</span><br><span class="line">for(++q; p &lt;&#x3D;q; ++p)  &#x2F;&#x2F;被删除元素之后的元素左移</span><br><span class="line">*(p-1) &#x3D; *p;      </span><br><span class="line">--L.lenth;     &#x2F;&#x2F;表长减1</span><br><span class="line">return OK;     </span><br><span class="line">&#125;&#x2F;&#x2F;ListDelete_Sq</span><br></pre></td></tr></table></figure><p>进行两个元素之间的比较（查找第一个值与e满足compare()的元素的位序）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int LocateElem_Sq(SqList L, ElemType e, Status(*compare)(ElemType, ElemType))&#123;</span><br><span class="line">&#x2F;&#x2F;在顺序表L中查找第一个值与e满足compare()的元素的位序</span><br><span class="line">&#x2F;&#x2F;若找到，返回其在L中的位序，否则返回0</span><br><span class="line">i &#x3D; 1;           &#x2F;&#x2F;i的初值为第1个元素的位序</span><br><span class="line">p &#x3D; L.elem;      &#x2F;&#x2F;p的初值为第1个元素的存储位置</span><br><span class="line">while(i &lt;&#x3D; L.lenth &amp;&amp; !(*compare)(*p++, e))</span><br><span class="line">++i;</span><br><span class="line">if(i &lt;&#x3D; L.lenth)</span><br><span class="line">return i;</span><br><span class="line">else</span><br><span class="line">return 0;</span><br><span class="line">&#125;&#x2F;&#x2F;LocateElem_Sq</span><br></pre></td></tr></table></figure><p>书中算法2.7与之前的算法类似，因此此处不在重复，但书中提到一点：即当*pa = *pb，即两集合中元素相同时，只需将两者其中之一插入Lc，并将两者均后移即可。（合并线性表LA，LB为新表LC算法）</p><p>单链表的表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;-----线性表的单链表存储结构-----</span><br><span class="line">typedef struct LNode&#123;</span><br><span class="line">ElemType data;</span><br><span class="line">struct LNode *next;</span><br><span class="line">&#125;LNode, *LinkList;</span><br></pre></td></tr></table></figure><p>单链表中获取第i个元素的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Status GetElem_L(LinkList L, int i, ElemType &amp;e)&#123;</span><br><span class="line">&#x2F;&#x2F;L为带头结点的单链表的头指针</span><br><span class="line">&#x2F;&#x2F;当第i个元素存在时，其值赋给e并返回OK，否则返回ERROR</span><br><span class="line">p &#x3D; L-&gt;next;  &#x2F;&#x2F;初始化，p指向第1个结点</span><br><span class="line">j &#x3D; 1;    &#x2F;&#x2F;j为计数器</span><br><span class="line">while(p &amp;&amp; j&lt;i)&#123;   &#x2F;&#x2F;顺指针向后查找，直到p指向第i个元素或p为空</span><br><span class="line">p &#x3D; p-&gt;next;</span><br><span class="line">++j;</span><br><span class="line">&#125;</span><br><span class="line">if(!p || j&gt;i)   &#x2F;&#x2F;第i个元素不存在</span><br><span class="line">return ERROR; </span><br><span class="line">e &#x3D; p-&gt;data;    &#x2F;&#x2F;取第i个元素</span><br><span class="line">return OK;</span><br><span class="line">&#125;&#x2F;&#x2F;GetElem_L</span><br></pre></td></tr></table></figure><p>单链表添加元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Status ListInsert_L(LinkList &amp;L, int i, ElemType e)&#123;</span><br><span class="line">&#x2F;&#x2F;在带头结点的单链线性表L中第i个位置之前插入元素</span><br><span class="line">p &#x3D; L;</span><br><span class="line">j &#x3D; 0;</span><br><span class="line">while(p &amp;&amp; j &lt; i-1)&#123;</span><br><span class="line">p &#x3D; p-&gt;next;</span><br><span class="line">++j;</span><br><span class="line">&#125;&#x2F;&#x2F;寻找第i-1个结点</span><br><span class="line">if(!p || j&gt;i-1) &#x2F;&#x2F;i小于1或者大于表长加1</span><br><span class="line">return ERROR;</span><br><span class="line">s &#x3D; (LinkList)malloc(sizeof(LNode)); &#x2F;&#x2F;生成新结点</span><br><span class="line">s-&gt;data &#x3D; e;</span><br><span class="line">s-&gt;next &#x3D; p-&gt;next;</span><br><span class="line">&#x2F;&#x2F;插入L中</span><br><span class="line">p-next &#x3D; s;</span><br><span class="line">return OK;</span><br><span class="line">&#125;&#x2F;&#x2F;ListInsert_L</span><br></pre></td></tr></table></figure><p>单链表删除元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Status ListDelete_L(LinkList &amp;L, int i, ElemType &amp;e)&#123;</span><br><span class="line">&#x2F;&#x2F;在带头结点的单链线性表L中，删除第i个元素，并由e返回其值</span><br><span class="line">p &#x3D; L;</span><br><span class="line">j &#x3D; 0;</span><br><span class="line">while(p-&gt;next &amp;&amp; j &lt; i-1)&#123; &#x2F;&#x2F;寻找第i个结点，并令p指向其前驱</span><br><span class="line">p &#x3D; p-&gt;next;</span><br><span class="line">++j;</span><br><span class="line">&#125;</span><br><span class="line">if(!(p-&gt;next) || j&gt;i-1)</span><br><span class="line">return ERROR;&#x2F;&#x2F;删除位置不合理</span><br><span class="line">q &#x3D; p-&gt;next;</span><br><span class="line">p-&gt;next &#x3D; q-&gt;next;&#x2F;&#x2F;删除并释放结点</span><br><span class="line">e &#x3D; q-&gt;data;</span><br><span class="line">free(q);</span><br><span class="line">return OK;</span><br><span class="line">&#125;&#x2F;&#x2F;ListDelete_L</span><br></pre></td></tr></table></figure><p>从表尾到表头逆向建立单链表的算法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void CreateList_L(LinkLIst &amp;L, int n)&#123;</span><br><span class="line">&#x2F;&#x2F;逆位序输入n个元素的值，建立带头结点的单链线性表L</span><br><span class="line">L &#x3D; (Linklist)malloc(sizeof(LNode));</span><br><span class="line">L-&gt;next &#x3D; NULL;  &#x2F;&#x2F;先建立一个带头结点的单链表</span><br><span class="line">for(i &#x3D; n; i &gt; 0; --i)&#123;</span><br><span class="line">p &#x3D; (LinkList)malloc(sizeof(LNode));  &#x2F;&#x2F;生成新结点</span><br><span class="line">scanf(&amp;p-&gt;data);   &#x2F;&#x2F;输入元素值</span><br><span class="line">p-&gt;next &#x3D; L-&gt;next &#x3D; p;  &#x2F;&#x2F;插入到表头</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;CreateList_L</span><br></pre></td></tr></table></figure><p>将两个有序链表合并为一个有序链表:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void MergeList_L(LinkList &amp;La, LinkList &amp;Lb, LinkList &amp;Lc)&#123;</span><br><span class="line">&#x2F;&#x2F;已知单链线性表La和Lb的元素按值非递减排列</span><br><span class="line">&#x2F;&#x2F;归并La和Lb得到新的单链线性表Lc，Lc的元素也按值非递减排列</span><br><span class="line">pa &#x3D; La-&gt;next;</span><br><span class="line">pb &#x3D; Lb-&gt;next;</span><br><span class="line">Lc &#x3D; pc &#x3D;La;    &#x2F;&#x2F;用La的头结点作为Lc的头结点</span><br><span class="line">while(pa &amp;&amp; pb)&#123;</span><br><span class="line">if(pa-&gt;data &lt;&#x3D; pb-&gt;data)&#123;</span><br><span class="line">pc-&gt;next &#x3D; pa;</span><br><span class="line">pc &#x3D; pa;</span><br><span class="line">pa &#x3D; pa-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">pc-&gt;next &#x3D; pb;</span><br><span class="line">pc &#x3D; pb;</span><br><span class="line">pb &#x3D; pb-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pc-&gt;next &#x3D; pa? pa : pb;  &#x2F;&#x2F;插入剩余段</span><br><span class="line">free(Lb);   &#x2F;&#x2F;释放Lb的头结点</span><br><span class="line">&#125;&#x2F;&#x2F;MergeList_L</span><br></pre></td></tr></table></figure><p>一维数组描述线性链表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;-----线性表的静态单链表存储结构-----</span><br><span class="line">#define MAXSIZE 1000</span><br><span class="line">typedef struct&#123;</span><br><span class="line">ElemType data;</span><br><span class="line">int cur;</span><br><span class="line">&#125;component,SLinkList[MAXSIZE];</span><br></pre></td></tr></table></figure><p>在静态链表中实现定位：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int LocateElem_SL(SLinkList S, ElemType e)&#123;</span><br><span class="line">&#x2F;&#x2F;在静态单链线性表L中查找第1个值为e的元素</span><br><span class="line">&#x2F;&#x2F;若找到，则返回它在L的位序，否则返回0</span><br><span class="line">i &#x3D; S[0].cur;   &#x2F;&#x2F;i指示表中第一个结点</span><br><span class="line">while(i &amp;&amp; S[i].data !&#x3D; e)</span><br><span class="line">i &#x3D; S[i].cur;    &#x2F;&#x2F;在表中顺链查找</span><br><span class="line">return i;</span><br><span class="line">&#125;&#x2F;&#x2F;LOcateElem_SL</span><br></pre></td></tr></table></figure><p><strong>注：为了辨明静态链表（数组）中哪些分量未被使用，可将所有未被使用过以及被删除的分量用游标链成一个备用的链表，需要插入时便可从备用链表上取得第一个结点作为待插入的新结点，需要删除时将从链表中删除下来的结点链接到备用链表上。</strong></p><p>将数组空间初始化为链表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void InitSpace_SL(SLinkList &amp;space)&#123;</span><br><span class="line">&#x2F;&#x2F;将一维数组space中各分量链成一个备用链表，space[0].cur为头指针</span><br><span class="line">&#x2F;&#x2F;“0”表示空指针</span><br><span class="line">for(i &#x3D; 0; i &lt; MAXSIZE - 1; ++i)</span><br><span class="line">space[i].cur &#x3D; i + 1；</span><br><span class="line">space[MAXSIZE-1].cur &#x3D; 0;</span><br><span class="line">&#125;&#x2F;&#x2F;InitSpace_SL</span><br></pre></td></tr></table></figure><p>从备用空间取得一个结点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int Malloc_SL(SLinkList &amp;space)&#123;</span><br><span class="line">&#x2F;&#x2F;若备用空间链表非空，则返回分配的结点下标，否则返回0</span><br><span class="line">i &#x3D; space[0].cur;</span><br><span class="line">if(space[0].cur)</span><br><span class="line">space[0].cur &#x3D; space[i].cur;</span><br><span class="line">return i;</span><br><span class="line">&#125;&#x2F;&#x2F;Malloc_SL</span><br></pre></td></tr></table></figure><p>将空闲结点链接到备用列表上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void Free_SL(SLinkList &amp;space, int k)&#123;</span><br><span class="line">&#x2F;&#x2F;将下标为k的空闲结点回收到备用列表</span><br><span class="line">space[k].cur &#x3D; space[0].cur;</span><br><span class="line">space[0].cur &#x3D; k;</span><br><span class="line">&#125;&#x2F;&#x2F;Free_SL</span><br></pre></td></tr></table></figure><p>已知集合A,B，求集合(A-B)U(B-A)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">void difference(SLinkList &amp;space, int &amp;s)&#123;</span><br><span class="line">&#x2F;&#x2F;依次输入集合A和B的元素，在一维数组space中建立表示集合(A-B)U(B-A)的静态链表，S为其头指针</span><br><span class="line">&#x2F;&#x2F;假设备用空间足够大，space[0].cur为其头指针</span><br><span class="line">InitSpace_SL(space);    &#x2F;&#x2F;初始化备用空间</span><br><span class="line">S &#x3D; Malloc_SL(space);   &#x2F;&#x2F;生成S的头结点</span><br><span class="line">r &#x3D; S;                  &#x2F;&#x2F;r指向S的当前最后一个结点</span><br><span class="line">scanf(m, n);            &#x2F;&#x2F;输入A和B的元素个数</span><br><span class="line">for(j &#x3D; 1; j &lt;&#x3D; m; ++j)&#123;&#x2F;&#x2F;建立集合A的链表</span><br><span class="line">i &#x3D; Malloc_SL(space);&#x2F;&#x2F;分配结点</span><br><span class="line">scanf(space[i].data);&#x2F;&#x2F;输入A的元素值</span><br><span class="line">space[r].cur &#x3D; i;</span><br><span class="line">r &#x3D; i;&#x2F;&#x2F;插入到表尾</span><br><span class="line">&#125;&#x2F;&#x2F;for</span><br><span class="line">space[r].cur &#x3D; 0;        &#x2F;&#x2F;尾结点的指针为空</span><br><span class="line">for(j &#x3D; 1; j &lt;&#x3D; n; ++j)&#123;&#x2F;&#x2F;依次输入B的元素，若不在当前表中，则插入，否则删除</span><br><span class="line">scanf(b);</span><br><span class="line">p &#x3D; S;</span><br><span class="line">k &#x3D; space[S].cur    &#x2F;&#x2F;k指向集合A中第一个结点</span><br><span class="line">while(k !&#x3D; space[r].cur &amp;&amp; space[k].data !&#x3D; b)&#123;&#x2F;&#x2F;在当前表中查找</span><br><span class="line">p &#x3D; k;</span><br><span class="line">k &#x3D; space[k].cur;</span><br><span class="line">&#125;&#x2F;&#x2F;while</span><br><span class="line">if(k &#x3D;&#x3D; space[r].cur)&#123;&#x2F;&#x2F;当前表中不存在该元素，插入在r所指结点之后，且r的位置不变</span><br><span class="line">i &#x3D; Malloc_SL(space);</span><br><span class="line">space[i].data &#x3D; b;</span><br><span class="line">space[i].cur &#x3D; space[r].cur;</span><br><span class="line">space[r].cur &#x3D; i;</span><br><span class="line">&#125;&#x2F;&#x2F;if</span><br><span class="line">else&#123;&#x2F;&#x2F;该元素已在表中，删除之</span><br><span class="line">space[p].cur &#x3D; space[k].cur;</span><br><span class="line">Free_SL(space, k);</span><br><span class="line">if(r &#x3D;&#x3D; k)</span><br><span class="line">r &#x3D; p;      &#x2F;&#x2F;若删除的是r所指结点，则需修改尾指针</span><br><span class="line">&#125;&#x2F;&#x2F;else</span><br><span class="line">&#125;&#x2F;&#x2F;for</span><br><span class="line">&#125;&#x2F;&#x2F;difference</span><br></pre></td></tr></table></figure><p>双向链表的C语言表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;-----线性表的双向链表存储结构-----</span><br><span class="line">typedef struct DuLNode&#123;</span><br><span class="line">ElemType data;</span><br><span class="line">struct DuLNode *prior;</span><br><span class="line">struct DuLNode *next;</span><br><span class="line">&#125;DuLNode, *DuLinkList;</span><br></pre></td></tr></table></figure><p>双向链表插入元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Status ListInsert_DuL(DuLinkList &amp;L, int i, ElemType e)&#123;</span><br><span class="line">&#x2F;&#x2F;在带头结点的双链循环线性表L中第i个位置之前插入元素e</span><br><span class="line">if(!(p &#x3D; GetElemP_DuL(L, i)))    &#x2F;&#x2F;在L中确定插入位置</span><br><span class="line">return ERROR;                &#x2F;&#x2F;p&#x3D;NULL，即插入位置不合法</span><br><span class="line">if(!(s &#x3D; (DuLinkList)malloc(sizeof(DuLNode))))</span><br><span class="line">return ERROR;</span><br><span class="line">s-&gt;data &#x3D; e;</span><br><span class="line">s-&gt;piror &#x3D; p-&gt;piror;</span><br><span class="line">p-&gt;piror-&gt;next &#x3D; s;</span><br><span class="line">s-&gt;next &#x3D; p;</span><br><span class="line">p-&gt;piror &#x3D; s;</span><br><span class="line">return OK;</span><br><span class="line">&#125;&#x2F;&#x2F;ListInsert_DuL</span><br></pre></td></tr></table></figure><p>双向链表删除元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Status ListDelete_DuL(DuLinkList &amp;L, int i, ElemType &amp;e)&#123;</span><br><span class="line">&#x2F;&#x2F;删除带头结点的双链循环线性表L的第i个元素</span><br><span class="line">if(!(p &#x3D; GetElemP_DuL(L, i)))  &#x2F;&#x2F;在L中确定第i个元素的位置指针p</span><br><span class="line">return ERROR;</span><br><span class="line">e &#x3D; p-&gt;data;</span><br><span class="line">p-&gt;piror-&gt;next &#x3D; p-&gt;next;</span><br><span class="line">p-&gt;next-&gt;piror &#x3D; p-&gt;piror;</span><br><span class="line">free(p);</span><br><span class="line">return OK;</span><br><span class="line">&#125;&#x2F;&#x2F;ListDelete_DuL</span><br></pre></td></tr></table></figure><p>一个带头结点的线性链表定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">typedef struct LNode&#123;&#x2F;&#x2F;结点类型</span><br><span class="line">ElemType data;</span><br><span class="line">struct LNode *next;</span><br><span class="line">&#125;*Link, *Position;</span><br><span class="line"></span><br><span class="line">typedef struct&#123;&#x2F;&#x2F;链表类型</span><br><span class="line">Link head, tail;  &#x2F;&#x2F;分别指向线性链表中的头结点和最后一个结点</span><br><span class="line">int len;          &#x2F;&#x2F;指示线性链表中数据元素的个数</span><br><span class="line">&#125; LinkList;</span><br><span class="line"></span><br><span class="line">Status MakeNode(Link &amp;p, ElemType e);</span><br><span class="line">&#x2F;&#x2F;分配由p指向的值为e的结点，并返回OK；若分配失败，则返回ERROR</span><br><span class="line">void FreeNode( Link &amp;p);</span><br><span class="line">&#x2F;&#x2F;释放p所指结点</span><br><span class="line"></span><br><span class="line">Status InitList(LinkList &amp;L);</span><br><span class="line">&#x2F;&#x2F;构造一个空的线性表L</span><br><span class="line">Status DestroyList(LinkList &amp;L);</span><br><span class="line">&#x2F;&#x2F;销毁线性链表L，L不再存在</span><br><span class="line">Status ClearList(LinkList &amp;L);</span><br><span class="line">&#x2F;&#x2F;将线性链表L重置为空表，并释放原链表L的结点空间</span><br><span class="line">Status InsFirst(Link h, Link s);</span><br><span class="line">&#x2F;&#x2F;已知h指向线性链表的头结点，将s所指结点插入在第一个结点之前</span><br><span class="line">Status DelFirst(Link h, Link &amp;q);</span><br><span class="line">&#x2F;&#x2F;已知h指向线性链表的头结点，删除链表中的第一个结点并以q返回</span><br><span class="line">Status Append(LinkList &amp;L,Link s);</span><br><span class="line">&#x2F;&#x2F;将指针s所指（彼此以指针相链）的一串结点链在线性链表L的最后一个结点</span><br><span class="line">&#x2F;&#x2F;之后，并改变链表L的尾指针指向新的尾结点</span><br><span class="line">Status Remove(LinkList &amp;L, Link &amp;q);</span><br><span class="line">&#x2F;&#x2F;删除线性链表L中的尾结点并以q返回，改变链表L的尾指针指向新的尾结点</span><br><span class="line">Status InsBefore(LinkList &amp;L, Link &amp;p, Link s);</span><br><span class="line">&#x2F;&#x2F;已知p指向线性链表L中的一个结点，将s所指结点插入在p所指结点之前，并修改指针p指向新的结点</span><br><span class="line">Status InsAfter(LinkList &amp;L, Link &amp;p, Link s);</span><br><span class="line">&#x2F;&#x2F;已知p指向线性链表L中的一个结点，将s所指结点插入在p所指结点之后，并修改指针p指向新的结点</span><br><span class="line">Status SetCurElem( Link &amp;p, ElemType e);</span><br><span class="line">&#x2F;&#x2F;已知p指向线性链表中的一个结点，用e更新p所指结点中数据元素的值</span><br><span class="line">ElemType GetCurElem(Link p);</span><br><span class="line">&#x2F;&#x2F;已知p指向线性链表中的一个结点，返回p所指结点中数据元素的值</span><br><span class="line">Status ListEmpty(LinkList L);</span><br><span class="line">&#x2F;&#x2F;若线性链表L为空表，则返回TURE，否则返回FALSE</span><br><span class="line">int ListLength(LinkList L);</span><br><span class="line">&#x2F;&#x2F;返回线性链表L中元素个数</span><br><span class="line">Position GetHead(LinkList L);</span><br><span class="line">&#x2F;&#x2F;返回线性链表L中头结点的位置</span><br><span class="line">Position GetLast(LinkList L);</span><br><span class="line">&#x2F;&#x2F;返回线性链表L中最后一个结点的位置</span><br><span class="line">Position PriorPos(LinkList L, Link p);</span><br><span class="line">&#x2F;&#x2F;已知p指向线性链表L中的一个结点，返回p所指结点的直接前驱的位置</span><br><span class="line">&#x2F;&#x2F;若无前驱，则返回NULL</span><br><span class="line">Position NextPos(LinkList L, Link p);</span><br><span class="line">&#x2F;&#x2F;已知p指向线性链表L中的一个结点，返回p所指结点的直接后继的位置</span><br><span class="line">&#x2F;&#x2F;若无后继，则返回NULL</span><br><span class="line">Status LocatePos(LinkList L, int i, Link &amp;p);</span><br><span class="line">&#x2F;&#x2F;返回p指示线性链表L中第i个结点的位置并返回OK；i值不合法时返回ERROR</span><br><span class="line">Position LocateElem(LinkList L, ElemType e, Status (*compare)(ElemType, ElemType));</span><br><span class="line">&#x2F;&#x2F;返回线性链表L中第1个与e满足函数compare()关系的元素的位置</span><br><span class="line">&#x2F;&#x2F;若不存在这样的元素，则返回NULL</span><br><span class="line">Status ListTraverse(LinkList L, Status (*visit)());</span><br><span class="line">&#x2F;&#x2F;依次对L的每个元素调用函数visit()，一旦visit()失败，则操作失败</span><br></pre></td></tr></table></figure><p>在第i个元素之前插入元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Status ListInsert_L(LinkList &amp;L, int i, ElemType e)&#123;</span><br><span class="line">&#x2F;&#x2F;在带头结点的单链线性表L的第i个元素之前插入元素e</span><br><span class="line">if(!LocatePos(L, i-1, h))</span><br><span class="line">return ERROR;    &#x2F;&#x2F;i值不合法</span><br><span class="line">if(!MakeNode(s, e))</span><br><span class="line">return ERROR;    &#x2F;&#x2F;结点存储分配失败</span><br><span class="line">InsFirst(h, s);      &#x2F;&#x2F;对于从第i个结点开始的链表，第i-1个结点是它的头结点</span><br><span class="line">return Ok;</span><br><span class="line">&#125;&#x2F;&#x2F;ListInsert_L</span><br></pre></td></tr></table></figure><p>两按值非递减排列的单链线性表合并为新的按值非递减排列的单链线性表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Status MergeList_L(LinkList &amp;La, LinkList &amp;Lb, LinkList &amp;Lc, int (*compare)(ElemType, Elemtype))&#123;</span><br><span class="line">&#x2F;&#x2F;已知单链线性表La和Lb的元素按值非递减排列</span><br><span class="line">&#x2F;&#x2F;排列La和Lb得到新的单链线性表Lc，Lc的元素也按值非递减排列</span><br><span class="line">if(!InitList(Lc))</span><br><span class="line">return ERROR;</span><br><span class="line">ha &#x3D; GetHead(La);     &#x2F;&#x2F;ha指向La的头结点</span><br><span class="line">hb &#x3D; GetHead(Lb);     &#x2F;&#x2F;hb指向Lb的头结点</span><br><span class="line">pa &#x3D; NextPos(La, ha); &#x2F;&#x2F;pa指向La中当前结点</span><br><span class="line">pb &#x3D; NextPos(Lb, hb); &#x2F;&#x2F;pb指向Lb中当前结点</span><br><span class="line">while(pa&amp;&amp;pb)&#123;        &#x2F;&#x2F;La和Lb均非空</span><br><span class="line">a &#x3D; GetCurElem(pa);</span><br><span class="line">b &#x3D; GetCurElem(pb);  &#x2F;&#x2F;a和b为当前两表中比较元素</span><br><span class="line">if((*compare)(a, b) &lt;&#x3D; 0)&#123;  &#x2F;&#x2F;a&lt;&#x3D;b</span><br><span class="line">DelFirst(ha, q);</span><br><span class="line">Append(Lc, q);</span><br><span class="line">pa &#x3D; NextPos(La, ha);</span><br><span class="line">&#125;</span><br><span class="line">else&#123;  &#x2F;&#x2F;a&gt;&#x3D;b</span><br><span class="line">DelFirst(hb, q);</span><br><span class="line">Append(Lc, q);</span><br><span class="line">pb &#x3D; NextPos(Lb, hb);</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;while</span><br><span class="line">if(pa)</span><br><span class="line">Append(Lc, pa);   &#x2F;&#x2F;链接La中剩余结点</span><br><span class="line">else</span><br><span class="line">Append(Lc, pb);   &#x2F;&#x2F;链接Lb中剩余结点</span><br><span class="line">FreeNode(ha);</span><br><span class="line">FreeNode(hb);         &#x2F;&#x2F;释放La和Lb的头结点</span><br><span class="line">return OK;</span><br><span class="line">&#125;&#x2F;&#x2F;MergeList_L</span><br></pre></td></tr></table></figure><p>抽象数据类型一元多项式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ADT Polynomial&#123;</span><br><span class="line">数据对象：D &#x3D; &#123;ai | ai ∈ TermSet, i &#x3D; 1,2,...,m,  m&gt;&#x3D;0</span><br><span class="line">TermSet中的每个元素包含一个表示系数的实数和表示指数的整数&#125;</span><br><span class="line"></span><br><span class="line">数据关系：R1 &#x3D; &#123;&lt;a(i-1),ai&gt;|a(i-1),ai∈D,且a(i-1)中的指数值&lt;ai中的指数值，i&#x3D;2,...,n&#125;</span><br><span class="line">基本操作：</span><br><span class="line">CreatPolyn( &amp;P, m )</span><br><span class="line">  操作结果：输入m项的系数和指数，建立一元多项式P</span><br><span class="line">  DestroyPolyn( &amp;P )</span><br><span class="line">  初始条件：一元多项式P已存在</span><br><span class="line">  操作结果：销毁一元多项式P</span><br><span class="line">  PrintPolyn( P )</span><br><span class="line">  初始条件：一元多项式P已存在</span><br><span class="line">  操作结果：打印输出一元多项式P</span><br><span class="line">  PolynLength( P )</span><br><span class="line">  初始条件：一元多项式P已存在</span><br><span class="line">  操作结果：返回一元多项式P中的项数</span><br><span class="line">  AddPolyn( &amp;Pa, &amp;Pb )</span><br><span class="line">  初始条件：一元多项式Pa和Pb已存在</span><br><span class="line">  操作结果：完成多项式相加运算，即：Pa &#x3D; Pa + Pb，并销毁一元多项式Pb</span><br><span class="line">  SubtractPolyn( &amp;Pa, &amp;Pb )</span><br><span class="line">  操作结果：完成多项式相减运算，即Pa&#x3D; Pa - Pb，并销毁一元多项式Pb</span><br><span class="line">  MultiplyPolyn( &amp;Pa, &amp;Pb )</span><br><span class="line">  初始条件：一元多项式Pa和Pb已存在</span><br><span class="line">  操作结果：完成多项式相乘运算，即Pa &#x3D; Pa * Pb，并销毁一元多项式Pb</span><br><span class="line">&#125;ADT Polynomial</span><br></pre></td></tr></table></figure><p>LocateElem()函数作用略有不同：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Status LocateElem(LinkList L, Elemtype e, Position &amp;q, int (*compare)(Elemtype, ElemType));</span><br><span class="line">&#x2F;&#x2F;若有序链表L中存在与e满足判定函数compaare()取值为0的元素，则q指示L中第一个值为e的结点的位置</span><br><span class="line">&#x2F;&#x2F;并返回TRUE，否则q指示第一个与e满足判定函数compare()取值&gt;0的元素的前驱位置，并返回FALSE</span><br></pre></td></tr></table></figure><p>OrderInsert()函数作用略有不同：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Status OrderInsert( LinkList &amp;L, ElemType e, int (*compare)(ElemType, ElemType));</span><br><span class="line">&#x2F;&#x2F;按有序判定函数compare()的约定，将值为e的结点插入到有序链表L的 适当位置上</span><br></pre></td></tr></table></figure><p>抽象数据类型Polynomial的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">typedef struct&#123;    &#x2F;&#x2F;项的表示，多项式的项作为LinkList的数据元素</span><br><span class="line">float coef;    &#x2F;&#x2F;系数</span><br><span class="line">int   expn;    &#x2F;&#x2F;指数</span><br><span class="line">&#125;term, ElemType;   &#x2F;&#x2F;两个类型名：term用于本ADT，ElemType为LinkList的数据对象名</span><br><span class="line"></span><br><span class="line">typedef LinkList polynomial;    &#x2F;&#x2F;用带表头结点的有序链表表示多项式</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F;-----基本操作的函数原型说明-----</span><br><span class="line">void CreatPolyn( Polynomial &amp;p, int m )&#123;</span><br><span class="line">&#x2F;&#x2F;输入m项的系数和指数，建立表示一元多项式的有序链表P</span><br><span class="line">InitList(P);</span><br><span class="line">h &#x3D; GetHead(P);</span><br><span class="line">e.coef &#x3D; 0.0;</span><br><span class="line">e.expn &#x3D; -1;</span><br><span class="line">SetCurElem(h,e);   &#x2F;&#x2F;设置头结点的数据元素</span><br><span class="line">for( i &#x3D; 1; i&lt;&#x3D;m; ++i)&#123;  &#x2F;&#x2F;依次输入m个非零项</span><br><span class="line">scanf(e.coef, e.expn);</span><br><span class="line">if(!LocateElem( P, e, q, (*cmp)()))&#123;  &#x2F;&#x2F;当前链表中不存在该指数项</span><br><span class="line">if(MakeNode(s,e))</span><br><span class="line">InsFirst( q, s );  &#x2F;&#x2F;生成结点并插入链表</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;CreatPolyn</span><br></pre></td></tr></table></figure><p>多项式加法实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">void AddPolyn( polynomial &amp;Pa, polynomial &amp;Pb)&#123;</span><br><span class="line">&#x2F;&#x2F;多项式加法：Pa &#x3D; Pa+Pb，利用两个多项式的结点构成“和多项式”</span><br><span class="line">ha &#x3D; GetHead(Pa);   &#x2F;&#x2F;ha指向Pa的头结点</span><br><span class="line">hb &#x3D; GetHead(Pb);   &#x2F;&#x2F;hb指向Pb的头结点</span><br><span class="line">qa &#x3D; NextPos(Pa,ha);   &#x2F;&#x2F;qa指向Pa中当前结点</span><br><span class="line">qb &#x3D; NextPos(Pb,hb);   &#x2F;&#x2F;qb指向Pb中当前结点</span><br><span class="line">while(qa &amp;&amp; Qb)&#123;&#x2F;&#x2F;qa和qb均非空</span><br><span class="line">a &#x3D; GetCurElem(qa);</span><br><span class="line">b &#x3D; GetCurElem(qb);   &#x2F;&#x2F;a和b为两表中当前比较元素</span><br><span class="line">switch( *cmp(a,b))&#123;</span><br><span class="line">case -1:    &#x2F;&#x2F;多项式Pa中当前结点的指数值小</span><br><span class="line">ha &#x3D; qa;</span><br><span class="line">qa &#x3D; NextPos(Pa, qa);</span><br><span class="line">break;</span><br><span class="line">case 0:     &#x2F;&#x2F;两者的指数值相等</span><br><span class="line">sum &#x3D; a.coef + b.coef;</span><br><span class="line">if(sum !&#x3D; 0.0)&#123;&#x2F;&#x2F;修改多项式Pa中当前结点的系数值</span><br><span class="line">SetCurElem(qa,sum);</span><br><span class="line">ha &#x3D; qa;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;&#x2F;&#x2F;删除多项式Pa中当前结点</span><br><span class="line">DelFirst(ha, qa);</span><br><span class="line">FreeNode(qa);</span><br><span class="line">&#125;</span><br><span class="line">DelFirst(hb, qb);</span><br><span class="line">FreeNode(qb);</span><br><span class="line">qb &#x3D; NextPos(Pb, hb);</span><br><span class="line">qa &#x3D; NextPos(Pa, ha);</span><br><span class="line">break;</span><br><span class="line">case 1:&#x2F;&#x2F;多项式Pb中当前结点的指数值小</span><br><span class="line">DelFirst(hb, qb);</span><br><span class="line">InsFirst( ha, qb);</span><br><span class="line">qb &#x3D; NextPos(Pb, hb);</span><br><span class="line">ha &#x3D; NextPos(Pa,ha);</span><br><span class="line">break;</span><br><span class="line">&#125;&#x2F;&#x2F;switch</span><br><span class="line">&#125;&#x2F;&#x2F;while</span><br><span class="line">if(!ListEmpty (Pb))</span><br><span class="line">Append(Pa, qb);&#x2F;&#x2F;链接Pb中剩余结点</span><br><span class="line">FreeNode(hb);&#x2F;&#x2F;释放Pb的头结点</span><br><span class="line">&#125;&#x2F;&#x2F;AddPolyn</span><br></pre></td></tr></table></figure><h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><p>栈的抽象数据类型定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">ADTStack&#123;</span><br><span class="line">数据对象：D &#x3D; &#123;ai|ai∈ElemSet, i &#x3D; 1,2,...,n,n&gt;&#x3D;0&#125;</span><br><span class="line">数据关系：R1 &#x3D; &#123; &lt;a(i-1),ai&gt;|a(i-1),ai∈D, i &#x3D; 2,...,n&#125;</span><br><span class="line">约定an端为栈顶，ai端为栈底</span><br><span class="line">基本操作：</span><br><span class="line">InitStack(&amp;S)</span><br><span class="line">操作结果：构造一个空栈S</span><br><span class="line">DestroyStack(&amp;S)</span><br><span class="line">初始条件：栈S已存在</span><br><span class="line">操作结果：栈S被销毁</span><br><span class="line">ClearStack(&amp;S)</span><br><span class="line">初始条件：栈S已存在</span><br><span class="line">操作结果：将S清为空栈</span><br><span class="line">StackEmpty(S)</span><br><span class="line">初始条件：栈S已存在</span><br><span class="line">操作结果：若栈S为空栈，则返回TRUE，否则返回FALSE</span><br><span class="line">StackLength(S)</span><br><span class="line">初始条件：栈S已存在</span><br><span class="line">操作结果：返回S的元素个数，即栈的长度</span><br><span class="line">GetTop(S,&amp;e)</span><br><span class="line">初始条件：栈S已存在且非空</span><br><span class="line">操作结果：用e返回S的栈顶元素</span><br><span class="line">Push(&amp;S, &amp;e)</span><br><span class="line">初始条件：栈S已存在</span><br><span class="line">操作结果：插入元素e为新的栈顶元素</span><br><span class="line">Pop(&amp;S, &amp;e)</span><br><span class="line">初始条件：栈S已存在且非空</span><br><span class="line">操作结果：删除S的栈顶元素，并用e返回其值</span><br><span class="line">StackTraverse(S,visit())</span><br><span class="line">初始条件：栈S已存在且非空</span><br><span class="line">操作结果：从栈底到栈顶依次对S的每个元素调用函数visit()，一旦visit()失败，则操作失败</span><br><span class="line">&#125;ADTStack</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;之后也多为如上定义，并将插入元素操作称为入栈，删除栈顶元素的操作为出栈</span><br></pre></td></tr></table></figure><p>顺序栈的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedefstruct&#123;</span><br><span class="line">SElemType*base;</span><br><span class="line">SElemType*top;</span><br><span class="line">intstacksize;</span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure><p>顺序栈的模块说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;ADT Stack的表示与实现&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-----栈的顺序存储表示-----</span><br><span class="line"></span><br><span class="line">#define STACK_INIT_SIZE100;&#x2F;&#x2F;存储空间初始分配量</span><br><span class="line">#defineSTACKINCREMENT10;&#x2F;&#x2F;存储空间分配增量</span><br><span class="line">typedefstruct&#123;</span><br><span class="line">SElemType*base;&#x2F;&#x2F;在栈构造之前和销毁之后，base的值为NULL</span><br><span class="line">SElemType*top;&#x2F;&#x2F;栈顶指针</span><br><span class="line">intstacksize;&#x2F;&#x2F;当前已分配的存储空间，以元素为单位</span><br><span class="line">&#125;SqStack;</span><br><span class="line">&#x2F;&#x2F;-----基本操作的函数原型说明-----</span><br><span class="line">StatusInitStack(SqStack &amp;S);</span><br><span class="line">&#x2F;&#x2F;构造一个空栈S</span><br><span class="line">StatusDestroyStack(SqStack &amp;S);</span><br><span class="line">&#x2F;&#x2F;销毁栈S，S不在存在</span><br><span class="line">StatusClearStack(SqStack&amp;S);</span><br><span class="line">&#x2F;&#x2F;把S置为空栈</span><br><span class="line">StatusStackEmpty(SqStackS);</span><br><span class="line">&#x2F;&#x2F;若栈S为空栈，则返回TRUE，否则返回FALSE</span><br><span class="line">int StackLength(SqStack S);</span><br><span class="line">&#x2F;&#x2F;返回S的元素个数，即栈的长度</span><br><span class="line">Status GetTop(SqStack S, SElemType &amp;e);</span><br><span class="line">&#x2F;&#x2F;若栈不空，则用e返回S的栈顶元素，并返回OK，否则返回ERROR</span><br><span class="line">Status Push(SqStack &amp;S,SElemType e);</span><br><span class="line">&#x2F;&#x2F;插入元素e为新的栈顶元素</span><br><span class="line">Status Pop(SqStack &amp;S, SElemType &amp;e);</span><br><span class="line">&#x2F;&#x2F;若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK，否则返回ERROR</span><br><span class="line">Status StackTraverse(SqStack S, Status (*visit)());</span><br><span class="line">&#x2F;&#x2F;从栈底到栈顶依次对栈中每个元素调用函数visit()，一旦visit()失败，则操作失败</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-----基本操作的算法描述（部分） -----</span><br><span class="line">Status InitStack (SqStack &amp;S)&#123;</span><br><span class="line">&#x2F;&#x2F;构造一个空栈S</span><br><span class="line">S.base &#x3D; (SElemType*)malloc(STACK_INIT_SIZE * sizeof(SElemType));</span><br><span class="line">if(!S.base)</span><br><span class="line">exit(OVERFLOW);&#x2F;&#x2F;存储分配失败</span><br><span class="line">S.top &#x3D; S.base;</span><br><span class="line">S.stacksize &#x3D; STACK_INIT_SIZE;</span><br><span class="line">return OK;</span><br><span class="line">&#125;&#x2F;&#x2F;InitStack</span><br><span class="line"></span><br><span class="line">StatusGetTop(SqStackS, SElemType &amp;e)&#123;</span><br><span class="line">&#x2F;&#x2F;若栈不空，则用e返回S的栈顶元素，并返回OK，否则返回ERROR</span><br><span class="line">if(S.top &#x3D;&#x3D; S.base)</span><br><span class="line">return ERROR;</span><br><span class="line">e &#x3D; *(S.top - 1);</span><br><span class="line">return OK;</span><br><span class="line">&#125;&#x2F;&#x2F;GetTop</span><br><span class="line"></span><br><span class="line">StatusPush(SqStack &amp;S, SElemType e)&#123;</span><br><span class="line">&#x2F;&#x2F;插入元素e为新的栈顶元素</span><br><span class="line">if(S.top - S.base &gt;&#x3D; S.stacksize)&#123;&#x2F;&#x2F;栈满，追加存储空间</span><br><span class="line">S.base &#x3D; (SElemType*)realloc( S.base, (S.stacksize + STACKINCREMENT) * sizeof(SElemType));</span><br><span class="line">if(!S.base)</span><br><span class="line">exit(OVERFLOW);&#x2F;&#x2F;存储分配失败</span><br><span class="line"></span><br><span class="line">S.top &#x3D; S.base + S.stacksize;</span><br><span class="line">S.stacksize +&#x3D; STACKINCREMENT;</span><br><span class="line">&#125;</span><br><span class="line">*S.top++ &#x3D; e;</span><br><span class="line">return OK;</span><br><span class="line">&#125;&#x2F;&#x2F;Push</span><br><span class="line"></span><br><span class="line">StatusPop(SqStack&amp;S,SEleType &amp;e)&#123;</span><br><span class="line">&#x2F;&#x2F;若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK，否则返回FALSE</span><br><span class="line">if(S.top &#x3D;&#x3D; S.base)</span><br><span class="line">return ERROR;</span><br><span class="line">e &#x3D; * --S.top;</span><br><span class="line">return OK;</span><br><span class="line">&#125;&#x2F;&#x2F;Pop</span><br></pre></td></tr></table></figure><p>十进制转八进制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;进制计算与打印过程刚好相反，满足栈的特性</span><br><span class="line"></span><br><span class="line">void conversion()&#123;</span><br><span class="line">&#x2F;&#x2F;对于输入的任意一个非负十进制整数，打印输出与其等值的八进制数</span><br><span class="line">InitStack(S);&#x2F;&#x2F;构造空栈</span><br><span class="line">scanf(&quot;%d&quot;,N);</span><br><span class="line">while(N)&#123;</span><br><span class="line">Push(S, N % 8);</span><br><span class="line">N &#x3D; N&#x2F;8;</span><br><span class="line">&#125;</span><br><span class="line">while(!StackEmpty(S))&#123;</span><br><span class="line">Pop(S,e);</span><br><span class="line">printf(&quot;%d&quot;,e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;conversion</span><br></pre></td></tr></table></figure><p>行编辑程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void LineEdit()&#123;</span><br><span class="line">&#x2F;&#x2F;利用字符栈S，从终端接受一行并传送至调用过程的数据区</span><br><span class="line">InitStack(S);&#x2F;&#x2F;构造空栈S</span><br><span class="line">ch &#x3D; getchar();&#x2F;&#x2F;从终端接收第一个字符</span><br><span class="line">while(ch !&#x3D; EOF)&#123;&#x2F;&#x2F;EOF为全文结束符</span><br><span class="line">while(ch !&#x3D; EOF &amp;&amp; ch !&#x3D; &#39;\n&#39;)&#123;</span><br><span class="line">switch(ch)&#123;</span><br><span class="line">case &#39;#&#39;:</span><br><span class="line">Pop(S,c);</span><br><span class="line">break;&#x2F;&#x2F;仅当栈非空时退栈</span><br><span class="line">case &#39;@&#39;:</span><br><span class="line">ClearStack(S);</span><br><span class="line">break;&#x2F;&#x2F;重置S为空栈</span><br><span class="line">default:</span><br><span class="line">Push(S,ch);</span><br><span class="line">break;&#x2F;&#x2F;有效字符进栈，未考虑栈满情况</span><br><span class="line">&#125;</span><br><span class="line">ch &#x3D; getchar();&#x2F;&#x2F;从终端接收下一个字符</span><br><span class="line">&#125;</span><br><span class="line">将从栈底到栈顶的栈内字符传送至调用过程的数据区</span><br><span class="line">ClearStack(S);&#x2F;&#x2F;重置S为空栈</span><br><span class="line">if(ch!&#x3D;EOF)</span><br><span class="line">ch &#x3D; getchar();</span><br><span class="line">&#125;</span><br><span class="line">DestroyStack(S);</span><br><span class="line">&#125;&#x2F;&#x2F;LineEdit</span><br></pre></td></tr></table></figure><p>求迷宫中一条从入口到出口的路径的算法描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">do&#123;</span><br><span class="line">若当前位置可通，则&#123;</span><br><span class="line">将当前位置压入栈顶；   &#x2F;&#x2F;  纳入路径</span><br><span class="line">若当前位置是出口位置，则结束；&#x2F;&#x2F;求得路径存放在栈中</span><br><span class="line">否则切换当前位置的东邻方块为新的当前位置；</span><br><span class="line">&#125;</span><br><span class="line">否则&#123;</span><br><span class="line">若栈不空且栈顶位置尚有其他地方尚未探索，则&#123;</span><br><span class="line">设定新的当前位置为沿顺时针方向旋转找到的栈顶位置的下一邻块</span><br><span class="line">&#125;</span><br><span class="line">若栈不空但栈顶位置的四周均不可通，则&#123;</span><br><span class="line">删去栈顶位置； &#x2F;&#x2F;从路径中删去该通道块</span><br><span class="line">若栈不空，则重新测试新的栈顶位置，，</span><br><span class="line">直至找到一个可通的相邻块或出栈至栈空；</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;while(栈不空)</span><br></pre></td></tr></table></figure><p>实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">typedefstruct&#123;</span><br><span class="line">intord;&#x2F;&#x2F;通道块在路径上的“序号”</span><br><span class="line">PosTypeseat;&#x2F;&#x2F;通道块在迷宫中的“坐标位置”</span><br><span class="line">intdi;&#x2F;&#x2F;从此通道块走向下一通道块的“方向”</span><br><span class="line">&#125;SElemType;&#x2F;&#x2F;栈的元素类型</span><br><span class="line"></span><br><span class="line">StatusMazePath( MazeTypemaze, PosType start, PosType end )&#123;</span><br><span class="line">&#x2F;&#x2F;若迷宫maze中存在从入口start到出口end的通道，则求得一条存放在栈中（从栈底到栈顶），并返回TRUE；</span><br><span class="line">&#x2F;&#x2F;否则返回FALSE</span><br><span class="line">InitStack(S);</span><br><span class="line">curpos &#x3D; start;&#x2F;&#x2F;设定“当前位置”为“入口位置”</span><br><span class="line">curstep &#x3D; 1;&#x2F;&#x2F;探索第一步</span><br><span class="line">do&#123;</span><br><span class="line">if(Pass(curpos))&#123;&#x2F;&#x2F;当前位置可以通过，即是未曾走到过的通道块</span><br><span class="line">FootPrint(curpos);&#x2F;&#x2F;留下足迹</span><br><span class="line">e &#x3D; ( curstep, curpos, 1 );&#x2F;&#x2F;此处e为SElemType类型的栈（书中未提及）</span><br><span class="line">Push(S,e);&#x2F;&#x2F;加入路径</span><br><span class="line">if(curpos&#x3D;&#x3D;end)</span><br><span class="line">return(TRUE);&#x2F;&#x2F;到达终点，出口</span><br><span class="line">curpos &#x3D; NextPos( curpos, 1 );&#x2F;&#x2F;下一位置是当前位置的东邻</span><br><span class="line">curstep++;&#x2F;&#x2F;探索下一步</span><br><span class="line">&#125;&#x2F;&#x2F;if</span><br><span class="line">else&#123;&#x2F;&#x2F;当前位置不能通过</span><br><span class="line">if(!StackEmpty(S))&#123;</span><br><span class="line">Pop(S,e);</span><br><span class="line">while(e.di &#x3D;&#x3D; 4 &amp;&amp; !StackEmpty(S))&#123;</span><br><span class="line">MarkPrint(e.seat);</span><br><span class="line">Pop(S,e);&#x2F;&#x2F;留下不能通过的标记，并退回一步</span><br><span class="line">&#125;&#x2F;&#x2F;while</span><br><span class="line">if(e.di&lt;4)&#123;</span><br><span class="line">e.di++;</span><br><span class="line">Push(S,e);&#x2F;&#x2F;换下一个方向探索</span><br><span class="line">curpos &#x3D; NextPos(e.seat, e.di);&#x2F;&#x2F;设定当前位置是该新方向上的相邻块</span><br><span class="line">&#125;&#x2F;&#x2F;if</span><br><span class="line">&#125;&#x2F;&#x2F;if</span><br><span class="line">&#125;&#x2F;&#x2F;else</span><br><span class="line">&#125;while( !StackEmpty(S));</span><br><span class="line">return (FALSE);</span><br><span class="line">&#125;&#x2F;&#x2F;MazePath</span><br></pre></td></tr></table></figure><p>带优先级的算术表达式求值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">OperandTypeEvaluateExpression()&#123;</span><br><span class="line">&#x2F;&#x2F;算数表达式求值的算符优先算法</span><br><span class="line">&#x2F;&#x2F;设OPTR和OPND分别为运算符栈和运算数栈，OP为运算符集合</span><br><span class="line">InitStack(OPTR);</span><br><span class="line">Push(OPTR, &#39;#&#39;);</span><br><span class="line">InitStack(OPND);</span><br><span class="line">c &#x3D; getchar();</span><br><span class="line">while(c!&#x3D;&#39;#&#39; || GetTop(OPTR)!&#x3D;&#39;#&#39;)&#123;</span><br><span class="line">if(!In(c, OP))&#123;</span><br><span class="line">Push(OPND, c);</span><br><span class="line">c &#x3D; getchar();</span><br><span class="line">&#125;&#x2F;&#x2F;不是运算符则进栈</span><br><span class="line">else&#123;</span><br><span class="line">switch(Precede(GetTop(OPTR),c))&#123;&#x2F;&#x2F;Precede()函数用于监测运算符优先级</span><br><span class="line">case &#39;&lt;&#39;:&#x2F;&#x2F;栈顶元素优先权低</span><br><span class="line">Push(OPTR, c);</span><br><span class="line">c &#x3D; getchar();</span><br><span class="line">break;</span><br><span class="line">case &#39;&#x3D;&#39;:&#x2F;&#x2F;脱括号并接受下一字符</span><br><span class="line">Pop(OPTR, x);</span><br><span class="line">c &#x3D; getchar();</span><br><span class="line">break;</span><br><span class="line">case &#39;&gt;&#39;:&#x2F;&#x2F;退栈并将运算结果入栈</span><br><span class="line">Pop(OPTR, theta);</span><br><span class="line">Pop(OPND, b);</span><br><span class="line">Pop(OPND, a);</span><br><span class="line">Push(OPND, Operate(a, theta, b));</span><br><span class="line">break;</span><br><span class="line">&#125;&#x2F;&#x2F;switch</span><br><span class="line">&#125;&#x2F;&#x2F;else</span><br><span class="line">&#125;&#x2F;&#x2F;while</span><br><span class="line">return GetTop(OPND);</span><br><span class="line">&#125;&#x2F;&#x2F;EvaluateExpression</span><br></pre></td></tr></table></figure><p>求解n阶Hanoi塔问题的C函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void hanoi(int n, char x, char y, char z)</span><br><span class="line">&#x2F;&#x2F;将塔座x上按直径由小到大且自上而下编号为1至n的n个圆盘按规则搬动到塔座z上，y可用作辅助塔座</span><br><span class="line">&#x2F;&#x2F;搬动操作move(x, n, z)可定义为（c是初值为0的全局变量，对搬动计数）：</span><br><span class="line">&#x2F;&#x2F;printf(&quot;%i. Move disk %i from %c to %c\n&quot;, ++c, n, x, z);</span><br><span class="line">&#123;</span><br><span class="line">if(n&#x3D;&#x3D;1)</span><br><span class="line">move(x,1,z);</span><br><span class="line">else&#123;</span><br><span class="line">honoi(n-1, x, z,y);&#x2F;&#x2F;将x上编号为1至n-1的圆盘移到y，z作辅助塔</span><br><span class="line">move(x, n, z);&#x2F;&#x2F;将编号为n的圆盘从x移到z</span><br><span class="line">hanoi(n-1, y, x, z);&#x2F;&#x2F;将y上编号为1至n-1的圆盘移到z，x作辅助塔</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>队列的抽象数据类型定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">ADTQueue&#123;</span><br><span class="line">数据对象:D&#x3D;&#123;ai|ai∈ElemSet, i &#x3D; 1,2,...,n, n&gt;&#x3D;0&#125;</span><br><span class="line">数据关系:R1&#x3D;&#123;&lt;a(i-1),ai&gt;|a(i-1),ai∈D, i&#x3D;2,...,n&#125;</span><br><span class="line">约定其中a1端为队列头，an端为队列尾</span><br><span class="line">基本操作：</span><br><span class="line">InitQueue(&amp;Q)</span><br><span class="line">操作结果：构造一个空队列Q</span><br><span class="line">DesTroyQueue(&amp;Q)</span><br><span class="line">初始条件：队列Q已存在</span><br><span class="line">操作结果：队列Q被销毁，不再存在</span><br><span class="line">ClearQueue(&amp;Q)</span><br><span class="line">初始条件：队列Q已存在</span><br><span class="line">操作结果：将Q清为空队列</span><br><span class="line">QueueEmpty(Q)</span><br><span class="line">初始条件：队列Q已存在</span><br><span class="line">操作结果：若Q为空队列，则返回TRUE，否则返回FALSE</span><br><span class="line">QueueLength(Q)</span><br><span class="line">初始条件：队列Q已存在</span><br><span class="line">操作结果：返回Q的元素个数，即队列的长度</span><br><span class="line">GetHead(Q, &amp;e)</span><br><span class="line">初始条件：队列Q已存在</span><br><span class="line">操作结果：用e返回Q的队头元素</span><br><span class="line">EnQueue(&amp;Q, e)</span><br><span class="line">初始条件：队列Q已存在</span><br><span class="line">操作结果：插入元素e为Q的新的队尾元素</span><br><span class="line">DeQueue(&amp;Q, &amp;e)</span><br><span class="line">初始条件：队列Q已存在</span><br><span class="line">操作结果：删除Q的队头元素，并用e返回其值</span><br><span class="line">QueueTraverse(Q,visit())</span><br><span class="line">初始条件：队列Q已存在</span><br><span class="line">操作结果：从队头到队尾，依次对Q的每个数据元素调用函数visit()。一旦visit()失败，则操作失败</span><br><span class="line">&#125;ADT Queue</span><br></pre></td></tr></table></figure><p>单链队列的表示与实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;ADT Queue的表示与实现&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-----单链队列——队列的链式存储结构-----</span><br><span class="line">typedefstructQNode&#123;</span><br><span class="line">QElemTypedata;</span><br><span class="line">structQNode*next;</span><br><span class="line">&#125;QNode, *QueuePtr;</span><br><span class="line">typedefstruct&#123;</span><br><span class="line">QueuePtrfront;&#x2F;&#x2F;队头指针</span><br><span class="line">QueuePtrrear;&#x2F;&#x2F;队尾指针</span><br><span class="line">&#125;&#x2F;&#x2F;LinkQueue;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-----基本操作的函数原型说明-----</span><br><span class="line">StatusInitQueue(LinkQueue&amp;Q)</span><br><span class="line">&#x2F;&#x2F;构造一个空队列Q</span><br><span class="line">StatusDestroyQueue(LinkQueue &amp;Q)</span><br><span class="line">&#x2F;&#x2F;销毁队列Q，Q不再存在</span><br><span class="line">StatusClearQueue(LinkQueue &amp;Q)</span><br><span class="line">&#x2F;&#x2F;将Q清为空队列</span><br><span class="line">StatusQueueEmpty(LinkQueue Q)</span><br><span class="line">&#x2F;&#x2F;若队列Q为空队列，则返回TRUE，否则返回FALSE</span><br><span class="line">intQueueLength(LinkQueue Q)</span><br><span class="line">&#x2F;&#x2F;返回队列Q的元素个数，即队列长度</span><br><span class="line">StatusGetHead(LinkQueue Q, QElemType &amp;e)</span><br><span class="line">&#x2F;&#x2F;若队列不空，则用e返回Q的队头元素，并返回OK，否则返回ERROR</span><br><span class="line">StatusEnQueue(LinkQueue &amp;Q, QElemType &amp;e)</span><br><span class="line">&#x2F;&#x2F;插入元素e为Q新的队尾元素</span><br><span class="line">StatusDeQueue(LinkQueue &amp;Q, QElemType &amp;e)</span><br><span class="line">&#x2F;&#x2F;若队列不空，则删除Q的队头元素，用e返回其值，并返回OK，否则返回ERROR</span><br><span class="line">StatusQueueTraverse(LinkQueue Q, visit())</span><br><span class="line">&#x2F;&#x2F;从队头到队尾依次对队列Q中每个元素调用函数visit()。一旦visit()失败，则操作失败</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-----基本操作的算法描述（部分） -----</span><br><span class="line">StatusInitQueue(LinkQueue&amp;Q)&#123;</span><br><span class="line">&#x2F;&#x2F;构造一个空队列Q</span><br><span class="line">Q.front &#x3D; Q.rear &#x3D; (QueuePtr)malloc(sizeof(QNode));</span><br><span class="line">if(!Q.front)</span><br><span class="line">exit(OVERFLOW);&#x2F;&#x2F;存储分配失败</span><br><span class="line">Q.front-&gt;next &#x3D; NULL;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StatusDestroyQueue(LinkQueue&amp;Q)&#123;</span><br><span class="line">&#x2F;&#x2F;销毁队列Q</span><br><span class="line">while(Q.front)&#123;</span><br><span class="line">Q.rear &#x3D; Q.front-&gt;next;</span><br><span class="line">free(Q.front);</span><br><span class="line">Q.front &#x3D; Q.rear;</span><br><span class="line">&#125;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StatusEnQueue(LinkQueue &amp;Q, QElemTypee)&#123;</span><br><span class="line">&#x2F;&#x2F;插入元素e为Q的新的队尾元素</span><br><span class="line">p &#x3D; (QueuePtr)malloc(sizeof(QNode));</span><br><span class="line">if(!p)</span><br><span class="line">exit(OVERFLOW);&#x2F;&#x2F;存储分配失败</span><br><span class="line">p-&gt;data &#x3D; e;</span><br><span class="line">p-&gt;next &#x3D; NULL;</span><br><span class="line">Q.rear-&gt;next &#x3D; p;</span><br><span class="line">Q.rear &#x3D; p;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StatusDeQueue(LinkQueue &amp;Q, QElemType &amp;e)&#123;</span><br><span class="line">&#x2F;&#x2F;若队列不空，则删除Q的队头元素，用e返回其值，并返回OK，否则返回ERROR</span><br><span class="line">if(Q.front &#x3D;&#x3D; Q.rear)</span><br><span class="line">return ERROR;</span><br><span class="line">p &#x3D; Q.front-&gt;next;</span><br><span class="line">e &#x3D; p-&gt;data;</span><br><span class="line">Q.front-&gt;next &#x3D; p-&gt;next;</span><br><span class="line">if(Q.rear &#x3D;&#x3D; p)&#x2F;&#x2F;队列中最后一个元素被删除，队列尾指针也丢失了，需对其也进行赋值</span><br><span class="line">Q.rear &#x3D; Q.front;</span><br><span class="line">free(p);</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环队列类型说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;-----循环队列——队列的顺序存储结构-----</span><br><span class="line">#defineMAXQSIZE100&#x2F;&#x2F;最大队列长度</span><br><span class="line">typedefstruct&#123;</span><br><span class="line">QElemType*base;&#x2F;&#x2F;初始化的动态分配存储空间</span><br><span class="line">intfront;&#x2F;&#x2F;头指针，若队列不空，指向队列头元素</span><br><span class="line">intrear;&#x2F;&#x2F;尾指针，若队列不空，指向队列尾元素的下一位置</span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-----循环队列的基本操作的算法描述-----</span><br><span class="line">StatusInitQueue(SqQueue &amp;Q)&#123;</span><br><span class="line">&#x2F;&#x2F;构造一个空队列Q</span><br><span class="line">Q.base &#x3D; (QElemType*)malloc(MAXSIZE * sizeof(QElemType));</span><br><span class="line">if(!Q.base)</span><br><span class="line">exit(OVERFLOW);</span><br><span class="line">Q.front &#x3D; Q.rear &#x3D; 0;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">intQueueLength(SqQueueQ)&#123;</span><br><span class="line">&#x2F;&#x2F;返回Q的元素个数，即队列的长度</span><br><span class="line">return (Q.rear - Q.front + MAXSIZE) % MASIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StatusEnQueue(SqQueue&amp;Q, QElemType e)&#123;</span><br><span class="line">&#x2F;&#x2F;插入元素e为Q的新的队尾元素</span><br><span class="line">if((Q.rear + 1) % MAXSIZE &#x3D;&#x3D; Q.front)</span><br><span class="line">return ERROR;&#x2F;&#x2F;队列满</span><br><span class="line">Q.base[Q.rear] &#x3D; e;</span><br><span class="line">Q.rear &#x3D; (Q.rear + 1) % MAXSIZE;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StatusDeQueue(SqQueue&amp;Q, QElemType &amp;e)&#123;</span><br><span class="line">&#x2F;&#x2F;若队列不空，则删除Q的队头元素，用e返回其值，并返回OK，否则返回ERROR</span><br><span class="line">if(Q.front &#x3D;&#x3D; Q.rear)</span><br><span class="line">returnERROR;</span><br><span class="line">e &#x3D; Q.base[Q.front];</span><br><span class="line">Q.front &#x3D; (Q.front + 1) % MAXSIZE;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>银行客户的离散事件驱动模拟程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void Bank_Simulation(int CloseTime)&#123;</span><br><span class="line">&#x2F;&#x2F;银行业务模拟，统计一天内客户在银行逗留的平均时间</span><br><span class="line"></span><br><span class="line">OpenForDay();&#x2F;&#x2F;初始化</span><br><span class="line">while(MoreEvent)&#123;</span><br><span class="line">EventDrived(OccurTime, EventType);&#x2F;&#x2F;事件驱动</span><br><span class="line">switch(EventType)&#123;</span><br><span class="line">case &#39;A&#39;:&#x2F;&#x2F;处理客户到达事件</span><br><span class="line">CustomerArrived();</span><br><span class="line">break;</span><br><span class="line">case &#39;D&#39;:&#x2F;&#x2F;处理客户离开事件</span><br><span class="line">CustomerDeparture();</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">Invalid();</span><br><span class="line">&#125;&#x2F;&#x2F;switch</span><br><span class="line">&#125;&#x2F;&#x2F;while</span><br><span class="line">CloseForDay;&#x2F;&#x2F;计算平均逗留时间</span><br><span class="line">&#125;&#x2F;&#x2F;Bank_Simulation</span><br></pre></td></tr></table></figure><p>所需有序链表和队列的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedefstruct&#123;</span><br><span class="line">intOccurTime;&#x2F;&#x2F;事件发生时刻</span><br><span class="line">intNType;&#x2F;&#x2F;事件类型，0表示到达事件，1至4表示四个窗口的离开事件</span><br><span class="line">&#125;Event, Elemtype;&#x2F;&#x2F;事件类型，有序链表LinkList的数据元素类型</span><br><span class="line"></span><br><span class="line">typedefLinkList EventList;&#x2F;&#x2F;事件链表类型，定义为有序链表</span><br><span class="line"></span><br><span class="line">typedefstruct&#123;</span><br><span class="line">intArrivalTime;&#x2F;&#x2F;到达时刻</span><br><span class="line">intDuration;&#x2F;&#x2F;办理事务所需时间</span><br><span class="line">&#125;QElemType;&#x2F;&#x2F;队列的数据元素类型</span><br></pre></td></tr></table></figure><p>银行事件驱动模拟程序算法实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;程序中用到的主要变量</span><br><span class="line">EventListev;&#x2F;&#x2F;事件表</span><br><span class="line">Eventen;&#x2F;&#x2F;事件</span><br><span class="line">LinkQueueq[5];&#x2F;&#x2F;4个客户队列</span><br><span class="line">QElemTypecustomer;&#x2F;&#x2F;客户记录</span><br><span class="line">intTotalTime, CustomerNum;&#x2F;&#x2F;累计客户逗留时间，客户数</span><br><span class="line"></span><br><span class="line">intcmp(Event a, Event b);</span><br><span class="line">&#x2F;&#x2F;依事件a发生的时刻&lt;,&#x3D;或&gt;事件b的发生时刻分别返回-1，0或1</span><br><span class="line"></span><br><span class="line">void OpenForDay()&#123;</span><br><span class="line">&#x2F;&#x2F;初始化操作</span><br><span class="line">TotalTime &#x3D; 0;&#x2F;&#x2F;初始化累计时间为0</span><br><span class="line">CustomerNum &#x3D; 0;&#x2F;&#x2F;初始化客户数为0</span><br><span class="line">InitList(ev);&#x2F;&#x2F;初始化事件链表为空表</span><br><span class="line">en.OcuurTime &#x3D; 0;</span><br><span class="line">en.NType &#x3D; 0;&#x2F;&#x2F;设定第一个客户到达事件</span><br><span class="line">OrderInsert(ev, en, cmp);&#x2F;&#x2F;插入事件表</span><br><span class="line">for(i&#x3D;1; i&lt;&#x3D;4; ++i)</span><br><span class="line">InitQueue(q[i]);&#x2F;&#x2F;置空队列</span><br><span class="line">&#125;&#x2F;&#x2F;OpenForDay</span><br><span class="line"></span><br><span class="line">void CustomerDeparture()&#123;</span><br><span class="line">&#x2F;&#x2F;处理客户离开事件，en.NType&gt;0</span><br><span class="line">i &#x3D; en.Ntype;</span><br><span class="line">DelQueue(q[i], customer);&#x2F;&#x2F;删除第i队列的排头客户</span><br><span class="line">TotalTime +&#x3D; en.OccurTime - customer.ArrivalTime;&#x2F;&#x2F;累计客户逗留时间</span><br><span class="line">if(!QueueEmpty(q[i]))&#123;&#x2F;&#x2F;设定第i队列的一个离开事件并插入事件表</span><br><span class="line">GetHead(q[i], customer);</span><br><span class="line">OrderInsert(ev, (en.OccurTime + customer.Duration, i),(*cmp)());</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;CustomerDeparture</span><br><span class="line"></span><br><span class="line">void Bank_Simulation(int CloseTime)&#123;</span><br><span class="line">OpenForDay();&#x2F;&#x2F;初始化</span><br><span class="line">while(!ListEmpty(ev))&#123;</span><br><span class="line">DelFirst(GetHead(ev), p);</span><br><span class="line">en 66&#x3D; GetCurElem(p);</span><br><span class="line">if(en.NType &#x3D;&#x3D; 0)</span><br><span class="line">CustomerArrived();&#x2F;&#x2F;处理客户到达事件</span><br><span class="line">else</span><br><span class="line">CustomerDeparture();&#x2F;&#x2F;处理客户离开事件</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;计算并输出平均逗留时间</span><br><span class="line">printf(&quot;The AverageTimeis%f\n&quot;,(float)TotalTime&#x2F;CustomerNum);</span><br><span class="line">&#125;&#x2F;&#x2F;Bank_Simulation</span><br></pre></td></tr></table></figure><h1 id="串"><a href="#串" class="headerlink" title="串"></a>串</h1><p>串的抽象数据类型定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">ADTString&#123;</span><br><span class="line">数据对象：D&#x3D;&#123;ai|ai∈CharacterSet, i &#x3D; 1,2,...,n, n&gt;&#x3D;0&#125;</span><br><span class="line">数据关系：R1&#x3D;&#123;&lt;a(i-1), ai&gt;|a(i-1),ai∈D, i &#x3D; 2,...,n&#125;</span><br><span class="line">基本操作：</span><br><span class="line">StrAssign(&amp;T, chars)</span><br><span class="line">初始条件：chars是字符串常量</span><br><span class="line">操作结果：生成一个其值等于chars的串T</span><br><span class="line">StrCopy(&amp;T, S)</span><br><span class="line">初始条件：串S存在</span><br><span class="line">操作结果：由串S复制得到串T</span><br><span class="line">StrEmpty(S)</span><br><span class="line">初始条件：串S存在</span><br><span class="line">操作结果：若S为空串，返回TRUE，否则返回FALSE</span><br><span class="line">StrCompare(S, T)</span><br><span class="line">初始条件：串S和T存在</span><br><span class="line">操作结果：若S&gt;T，则返回值&gt;0，若S&#x3D;T，则返回值&#x3D;0，若S&lt;T，则返回值&lt;0</span><br><span class="line">StrLength(S)</span><br><span class="line">初始条件：串S存在</span><br><span class="line">操作结果：返回S的元素个数，称为串的长度</span><br><span class="line">ClearString(&amp;S)</span><br><span class="line">初始条件：串S存在</span><br><span class="line">操作结果：将S清空为空串</span><br><span class="line">Concat(&amp;T, S1, S2)</span><br><span class="line">初始条件：串S1和S2存在</span><br><span class="line">操作结果：用T返回由S1和S2联接而成的新串</span><br><span class="line">SubString(&amp;Sub, S, pos, len)</span><br><span class="line">初始条件：串S存在，1&lt;&#x3D;pos&lt;&#x3D;StrLength(S)且0&lt;&#x3D;len&lt;&#x3D;StrLength(S)-pos+1</span><br><span class="line">操作结果：用Sub返回串S的第pos个字符起长度为len的子串</span><br><span class="line">Index(S, T, pos)</span><br><span class="line">初始条件：串S和T存在，T是非空串，1&lt;&#x3D;pos&lt;&#x3D;StrLength(S)</span><br><span class="line">操作结果：若主串S中存在和串T值相同的子串，则返回它在主串S中第pos个字符之后第一次出现的位置，否则函数值为0</span><br><span class="line">Replace(&amp;S, T, V)</span><br><span class="line">初始条件：串S，T和V存在，T是非空串</span><br><span class="line">操作结果：用V替换主串S中出现的所有与T相等的不重叠的子串</span><br><span class="line">StrInsert(&amp;S, pos, T)</span><br><span class="line">初始条件：串S和T存在，1&lt;&#x3D;pos&lt;&#x3D;SreLength(S)+1</span><br><span class="line">操作结果：在串S的第pos个字符之前插入串T</span><br><span class="line">StrDelete(&amp;S, pos, len)</span><br><span class="line">初始条件：串S存在，1&lt;&#x3D;pos&lt;&#x3D;StrLength(S)-len+1</span><br><span class="line">操作结果：从串S中删除第pos个字符起长度为len的字串</span><br><span class="line">DestoryString(&amp;S)</span><br><span class="line">初始条件：串S存在</span><br><span class="line">操作结果：串S被销毁</span><br><span class="line">&#125;ADT String</span><br></pre></td></tr></table></figure><p>利用判定、求串长和求子串等操作实现定位函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int Index(String S, String T, int pos)&#123;</span><br><span class="line">&#x2F;&#x2F;T为非空串。若主串S中第pos个字符之后存在与T相等的子串，则返回第一个这样的子串在S中的位置，否则返回0</span><br><span class="line">if(pos&gt;0)&#123;</span><br><span class="line">n &#x3D; StrLength(S);</span><br><span class="line">m &#x3D; StrLength(T);</span><br><span class="line">i &#x3D; pos;</span><br><span class="line">while(i &lt;&#x3D; n - m + 1)&#123;</span><br><span class="line">SubString(sub, S, i, m);</span><br><span class="line">if(StrCompare(sub,T) !&#x3D; 0)</span><br><span class="line">++i;</span><br><span class="line">else</span><br><span class="line">return i;&#x2F;&#x2F;返回子串在主串中的位置</span><br><span class="line">&#125;&#x2F;&#x2F;while</span><br><span class="line">&#125;&#x2F;&#x2F;if</span><br><span class="line">return 0;&#x2F;&#x2F;S中不存在与T相等的子串</span><br><span class="line">&#125;&#x2F;&#x2F;Index</span><br></pre></td></tr></table></figure><p>定长数组描述串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;-----串的定长顺序存储表示-----</span><br><span class="line">#defineMAXSTRLEN255&#x2F;&#x2F;用户可在255以内定义最大串长</span><br><span class="line">typedefunsigned charSString[MAXSTRLEN + 1];&#x2F;&#x2F;0号单元存放串的长度</span><br></pre></td></tr></table></figure><p>串联接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">StatusConcat(SString &amp;T,SString S1, SString S2)&#123;</span><br><span class="line">&#x2F;&#x2F;用T返回由S1和S2联接而成的新串。若未截断，则返回TRUE，否则返回FALSE</span><br><span class="line">if(S1[0] + S2[0] &lt;&#x3D; MAXSTRLEN)&#123;&#x2F;&#x2F;未截断</span><br><span class="line">T[1..S1[0]] &#x3D; S1[1..S1[0]];</span><br><span class="line">T[S1[0]+1..S1[0]+S2[0]] &#x3D; S2[1..S2[0]];</span><br><span class="line">T[0] &#x3D; S1[0] + S2[0];</span><br><span class="line">uncut &#x3D; TRUE;</span><br><span class="line">&#125;</span><br><span class="line">else if(S1[0] &lt; MAXSTRLEN)&#123;&#x2F;&#x2F;截断</span><br><span class="line">T[1..S1[0]] &#x3D; S1[1..S1[0]];</span><br><span class="line">T[S1[0] + 1..MAXSTRLEN] &#x3D; S2[1..MAXSTRLEN-S1[0]];</span><br><span class="line">T[0] &#x3D; MAXSTRLEN;</span><br><span class="line">uncut &#x3D; FALSE;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">T[0..MAXSTRLEN] &#x3D; S1[0..MAXSTRLEN];</span><br><span class="line">&#x2F;&#x2F;T[0] &#x3D;&#x3D; S1[0] &#x3D;&#x3D;MAXSTRLEN</span><br><span class="line">uncut &#x3D; FALSE;</span><br><span class="line">&#125;</span><br><span class="line">return uncut;</span><br><span class="line">&#125;&#x2F;&#x2F;Concat</span><br><span class="line">&#x2F;&#x2F;因为0位表示长度，故1..S1[0]表示从S1的第一个元素到最后一个元素，1..S2[0]同理</span><br></pre></td></tr></table></figure><p>求子串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">StatusSubString(SString &amp;Sub,SString S, int pos, int len)&#123;</span><br><span class="line">&#x2F;&#x2F;用Sub返回串S的第pos个字符起长度为Len的子串</span><br><span class="line">&#x2F;&#x2F;其中，1&lt;&#x3D;pos&lt;&#x3D;StrLength(S)且0&lt;&#x3D;len&lt;&#x3D;StrLength(S)-pos+1</span><br><span class="line">if(pos &lt; 1 || pos &gt; S[0] || len &lt; 0 || len &gt; S[0]-pos+1)</span><br><span class="line">return ERROR;</span><br><span class="line">Sub[1..len] &#x3D; S[pos..pos+len-1];</span><br><span class="line">Sub[0] &#x3D; len;</span><br><span class="line">returnOK;</span><br><span class="line">&#125;&#x2F;&#x2F;SubString</span><br></pre></td></tr></table></figure><p>堆分配存储表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;-----串的堆分配存储表示 -----</span><br><span class="line">typedefstruct&#123;</span><br><span class="line">char*ch;&#x2F;&#x2F;若是非空串，则按串长分配存储区，否则ch为NULL</span><br><span class="line">intlength;&#x2F;&#x2F;串长度</span><br><span class="line">&#125;HString;</span><br></pre></td></tr></table></figure><p>串的插入操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Status StrInsert(HString &amp;S, int pos, HString T)&#123;</span><br><span class="line">&#x2F;&#x2F;1&lt;&#x3D;pos&lt;&#x3D;Strlength(S)+1。在串的第pos个字符之前插入串T</span><br><span class="line">if(pos&lt;1||pos&gt;S.length+1)</span><br><span class="line">returnERROR;&#x2F;&#x2F;pos不合法</span><br><span class="line">if(T.length)&#123;&#x2F;&#x2F;T非空，则重新分配空间，插入T</span><br><span class="line">if(!(S.ch &#x3D; (char *)realloc(S.ch, (S.length+T.length)*sizeof(char))))</span><br><span class="line">exit(OVERFLOW);</span><br><span class="line">for(i&#x3D;S.length-1; i&gt;&#x3D;pos-1; --i)&#x2F;&#x2F;为插入T而腾出位置</span><br><span class="line">S.ch[i+T.length] &#x3D; S.ch[i];</span><br><span class="line">S.ch[pos-1..pos+T.length-2] &#x3D; T.ch[0..T.length-1];&#x2F;&#x2F;插入T</span><br><span class="line">S.length +&#x3D; T.length;</span><br><span class="line">&#125;</span><br><span class="line">return OK;</span><br><span class="line">&#125;&#x2F;&#x2F;StrInsert</span><br></pre></td></tr></table></figure><p>串的表示与实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;ADT String的表示与实现 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x2F;&#x2F;-----串的堆分配存储表示 -----</span><br><span class="line">typedefstruct&#123;</span><br><span class="line">char*ch;&#x2F;&#x2F;若是非空串，则按串长分配存储区，否则ch为NULL</span><br><span class="line">intlength;&#x2F;&#x2F;串长度</span><br><span class="line">&#125;HString;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-----基本操作的函数原型说明-----</span><br><span class="line">StatusStrAssign(HString &amp;T, char *chars);</span><br><span class="line">&#x2F;&#x2F;生成一个其值为串常量chars的串T</span><br><span class="line">intStrLength(HString S);</span><br><span class="line">&#x2F;&#x2F;返回S的元素个数，称为串的长度</span><br><span class="line">intStrCompare(HString S, HString T);</span><br><span class="line">&#x2F;&#x2F;若S&gt;T，则返回值&gt;0，若S&#x3D;T，则返回值&#x3D;0，若S&lt;T，则返回值&lt;0</span><br><span class="line">StatusClearString(HString &amp;S);</span><br><span class="line">&#x2F;&#x2F;将S清为空串，并释放S所占的空间</span><br><span class="line">StatusConcat(HString &amp;T, HString S1, HString S2);</span><br><span class="line">&#x2F;&#x2F;用T返回由S1和S2联接而成的新串</span><br><span class="line">HStringSubString(HString S, int pos, int len);</span><br><span class="line">&#x2F;&#x2F;1&lt;&#x3D;pos&lt;&#x3D;StrLength(S)且0&lt;&#x3D;len&lt;&#x3D;StrLength(S)-pos+1</span><br><span class="line">&#x2F;&#x2F;返回串S的第pos个字符起长度为len的子串</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-----基本操作的算法描述-----</span><br><span class="line">StatusStrAssign(HString &amp;T, char *chars)&#123;</span><br><span class="line">&#x2F;&#x2F;生成一个其值等于串常量chars的串T</span><br><span class="line">if(T.ch)</span><br><span class="line">free(T.ch);&#x2F;&#x2F;释放T原空间</span><br><span class="line">for(i&#x3D;0, c&#x3D;chars; *c; ++i, ++c)</span><br><span class="line">;&#x2F;&#x2F;求chars的长度i</span><br><span class="line">if(!i)&#123;</span><br><span class="line">T.ch &#x3D; NULL;</span><br><span class="line">T.length &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">if(!(T.ch&#x3D;(char *)malloc(i * sizeof(char))))</span><br><span class="line">exit(OVERFLOW);</span><br><span class="line">T.ch[0..i-1]&#x3D;chars[0..i-1];</span><br><span class="line">T.length &#x3D; i;</span><br><span class="line">&#125;</span><br><span class="line">returnOK;</span><br><span class="line">&#125;&#x2F;&#x2F;StrAssign</span><br><span class="line"></span><br><span class="line">intStrLength(HString S)&#123;</span><br><span class="line">&#x2F;&#x2F;返回S的元素个数，称为串的长度</span><br><span class="line">returnS.length;</span><br><span class="line">&#125;&#x2F;&#x2F;StrLength</span><br><span class="line"></span><br><span class="line">int StrCompare(HStringS, HStringT)&#123;</span><br><span class="line">&#x2F;&#x2F;若S&gt;T，则返回值&gt;0；若S&#x3D;T，则返回值&#x3D;0；若S&lt;T，则返回值&lt;0</span><br><span class="line">for(i&#x3D;0; i&lt;S.length&amp;&amp;S.T.length; ++i)</span><br><span class="line">if(S.ch[i]!&#x3D;T.ch[i])</span><br><span class="line">returnS.ch[i] - T.ch[i];</span><br><span class="line">returnS.length-T.length;</span><br><span class="line">&#125;&#x2F;&#x2F;StrCompare</span><br><span class="line"></span><br><span class="line">StatusClearString(HString&amp;S)&#123;</span><br><span class="line">&#x2F;&#x2F;将S清为空串</span><br><span class="line">if(S.ch)&#123;</span><br><span class="line">free(S.ch);</span><br><span class="line">S.ch &#x3D; NULL;</span><br><span class="line">&#125;</span><br><span class="line">S.length &#x3D; 0;</span><br><span class="line">returnOK;</span><br><span class="line">&#125;&#x2F;&#x2F;ClearString</span><br><span class="line"></span><br><span class="line">StatusConcat(HString&amp;T, HStringS1, HStringS2)&#123;</span><br><span class="line">&#x2F;&#x2F;用T返回由S1和S2联接而成的新串</span><br><span class="line">if(T.ch)</span><br><span class="line">free(T.ch);&#x2F;&#x2F;释放旧空间</span><br><span class="line">if(!(T.ch &#x3D; (char *)malloc((S1.length+S2.length) * sizeof(char))))</span><br><span class="line">exit(OVERFLOW);</span><br><span class="line">T.ch[0..S1.length-1] &#x3D; S1[0..S1.length-1];</span><br><span class="line">T.length &#x3D; S1.length + S2.length;</span><br><span class="line">T.ch[S1.length..T.length-1] &#x3D; S2.ch[0..S2.length-1];</span><br><span class="line">returnOK;</span><br><span class="line">&#125;&#x2F;&#x2F;Concat</span><br><span class="line"></span><br><span class="line">StatusSubString(HString &amp;Sub, HString S, int pos, int len)&#123;</span><br><span class="line">&#x2F;&#x2F;用Sub返回串S的第pos个字符起长度为len的子串</span><br><span class="line">&#x2F;&#x2F;其中，1&lt;&#x3D;pos&lt;&#x3D;StrLength(S)且0&lt;&#x3D;len&lt;&#x3D;StrLength(S)-pos+1</span><br><span class="line">if(pos &lt; 1 || pos &gt; S.length || len &lt; 0 || len &gt; S.length-pos+1)</span><br><span class="line">returnERROR;</span><br><span class="line">if(Sub.ch)</span><br><span class="line">free(Sub.ch);</span><br><span class="line">if(!len)&#123;</span><br><span class="line">Sub.ch &#x3D; NULL;</span><br><span class="line">Sub.length &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">Sub.ch &#x3D; (char *)malloc(len * sizeof(char));</span><br><span class="line">Sub.ch[0..len-1] &#x3D; S.ch[pos-1..pos+len-2];</span><br><span class="line">Sub.length &#x3D; len;</span><br><span class="line">&#125;</span><br><span class="line">returnOK;</span><br><span class="line">&#125;&#x2F;&#x2F;SubString</span><br></pre></td></tr></table></figure><p>串的块链结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;串的块链存储表示 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">#defineCHUNKSIZE80&#x2F;&#x2F;可由用户定义块的大小</span><br><span class="line">typedefstructChunk&#123;</span><br><span class="line">charch[CHUNKSIZE];</span><br><span class="line">structChunk*next;</span><br><span class="line">&#125;Chunk;</span><br><span class="line">typedefstruct&#123;</span><br><span class="line">Chunk*head, *tail;&#x2F;&#x2F;串的头和尾指针</span><br><span class="line">intcurlen;&#x2F;&#x2F;串的当前长度</span><br><span class="line">&#125;LString;</span><br></pre></td></tr></table></figure><p>求子串位置的定位函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">intIndex(SString S, SString T, intpos)&#123;</span><br><span class="line">&#x2F;&#x2F;返回子串T在主串S中第pos个字符之后的位置。若不存在，则函数值为0</span><br><span class="line">&#x2F;&#x2F;其中，T非空，1&lt;&#x3D;pos&lt;&#x3D;StrLength(S)</span><br><span class="line">i &#x3D; pos;</span><br><span class="line">j &#x3D; 1;</span><br><span class="line">while(i &lt;&#x3D; S[0] &amp;&amp; j &lt;&#x3D; T[0])&#123;</span><br><span class="line">if(S[i] &#x3D;&#x3D; T[j])&#123;</span><br><span class="line">++i;</span><br><span class="line">++j;</span><br><span class="line">&#125;&#x2F;&#x2F;继续比较后继字符</span><br><span class="line">else&#123;</span><br><span class="line">i &#x3D; i-j+2;</span><br><span class="line">j &#x3D; 1;</span><br><span class="line">&#125;&#x2F;&#x2F;指针后退重新开始匹配</span><br><span class="line">&#125;</span><br><span class="line">if(j &gt; T[0])</span><br><span class="line">returni-T[0];</span><br><span class="line">else</span><br><span class="line">return0;</span><br><span class="line">&#125;&#x2F;&#x2F;Index</span><br></pre></td></tr></table></figure><p>利用模式串的next()函数的KMP算法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">intIndex_KMP(SString S, SString T, intpos)&#123;</span><br><span class="line">&#x2F;&#x2F;利用模式串T的next函数求T在主串S中第pos个字符之后的位置的KMP算法</span><br><span class="line">&#x2F;&#x2F;其中，T非空，1&lt;&#x3D;pos&lt;&#x3D;StrLength(S)</span><br><span class="line">i &#x3D; pos;</span><br><span class="line">j &#x3D; 1;</span><br><span class="line">while(i &lt;&#x3D; S[0] &amp;&amp; j &lt;&#x3D; T[0])&#123;</span><br><span class="line">if( j &#x3D;&#x3D; 0 || S[i] &#x3D;&#x3D; T[j] )&#123;</span><br><span class="line">++i;</span><br><span class="line">++j;</span><br><span class="line">&#125;&#x2F;&#x2F;继续比较后继字符</span><br><span class="line">else</span><br><span class="line">j &#x3D; next[j];</span><br><span class="line">&#125;</span><br><span class="line">if(j &gt; T[0])</span><br><span class="line">returni - T[0];</span><br><span class="line">else</span><br><span class="line">return0;</span><br><span class="line">&#125;&#x2F;&#x2F;Index_KMP</span><br></pre></td></tr></table></figure><p>KMP算法中的next函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void get_next(SString T, int next[])&#123;</span><br><span class="line">&#x2F;&#x2F;求模式串T的next函数值并存入数组next</span><br><span class="line">i &#x3D; 1;</span><br><span class="line">next[1] &#x3D; 0;</span><br><span class="line">j &#x3D; 0;</span><br><span class="line">while(i &lt; T[0])&#123;</span><br><span class="line">if(j &#x3D;&#x3D; 0 || T[i] &#x3D;&#x3D; T[j])&#123;</span><br><span class="line">++i;</span><br><span class="line">++j;</span><br><span class="line">next[i] &#x3D; j;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">j &#x3D; next[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;get_next</span><br></pre></td></tr></table></figure><p>计算next函数修正值的算法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void get_nextval(SString T, int nextval[])&#123;</span><br><span class="line">&#x2F;&#x2F;求模式串T的next函数修正值并存入数组nextval</span><br><span class="line">i &#x3D; 1;</span><br><span class="line">nextval[1] &#x3D; 0;</span><br><span class="line">j &#x3D; 0;</span><br><span class="line">while(i&lt;T[0])&#123;</span><br><span class="line">if(j &#x3D;&#x3D; 0 || T[i] &#x3D;&#x3D; T[j])&#123;</span><br><span class="line">++i;</span><br><span class="line">++j;</span><br><span class="line">if(T[i] !&#x3D; T[j])</span><br><span class="line">nextval[i] &#x3D; j;</span><br><span class="line">else</span><br><span class="line">nextval[i] &#x3D; nextval[j];</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">j &#x3D; nextval[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;get_nextval</span><br></pre></td></tr></table></figure><p>词典索引表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#defineMaxBookNum1000&#x2F;&#x2F;假设只对1000本书建索引表</span><br><span class="line">#defineMaxKeyNum2500&#x2F;&#x2F;索引表的最大容量</span><br><span class="line">#defineMaxLineLen500&#x2F;&#x2F;书目串的最大长度</span><br><span class="line">#defineMaxWordNum10&#x2F;&#x2F;词表的最大容量</span><br><span class="line"></span><br><span class="line">typedefstruct&#123;</span><br><span class="line">char*item[];&#x2F;&#x2F;字符串的数组</span><br><span class="line">intlast;&#x2F;&#x2F;词表的长度</span><br><span class="line">&#125;WordListType;&#x2F;&#x2F;词表类型（顺序表）</span><br><span class="line">typedefintElemType;&#x2F;&#x2F;定义链表的数据元素类型为整型（书号类型）</span><br><span class="line">typedefstruct&#123;</span><br><span class="line">HStringkey;&#x2F;&#x2F;关键词</span><br><span class="line">LinkList bnolist;&#x2F;&#x2F;存放书号索引的链表</span><br><span class="line">&#125;IdxTermType;&#x2F;&#x2F;索引项类型</span><br><span class="line">typedefstruct&#123;</span><br><span class="line">IdxTermTypeitem[MaxKetNum+1];</span><br><span class="line">intlast;</span><br><span class="line">&#125;IdxListType;&#x2F;&#x2F;索引表类型（有序表）</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;主要变量</span><br><span class="line">char*buf;&#x2F;&#x2F;书目串缓冲区</span><br><span class="line">WordListTypewdlist;&#x2F;&#x2F;词表</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;基本操作</span><br><span class="line">voidInitIdxList(IdxListType&amp;idxlist);</span><br><span class="line">&#x2F;&#x2F;初始化操作，置索引表idxlist为空表，且在idxlist.item[0]设一空串</span><br><span class="line">voidGetLine(FILE f);</span><br><span class="line">&#x2F;&#x2F;从文件f读入一个书目信息到书目缓冲区buf</span><br><span class="line">voidExtractKeyWord(ElemType&amp;bno);</span><br><span class="line">&#x2F;&#x2F;从buf中提取书名关键词到词表wdlist，书号存入bno</span><br><span class="line">StatusInsIdxList(IdxListType &amp;idxlist, ElemType bno);</span><br><span class="line">&#x2F;&#x2F;将书号为bno的书名关键词按词典顺序插入索引表idxlist</span><br><span class="line">void PutText(FILE g, IdxListType idxlist);</span><br><span class="line">&#x2F;&#x2F;将生成的索引表idxlist输出到文件g</span><br><span class="line"></span><br><span class="line">void main()&#123;&#x2F;&#x2F;主函数</span><br><span class="line">if(f &#x3D; openf(&quot;BookInfo.txt&quot;,&quot;r&quot;))&#123;</span><br><span class="line">if(g &#x3D; openf(&quot;BookIdx.txt&quot;,&quot;w&quot;))&#123;</span><br><span class="line">InitIdxList(idxlist);&#x2F;&#x2F;初始化索引表idxlist为空表</span><br><span class="line">while(!feof(f))&#123;</span><br><span class="line">GetLine(f);&#x2F;&#x2F;从文件f读入一个书目信息到buf</span><br><span class="line">ExtractKeyWord(BookNo);&#x2F;&#x2F;从buf提取关键词到词表，书号存入BookNo</span><br><span class="line">InsIdxList(idxlist, BookNo);&#x2F;&#x2F;将书号为BookNo的关键词插入索引表</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">PutText(g, idxlist);&#x2F;&#x2F;将生成的索引表idxlist输出到文件g</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;main</span><br></pre></td></tr></table></figure><p>实现插入操作所必须函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">voidGetWord(int i, HString&amp;wd);</span><br><span class="line">&#x2F;&#x2F;用wd返回词表wdlist中第i个关键词</span><br><span class="line">intLocate(IdxListType idxlist, HString wd, Boolean &amp;b);</span><br><span class="line">&#x2F;&#x2F;在索引表idxlist中查询是否存在与wd相等的关键词</span><br><span class="line">&#x2F;&#x2F;若存在，则返回其在索引表中的位置，且b取值TRUE，否则返回插入位置，且b取值FALSE</span><br><span class="line">void InsertNewKey(IdxListType &amp;idxlist, int i, HString wd);</span><br><span class="line">&#x2F;&#x2F;在索引表idxlist的第i项上插入新关键词wd，并初始化书号索引的链表为空表</span><br><span class="line">StatusInsIdxList(IdxListType&amp;idxlist, int i, int bno);</span><br><span class="line">&#x2F;&#x2F;在索引表idxlist的第i项中插入书号为bno的索引</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;插入算法</span><br><span class="line">StatusInsIdxList(IdxListType &amp;idxlist, int bno)&#123;</span><br><span class="line">for(i&#x3D;0; i&lt;wdlist.last; ++i)&#123;</span><br><span class="line">GetWord(i, wd);</span><br><span class="line">j &#x3D; Locate(idxlist, wd, b);</span><br><span class="line">if(!b)</span><br><span class="line">InsertNewKey(idxlist, j, wd);&#x2F;&#x2F;插入新的索引项</span><br><span class="line">if(!InsertBook(idxlist,j,bno))</span><br><span class="line">returnOVERFLOW；&#x2F;&#x2F;插入书号索引</span><br><span class="line">&#125;</span><br><span class="line">returnOK;</span><br><span class="line">&#125;&#x2F;&#x2F;InsertIdxList</span><br><span class="line"></span><br><span class="line">void GetWord(int i, HString &amp;wd)&#123;</span><br><span class="line">p&#x3D; *(wd.list.item + i);&#x2F;&#x2F;取词表中第i个字符串</span><br><span class="line">StrAssign(wd,p);&#x2F;&#x2F;生成关键字字符串</span><br><span class="line">&#125;&#x2F;&#x2F;GetWord</span><br><span class="line"></span><br><span class="line">int Locate(IdxListType&amp;idxlist, HString wd, Boolean &amp;b)&#123;</span><br><span class="line">for(i &#x3D; idxlist.last - 1; (m &#x3D; StrCompare(idxlist.item[i].key, wd)) &gt; 0; --i)</span><br><span class="line">;</span><br><span class="line">if(m&#x3D;&#x3D;0)&#123;</span><br><span class="line">b &#x3D;TRUE;</span><br><span class="line">returni;&#x2F;&#x2F;找到</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">b &#x3D; FALSE;</span><br><span class="line">return i+1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;Locate</span><br><span class="line"></span><br><span class="line">void InsertNewKey(int i, StrType wd)&#123;</span><br><span class="line">for(j &#x3D; idxlist.last-1; j&gt;&#x3D;1; --j)&#x2F;&#x2F;后移索引项</span><br><span class="line">idxlist.item[j+1] &#x3D; idxlist.item[j];</span><br><span class="line">&#x2F;&#x2F;插入新的索引项</span><br><span class="line">StrCopy(idxlist.item[i].key, wd);&#x2F;&#x2F;串赋值</span><br><span class="line">InitList(idxlist.item[i].bnolist);&#x2F;&#x2F;初始化书号索引表为空表</span><br><span class="line">++idxlist.last;</span><br><span class="line">&#125;&#x2F;&#x2F;InsertNewKey</span><br><span class="line"></span><br><span class="line">StatusInsertBook(IdxListType &amp;idxlist, int i, int bno)&#123;</span><br><span class="line">if(!MakeNode(p, bno))</span><br><span class="line">returnERROR;&#x2F;&#x2F;分配失败</span><br><span class="line">Appand(idxlist.item[i].bnolist, p);&#x2F;&#x2F;插入新的书号索引</span><br><span class="line">returnOK;</span><br><span class="line">&#125;&#x2F;&#x2F;InserBook</span><br></pre></td></tr></table></figure><h1 id="数组与广义表"><a href="#数组与广义表" class="headerlink" title="数组与广义表"></a>数组与广义表</h1><p>数组的抽象数据类型定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ADTArray&#123;</span><br><span class="line">数据对象：ji&#x3D;0,...,bi-1,i &#x3D; 1,2,...,n</span><br><span class="line">D &#x3D; &#123;aj1j2...jn |n(&gt;0)称为数组的维数，bi是数组第i维的长度，ji是数组元素的第i维下标，aj1j2...jn∈ElemSet&#125;</span><br><span class="line">数据关系：R &#x3D; &#123;R1, R2, ..., Rn&#125;</span><br><span class="line">Ri &#x3D; &#123;&lt;aj1...ji...jn , aj1...ji+1...jn&gt;|0&lt;&#x3D;jk&lt;&#x3D;bk-1, 1&lt;&#x3D;k&lt;&#x3D;n且k≠i,0&lt;&#x3D;ji&lt;&#x3D;bi-2,aj1...ji...jn , aj1...ji+1...jn∈D, i&#x3D;2,...,n&#125;</span><br><span class="line">基本操作：</span><br><span class="line">InitArray(&amp;A, n, bound1, ..., boundn)</span><br><span class="line">操作结果：若维数n和各维长度合法，则构造相应数组A，并返回OK</span><br><span class="line">DestroyArray(&amp;A)</span><br><span class="line">操作结果：销毁数组A</span><br><span class="line">value(A, &amp;e, index1, ..., indexn)</span><br><span class="line">初始条件：A是n维数组，e为元素变量，随后是n个下标值</span><br><span class="line">操作结果：若各下标不超界，则e赋值为所指定的A的元素值，并返回OK</span><br><span class="line">Assign(&amp;A, e, index1, ..., indexn)</span><br><span class="line">初始条件：A是n维数组，e为元素变量，随后是n个下标</span><br><span class="line">操作结果：若下标不越界，则将e的值赋给所指定的A的元素，并返回OK</span><br><span class="line">&#125;ADT Array</span><br></pre></td></tr></table></figure><p>数组的顺序存储表示及实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;-----数组的顺序存储表示 -----</span><br><span class="line">#include&lt;stdio.h&gt;&#x2F;&#x2F;标准头文件，提供宏va_start、va_arg和va_end</span><br><span class="line">&#x2F;&#x2F;用于存取变长参数表</span><br><span class="line">#defineMAX_ARRAY_DIM8&#x2F;&#x2F;假设数组维数的最大值为8</span><br><span class="line">typedefstruct&#123;</span><br><span class="line">ElemType*base;&#x2F;&#x2F;数组元素基址，由InitArray分配</span><br><span class="line">intdim;&#x2F;&#x2F;数组维数</span><br><span class="line">int*bounds;&#x2F;&#x2F;数组维数基址，由InitArray分配</span><br><span class="line">int*constanst;&#x2F;&#x2F;数组映像函数常量基址，由InitArray分配</span><br><span class="line">&#125;Array;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-----基本操作的函数原型说明 -----</span><br><span class="line">StatusInitArray(Array&amp;A, intdim, ...);</span><br><span class="line">&#x2F;&#x2F;若维数dim和各维长度合法，则构造相应的数组A，并返回OK</span><br><span class="line">StatusDestroyArray(Array&amp;A);</span><br><span class="line">&#x2F;&#x2F;销毁数组A</span><br><span class="line">StatusValue(ArrayA, ElemType&amp;e, ...);</span><br><span class="line">&#x2F;&#x2F;A是n维数组，e为元素变量，随后是n个下标值</span><br><span class="line">&#x2F;&#x2F;若各下标不超界，则e的赋值给所指定的A的元素值，并返回OK</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-----基本操作的算法描述 -----</span><br><span class="line">StatusInitArray(Array&amp;A, int dim, ...)&#123;</span><br><span class="line">&#x2F;&#x2F;若维数dim和各维长度合法，则构造相应的数组A，并返回OK</span><br><span class="line">if(dim &lt; 1 || dim &gt; MAX_ARRAY_DIM)</span><br><span class="line">returnERROR;</span><br><span class="line">A.dim &#x3D; dim;</span><br><span class="line">A.bounds &#x3D; (int*)malloc(dim * sizeof( int ));</span><br><span class="line">if(!A.bounds)</span><br><span class="line">exit(OVERFLOW);</span><br><span class="line">&#x2F;&#x2F;若各维长度合法，则存入A.bounds，并求出A的元素总数elemtotal</span><br><span class="line">elemtotal &#x3D; 1;</span><br><span class="line">va_start(ap, dim);&#x2F;&#x2F;ap为va_list类型，是存放变长参数表信息的数组</span><br><span class="line">for(i &#x3D; 0; i&lt;dim; ++i)&#123;</span><br><span class="line">A.bounds[i] &#x3D; va_arg(ap, int);</span><br><span class="line">if(A.bounds[i]&lt;0)</span><br><span class="line">returnUNDERFLOW;</span><br><span class="line">elemtotal *&#x3D; A.bounds[i];</span><br><span class="line">&#125;</span><br><span class="line">va_end(ap);</span><br><span class="line">A.base &#x3D; (ElemType*)malloc(elemtotal * sizeof(ElemType));</span><br><span class="line">if(!A.base)</span><br><span class="line">exit(OVERFLOW);</span><br><span class="line">&#x2F;&#x2F;求映像函数的常数c，并存入A.constants[i-1], i &#x3D; 1,...,dim</span><br><span class="line">A.constants &#x3D; (int *)malloc(dim * sizeof(int));</span><br><span class="line">if(!A.constants)</span><br><span class="line">exit(OVERFLOW);</span><br><span class="line">A.constants[dim-1] &#x3D; 1;&#x2F;&#x2F;L&#x3D;1，指针的增减以元素的大小为单位</span><br><span class="line">for( i &#x3D; dim-2; i&gt;&#x3D;0; --i )</span><br><span class="line">A.constants[i] &#x3D; A.bounds[i + 1] * A.constants[i + 1];</span><br><span class="line">returnOK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StatusDestroyArray(Array&amp;A)&#123;</span><br><span class="line">&#x2F;&#x2F;销毁数组A</span><br><span class="line">if(！A.base)</span><br><span class="line">returnERROR;</span><br><span class="line">free(A.base);</span><br><span class="line">A.base &#x3D; NULL;</span><br><span class="line">if(A.bounds)</span><br><span class="line">returnERROR;</span><br><span class="line">free(A.bounds);</span><br><span class="line">A.bounds &#x3D; NULL;</span><br><span class="line">if(!A.constants)</span><br><span class="line">returnERROR;</span><br><span class="line">free(A.constants);</span><br><span class="line">A.constants &#x3D; NULL;</span><br><span class="line">returnOK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StatusLocate(Array A, va_list ap, int&amp;off)&#123;</span><br><span class="line">&#x2F;&#x2F;若ap指示的各下标值合法，则求出该元素在A中的相对地址off</span><br><span class="line">off &#x3D; 0;</span><br><span class="line">for( i &#x3D; 0; i&lt;A.dim; ++i)&#123;</span><br><span class="line">ind &#x3D; va_arg(ap, int);</span><br><span class="line">if(ind&lt;0 || ind&gt;&#x3D;A.bounds[i])</span><br><span class="line">returnOVERFLOW;</span><br><span class="line">off +&#x3D; A.constants[i] * ind;</span><br><span class="line">&#125;</span><br><span class="line">returnOK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StatusValue(Array A, ElemType&amp;e, ...)&#123;</span><br><span class="line">&#x2F;&#x2F;A是n维数组，e为元素变量，随后是n个下标值</span><br><span class="line">&#x2F;&#x2F;若各下标值不超界，则e赋值为所指定的A的元素值，并返回OK</span><br><span class="line">va_start(ap, e);</span><br><span class="line">if((result &#x3D; Locate(A, ap, off))&lt;&#x3D;0)</span><br><span class="line">returnresult;</span><br><span class="line">e &#x3D; *(A.base + off);</span><br><span class="line">returnOK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StatusAssign(Array &amp;A, ElemType e, ...)&#123;</span><br><span class="line">&#x2F;&#x2F;A是n维数组，e为元素变量，随后是n个下标值</span><br><span class="line">&#x2F;&#x2F;若下标不超界，则将e的值赋给所指定的A的元素，并返回OK</span><br><span class="line">va_start(ap, e);</span><br><span class="line">if((result &#x3D; Locate(A, ap, off))&lt;&#x3D;0)</span><br><span class="line">returnresult;</span><br><span class="line">*(A.base + off) &#x3D; e;</span><br><span class="line">returnOK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>稀疏矩阵的抽象数据类型定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">ADTSparseMatrix&#123;</span><br><span class="line">数据对象：D &#x3D; &#123;aij|i &#x3D; 1,2,...,n;ai,j∈ElemSet，m和n分别称为矩阵的行数和列数&#125;</span><br><span class="line">数据关系：R &#x3D; &#123;Row, Col&#125;</span><br><span class="line">Row &#x3D; &#123;&lt;ai,j,ai,j+1&gt;| 1&lt;&#x3D;i&lt;&#x3D;m, 1&lt;&#x3D;j&lt;&#x3D;n-1&#125;</span><br><span class="line">Col &#x3D; &#123;&lt;ai,j,ai+1,j&gt;| 1&lt;&#x3D;i&lt;&#x3D;m-1, 1&lt;&#x3D;j&lt;&#x3D;n&#125; </span><br><span class="line">基本操作：</span><br><span class="line">CreateSMatrix(&amp;M);</span><br><span class="line">操作结果：创建稀疏矩阵M</span><br><span class="line">DestroySMatrix(&amp;M);</span><br><span class="line">初始条件：稀疏矩阵M存在</span><br><span class="line">操作结果：销毁稀疏矩阵M</span><br><span class="line">PrintSMatrix(M);</span><br><span class="line">初始条件：稀疏矩阵M存在</span><br><span class="line">操作结果：输出稀疏矩阵M</span><br><span class="line">CopySMatrix(M, &amp;T);</span><br><span class="line">初始条件：稀疏矩阵M存在</span><br><span class="line">操作结果：由稀疏矩阵M复制得到T</span><br><span class="line">AddSMatrix(M, N, &amp;Q);</span><br><span class="line">初始条件：稀疏矩阵M与N的行数与列数对应相等</span><br><span class="line">操作结果：求稀疏矩阵的和Q &#x3D; M + N</span><br><span class="line">SubSMatrix(M, N, &amp;Q);</span><br><span class="line">初始条件：稀疏矩阵M与N的行数与列数对应相等</span><br><span class="line">操作结果：求稀疏矩阵的差Q &#x3D; M - N</span><br><span class="line">MultSMatrix(M, N, &amp;Q);</span><br><span class="line">初始条件：稀疏矩阵M的列数等于N的行数</span><br><span class="line">操作结果：求稀疏矩阵乘积Q &#x3D; M * N</span><br><span class="line">TransposeSmatrix(M, &amp;T);</span><br><span class="line">初始条件：稀疏矩阵M存在</span><br><span class="line">操作结果：求稀疏矩阵M的转置矩阵T</span><br><span class="line">&#125;ADT SparseMatrix</span><br></pre></td></tr></table></figure><p>稀疏矩阵的三元组表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;-----稀疏矩阵的三元组顺序表存储表示-----</span><br><span class="line">#defineMAXSIZE12500&#x2F;&#x2F;假设非零元个数的最大值为12500</span><br><span class="line">typedefstruct&#123;</span><br><span class="line">inti, j;&#x2F;&#x2F;该非零元的行下标和列下标</span><br><span class="line">ElemTypee;</span><br><span class="line">&#125;Triple</span><br><span class="line">typedefstruct&#123;</span><br><span class="line">Tripledata[MAXSIZE + 1];&#x2F;&#x2F;非零元三元组表，data[0]未用</span><br><span class="line">intmu, nu, tu;&#x2F;&#x2F;矩阵的行数，列数和非零元个数</span><br><span class="line">&#125;TSMatrix;</span><br></pre></td></tr></table></figure><p>三元组表示求稀疏矩阵的转置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">StatusTransposeSMatrix(TSMatrix M, TSMatrix &amp;T)&#123;</span><br><span class="line">&#x2F;&#x2F;采用三元组表存储表示，求稀疏矩阵M的转置矩阵T</span><br><span class="line">T.mu &#x3D; M.nu;</span><br><span class="line">T.nu &#x3D; M.nu;</span><br><span class="line">T.tu &#x3D; M.tu;</span><br><span class="line">if(T.tu)&#123;</span><br><span class="line">q &#x3D; 1;</span><br><span class="line">for(col &#x3D; 1; col&lt;&#x3D;M.nu; ++col)&#123;</span><br><span class="line">for(p &#x3D; 1; p&lt;&#x3D;M.tu; ++p)&#123;</span><br><span class="line">if(M.data[p].j &#x3D;&#x3D; col)&#123;</span><br><span class="line">T.data[q].i &#x3D; M.data[p].j;</span><br><span class="line">T.data[q].j &#x3D; M.data[p].i;</span><br><span class="line">T.data[q].e &#x3D; M.data[p].e;</span><br><span class="line">++q;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">returnOK;</span><br><span class="line">&#125;&#x2F;&#x2F;TransposeSMatrix</span><br></pre></td></tr></table></figure><p>快速转置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">StatusFastTransposeSMatrix(TSMatrix M, TSMatrix &amp;T)&#123;</span><br><span class="line">&#x2F;&#x2F;采用三元组顺序表存储表示，求稀疏矩阵M的转置矩阵T</span><br><span class="line">T.mu &#x3D; M.nu;</span><br><span class="line">T.nu &#x3D; M.mu;</span><br><span class="line">T.tu &#x3D; M.tu;</span><br><span class="line">if(T.tu)&#123;</span><br><span class="line">for(col &#x3D; 1; col&lt;&#x3D;M.nu; ++col)</span><br><span class="line">num[col] &#x3D; 0;</span><br><span class="line">for(t &#x3D; 1; t&lt;&#x3D;M.tu; ++t)</span><br><span class="line">++num[M.data[t].j];&#x2F;&#x2F;求M中每一列含非零元个数</span><br><span class="line">cpot[1] &#x3D; 1;</span><br><span class="line">&#x2F;&#x2F;求第col列中第一个非零元在b.data中的序号</span><br><span class="line">for(col &#x3D; 2; col&lt;&#x3D;M.nu; ++col)</span><br><span class="line">cpot[col] &#x3D; cpot[col - 1] + num[col - 1];</span><br><span class="line">for(p &#x3D; 1; p&lt;&#x3D;M.tu; ++p)&#123;</span><br><span class="line">col &#x3D; M.data[p].j;</span><br><span class="line">q &#x3D; cpot[col];</span><br><span class="line">T.data[q].i &#x3D; M.data[p].j;</span><br><span class="line">T.data[q].j &#x3D; M.data[p].i;</span><br><span class="line">T.data[q].e &#x3D; M.data[p].e;</span><br><span class="line">++cpot[col];</span><br><span class="line">&#125;&#x2F;&#x2F;for</span><br><span class="line">&#125;&#x2F;&#x2F;if</span><br><span class="line">returnOK;</span><br><span class="line">&#125;&#x2F;&#x2F;FastTransposeSmatrix</span><br></pre></td></tr></table></figure><p>行逻辑链接的顺序表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedefstruct&#123;</span><br><span class="line">Tripledata[MAXSIZE + 1];&#x2F;&#x2F;非零元三元组表</span><br><span class="line">intrpos[MAXRC + !];&#x2F;&#x2F;各行第一个非零元的位置表</span><br><span class="line">intmu, nu, tu;&#x2F;&#x2F;矩阵的行数、列数和非零元个数</span><br><span class="line">&#125;RLSMatrix;</span><br></pre></td></tr></table></figure><p>两个矩阵相乘的过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Q初始化;</span><br><span class="line">if(Q是非零矩阵)&#123;&#x2F;&#x2F;逐行压缩</span><br><span class="line">for(arow &#x3D; 1; arow&lt;&#x3D;M.mu; ++arow)&#123;&#x2F;&#x2F;处理M的每一行</span><br><span class="line">ctemp[ ] &#x3D; 0;&#x2F;&#x2F;累加器清零</span><br><span class="line">计算Q中第arow行的积并存入ctemp[ ]中;</span><br><span class="line">将ctemp[ ]中的非零元压缩存储到Q.data;</span><br><span class="line">&#125;&#x2F;&#x2F;forarow</span><br><span class="line">&#125;&#x2F;&#x2F;if</span><br></pre></td></tr></table></figure><p>求精后可得：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">StatusMultSMatrix(RLSMatrix M, RLSMatrix N, RLSMatrix&amp;Q)&#123;</span><br><span class="line">&#x2F;&#x2F;求矩阵乘积Q &#x3D; M * N，采用行逻辑链接存储表示</span><br><span class="line">if(M.nu !&#x3D; N.mu)</span><br><span class="line">returnERROR;</span><br><span class="line">Q.mu &#x3D; M.mu;</span><br><span class="line">Q.nu &#x3D; N.nu;</span><br><span class="line">Q.tu &#x3D; 0;&#x2F;&#x2F;Q初始化</span><br><span class="line">if(M.tu * N.tu !&#x3D; 0)&#123;&#x2F;&#x2F;Q是非零矩阵</span><br><span class="line">for(arow &#x3D; 1; arow&lt;&#x3D;M.mu; ++arow)&#123;&#x2F;&#x2F;处理M的每一行</span><br><span class="line">ctemp[ ] &#x3D; 0;&#x2F;&#x2F;当前行各元素累加器清零</span><br><span class="line">Q.rpos[arow] &#x3D; Q.tu + 1;</span><br><span class="line">if(arow&lt;M.mu)</span><br><span class="line">tp &#x3D; M.rpos[arow + 1];</span><br><span class="line">else&#123;</span><br><span class="line">tp &#x3D; M.tu + 1;</span><br><span class="line">&#125;</span><br><span class="line">for(p &#x3D; M.rpos[arow]; p&lt;tp; ++p)&#123;&#x2F;&#x2F;对当前行中每一个非零元</span><br><span class="line">brow &#x3D; M.data[p].j;&#x2F;&#x2F;找到对应元在N中的行号</span><br><span class="line">if(brow &lt; N.mu)</span><br><span class="line">t &#x3D; N.rpos[brow + 1];</span><br><span class="line">else&#123;</span><br><span class="line">t &#x3D; N.tu + 1;</span><br><span class="line">&#125;</span><br><span class="line">for(q &#x3D; N.rpos[brow]; q&lt;t; ++q)&#123;</span><br><span class="line">ccol &#x3D; N.data[q].j;&#x2F;&#x2F;乘积元素在Q中列号</span><br><span class="line">ctemp[ccol] +&#x3D; M.data[p].e * N.data[q].e;</span><br><span class="line">&#125;&#x2F;&#x2F;for q</span><br><span class="line">&#125;&#x2F;&#x2F;求得Q中第crow( &#x3D;arow)行的非零元</span><br><span class="line">for(ccol &#x3D; 1; ccol&lt;&#x3D;Q.nu; ++ccol)&#x2F;&#x2F;压缩存储该行非零元</span><br><span class="line">if(ctemp[ccol])&#123;</span><br><span class="line">if( ++Q.tu &gt; MAXSIZE)</span><br><span class="line">returnERROR;</span><br><span class="line">Q.data[Q.tu] &#x3D; (arow, ccol, ctemp[ccol]);</span><br><span class="line">&#125;&#x2F;&#x2F;if</span><br><span class="line">&#125;&#x2F;&#x2F;for arow</span><br><span class="line">&#125;&#x2F;&#x2F;if</span><br><span class="line">returnOK;</span><br><span class="line">&#125;&#x2F;&#x2F;MultSMatrix</span><br></pre></td></tr></table></figure><p>稀疏矩阵的十字链表存储表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;-----稀疏矩阵的十字链表存储表示 -----</span><br><span class="line">typedefstruct OLNode&#123;</span><br><span class="line">inti, j;&#x2F;&#x2F;该非零元的行和列下标</span><br><span class="line">ElemTypee;</span><br><span class="line">structOLNode*right, *down;&#x2F;&#x2F;该非零元所在行表和列表的后继链域</span><br><span class="line">&#125;OLNode;*OLink;</span><br><span class="line"></span><br><span class="line">typedefstruct&#123;</span><br><span class="line">Olink*rhead, *chead;&#x2F;&#x2F;行和列链表的头指针向量基址，由CreatSMatrix分配</span><br><span class="line">intmu, nu, tu;&#x2F;&#x2F;稀疏矩阵的行数、列数和非零元个数</span><br><span class="line">&#125;CrossList;</span><br><span class="line"></span><br><span class="line">StatusCreatSMatrix_OL(CrossList &amp;M)&#123;</span><br><span class="line">&#x2F;&#x2F;创建稀疏矩阵，用十字链表存储表示</span><br><span class="line">if(M)</span><br><span class="line">free(M);</span><br><span class="line">scanf(&amp;m, &amp;n, &amp;t);&#x2F;&#x2F;输入m的行数、列数和非零元个数</span><br><span class="line">M.mu :&#x3D; m；</span><br><span class="line">M.nu :&#x3D; n;</span><br><span class="line">M.tu :&#x3D; t;</span><br><span class="line">if(!(M.rhead &#x3D; (OLink *)malloc((m + 1) * sizeof(OLink))))</span><br><span class="line">exit(OVERFLOW);</span><br><span class="line">if(!(M.chead &#x3D; (OLink *)malloc((m + 1) * sizeof(OLink))))</span><br><span class="line">exit(OVERFLOW);</span><br><span class="line">M.rhead[ ] &#x3D; M.chead[ ] &#x3D; NULL;&#x2F;&#x2F;初始化行列头指针向量；各行列链表为空链表</span><br><span class="line">for(scanf(&amp;i, &amp;j, &amp;e); i!&#x3D;0; scanf(&amp;i, &amp;j, &amp;e))&#123;&#x2F;&#x2F;按任意次序输入非零元</span><br><span class="line">if(!(p &#x3D; (OLNode *)malloc(sizeof(OLNode))))</span><br><span class="line">exit(OVERFLOW);</span><br><span class="line">p-&gt;i &#x3D; i;</span><br><span class="line">p-&gt;j &#x3D; j;</span><br><span class="line">p-&gt;e &#x3D; e;&#x2F;&#x2F;生成结点</span><br><span class="line">if(M.rhead[i] &#x3D;&#x3D; NULL || M.rhead[i]-&gt;j&gt;j)&#123;</span><br><span class="line">p-&gt;right &#x3D; M.rhead[i];</span><br><span class="line">M.rhead[i] &#x3D; p;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;&#x2F;&#x2F;巡查在行表中的插入位置</span><br><span class="line">for( q &#x3D; M.rhead[i]; (q-&gt;right) &amp;&amp; q-&gt;right-&gt;j&lt;j; q &#x3D; q-&gt;right)</span><br><span class="line">;</span><br><span class="line">p-&gt;right &#x3D; q-&gt;right;</span><br><span class="line">q-&gt;rignt &#x3D; p;</span><br><span class="line">&#125;&#x2F;&#x2F;完成行插入</span><br><span class="line">if(M.chead[j] &#x3D;&#x3D; NULL || M.chead[j]-&gt;i&gt;i)&#123;</span><br><span class="line">p-&gt;down &#x3D; M.chead[j];</span><br><span class="line">M.chead[j] &#x3D; p;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;&#x2F;&#x2F;巡查在列表中的插入位置</span><br><span class="line">for( q &#x3D; M.chead[i]; (q-&gt;down) &amp;&amp; q-&gt;down-&gt;i&lt;i; q &#x3D; q-&gt;down)</span><br><span class="line">;</span><br><span class="line">p-&gt;down &#x3D; q-&gt;down;</span><br><span class="line">q-&gt;down &#x3D; p;</span><br><span class="line">&#125;&#x2F;&#x2F;完成列插入</span><br><span class="line">&#125;</span><br><span class="line">returnOK;</span><br><span class="line">&#125;&#x2F;&#x2F;CreateSMatrix_OL</span><br></pre></td></tr></table></figure><p>广义表的抽象数据类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">ADTGList&#123;</span><br><span class="line">数据对象：D &#x3D; &#123;ei|i &#x3D; 1,2,...,n;ei∈AtomSet或ei∈GList,AtomSet为某个元素的数据对象&#125;</span><br><span class="line">数据关系：R1 &#x3D; &#123;&lt;ei-1, ei&gt;|ei-1,ei∈D, 2&lt;&#x3D;i&lt;&#x3D;n&#125;</span><br><span class="line">基本操作：</span><br><span class="line">InitGList(&amp;L);</span><br><span class="line">操作结果：创建空间的广义表L</span><br><span class="line">CreateGList(&amp;L, S);</span><br><span class="line">初始条件：S是广义表的书写形式串</span><br><span class="line">操作结果：由S创建广义表L</span><br><span class="line">DestroyGList(&amp;L);</span><br><span class="line">初始条件：广义表L存在</span><br><span class="line">操作结果：销毁广义表L</span><br><span class="line">CopyGList(&amp;T, L);</span><br><span class="line">初始条件：广义表L存在</span><br><span class="line">操作结果：由广义表L复制得到广义表T</span><br><span class="line">GListLength(L);</span><br><span class="line">初始条件：广义表L存在</span><br><span class="line">操作结果：求广义表的长度，即元素个数</span><br><span class="line">GListDepth(L);</span><br><span class="line">初始条件：广义表L存在</span><br><span class="line">操作结果：求广义表的深度</span><br><span class="line">GListEmpty(L);</span><br><span class="line">初始条件：广义表L存在</span><br><span class="line">操作结果：判定广义表L是否为空</span><br><span class="line">GetHead(L);</span><br><span class="line">初始条件：广义表L存在</span><br><span class="line">操作结果：取广义表L的头</span><br><span class="line">GetTail(L);</span><br><span class="line">初始条件：广义表L存在</span><br><span class="line">操作结果：取广义表L的尾</span><br><span class="line">InsertFirst_GL(&amp;L, &amp;e);</span><br><span class="line">初始条件：广义表L存在</span><br><span class="line">操作结果：插入元素e作为广义表的第一元素</span><br><span class="line">DeleteFirst_GL(&amp;L, &amp;e);</span><br><span class="line">初始条件：广义表L存在</span><br><span class="line">操作结果：删除广义表的第一元素，并用e返回其值</span><br><span class="line">Traverse_GL(L, Visit());</span><br><span class="line">初始条件：广义表L存在</span><br><span class="line">操作结果：遍历广义表L，用函数Visit处理每个元素</span><br><span class="line">&#125;ADTGList</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">在学习《数据结构（C语言版）》一书时，我将其中的算法在此记录，以便有需要时进行查阅。</summary>
    
    
    
    <category term="笔记" scheme="http://decucin.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="c" scheme="http://decucin.github.io/tags/c/"/>
    
    <category term="数据结构" scheme="http://decucin.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="算法" scheme="http://decucin.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机问题</title>
    <link href="http://decucin.github.io/2020/06/04/%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%97%B6%E7%A2%B0%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://decucin.github.io/2020/06/04/%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%97%B6%E7%A2%B0%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2020-06-04T11:08:37.000Z</published>
    <updated>2022-03-21T06:46:28.901Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p><strong>我的VBOX是6.1.8版本，虚拟机安装的系统为CentOS 8.0版本，如果版本不同，解决方式可能略有不同。</strong></p><h1 id="CentOS中常用的进行网络设置的代码"><a href="#CentOS中常用的进行网络设置的代码" class="headerlink" title="CentOS中常用的进行网络设置的代码"></a>CentOS中常用的进行网络设置的代码</h1><p>重启网络服务的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection reload</span><br></pre></td></tr></table></figure><p>查看基本网络参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure><p>检查默认网关地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route -n</span><br></pre></td></tr></table></figure><p>检查DNS服务器地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;resolv.conf</span><br></pre></td></tr></table></figure><p>可视化配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmtui</span><br></pre></td></tr></table></figure><h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><p>我一开始使用的是net连接模式，但尝试了很多次都无法正确连上网，之后我将注意力转移到了桥接模式，这里记录以下我是如何使用仅主机网络模式将虚拟机连上网的。</p><h3 id="虚拟机使用仅主机网络联网"><a href="#虚拟机使用仅主机网络联网" class="headerlink" title="虚拟机使用仅主机网络联网"></a>虚拟机使用仅主机网络联网</h3><h4 id="1-首先将虚拟机网络与计算机已经连接好的网络进行桥接"><a href="#1-首先将虚拟机网络与计算机已经连接好的网络进行桥接" class="headerlink" title="1.首先将虚拟机网络与计算机已经连接好的网络进行桥接"></a>1.首先将虚拟机网络与计算机已经连接好的网络进行桥接</h4><p>依次打开电脑的“控制面板”–&gt;“网络和Internet”–&gt;“网络连接”查看当前计算机的网络连接，之后选择计算机已经连上的网络以及虚拟机的网卡，右键选择桥接。</p><h4 id="2-将虚拟机的网络连接方式设置为仅主机"><a href="#2-将虚拟机的网络连接方式设置为仅主机" class="headerlink" title="2.将虚拟机的网络连接方式设置为仅主机"></a>2.将虚拟机的网络连接方式设置为仅主机</h4><p>打开VBOX虚拟机管理器，右键虚拟机选择设置，选择“网络”，将连接方式改为“仅主机（Host-Only）网络”，点击确定即可。</p>]]></content>
    
    
    <summary type="html">在使用VBOX创建虚拟机的过程中，我发现我的虚拟机无法连接上网络，因此记录下我的解决方法。</summary>
    
    
    
    <category term="项目" scheme="http://decucin.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="问题" scheme="http://decucin.github.io/tags/%E9%97%AE%E9%A2%98/"/>
    
    <category term="虚拟机" scheme="http://decucin.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>链表之坑</title>
    <link href="http://decucin.github.io/2020/05/19/%E6%88%91%E5%9C%A8%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://decucin.github.io/2020/05/19/%E6%88%91%E5%9C%A8%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2020-05-19T11:08:37.000Z</published>
    <updated>2022-03-21T06:46:58.996Z</updated>
    
    <content type="html"><![CDATA[<p>当我初学链表时犯过以下错误：</p><a id="more"></a><p>此处以学生成绩系统为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct stuent</span><br><span class="line">&#123;</span><br><span class="line">char name[9];&#x2F;&#x2F;名称</span><br><span class="line">int score;&#x2F;&#x2F;成绩</span><br><span class="line">struct student *next;&#x2F;&#x2F;下一节点</span><br><span class="line">&#125;Stu;</span><br><span class="line">&#x2F;&#x2F;此处用typedef是为了后续方便，可用可不用</span><br></pre></td></tr></table></figure><h1 id="忘记循环申请新节点空间"><a href="#忘记循环申请新节点空间" class="headerlink" title="忘记循环申请新节点空间"></a>忘记循环申请新节点空间</h1><p>在链表的构建中，我将新节点插入到链表之中后，往往会忘记再次为新节点申请空间，这就导致为节点赋值时程序出现bug。</p><h1 id="头插法和尾插法分不清"><a href="#头插法和尾插法分不清" class="headerlink" title="头插法和尾插法分不清"></a>头插法和尾插法分不清</h1><p>头插法是直接将新节点插入到头节点之后，这就导致在使用头插法插入节点的过程中先插入的反而后输出；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;头插法</span><br><span class="line">for(int i &#x3D; 0;i &lt; n;i++)&#x2F;&#x2F;此处n为你要添加的节点个数</span><br><span class="line">&#123;</span><br><span class="line">new &#x3D; (Stu *)malloc(sizeof(Stu));&#x2F;&#x2F;此处的Stu是你定义的结构体类型名称</span><br><span class="line">new-&gt;name &#x3D; x;&#x2F;&#x2F;x代表学生姓名</span><br><span class="line">new-&gt;score &#x3D; y;&#x2F;&#x2F;y代表学生成绩</span><br><span class="line">new-&gt;next &#x3D; head-&gt;next;</span><br><span class="line">head-&gt;next &#x3D; new;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尾插法与头插法相比略微有些麻烦，因为尾插法还需要一个尾节点，插入过程中便是将新节点插入到尾节点之后,但要注意必须首先找到尾节点所在。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">tail &#x3D; head;</span><br><span class="line">while(tail-&gt;next !&#x3D; NULL)&#x2F;&#x2F;找到尾节点所在</span><br><span class="line">&#123;</span><br><span class="line">tail &#x3D; tail-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;尾插法</span><br><span class="line">for(int i &#x3D; 0;i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">new &#x3D; (Stu *)malloc(sizeof(Stu));</span><br><span class="line">new-&gt;name &#x3D; x;</span><br><span class="line">new-&gt;score &#x3D; y;</span><br><span class="line">new-&gt;next &#x3D; tail-&gt;next;&#x2F;&#x2F;连接新节点与NULL(new-&gt;next &#x3D; NULL;)</span><br><span class="line">tail-&gt;next &#x3D; new;&#x2F;&#x2F;连接尾节点与新节点</span><br><span class="line">tail &#x3D; new;&#x2F;&#x2F;之后以新节点作为尾节点(tail &#x3D; tail-&gt;next;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>暂时先写这么多，日后补充。</p>]]></content>
    
    
    <summary type="html">链表是一种比较基础的数据结构，与数组相比，各有优劣，链表更利于删除数据，但数组更便于访问数据。</summary>
    
    
    
    <category term="笔记" scheme="http://decucin.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="链表" scheme="http://decucin.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="数据结构" scheme="http://decucin.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>hexo + github搭建个人博客</title>
    <link href="http://decucin.github.io/2020/05/18/hexo%20+%20github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://decucin.github.io/2020/05/18/hexo%20+%20github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2020-05-18T11:08:37.000Z</published>
    <updated>2022-03-21T06:44:07.401Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="git账号的注册"><a href="#git账号的注册" class="headerlink" title="git账号的注册"></a>git账号的注册</h2><p>这一步不必过多赘述，直接到<a href="https://github.com/" target="_blank" rel="noopener">git官网</a>进行注册即可。</p><h2 id="git-bash的安装"><a href="#git-bash的安装" class="headerlink" title="git bash的安装"></a>git bash的安装</h2><p>建议在<a href="https://gitforwindows.org/" target="_blank" rel="noopener">git bash for windows</a>下载并默认安装。</p><h2 id="node-js的下载安装"><a href="#node-js的下载安装" class="headerlink" title="node.js的下载安装"></a>node.js的下载安装</h2><p>先在<a href="http://nodejs.org/zh-cn" target="_blank" rel="noopener">http://nodejs.org/zh-cn</a>下载，建议下载长期支持版，之后按照提示默认安装即可（也可更改安装目录，取决于自身），win+r打开运行框，输入cmd运行，在命令框中输入node -v,如出现版本号证明已安装好.</p><h2 id="npm的安装"><a href="#npm的安装" class="headerlink" title="npm的安装"></a>npm的安装</h2><p>在git bash中输入以下代码安装hexo：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo</span><br></pre></td></tr></table></figure><p>至此，准备工作基本完成。</p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>出现版本号证明安装完毕。</p><h1 id="创建git仓库"><a href="#创建git仓库" class="headerlink" title="创建git仓库"></a>创建git仓库</h1><p>打开<a href="https://www.github.com/" target="_blank" rel="noopener">github官网</a>，登录自己申请的账号后，点开右上角的加号，选择New repository，在Repository name下输入仓库名，必须是username.github.io（此处的username必须是你github的用户名），选择Public，勾选Initialize this repository with a README，点击Create repository，仓库至此创建完成。</p><h1 id="利用hexo写出博客框架"><a href="#利用hexo写出博客框架" class="headerlink" title="利用hexo写出博客框架"></a>利用hexo写出博客框架</h1><h2 id="建立myBlog目录"><a href="#建立myBlog目录" class="headerlink" title="建立myBlog目录"></a>建立myBlog目录</h2><p>在计算机的恰当位置建立文件夹（位置任意，名称任意，但建议具有代表性）。</p><h2 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h2><p>进入刚刚建立的文件夹，选择git bash here进入git bash，输入以下代码初始化博客：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init</span><br><span class="line">$ hexo g #生成</span><br><span class="line">$ hexo s #开启本地预览</span><br></pre></td></tr></table></figure><p>此时你可以在浏览器中输入<a href="http://localhost:4000进行访问，本地预览我们的博客。">http://localhost:4000进行访问，本地预览我们的博客。</a></p><p>观看完之后CTRL+C关闭。</p><p>只有将两者连接以后我们的git bash才和我们的git账户关联起来，通过密钥进行访问。</p><!--more--><h1 id="连接本地计算机和git服务器"><a href="#连接本地计算机和git服务器" class="headerlink" title="连接本地计算机和git服务器"></a>连接本地计算机和git服务器</h1><h2 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h2><p>打开git bash，在终端配置user.name和user.email信息，输入以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;user.name&quot;&#x2F;&#x2F;user.name处填写你的GitHub用户名</span><br><span class="line">git config --global user.email &quot;user.email&quot;&#x2F;&#x2F;user.email处填写你注册GitHUb是所用的邮箱</span><br></pre></td></tr></table></figure><h2 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h2><p>在git bash中输入以下代码生成ssh密钥文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;YourEmil&quot;&#x2F;&#x2F;YouEmail处填写你注册GitHub的邮箱</span><br></pre></td></tr></table></figure><p>然后输入三个回车即可，即默认不需要设置密码。</p><p>通过以上步骤便得到了两个文件，id_rsa和id_rsa.pub。</p><p>打开id_rsa.pub文件，复制全部内容。</p><h2 id="将密钥粘贴到GitHub的ssh-key处"><a href="#将密钥粘贴到GitHub的ssh-key处" class="headerlink" title="将密钥粘贴到GitHub的ssh key处"></a>将密钥粘贴到GitHub的ssh key处</h2><p>打开GitHub，点击你的GitHub头像，选择Settings，选择SSH and GPG keys，点击New SSH key，Title随便设置，在Key中粘贴刚刚复制的id_rsa.pub的内容。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>在git bash中输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>再输入yes，如果看到Hi后面有你的用户名证明连接成功。</p><p>至此我们搭建好了框架，但只有将其上传到GitHub中才能通过浏览器访问，而不是像之前一样只能本地访问。</p><h1 id="将该框架上传到github"><a href="#将该框架上传到github" class="headerlink" title="将该框架上传到github"></a>将该框架上传到github</h1><h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><p>已经配置好SSH Key。</p><h2 id="开始配置"><a href="#开始配置" class="headerlink" title="开始配置"></a>开始配置</h2><p>之后便是打开文件夹中的_config.yml文件（文本编辑器打开即可），找到最后的部分，将其更改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:username&#x2F;username.github.io.git&#x2F;&#x2F;其实就是在repo处填上你的github page地址</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>注意：每个冒号后都有且只有一个半角的空格符，如果type处已有一对单引号，只需将git输到单引号中即可。</p><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>如缺少此步骤，在hexo g命令时会出现“deployer:git not found”。 </p><p>在你的博客文件夹中选择git bash here，输入以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h2 id="提交到GitHub"><a href="#提交到GitHub" class="headerlink" title="提交到GitHub"></a>提交到GitHub</h2><p>输入以下代码将博客在GitHub上托管：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean            ##清除缓存</span><br><span class="line">$ hexo g                ##生成静态网页</span><br><span class="line">$ hexo d                ##将其部署到服务器上</span><br></pre></td></tr></table></figure><p>之后需要输入你GitHub的用户名和密码进行验证。</p><h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><p>在浏览器中输入<a href="https://username.github.io就可以看到你搭建的博客了。" target="_blank" rel="noopener">https://username.github.io就可以看到你搭建的博客了。</a></p><p>此处我使用了主题，后面会介绍到。</p><p>可以看到，我们博客的主题十分单调，并不好看，因此我们需要为我们的博客更换主题，这里我推荐next主题，它是目前应用较多的hexo主题。</p><h1 id="选取合适主题，美化博客"><a href="#选取合适主题，美化博客" class="headerlink" title="选取合适主题，美化博客"></a>选取合适主题，美化博客</h1><h2 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h2><p>打开博客根目录进入git bash，输入以下代码下载next主题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure><p>等待安装完成。</p><h2 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h2><h3 id="根目录配置"><a href="#根目录配置" class="headerlink" title="根目录配置"></a>根目录配置</h3><p>打开博客根目录中的_config.yml文件，找到其中的theme字段，将其值改为next，之后可根据需要更改#site字段下的内容，比如title（文章标题），description（简介或格言），author（网站作者），language（主题语言），timezone（时区）。</p><p>依旧注意冒号后的空格，如果有一对单引号，直接将内容填至单引号中即可，主题语言打开themes/next/language中查看。</p><h3 id="修改主题配置文件"><a href="#修改主题配置文件" class="headerlink" title="修改主题配置文件"></a>修改主题配置文件</h3><p>在由于next主题有四种类型，Muse、Mist、Pisces、Gemini，默认为Muse，如需更改，只要打开根目录/themes/next下的_config,yml，找到#Scheme字段，将你需要的主题前的#删除即可，记得其它三个主题前必须要有#。</p><h2 id="展示"><a href="#展示" class="headerlink" title="展示"></a>展示</h2><p>回到根目录打开git bash，输入以下指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><p>完成后你的博客主题便已经更改完毕。</p>]]></content>
    
    
    <summary type="html">利用hexo + github搭建个人博客的过程。</summary>
    
    
    
    <category term="博客搭建" scheme="http://decucin.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="博客" scheme="http://decucin.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
