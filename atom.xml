<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog of Decucin</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2022-03-13T04:49:23.127Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Decucin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>牛客题解</title>
    <link href="http://yoursite.com/2022/03/13/%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3/"/>
    <id>http://yoursite.com/2022/03/13/%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3/</id>
    <published>2022-03-13T04:50:37.359Z</published>
    <updated>2022-03-13T04:49:23.127Z</updated>
    
    <content type="html"><![CDATA[<h1 id="链表部分"><a href="#链表部分" class="headerlink" title="链表部分"></a>链表部分</h1><h2 id="BM1-反转链表"><a href="#BM1-反转链表" class="headerlink" title="BM1 反转链表"></a>BM1 <a href="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=295&tqId=23286&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">反转链表</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个单链表的头结点pHead(该头节点是有值的，比如在下图，它的val是1)，长度为n，反转该链表后，返回新链表的表头。 </p><p>数据范围： 0≤<em>n</em>≤1000</p><p>要求：空间复杂度 O(1) ，时间复杂度 O(n)。 </p><p>如当输入链表{1,2,3}时， </p><p>经反转后，原链表变为{3,2,1}，所以对应的输出为{3,2,1}。 </p><p>以上转换过程如下图所示：</p><p><img src="https://uploadfiles.nowcoder.com/images/20211014/423483716_1634206291971/4A47A0DB6E60853DEDFCFDF08A5CA249" alt="img"></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>反转链表的基本思想就是利用三个指针，pre，cur，nex分别表示当前节点前一个节点、当前节点以及当前节点后面的节点，之后再令cur.next = pre;其实就完成了反转操作，完成反转操作之后将三个指针依次后移即可。</p><h3 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 优先考虑特殊情况，一个节点都没有或是只有一个节点，直接返回即可</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode nex = cur.next;</span><br><span class="line">            <span class="comment">// 这里是反转的核心，令之前在前面的指针挪到后面</span></span><br><span class="line">            cur.next = pre;</span><br><span class="line">            <span class="comment">// 之后依次将各指针后移即可；</span></span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = nex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当退出循环时，其实就是cur == null的情况，这时</span></span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM2-链表内指定区间反转"><a href="#BM2-链表内指定区间反转" class="headerlink" title="BM2 链表内指定区间反转"></a>BM2 <a href="https://www.nowcoder.com/practice/b58434e200a648c589ca2063f1faf58c?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">链表内指定区间反转</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>将一个节点数为 size 链表 m 位置到 n 位置之间的区间反转，要求时间复杂度 O<em>(</em>n<em>)，空间复杂度 *O</em>(1)。<br>例如：<br>给出的链表为 1→2→3→4→5→<em>NULL</em>, m=2,n=4<em>m</em>=2,<em>n</em>=4,<br>返回 1→4→3→2→5→<em>NULL</em>.</p><p><strong>数据范围： 链表长度 0&lt;size≤1000，0&lt;m≤n≤size，链表中每个节点的值满足 |val|≤1000|val|≤1000</strong></p><p><strong>要求：时间复杂度 <em>O</em>(<em>n</em>) ，空间复杂度 <em>O</em>(<em>n</em>)</strong></p><p><strong>进阶：时间复杂度 <em>O</em>(<em>n</em>) ，空间复杂度 <em>O</em>(<em>1</em>)</strong></p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>这题的思想和反转链表实际上是一样的，关键点（与反转整个链表不同之处）在于这里反转的链表只是整个链表中的一部分，故涉及链表的截断(cur.next = null)以及连接(cur.next = head2.next)，考虑方法如下：首先需要将链表的头尾指针进行保存（考虑如下几个指针的保存，原链表截断之前的指针，截断部分的头尾指针以及截断部分之后的头指针），之后将截断部分进行反转，之后再进行链表的拼接即可。</p><p><strong>可用一个虚拟头节点防止头节点各种复杂条件判断</strong></p><h3 id="Java代码实现-1"><a href="#Java代码实现-1" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span> <span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 首先考虑特殊情况，若是m == n即有一个节点需要反转，那直接无需反转</span></span><br><span class="line">        <span class="keyword">if</span>(m == n)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 首先考虑需要的指针，总共有三条链表，用head1-3以及tail1-3分别表示其头尾</span></span><br><span class="line">        ListNode head2 = <span class="keyword">null</span>;</span><br><span class="line">        ListNode head3 = <span class="keyword">null</span>;</span><br><span class="line">        ListNode tail1 = <span class="keyword">null</span>;</span><br><span class="line">        ListNode tail2 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 此外，链表遍历还用到两个指针</span></span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="comment">// 考虑利用虚指针</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        pre = dummy;</span><br><span class="line">        <span class="comment">// 用于标记索引下标</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == m)&#123;</span><br><span class="line">                <span class="comment">//将链表截断</span></span><br><span class="line">                pre.next = <span class="keyword">null</span>;</span><br><span class="line">                tail1 = pre;</span><br><span class="line">                head2 = cur;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == n + <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//将链表截断</span></span><br><span class="line">                pre.next = <span class="keyword">null</span>;</span><br><span class="line">                tail2 = pre;</span><br><span class="line">                pre.next = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 这里可能只有n个节点，但此时到了第i + 1个节点，为null</span></span><br><span class="line">                <span class="keyword">if</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    head3 = cur;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 无论是否需要截断链表都将指针后移</span></span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将其反转拼接第一二段</span></span><br><span class="line">        tail1.next = reverse(head2);</span><br><span class="line">        <span class="comment">// 拼接二三段</span></span><br><span class="line">        head2 = tail1;</span><br><span class="line">        <span class="keyword">while</span>(head2.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            head2 = head2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        head2.next = head3;</span><br><span class="line"><span class="comment">//         这里的拼接过程，我的原本是，没有连接上，若是要连接链表，需要通过next下标</span></span><br><span class="line"><span class="comment">//         while(tail1 != null)&#123;</span></span><br><span class="line"><span class="comment">//             tail1 = tail1.next;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         tail1 = head3;</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里返回反转后的头指针</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode nex = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = nex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM3-链表中的节点每k个一组翻转"><a href="#BM3-链表中的节点每k个一组翻转" class="headerlink" title="BM3 链表中的节点每k个一组翻转"></a>BM3 <a href="https://www.nowcoder.com/practice/b49c3dc907814e9bbfa8437c251b028e?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">链表中的节点每k个一组翻转</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>将给出的链表中的节点每 k 个一组翻转，返回翻转后的链表<br>如果链表中的节点数不是 k 的倍数，将最后剩下的节点保持原样<br>你不能更改节点中的值，只能更改节点本身。</p><p>数据范围：0≤<em>n</em>≤2000 ，1≤<em>k</em>≤2000 ，链表中每个元素都满足 0≤<em>val</em>≤1000</p><p>要求空间复杂度<em>O(1)<em>，时间复杂度、</em>O(n)</em></p><p>例如： </p><p>给定的链表是1→2→3→4→5</p><p>对于<em>k</em>=2 , 你应该返回2→1→4→3→5</p><p>对于<em>k</em>=3 , 你应该返回 3→2→1→4→5</p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>先求出链表的长度，然后判断需要分几组，之后对每组进行反转并连接，过程中需要注意保存以下节点：preStart–&gt;需要反转的节点之前的节点，start–&gt;开始反转的节点，afterStart–&gt;反转结束的下一个节点，end–&gt;反转结束的节点，还有就是反转链表需要的三个节点pre，cur以及nex。</p><p><strong>可用一个虚拟头节点防止头节点各种复杂条件判断</strong></p><p><strong>注意点：每次连接时只连接一端（连接上一个链表和这一个链表），当全部反转都完成之后，再连接这一个链表和下一个链表</strong></p><h3 id="Java代码实现-2"><a href="#Java代码实现-2" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span> <span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 特殊情况，每1个为1组进行反转，直接返回即可</span></span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 长度</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 虚拟头节点</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        <span class="comment">// 反转节点之前的节点</span></span><br><span class="line">        ListNode preStart = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 开始反转的节点（反转之后变成了需要和后面链表进行拼接的节点）</span></span><br><span class="line">        ListNode start = dummy;</span><br><span class="line">        <span class="comment">// 反转结束的节点</span></span><br><span class="line">        ListNode end = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 反转结束节点之后的节点</span></span><br><span class="line">        ListNode afterStart = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 反转过程中需要的节点</span></span><br><span class="line">        ListNode pre = dummy;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        ListNode nex = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ++len;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断需要分几组</span></span><br><span class="line">        <span class="keyword">int</span> group = len / k;</span><br><span class="line">        <span class="comment">// 特殊情况，head为空或为1直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span> || len == <span class="number">1</span> || group &lt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; group; ++i)&#123;</span><br><span class="line">            <span class="comment">// 先记录反转之前的节点以及开始节点</span></span><br><span class="line">            preStart = start;    <span class="comment">// 反转之前的节点实际上是上一反转链表的头（第一次反转，其前一个节点为dummy，故对preStart赋初值应为dummy）</span></span><br><span class="line">            start = cur;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++j)&#123;</span><br><span class="line">                nex = cur.next;</span><br><span class="line">                <span class="comment">// 开始进行反转</span></span><br><span class="line">                cur.next = pre;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = nex;</span><br><span class="line">            &#125;</span><br><span class="line">            end = pre;</span><br><span class="line">            afterStart = cur;</span><br><span class="line">            <span class="comment">// 开始进行连接，注意这里只是连接反转之前的头和这一次的尾</span></span><br><span class="line">            preStart.next = end;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当反转全部完成时，再将这一次反转的尾和反转之后的节点进行连接</span></span><br><span class="line">        start.next = afterStart;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM4-合并两个排序的链表"><a href="#BM4-合并两个排序的链表" class="headerlink" title="BM4 合并两个排序的链表"></a>BM4 <a href="https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">合并两个排序的链表</a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两个递增的链表，单个链表的长度为n，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><p>数据范围： 0≤n≤10000，−1000≤节点值≤1000<br>要求：空间复杂度 O(1)，时间复杂度 O(n)</p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>双指针移动即可，但若是想达到O(1)的时间复杂度，则需要原地修改指针，故选择如下方法：将两个链表中的当前节点标记，标记当前节点的作用是，判断本次应该连接哪一个节点（链表1中的节点或是链表2中的节点），之后再将剩下的链表合并即可。</p><p><strong>可用一个虚拟头节点防止头节点各种复杂条件判断</strong></p><h3 id="Java代码实现-3"><a href="#Java代码实现-3" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 首先考虑特殊情况，即两个链表中一个链表为空时，直接返回另一个链表即可</span></span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="keyword">null</span> || list2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list1 == <span class="keyword">null</span> ? list2 : list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 首先需要两个指针分别记录两个链表走到了哪</span></span><br><span class="line">        ListNode cur1 = list1;</span><br><span class="line">        ListNode cur2 = list2;</span><br><span class="line">        <span class="comment">// 避免考虑头节点，先来个虚拟节点</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode cur = dummy;</span><br><span class="line">        <span class="comment">// 先将两个链表合并</span></span><br><span class="line">        <span class="keyword">while</span>(cur1 != <span class="keyword">null</span> &amp;&amp; cur2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur1.val &lt; cur2.val)&#123;</span><br><span class="line">                cur.next = cur1;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur.next = cur2;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 再合并剩下的部分，此时一个链表已经为空了</span></span><br><span class="line">        cur.next = cur1 == <span class="keyword">null</span> ? cur2 : cur1;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM5-合并k个已排序的链表"><a href="#BM5-合并k个已排序的链表" class="headerlink" title="BM5 合并k个已排序的链表"></a>BM5 <a href="https://www.nowcoder.com/practice/65cfde9e5b9b4cf2b6bafa5f3ef33fa6?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">合并k个已排序的链表</a></h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>合并 k 个升序的链表并将结果作为一个升序的链表返回其头节点。</p><p>数据范围：节点总数 0≤n≤5000，每个节点的val满足 ∣val∣&lt;=100</p><p>要求：时间复杂度 O(nlogn)</p><h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><p>这题只说了要求时间复杂度O(nlogn)，而未要求空间复杂度，我自己的想法是将链表中所有节点的值保存到ArrayList中进行排序，排序之后再依次生成节点即可。</p><h3 id="Java代码实现-4"><a href="#Java代码实现-4" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ArrayList&lt;ListNode&gt; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = lists.size();</span><br><span class="line">        <span class="comment">// 当前节点</span></span><br><span class="line">        ListNode cur = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 存储全部元素所用的集合</span></span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="comment">// 将每个链表的每个节点都存入</span></span><br><span class="line">            cur = lists.get(i);</span><br><span class="line">            <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">                res.add(cur.val);</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(res);</span><br><span class="line">        <span class="comment">// 建一个虚拟头指针已防止头节点的误判</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        cur = dummy;</span><br><span class="line">        <span class="keyword">for</span>(Integer num : res)&#123;</span><br><span class="line">            cur.next = <span class="keyword">new</span> ListNode(num);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是注意以上题解并未使用到一个条件–&gt;这n个链表均为有序链表，因此时间复杂度肯定不是最佳，想到用k个指针进行迭代，但经过k - 1次比较之后才能完成1个数的排序，故其时间复杂度为O(kn)，由此想到维护一个一直有序的数组，每次取出下标为0的位置，并将该数所在链表的后一个节点放入数组中（保证其有序–&gt;这里可以使用二分找到对应的下标），但此时出现矛盾，使用二分进行查找，那数组更合适，但若是涉及插入操作，则链表更合适，，，矛盾，故舍弃此思路。</p><p>但看题解是发现大部分此思路采用的是优先队列来实现，队列自动维护，每次只需取出队头就行。</p><p>看了题解后发现：不是使用k个指针，而是每次合并的时候是两两合并，如有链表1, 2, 3, 4, 5, 6, 7, 8，第一次合并，将12合并，34合并，56合并，78合并，得到四个新链表1, 2, 3, 4，之后再次合并，12合并，34合并，得到链表1, 2，最后再将12合并得到所需的链表，完整题解如下：</p><h3 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h3><p>采用分治法的思想（先分后并），将所给的k个链表分成两份，一直持续地分，分到不能再分为止（k个链表被分为k份），之后再依次将两个链表进行合并，直到合并为最后一个链表为止。</p><h3 id="Java代码实现-5"><a href="#Java代码实现-5" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ArrayList&lt;ListNode&gt; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = lists.size();</span><br><span class="line">        <span class="comment">// 此函数确定需要合并的下标范围0----n-1</span></span><br><span class="line">        <span class="keyword">return</span> merge(lists, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这个函数的作用是从left合并到right</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">merge</span><span class="params">(ArrayList&lt;ListNode&gt; lists, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 若是无法再分，则直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">            <span class="keyword">return</span> lists.get(left);</span><br><span class="line">            <span class="comment">// left &gt; right表示长度为0，即merge(lists, 0, -1)，数组中有任何一个链表为空时都会产生此情况</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 否则考虑合并left， mid为一个链表，mid +1 到right为一个链表</span></span><br><span class="line">            <span class="keyword">return</span> merge2Lists(merge(lists, left, mid), merge(lists, mid + <span class="number">1</span>, right));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这一部分完全就是合并两个链表的代码</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">merge2Lists</span><span class="params">(ListNode list1, ListNode list2)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 首先考虑特殊情况，即两个链表中一个链表为空时，直接返回另一个链表即可</span></span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="keyword">null</span> || list2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list1 == <span class="keyword">null</span> ? list2 : list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 首先需要两个指针分别记录两个链表走到了哪</span></span><br><span class="line">        ListNode cur1 = list1;</span><br><span class="line">        ListNode cur2 = list2;</span><br><span class="line">        <span class="comment">// 避免考虑头节点，先来个虚拟节点</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode cur = dummy;</span><br><span class="line">        <span class="comment">// 先将两个链表合并</span></span><br><span class="line">        <span class="keyword">while</span>(cur1 != <span class="keyword">null</span> &amp;&amp; cur2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur1.val &lt; cur2.val)&#123;</span><br><span class="line">                cur.next = cur1;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur.next = cur2;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 再合并剩下的部分，此时一个链表已经为空了</span></span><br><span class="line">        cur.next = cur1 == <span class="keyword">null</span> ? cur2 : cur1;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM6-判断链表中是否有环"><a href="#BM6-判断链表中是否有环" class="headerlink" title="BM6 判断链表中是否有环"></a>BM6 <a href="https://www.nowcoder.com/practice/650474f313294468a4ded3ce0f7898b9?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">判断链表中是否有环</a></h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>判断给定的链表中是否有环。如果有环则返回true，否则返回false。 </p><p>数据范围：链表长度 0≤n≤10000，链表中任意节点的值满足 ∣val∣&lt;=100000</p><p>要求：空间复杂度 O(1)，时间复杂度 O(n)</p><p>输入分为两部分，第一部分为链表，第二部分代表是否有环，然后将组成的head头结点传入到函数里面。-1代表无环，其它的数字代表有环，这些参数解释仅仅是为了方便读者自测调试。实际在编程时读入的是链表的头节点。</p><p>例如输入{3,2,0,-4},1时，对应的链表结构如下图所示： </p><p><img src="https://uploadfiles.nowcoder.com/images/20220110/423483716_1641800950920/0710DD5D9C4D4B11A8FA0C06189F9E9C" alt="img"></p><p>可以看出环的入口结点为从头结点开始的第1个结点（注：头结点为第0个结点），所以输出true。</p><h3 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h3><p>快慢指针，一个每次走一格，一个每次走两个，若是有环则必会相遇，这里题目中没说任意节点的值均不同，判断两指针是否相遇时最好不只是判断两个节点的val是否相遇而是判断两个指针的地址是否相同</p><h3 id="Java代码实现-6"><a href="#Java代码实现-6" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里注意题目中说0 &lt;= n，故有可能为0，特殊情况优先考虑</span></span><br><span class="line">        <span class="comment">// 由于之后的fast和slow都是先赋值，为了防止对空指针进行操作，需要先进行判断</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head.next;</span><br><span class="line">        ListNode fast = head.next.next;</span><br><span class="line">        <span class="comment">// 快慢指针，若是有一个先遍历完，那必然是快指针</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 这里是先比较后移动，因为第一次移动过了</span></span><br><span class="line">            <span class="keyword">if</span>(slow == fast)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="comment">// 增加这个判断是防止当fast到了最后一个元素时，fast.next.next就对空指针进行了操作</span></span><br><span class="line">            <span class="comment">// 也可以将判断条件加在while循环中，即：while(fast != null &amp;&amp; fast.next != null)</span></span><br><span class="line">            <span class="keyword">if</span>(fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">                fast = fast.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM7-链表中环的入口节点"><a href="#BM7-链表中环的入口节点" class="headerlink" title="BM7 链表中环的入口节点"></a>BM7 <a href="https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">链表中环的入口节点</a></h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><p>给一个长度为n链表，若其中包含环，请找出该链表的环的入口结点，否则，返回null。 </p><p>数据范围： n≤10000，1&lt;=结点值&lt;=10000</p><p>要求：空间复杂度 O(1)，时间复杂度 O(n)</p><p>例如，输入{1,2},{3,4,5}时，对应的环形链表如下图所示：</p><p><img src="https://uploadfiles.nowcoder.com/images/20211025/423483716_1635154005498/DA92C945EF643F1143567935F20D6B46" alt="img"></p><p>可以看到环的入口结点的结点值为3，所以返回结点值为3的结点。</p><h4 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h4><p>输入分为2段，第一段是入环前的链表部分，第二段是链表环的部分，后台会根据第二段是否为空将这两段组装成一个无环或者有环单链表</p><h4 id="返回值描述"><a href="#返回值描述" class="headerlink" title="返回值描述"></a>返回值描述</h4><p>返回链表的环的入口结点即可，我们后台程序会打印这个结点对应的结点值；若没有，则返回对应编程语言的空结点即可。</p><h3 id="题解-7"><a href="#题解-7" class="headerlink" title="题解"></a>题解</h3><p>这题的做法和判断是否有环类似，都是先使用快慢指针找到两个指针重合的位置判定有环，之后注意一个点，此时将其中一个指针移至原链表头并让两个指针以相同的速度移动，那么当两个指针再次相遇时的节点即为入口节点，具体证明如下，图可参考<a href="https://blog.nowcoder.net/n/9d3ffa4b004e43d1aff512141d0d7dac" target="_blank" rel="noopener">官方题解</a>：</p><p>首先假设链表中无环的部分（从头节点到环的入口节点）距离为x，从环的入口到相遇节点的距离为y，从相遇节点再次到环的入口距离为m，则由快慢指针的速度可得如下距离方程：</p><p>(x + y + m + y) / (x + y) = 2</p><p>其中除号左边为快指针走的距离，除号右边为慢指针走的距离，两者走了相同的时间，距离刚好与速度成正比</p><h3 id="Java代码实现-7"><a href="#Java代码实现-7" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况优先考虑</span></span><br><span class="line">        <span class="keyword">if</span>(pHead == <span class="keyword">null</span> || pHead.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode fast = pHead.next.next;</span><br><span class="line">        ListNode slow = pHead.next;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">                <span class="comment">// 此时有环，开始第二轮遍历</span></span><br><span class="line">                fast = pHead;</span><br><span class="line">                <span class="keyword">while</span>(fast != slow)&#123;</span><br><span class="line">                    fast = fast.next;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> fast;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 退出了循环证明无环</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM8-链表中倒数最后k个节点"><a href="#BM8-链表中倒数最后k个节点" class="headerlink" title="BM8 链表中倒数最后k个节点"></a>BM8 <a href="https://www.nowcoder.com/practice/886370fe658f41b498d40fb34ae76ff9?tpId=295&tqId=1377477&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">链表中倒数最后k个节点</a></h2><h3 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个长度为 n 的链表，设链表中的元素的值为 ai ，返回该链表中倒数第k个节点。 </p><p>如果该链表长度小于k，请返回一个长度为 0 的链表。 </p><p>数据范围：0≤n≤105，0≤ai≤109，0≤k≤109</p><p>要求：空间复杂度 O(n)，时间复杂度 O(n)</p><p>进阶：空间复杂度 O(1)，时间复杂度 O(n)</p><p>例如输入{1,2,3,4,5},2时，对应的链表结构如下图所示： </p><p><img src="https://uploadfiles.nowcoder.com/images/20211105/423483716_1636084313645/5407F55227804F31F5C5D73558596F2C" alt="img"></p><p>其中蓝色部分为该链表的最后2个结点，所以返回倒数第2个结点（也即结点值为4的结点）即可，系统会打印后面所有的节点来比较。</p><h3 id="题解-8"><a href="#题解-8" class="headerlink" title="题解"></a>题解</h3><p>两次遍历链表，第一次求出链表长度，第二次直接返回最后k个节点的开始节点</p><h3 id="Java代码实现-8"><a href="#Java代码实现-8" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pHead ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span> <span class="params">(ListNode pHead, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        ListNode cur = pHead;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ++len;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 题目中说若是链表长度小于k则返回空链表，这里已经考虑了链表为空的情况(len = 0)</span></span><br><span class="line">        <span class="keyword">if</span>(len &lt; k)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = pHead;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 这里需要稍微考虑下i++到底应该小于多少</span></span><br><span class="line">        <span class="keyword">while</span>(i++ &lt; len - k)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM9-删除链表的倒数第n个节点"><a href="#BM9-删除链表的倒数第n个节点" class="headerlink" title="BM9 删除链表的倒数第n个节点"></a>BM9 <a href="https://www.nowcoder.com/practice/f95dcdafbde44b22a6d741baf71653f6?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">删除链表的倒数第n个节点</a></h2><h3 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个链表，删除链表的倒数第 n 个节点并返回链表的头指针<br>例如， </p><p>给出的链表为: 1→2→3→4→5, n=2.<br>删除了链表的倒数第 n<em>n</em> 个节点之后,链表变为1→2→3→5.</p><p>数据范围： 链表长度 0≤n≤1000，链表中任意节点的值满足 0≤val≤100</p><p>要求：空间复杂度 O(1)，时间复杂度 O(n)<br>备注： </p><p>题目保证 n 一定是有效的</p><h3 id="题解-9"><a href="#题解-9" class="headerlink" title="题解"></a>题解</h3><p>这里的思路也是两次遍历链表，然后找到需要删除的节点，但要注意保存需要删除的节点之前的节点。</p><p><strong>可用一个虚拟头节点防止各种复杂条件判断</strong></p><h3 id="Java代码实现-9"><a href="#Java代码实现-9" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span> <span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 虚拟头节点</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        <span class="comment">// 遍历需要的两个节点</span></span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        ListNode pre = dummy;</span><br><span class="line">        <span class="comment">// 开始第一次遍历求出链表长度</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ++len;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 题目中说n符合要求，故无需判断，直接二次遍历即可</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//注意这里将cur指针返回head</span></span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span>(i++ &lt; len - n)&#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里将cur节点删除，实际上就是将cur之前的指针与cur之后的指针进行连接即可</span></span><br><span class="line">        pre.next = cur.next;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM10-两个链表的第一个公共结点"><a href="#BM10-两个链表的第一个公共结点" class="headerlink" title="BM10 两个链表的第一个公共结点"></a>BM10 <a href="https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">两个链表的第一个公共结点</a></h2><h3 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两个无环的单向链表，找出它们的第一个公共结点，如果没有公共节点则返回空。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的） </p><p>数据范围： n≤1000<br>要求：空间复杂度 O(1)，时间复杂度 O(n)</p><p>例如，输入{1,2,3},{4,5},{6,7}时，两个无环的单向链表的结构如下图所示：</p><p><img src="https://uploadfiles.nowcoder.com/images/20211104/423483716_1635999204882/394BB7AFD5CEA3DC64D610F62E6647A6" alt="img"></p><p>可以看到它们的第一个公共结点的结点值为6，所以返回结点值为6的结点。</p><h4 id="输入描述："><a href="#输入描述：" class="headerlink" title="输入描述："></a>输入描述：</h4><p>输入分为是3段，第一段是第一个链表的非公共部分，第二段是第二个链表的非公共部分，第三段是第一个链表和第二个链表的公共部分。 后台会将这3个参数组装为两个链表，并将这两个链表对应的头节点传入到函数FindFirstCommonNode里面，用户得到的输入只有pHead1和pHead2。</p><h4 id="返回值描述："><a href="#返回值描述：" class="headerlink" title="返回值描述："></a>返回值描述：</h4><p>返回传入的pHead1和pHead2的第一个公共结点，后台会打印以该节点为头节点的链表。</p><h3 id="题解-10"><a href="#题解-10" class="headerlink" title="题解"></a>题解</h3><p>最简单的方法是先将一个链表中的所有节点放入一个set中，之后对于第二个链表中的每一个节点，若是set中已有，则返回该节点（需要的是第一个公共节点，故只要找到就直接返回），若是遍历完之后仍然没有找到公共节点，那么返回null，但此方法空间复杂度为O(n)，不合题意，若是想要O(1)的时间复杂度可采取如下思路：</p><p>两次遍历链表，第一次遍历记载两个链表的长度，然后找到一个链表比另一个链表长多少(len1 - len2)，较长的链表先走(len1 - len2)格，之后两个链表一起走，若是某时刻两个节点相同，那直接返回，之后若是遍历完仍然未找到相同元素，返回null</p><h3 id="Java代码实现-10"><a href="#Java代码实现-10" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况，若是两个链表某一个为空，那直接返回null</span></span><br><span class="line">        <span class="keyword">if</span>(pHead1 == <span class="keyword">null</span> || pHead2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len2 = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 当前链表1走到了哪</span></span><br><span class="line">        ListNode cur1 = pHead1;</span><br><span class="line">        <span class="comment">// 当前链表2走到了哪</span></span><br><span class="line">        ListNode cur2 = pHead2;</span><br><span class="line">        <span class="keyword">while</span>(cur1 != <span class="keyword">null</span> || cur2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">                ++len1;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">                ++len2;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将指针放回头部</span></span><br><span class="line">        cur1 = pHead1;</span><br><span class="line">        cur2 = pHead2;</span><br><span class="line">        <span class="keyword">if</span>(len1 &gt;= len2)&#123;</span><br><span class="line">            <span class="keyword">return</span> run(cur1, cur2, len1 - len2);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> run(cur2, cur1, len2 - len1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">run</span><span class="params">(ListNode head1, ListNode head2, <span class="keyword">int</span> lenSub)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 先让head1走lenSub格，已经确保head1不比head2短</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i++ &lt; lenSub)&#123;</span><br><span class="line">            head1 = head1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 之后两个一起走</span></span><br><span class="line">        <span class="keyword">while</span>(head1 != <span class="keyword">null</span> &amp;&amp; head2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head1 == head2)&#123;</span><br><span class="line">                <span class="keyword">return</span> head1;</span><br><span class="line">            &#125;</span><br><span class="line">            head1 = head1.next;</span><br><span class="line">            head2 = head2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 要是退出循环（遍历完）还未找到说明不存在</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM11-链表相加（二）"><a href="#BM11-链表相加（二）" class="headerlink" title="BM11 链表相加（二）"></a>BM11 <a href="https://www.nowcoder.com/practice/c56f6c70fb3f4849bc56e33ff2a50b6b?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">链表相加（二）</a></h2><h3 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h3><p>假设链表中每一个节点的值都在 0 - 9 之间，那么链表整体就可以代表一个整数。 </p><p>给定两个这种链表，请生成代表两个整数相加值的结果链表。 </p><p>数据范围：0≤n,m≤1000000，链表任意值 0≤val≤9<br>要求：空间复杂度 O(n)，时间复杂度 O(n)</p><p>例如：链表 1 为 9-&gt;3-&gt;7，链表 2 为 6-&gt;3，最后生成新的结果链表为 1-&gt;0-&gt;0-&gt;0。 </p><p><img src="https://uploadfiles.nowcoder.com/images/20211105/423483716_1636084743981/C2DB572B01B0FDC03C097BE7ABA45114" alt="img"></p><h3 id="题解-11"><a href="#题解-11" class="headerlink" title="题解"></a>题解</h3><p>最简单的方法，将链表中的每一个元素取出来，两个数相加之后再返回，但是注意数据范围是0≤n,m≤1000000，此方法无法保存这么大的数据，故舍弃。</p><p>考虑直接对链表节点进行相加，但涉及两个问题，一是顺序问题（链表是正序的，但是相加时需要逆序），而是考虑进位问题，对于顺序问题，先进后出考虑用栈解决，进位只需多一个节点进行保存即可。</p><h3 id="Java代码实现-11"><a href="#Java代码实现-11" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head1 ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head2 ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addInList</span> <span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 特殊情况优先考虑，若是两个链表一个为空那直接返回另一个即可</span></span><br><span class="line">        <span class="keyword">if</span>(head1 == <span class="keyword">null</span> || head2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head1 == <span class="keyword">null</span> ? head2 : head1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 栈中存节点空间消耗太大，直接存节点中的值即可</span></span><br><span class="line">        <span class="comment">// 保存第一个链表中的数</span></span><br><span class="line">        Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">// 保存第二个链表中的数</span></span><br><span class="line">        Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">// 保存相加之后的结果</span></span><br><span class="line">        Stack&lt;Integer&gt; ans = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        ListNode cur = head1;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack1.push(cur.val);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head2;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack2.push(cur.val);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 进位</span></span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stack1.isEmpty() || !stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> num1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> num2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(!stack1.isEmpty())&#123;</span><br><span class="line">                num1 = stack1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!stack2.isEmpty())&#123;</span><br><span class="line">                num2 = stack2.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> sum = num1 + num2 + carry;</span><br><span class="line">            ans.push(sum % <span class="number">10</span>);</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里最后判断一下进位是否为0，若进位不是0则需要处理</span></span><br><span class="line">        <span class="keyword">if</span>(carry != <span class="number">0</span>)&#123;</span><br><span class="line">            ans.push(carry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 生成链表</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        cur = dummy;</span><br><span class="line">        <span class="keyword">while</span>(!ans.isEmpty())&#123;</span><br><span class="line">            cur.next = <span class="keyword">new</span> ListNode(ans.pop());</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM12-单链表的排序问题"><a href="#BM12-单链表的排序问题" class="headerlink" title="BM12 单链表的排序问题"></a>BM12 <a href="https://www.nowcoder.com/practice/f23604257af94d939848729b1a5cda08?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">单链表的排序问题</a></h2><h3 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个节点数为n的无序单链表，对其按升序排序。</p><p>数据范围：0&lt;n≤100000</p><p>要求：空间复杂度 O(n)，时间复杂度 O(nlogn)</p><h3 id="题解-12"><a href="#题解-12" class="headerlink" title="题解"></a>题解</h3><p>最简单的做法是遍历链表，将链表中每个节点的值放入数组中，对数组进行排序，之后再逐个取出元素并新建链表节点，这里注意将链表的每个节点值存入数组中空间占用更小</p><h3 id="Java代码实现-12"><a href="#Java代码实现-12" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 the head node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortInList</span> <span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 特殊情况，只有一个元素时无需排序（题目中说节点数n &gt; 0）</span></span><br><span class="line">        <span class="keyword">if</span>(head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            list.add(cur.val);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        <span class="comment">// 记得把指针回退</span></span><br><span class="line">        cur = dummy;</span><br><span class="line">        <span class="comment">// 逐一构造</span></span><br><span class="line">        <span class="keyword">for</span>(Integer num : list)&#123;</span><br><span class="line">            cur.next = <span class="keyword">new</span> ListNode(num);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM13-判断一个链表是否是回文结构"><a href="#BM13-判断一个链表是否是回文结构" class="headerlink" title="BM13 判断一个链表是否是回文结构"></a>BM13 <a href="https://www.nowcoder.com/practice/3fed228444e740c8be66232ce8b87c2f?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">判断一个链表是否是回文结构</a></h2><h3 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个链表，请判断该链表是否为回文结构。</p><p>回文是指该字符串正序逆序完全一致。 </p><p>数据范围： 链表节点数 0≤n≤105，链表中每个节点的值满足 ∣val∣≤107</p><h3 id="题解-13"><a href="#题解-13" class="headerlink" title="题解"></a>题解</h3><p>很多实惠，直接对链表进行操作不方便，可以借助数组辅助操作，这里只要将节点中的每个数放入数组中进行比较即可，但这里注意一点，题目中说了回文但是每个节点的值满足|val|&lt;=10^7，那{1, 235, 235, 1}算回文还是{1, 235, 532, 1}算回文，若是第一种的话，只要将每个节点的值放入数组中，两个指针同时移动，判断是否相等即可，若是另一种，则建议将整数转化为字符串进行操作，之后对于字符串中的每个字符进行操作。</p><h3 id="Java代码实现-13"><a href="#Java代码实现-13" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 the head</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPail</span> <span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 特殊情况head为null</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; nums = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            nums.add(cur.val);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="comment">// 注意这里用的是equals而不是==，用==比较的是地址，只有当两个数都在常量池中时才会成功</span></span><br><span class="line">            <span class="keyword">if</span>(!nums.get(i).equals(nums.get(n - i - <span class="number">1</span>)))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码最终是正确的，因此这里所说的回文是第一种，不过需要注意的是在比较Integer的过程中用equals而不是用==，或者就利用自动装箱机制转换为int，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num1 = nums.get(i);</span><br><span class="line"><span class="keyword">int</span> num2 = nums.get(n - i - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(num1 != num2)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM14-链表的奇偶重拍"><a href="#BM14-链表的奇偶重拍" class="headerlink" title="BM14 链表的奇偶重拍"></a>BM14 <a href="https://www.nowcoder.com/practice/02bf49ea45cd486daa031614f9bd6fc3?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">链表的奇偶重拍</a></h2><h3 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个单链表，请设定一个函数，将链表的奇数位节点和偶数位节点分别放在一起，重排后输出。 </p><p>注意是节点的编号而非节点的数值。 </p><p>数据范围：节点数量满足 0≤n≤105，节点中的值都满足 0≤val≤1000</p><p>要求：空间复杂度 O(n)，时间复杂度 O(n)</p><h3 id="题解-14"><a href="#题解-14" class="headerlink" title="题解"></a>题解</h3><p>新建两个链表，一个用于放奇数的节点，一个用于放偶数的节点，再将两个链表连接即可。</p><h3 id="Java代码实现-14"><a href="#Java代码实现-14" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">oddEvenList</span> <span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 特殊情况依旧优先考虑，当链表有012个节点时直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结果链表以及奇偶链表的头节点</span></span><br><span class="line">        ListNode dummy1 = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode dummy2 = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 当前的初始链表以及奇偶链表到达的位置</span></span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        ListNode cur1 = dummy1;</span><br><span class="line">        ListNode cur2 = dummy2;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ++len;</span><br><span class="line">            <span class="comment">// 这里是奇偶判断，只不过位运算更快，故选择位运算</span></span><br><span class="line">            <span class="keyword">if</span>((len &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">                cur1.next = cur;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur2.next = cur;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 防止有粘连，先将链表断开</span></span><br><span class="line">        <span class="comment">// 但思考之后发现只需要断开偶数的即可，因为奇数的后一步操作实际上已经断开了</span></span><br><span class="line">        <span class="keyword">if</span>(cur1.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            cur1.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur2.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            cur2.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将奇链表与偶链表连接，cur1即为奇链表的尾</span></span><br><span class="line">        <span class="comment">// 这里其实已经避免了奇数的粘连</span></span><br><span class="line">        cur1.next = dummy2.next;    <span class="comment">// 注意这里偶链表真正开始的节点为dummy2.next（虚节点）</span></span><br><span class="line">        <span class="keyword">return</span> dummy1.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里有必要提一下我注释中说到的粘连，假设有链表{1, 2, 3, 4, 5, 6}，当进行上述代码的操作之后得到的链表实际是这样的{1, 3, 5, 6} 和{2, 4, 6}，我们需要的只有1 3 5，但6由于在原始链表中是5的next，故也放到了链表中，这对于原链表长度为偶数的时候不影响（因为后面连接的操作实际上已经把粘连部分去除了），但当原链表长度为奇数时就有影响了，假设有链表{1, 2, 3, 4, 5}，操作之后得到的链表是{1, 3, 5}和{2, 4, 5}，此时就无法得到正常结果</strong></p><h2 id="BM15-删除有序链表中重复的元素-I"><a href="#BM15-删除有序链表中重复的元素-I" class="headerlink" title="BM15 删除有序链表中重复的元素-I"></a>BM15 <a href="https://www.nowcoder.com/practice/c087914fae584da886a0091e877f2c79?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">删除有序链表中重复的元素-I</a></h2><h3 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h3><p>删除给出链表中的重复元素（链表中元素从小到大有序），使链表中的所有元素都只出现一次<br>例如：<br>给出的链表为1→1→2,返回1→2.<br>给出的链表为1→1→2→3→3,返回1→2→3. </p><h3 id="题解-15"><a href="#题解-15" class="headerlink" title="题解"></a>题解</h3><p>去重最简单的办法是利用HashSet，每次将节点的值放入HashSet中，又考虑之后还要有序构建，因此考虑LinedHashSet，但此时空间复杂度为O(n)，不合题意。</p><p>想到利用两个指针，一个记录当前位，另一个记录下一位，使用两个指针的目的是，当遇到当前元素与下一位元素相同时，不移动当前位，移动下一位直至当前位与下一位不同时，将当前位与下一位连接，如此遍历数组即可</p><h3 id="Java代码实现-15"><a href="#Java代码实现-15" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span> <span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 特殊情况优先考虑</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        ListNode nex = head.next;</span><br><span class="line">        <span class="comment">// 肯定是后一个先到，但存在一种情况就是后面几个元素都相同时需要显式地令cur.nex = null</span></span><br><span class="line">        <span class="keyword">while</span>(nex != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.val == nex.val)&#123;</span><br><span class="line">                nex = nex.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur.next = nex;</span><br><span class="line">                cur = nex;</span><br><span class="line">                nex = nex.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时cur所在的位置可能有多种</span></span><br><span class="line">        <span class="comment">// 一是倒数第一个元素</span></span><br><span class="line">        <span class="comment">// 二是倒数第k个元素（后面k个元素值都相同）</span></span><br><span class="line">        <span class="comment">// 此时只需比较cur以及其后面第一个元素（前提是其后面有元素），要是相同则显式令其next为null，反之则无需操作</span></span><br><span class="line">        <span class="keyword">if</span>(cur.next != <span class="keyword">null</span> &amp;&amp; cur.val == cur.next.val)&#123;</span><br><span class="line">            cur.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM16-删除有序列表中重复的元素-II"><a href="#BM16-删除有序列表中重复的元素-II" class="headerlink" title="BM16 删除有序列表中重复的元素-II"></a>BM16 <a href="https://www.nowcoder.com/practice/71cef9f8b5564579bf7ed93fbe0b2024?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">删除有序列表中重复的元素-II</a></h2><h3 id="题目描述-15"><a href="#题目描述-15" class="headerlink" title="题目描述"></a>题目描述</h3><p>给出一个升序排序的链表，删除链表中的所有重复出现的元素，只保留原链表中只出现一次的元素。<br>例如：<br>给出的链表为1→2→3→3→4→4→5, 返回1→2→5.<br>给出的链表为1→1→1→2→3, 返回2→3. </p><h3 id="题解-16"><a href="#题解-16" class="headerlink" title="题解"></a>题解</h3><p>第一种思路是使用两个Set加一个数组实现一个set放全部元素，另一个set放重复的元素，数组按序放节点的值，第一次遍历，若是发现放全部元素的Set中已有这个元素，那么将此元素放入放置重复元素的Set中，此外第一次遍历还需要将链表中的全部节点值放入数组中，第二次遍历数组，若是数组中的元素并不属于放重复元素的Set中，那么以此值新建节点并连接到链表中，但此时空间复杂度为O(n)，不合题意。</p><p>正确思路是：使用三个指针，pre表示前一个，cur表示当前，nex表示后一个，若是遇到相同元素，则移动nex指针直到cur与nex值不相同，若是不同则直接pre指向nex，然后三个指针依次后移一位即可</p><h3 id="Java代码实现-16"><a href="#Java代码实现-16" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span> <span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 特殊情况优先考虑</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 防止出现第一个元素就需要删除的情况，用虚拟头节点</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode pre = dummy;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        ListNode nex = head.next;</span><br><span class="line">        <span class="keyword">while</span>(nex != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.val == nex.val)&#123;</span><br><span class="line">                <span class="comment">// 元素相同时不断移动nex指针</span></span><br><span class="line">                <span class="keyword">while</span>(nex != <span class="keyword">null</span> &amp;&amp; cur.val == nex.val)&#123;</span><br><span class="line">                    nex = nex.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//此时以及移动完了，修改指针</span></span><br><span class="line">                pre.next = nex;</span><br><span class="line">                cur = nex;</span><br><span class="line">                <span class="comment">// 退出循环还有一种情况是nex为null了，此时不再后移nex指针</span></span><br><span class="line">                <span class="keyword">if</span>(nex != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    nex = nex.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 元素不同时先连接pre和nex，再移动</span></span><br><span class="line">                pre.next = cur;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = nex;</span><br><span class="line">                nex = nex.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二分查找-排序"><a href="#二分查找-排序" class="headerlink" title="二分查找/排序"></a>二分查找/排序</h1><h2 id="BM17-二分查找-I"><a href="#BM17-二分查找-I" class="headerlink" title="BM17 二分查找-I"></a>BM17 <a href="https://www.nowcoder.com/practice/d3df40bd23594118b57554129cadf47b?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">二分查找-I</a></h2><h3 id="题目描述-16"><a href="#题目描述-16" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现无重复数字的升序数组的二分查找 </p><p>给定一个 元素升序的、无重复数字的整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标（下标从 0 开始），否则返回 -1 </p><p>数据范围：0≤len(nums)≤2×105， 数组中任意值满足 ∣val∣≤109</p><p>进阶：时间复杂度 O(log⁡n)，空间复杂度 O(1)</p><h3 id="题解-17"><a href="#题解-17" class="headerlink" title="题解"></a>题解</h3><p>二分实际上就是把一个数组分为左右两份，每次比较目标值与中间值，若是中间值比较大那证明在左半部分，若是目标值比较大说明在右半部分，若是最后（那部分只有一个数切这个数不为目标值，那证明此数组中没有该目标值）。</p><h3 id="Java代码实现-17"><a href="#Java代码实现-17" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span> <span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">                <span class="comment">// 相等了直接返回</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                <span class="comment">// 比目标值小说明在右半部分</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 否则在左半部分</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM18-二维数组中的查找"><a href="#BM18-二维数组中的查找" class="headerlink" title="BM18 二维数组中的查找"></a>BM18 二维数组中的查找</h2><h3 id="题目描述-17"><a href="#题目描述-17" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个二维数组array中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 </p><p>[ </p><p>[1,2,8,9],<br>[2,4,9,12],<br>[4,7,10,13],<br>[6,8,11,15]</p><p>] </p><p>给定 target = 7，返回 true。 </p><p>给定 target = 3，返回 false。 </p><p>数据范围：矩阵的长宽满足 0≤n,m≤500， 矩阵中的值满足 0≤val≤109<br>进阶：空间复杂度 O(1)，时间复杂度 O(n+m)</p><h3 id="题解-18"><a href="#题解-18" class="headerlink" title="题解"></a>题解</h3><p>这题首先保证目标值和当前值大小关系确定时只需向一个方向移动（比如说当前值小于目标值时是应该向下移动或是向右移动），为了保证这一点，我们可以从数组的右上或是左下开始遍历，从右上遍历保证当前数是这一行最大的，当前这一列最小的，若是需要更大的只需要往下找即可，若是需要更小的只需要往左找即可，从左下开始遍历可以保证每个数都是当前这一行最小的，当前这一列最大的，若是需要更大的就往右走，若是需要更小的就往左走。</p><h3 id="Java代码实现-18"><a href="#Java代码实现-18" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(array == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 确定行列数</span></span><br><span class="line">        <span class="keyword">int</span> m = array.length;</span><br><span class="line">        <span class="keyword">int</span> n = array[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// 从右上开始遍历，行数为0列数为n-1</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= m - <span class="number">1</span> &amp;&amp; j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i][j] == target)&#123;</span><br><span class="line">                <span class="comment">// 相等返回true</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[i][j] &lt; target)&#123;</span><br><span class="line">                <span class="comment">// 小于就往下找</span></span><br><span class="line">                ++i;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 大于就往左找</span></span><br><span class="line">                --j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时仍未找到就返回false；</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM19-寻找峰值"><a href="#BM19-寻找峰值" class="headerlink" title="BM19 寻找峰值"></a>BM19 <a href="https://www.nowcoder.com/practice/fcf87540c4f347bcb4cf720b5b350c76?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">寻找峰值</a></h2><h3 id="题目描述-18"><a href="#题目描述-18" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个长度为n的数组nums，请你找到峰值并返回其索引。数组可能包含多个峰值，在这种情况下，返回任何一个所在位置即可。 </p><p>1.峰值元素是指其值严格大于左右相邻值的元素。严格大于即不能有等于</p><p>2.假设 nums[-1] = nums[n] = −∞</p><p>3.对于所有有效的 i 都有 nums[i] != nums[i + 1] </p><p>4.你可以使用O(logN)的时间复杂度实现此问题吗？ </p><p>数据范围： </p><p>1≤nums.length≤2×105</p><p>−231&lt;=nums[i]&lt;=2^31−1</p><p>如输入[2,4,1,2,7,8,4]时，会形成两个山峰，一个是索引为1，峰值为4的山峰，另一个是索引为5，峰值为8的山峰，如下图所示： </p><p><img src="https://uploadfiles.nowcoder.com/images/20211014/423483716_1634212356346/9EB9CD58B9EA5E04C890326B5C1F471F" alt="img"></p><h3 id="题解-19"><a href="#题解-19" class="headerlink" title="题解"></a>题解</h3><p>题目中已经假定数组之外的部分都为无穷小，那么当发现此时数组是递增的，那么就一定会存在山峰，因为即使递增到数组的边界，那边界值就是山峰（边界之外的部分是无穷小），反之若是递减则不一定存在山峰。</p><p>明确了以上问题之后，可以用二分的方式进行查询，但二分的思想需要一个目标值target，让target与中间值比较，在这里我们选择使用中间值的后一位作为target（这里注意只有当left == right == n - 1中间值才取到最后一位的，但此时实际上right即为波峰），那么当target大于中间值时，从中间值到target必有一部分是递增的，当target小于中间值的时候，我们考虑数组的另一部分。</p><h3 id="Java代码实现-19"><a href="#Java代码实现-19" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span> <span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 特殊情况只有一个元素时是波峰</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 这里的不同之处在于不能取等号，因为最后面返回的值是最大值，即只要一直在上坡，那么right永远大于mid大于left</span></span><br><span class="line">        <span class="comment">// 反之若是发现在下坡，那就寻找另一半</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[mid + <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="comment">// 此时右侧为上坡，继续寻找即可</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 此时右侧为下坡，为了避免当前值为波峰，这里right应为mid而不是mid - 1</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM20-数组中的逆序对"><a href="#BM20-数组中的逆序对" class="headerlink" title="BM20 数组中的逆序对"></a>BM20 <a href="https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">数组中的逆序对</a></h2><h3 id="题目描述-19"><a href="#题目描述-19" class="headerlink" title="题目描述"></a>题目描述</h3><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P mod 1000000007</p><p>数据范围： 对于 50%50% 的数据, size≤104<br>对于 100%100% 的数据, size≤105</p><p>数组中所有数字的值满足 0≤val≤1000000</p><p>要求：空间复杂度 O(n)，时间复杂度 O(nlogn)</p><h2 id="题解-20"><a href="#题解-20" class="headerlink" title="题解"></a>题解</h2><p>这题由于是逆序对（只有两个元素），因此最简单的方法是将数组中所有的数对都表示出来，之后判断是否是逆序对，是的话在逆序对计数的地方加1，如此便能解决问题，但时间复杂度为O(n^2)，题目中要求的是O(nlogn)，不合题意。</p><p>这题看时间复杂度想到用合并排序的思想来解决问题，合并排序中需要对两个有序数组进行合并，此时需要移动元素，若是当前元素比其前一个元素小，那么就需要前移元素，此时，一个前移操作就找到了一个逆序对，计算出每次合并需要的元素个数即为逆序对的数目。</p><h3 id="Java代码实现-20"><a href="#Java代码实现-20" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOD = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(array == <span class="keyword">null</span> || array.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在分治的过程中求出解</span></span><br><span class="line">        mergeSort(array);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分治算法的思想，先将数组分为有限个子序列，先令子序列有序，再合并有序的字序列</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] nums1 = Arrays.copyOfRange(nums, <span class="number">0</span>, n / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">int</span>[] nums2 = Arrays.copyOfRange(nums, n / <span class="number">2</span>, n);</span><br><span class="line">            mergeSort(nums1);</span><br><span class="line">            mergeSort(nums2);</span><br><span class="line">            merge(nums, nums1, nums2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在这里对两个数组进行合并并在每次合并中查找逆序对</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] sorted, <span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> n2 = nums2.length;</span><br><span class="line">        <span class="comment">// 标记当前两个数组走到了哪</span></span><br><span class="line">        <span class="keyword">int</span> cur1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cur2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sorted.length; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur1 == n1)&#123;</span><br><span class="line">                <span class="comment">// 第一个数组遍历完了</span></span><br><span class="line">                sorted[i] = nums2[cur2];</span><br><span class="line">                ++cur2;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur2 == n2)&#123;</span><br><span class="line">                <span class="comment">// 第二个数组遍历完了</span></span><br><span class="line">                sorted[i] = nums1[cur1];</span><br><span class="line">                ++cur1;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 两个数组都没遍历完</span></span><br><span class="line">                <span class="keyword">if</span>(nums1[cur1] &gt; nums2[cur2])&#123;</span><br><span class="line">                    <span class="comment">// 需要先插入后面的元素</span></span><br><span class="line">                    sorted[i] = nums2[cur2];</span><br><span class="line">                  <span class="comment">// 特别注意这里，总共有6个元素，当前下标为3表示是第四个元素（这个元素已经后面的全部元素都是逆序对）</span></span><br><span class="line">                    res += n1 - cur1;</span><br><span class="line">                    res %= MOD;</span><br><span class="line">                    ++cur2;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    sorted[i] = nums1[cur1];</span><br><span class="line">                    ++cur1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这个题解跟大部分的思路不同，采用了最原始的Arrays.copyOfRange()方法，因此res += 部分也与其余题解有所不同，但思路一致。</strong></p><h2 id="BM21-旋转数组的最小数字"><a href="#BM21-旋转数组的最小数字" class="headerlink" title="BM21 旋转数组的最小数字"></a>BM21 <a href="https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">旋转数组的最小数字</a></h2><h3 id="题目描述-20"><a href="#题目描述-20" class="headerlink" title="题目描述"></a>题目描述</h3><p>有一个长度为 n 的非降序数组，比如[1,2,3,4,5]，将它进行旋转，即把一个数组最开始的若干个元素搬到数组的末尾，变成一个旋转数组，比如变成了[3,4,5,1,2]，或者[4,5,1,2,3]这样的。请问，给定这样一个旋转数组，求数组中的最小值。</p><p>数据范围：1≤n≤10000，数组中任意元素的值: 0≤val≤10000</p><p>要求：空间复杂度：O(1)，时间复杂度：O(logn)</p><h3 id="题解-21"><a href="#题解-21" class="headerlink" title="题解"></a>题解</h3><p>最简单的方法是遍历数组找到最小值，但时间复杂度是O(n)，不合题意。由于数组原始是非降序的之后将最开始的几个元素搬到了末尾，那么数组部分是有序的，可以使用二分，以数组的端点作为target值，当中间值小于target时，证明在左半部分（由于原数组非降序，不可能出现大于最大值之后，从最小值开始仍然大于中间值，即不可能出现mid到target是{6, 7, 1, 4, 8}的情况），当中间值大于target时，证明在右半部分，若是特别特殊，两者相等，即原数组为{5, 5, 5, 5, 5, 1, 2, 3, 4, 5}或者{1, 0, 1, 1, 1}时，无法确定属于哪部分，令target = nums[right - 1]，缩小范围后继续，如此循环便能找到。</p><h3 id="Java代码实现-21"><a href="#Java代码实现-21" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(array.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[mid] &lt; array[right])&#123;</span><br><span class="line">                <span class="comment">// 小于表示在左半部分</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[mid] &gt; array[right])&#123;</span><br><span class="line">                <span class="comment">// 大于表示在右半部分</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 等于则缩小范围</span></span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用二分法时，有时题目中没有target，那么需要考虑如何选择target才最优，寻找山峰问题target是中间值的下一位，而这里target是right</strong></p><h2 id="BM22-比较版本号"><a href="#BM22-比较版本号" class="headerlink" title="BM22 比较版本号"></a>BM22 <a href="https://www.nowcoder.com/practice/2b317e02f14247a49ffdbdba315459e7?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">比较版本号</a></h2><h3 id="题目描述-21"><a href="#题目描述-21" class="headerlink" title="题目描述"></a>题目描述</h3><p>牛客项目发布项目版本时会有版本号，比如1.02.11，2.14.4等等 </p><p>现在给你2个版本号version1和version2，请你比较他们的大小</p><p>版本号是由修订号组成，修订号与修订号之间由一个”.”连接。1个修订号可能有多位数字组成，修订号可能包含前导0，且是合法的。例如，1.02.11，0.1，0.2都是合法的版本号</p><p>每个版本号至少包含1个修订号。 </p><p>修订号从左到右编号，下标从0开始，最左边的修订号下标为0，下一个修订号下标为1，以此类推。 </p><p>比较规则： </p><p>一. 比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较忽略任何前导零后的整数值。比如”0.1”和”0.01”的版本号是相等的 </p><p>二. 如果版本号没有指定某个下标处的修订号，则该修订号视为0。例如，”1.1”的版本号小于”1.1.1”。因为”1.1”的版本号相当于”1.1.0”，第3位修订号的下标为0，小于1 </p><p>三. version1 &gt; version2 返回1，如果 version1 &lt; version2 返回-1，不然返回0. </p><p>数据范围： </p><p>1&lt;=version1.length,version2.length&lt;=1000</p><p>version1 和 version2 的修订号不会超过int的表达范围，即不超过 <strong>32 位整数</strong> 的范围</p><p>进阶： 空间复杂度 O(1)， 时间复杂度 O(n)</p><h3 id="题解-22"><a href="#题解-22" class="headerlink" title="题解"></a>题解</h3><p>最简单的方法是利用.将两个字符串分解为字符数组，之后逐个比较，但此方法需要额外开辟空间，空间复杂度为O(n)，不合题意。</p><h3 id="Java代码实现如下"><a href="#Java代码实现如下" class="headerlink" title="Java代码实现如下"></a>Java代码实现如下</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 比较版本号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> version1 string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> version2 string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span> <span class="params">(String version1, String version2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">      <span class="comment">// 这里注意正则表达式的书写，\需要转译</span></span><br><span class="line">        String[] strs1 = version1.split(<span class="string">"\\."</span>);</span><br><span class="line">        String[] strs2 = version2.split(<span class="string">"\\."</span>);</span><br><span class="line">        <span class="keyword">int</span> len1 = strs1.length;</span><br><span class="line">        <span class="keyword">int</span> len2 = strs2.length;</span><br><span class="line">        <span class="keyword">int</span> minLen = len1 &lt; len2 ? len1 : len2;</span><br><span class="line">      <span class="comment">// 匹配两者都有的部分</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; minLen; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> num1 = Integer.parseInt(strs1[i]);</span><br><span class="line">            <span class="keyword">int</span> num2 = Integer.parseInt(strs2[i]);</span><br><span class="line">            <span class="keyword">if</span>(num1 &lt; num2)&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num1 &gt; num2)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// 匹配完了开始判断</span></span><br><span class="line">        <span class="keyword">if</span>(len1 == len2)&#123;</span><br><span class="line">            <span class="comment">// 长度相等直接返回0（之前已经能确定全部匹配）</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len1 &gt; len2)&#123;</span><br><span class="line">            <span class="comment">// version1比较长，多出来的和0比较</span></span><br><span class="line">            <span class="keyword">while</span>(minLen &lt; len1)&#123;</span><br><span class="line">                <span class="keyword">if</span>(Integer.parseInt(strs1[minLen]) != <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ++minLen;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// version2长同理，和0比较</span></span><br><span class="line">            <span class="keyword">while</span>(minLen &lt; len2)&#123;</span><br><span class="line">                <span class="keyword">if</span>(Integer.parseInt(strs2[minLen]) != <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ++minLen;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题解-23"><a href="#题解-23" class="headerlink" title="题解"></a>题解</h3><p>若是想达到O(1)的空间复杂度，可以考虑使用双指针，一个指针用于解析version1，一个指针用于解析version2，对于前导0的处理是不处理（因为每次只用处理一个字符，若是当前字符不是’.’，那么直接用已经解析出的值（当前值前面的值） * 10 + 当前的值），遇到前导0，已经解析出的值为0，0 * 10 + 0 = 0，并无影响，此方法主要是逐个读取字符，即：”103”的解析过程为1，1 * 10 + 0 = 10，10 * 10 + 3 = 103。</p><h3 id="Java代码实现-22"><a href="#Java代码实现-22" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 比较版本号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> version1 string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> version2 string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span> <span class="params">(String version1, String version2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">char</span>[] str1 = version1.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] str2 = version2.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> len1 = str1.length;</span><br><span class="line">        <span class="keyword">int</span> len2 = str2.length;</span><br><span class="line">        <span class="comment">// 两个遍历指针</span></span><br><span class="line">        <span class="keyword">int</span> cur1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cur2 = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 只要两个字符串中任何一个没有解析完，那就继续解析</span></span><br><span class="line">        <span class="keyword">while</span>(cur1 &lt; len1 || cur2 &lt; len2)&#123;</span><br><span class="line">            <span class="comment">// 设置解析出的元素，初始值为0</span></span><br><span class="line">            <span class="keyword">int</span> num1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> num2 = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 只有str1未解析完才解析，否则其为0</span></span><br><span class="line">            <span class="keyword">if</span>(cur1 &lt; len1)&#123;</span><br><span class="line">                <span class="comment">// 这里必须是cur++，否则会导致解析不到.之前的那个数，而且这样也直接跳过了.</span></span><br><span class="line">                <span class="keyword">while</span>(cur1 &lt; len1 &amp;&amp; str1[cur1++] != <span class="string">'.'</span>)&#123;</span><br><span class="line">                    <span class="comment">// 这里为什么是cur-1呢，因为前面已经自增过一次</span></span><br><span class="line">                    num1 = <span class="number">10</span> * num1 + str1[cur1 - <span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 同理只有str2未解析完才解析，否则为初始值0</span></span><br><span class="line">            <span class="keyword">if</span>(cur2 &lt; len2)&#123;</span><br><span class="line">                <span class="comment">// 这里必须是cur++，否则会导致解析不到.之前的那个数，而且这样也直接跳过了.</span></span><br><span class="line">                <span class="keyword">while</span>(cur2 &lt; len2 &amp;&amp; str2[cur2++] != <span class="string">'.'</span>)&#123;</span><br><span class="line">                    <span class="comment">// 这里为什么是cur-1呢，因为前面已经自增过一次</span></span><br><span class="line">                    num2 = <span class="number">10</span> * num2 + str2[cur2 - <span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 通过以上步骤已经将两个都解析了，这里只需要判断就好</span></span><br><span class="line">            <span class="keyword">if</span>(num1 &gt; num2)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num1 &lt; num2)&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="BM23-二叉树的前序遍历"><a href="#BM23-二叉树的前序遍历" class="headerlink" title="BM23 二叉树的前序遍历"></a>BM23 <a href="https://www.nowcoder.com/practice/5e2135f4d2b14eb8a5b06fab4c938635?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">二叉树的前序遍历</a></h3><h3 id="题目描述-22"><a href="#题目描述-22" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你二叉树的根节点 root ，返回它节点值的 前序 遍历。</p><p>数据范围：二叉树的节点数量满足 1≤n≤100，二叉树节点的值满足 1≤val≤100，树的各节点的值各不相同</p><h3 id="题解-24"><a href="#题解-24" class="headerlink" title="题解"></a>题解</h3><p>二叉树的前序遍历就是先访问根节点，再访问左右子树，即“根左右”。</p><h3 id="Java代码实现-23"><a href="#Java代码实现-23" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] preorderTraversal (TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 用于保存返回结果</span></span><br><span class="line">        ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(root, ans);</span><br><span class="line">        <span class="comment">// 这里这个方法之前没用过，若是不用此方法也可以，如下：</span></span><br><span class="line">        <span class="comment">// int[] res = new int(ans.size());</span></span><br><span class="line">        <span class="comment">// for(int i = 0; i &lt; ans.size(); ++i)&#123;</span></span><br><span class="line">        <span class="comment">//     res[i] = ans.get(i);</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="keyword">return</span> ans.stream().mapToInt(Integer::valueOf).toArray();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; nums)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 可以不用这个cur变量直接在root上操作，但使用这个变量可以保证root不会变化</span></span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            nums.add(root.val);</span><br><span class="line">            dfs(root.left, nums);</span><br><span class="line">            dfs(root.right, nums);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM24-二叉树的中序遍历"><a href="#BM24-二叉树的中序遍历" class="headerlink" title="BM24 二叉树的中序遍历"></a>BM24 <a href="https://www.nowcoder.com/practice/0bf071c135e64ee2a027783b80bf781d?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">二叉树的中序遍历</a></h2><h3 id="题目描述-23"><a href="#题目描述-23" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树的根节点root，返回它的中序遍历结果。 </p><p>数据范围：树上节点数满足 0≤n≤1000，树上每个节点的值满足 0≤val≤1000<br>进阶：空间复杂度 O(n)，时间复杂度 O(n)</p><h3 id="题解-25"><a href="#题解-25" class="headerlink" title="题解"></a>题解</h3><p>二叉树的中序遍历就是先访问左子树，再访问根节点，最后访问右子树，即“左根右”。</p><h3 id="Java代码实现-24"><a href="#Java代码实现-24" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] inorderTraversal (TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 用于保存返回结果</span></span><br><span class="line">        ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(root, ans);</span><br><span class="line">        <span class="keyword">return</span> ans.stream().mapToInt(Integer::valueOf).toArray();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; nums)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 可以不用这个cur变量直接在root上操作，但使用这个变量可以保证root不会变化</span></span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            dfs(root.left, nums);</span><br><span class="line">            nums.add(root.val);</span><br><span class="line">            dfs(root.right, nums);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM25-二叉树的后序遍历"><a href="#BM25-二叉树的后序遍历" class="headerlink" title="BM25 二叉树的后序遍历"></a>BM25 <a href="https://www.nowcoder.com/practice/1291064f4d5d4bdeaefbf0dd47d78541?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">二叉树的后序遍历</a></h2><h3 id="题目描述-24"><a href="#题目描述-24" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树，返回他的后序遍历的序列。 </p><p>后序遍历是值按照 左节点-&gt;右节点-&gt;根节点 的顺序的遍历。 </p><p>数据范围：二叉树的节点数量满足 1≤n≤100，二叉树节点的值满足 1≤val≤100，树的各节点的值各不相同</p><h3 id="题解-26"><a href="#题解-26" class="headerlink" title="题解"></a>题解</h3><p>二叉树的后序遍历就是先访问左右子树，再访问根节点，即“左右根”。</p><h3 id="Java代码实现-25"><a href="#Java代码实现-25" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] postorderTraversal (TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 用于保存返回结果</span></span><br><span class="line">        ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(root, ans);</span><br><span class="line">        <span class="keyword">return</span> ans.stream().mapToInt(Integer::valueOf).toArray();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; nums)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 可以不用这个cur变量直接在root上操作，但使用这个变量可以保证root不会变化</span></span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            dfs(root.left, nums);</span><br><span class="line">            dfs(root.right, nums);</span><br><span class="line">            nums.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>前中后序遍历只有dfs函数的顺序不同，其余操作完全一致</strong></p><h2 id="BM26-求二叉树的层序遍历"><a href="#BM26-求二叉树的层序遍历" class="headerlink" title="BM26 求二叉树的层序遍历"></a>BM26 <a href="https://www.nowcoder.com/practice/04a5560e43e24e9db4595865dc9c63a3?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">求二叉树的层序遍历</a></h2><h2 id="题目描述-25"><a href="#题目描述-25" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树，返回该二叉树层序遍历的结果，（从左到右，一层一层地遍历）<br>例如：<br>给定的二叉树是{3,9,20,#,#,15,7},<br><img src="https://uploadfiles.nowcoder.com/images/20210114/999991351_1610616074120/036DC34FF19FB24652AFFEB00A119A76" alt="img"><br>该二叉树层序遍历的结果是<br>[<br>[3],<br>[9,20],<br>[15,7] </p><p>] </p><p>提示: </p><p>0 &lt;= 二叉树的结点数 &lt;= 1500</p><h3 id="题解-27"><a href="#题解-27" class="headerlink" title="题解"></a>题解</h3><p>层序遍历实际上就是BFS（广度优先搜索），一般情况下，深度优先遍历用栈辅助操作，广度优先遍历用队列辅助操作，具体操作如下：</p><p>首先判断根节点是否为空，若是为空直接返回空，不为空将根节点放入队列中，当队列不为空的时候就不断循环，取出队头，将其左右子树分别插入队尾，直到队列为空时就得到了BFS结果。</p><h3 id="Java代码实现-26"><a href="#Java代码实现-26" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型ArrayList&lt;ArrayList&lt;&gt;&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelOrder (TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 用于返回结果</span></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 特殊情况优先考虑</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用于存放每一层的节点</span></span><br><span class="line">        ArrayList&lt;TreeNode&gt; nodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 链表实际上实现了Queue接口</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 将根节点放入队列中</span></span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; nums = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">// 取出当前层所有节点</span></span><br><span class="line">            <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">                TreeNode cur = queue.poll();</span><br><span class="line">                nums.add(cur.val);</span><br><span class="line">                nodes.add(cur);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对于这一层的所有节点，遍历</span></span><br><span class="line">            <span class="keyword">for</span>(TreeNode cur : nodes)&#123;</span><br><span class="line">                <span class="comment">// 左子树不为空，放入队列</span></span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.offer(cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 右子树不为空，放入队列</span></span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.offer(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(nums);</span><br><span class="line">            <span class="comment">// 注意结束后将nodes置空</span></span><br><span class="line">            nodes.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里的话注意返回的是一个二维数组，故每次都需要将这一层的数据取完，保存在一个中间数组中，之后在每一层新建一个数组用于放置节点值</strong></p><h2 id="BM27-按之字形顺序打印二叉树"><a href="#BM27-按之字形顺序打印二叉树" class="headerlink" title="BM27 按之字形顺序打印二叉树"></a>BM27 <a href="https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">按之字形顺序打印二叉树</a></h2><h3 id="题目描述-26"><a href="#题目描述-26" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树，返回该二叉树的之字形层序遍历，（第一层从左向右，下一层从右向左，一直这样交替） </p><p>数据范围：0≤n≤1500,树上每个节点的val满足 ∣val∣&lt;=150<br>要求：空间复杂度：O(n)<em>O</em>(<em>n</em>)，时间复杂度：O(n)<em>O</em>(<em>n</em>)</p><p>例如：<br>给定的二叉树是{1,2,3,#,#,4,5}<br><img src="https://uploadfiles.nowcoder.com/images/20210717/557336_1626492068888/41FDD435F0BA63A57E274747DE377E05" alt="img"><br>该二叉树之字形层序遍历的结果是 </p><p>[ </p><p>[1], </p><p>[3,2], </p><p>[4,5] </p><p>]</p><h3 id="题解-28"><a href="#题解-28" class="headerlink" title="题解"></a>题解</h3><p>这题也是层序遍历只不过遍历的顺序不一致，这就需要考虑利用辅助变量level外加栈来控制顺序，首先将根节点放入栈中，此时level为1，若是level为奇数则先放左子树后放右子树，因为栈的性质，在下一次遍历时右子树就会优先被输出，若是level为偶数，那么先放右子树后方左子树，那么下次遍历时左子树就会优先被输出，知道栈空位置。</p><h3 id="Java代码实现-27"><a href="#Java代码实现-27" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 特殊情况依旧优先考虑</span></span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用于判断层数（奇数先右后左，偶数先左后右）</span></span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 用于存储某一层的全部节点</span></span><br><span class="line">        ArrayList&lt;TreeNode&gt; nodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 先将根节点入栈</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(pRoot);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// 用于保存这一层所有元素</span></span><br><span class="line">            ArrayList&lt;Integer&gt; nums = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">// 取出这一层所有元素</span></span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">                TreeNode cur = stack.pop();</span><br><span class="line">                nums.add(cur.val);</span><br><span class="line">                nodes.add(cur);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((level &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 奇数层，那么表示下一次是偶数层，需要从右到左，因为栈的性质，先放左子树</span></span><br><span class="line">                <span class="keyword">for</span>(TreeNode node : nodes)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        stack.push(node.left);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        stack.push(node.right);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 偶数层，下一层是奇数层，需要从左到右，因为栈的性质，先放右子树</span></span><br><span class="line">                <span class="keyword">for</span>(TreeNode node : nodes)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        stack.push(node.right);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        stack.push(node.left);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将这一层的结果加入结果集中</span></span><br><span class="line">            res.add(nums);</span><br><span class="line">            <span class="comment">// 增加层数</span></span><br><span class="line">            ++level;</span><br><span class="line">            <span class="comment">// 将nodes集置空</span></span><br><span class="line">            nodes.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对于BFS，一般使用队列，对于这种需要确定顺序的，只需要在偶数层反转队列即可，Java中队列没有自带的reverse方法，故不考虑此做法，这里插一句，利用两个队列可以实现一个栈，利用两个栈也可以实现一个队列，具体做法是，只保证其中一个有数据，插入时只查到有数据的那个，删除时将前n-1个数据移到另一部分，再将最后一个元素取出</strong></p><p><strong>这里判断奇偶性使用的是或运算而不是对2求余，这样会快一些</strong></p><h2 id="BM28-二叉树的最大深度"><a href="#BM28-二叉树的最大深度" class="headerlink" title="BM28 二叉树的最大深度"></a>BM28 <a href="https://www.nowcoder.com/practice/8a2b2bf6c19b4f23a9bdb9b233eefa73?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">二叉树的最大深度</a></h2><h3 id="题目描述-27"><a href="#题目描述-27" class="headerlink" title="题目描述"></a>题目描述</h3><p>求给定二叉树的最大深度， </p><p>深度是指树的根节点到任一叶子节点路径上节点的数量。 </p><p>最大深度是所有叶子节点的深度的最大值。 </p><p>（注：叶子节点是指没有子节点的节点。）</p><p>数据范围：0≤n≤100000，树上每个节点的val满足 ∣val∣≤100<br>要求： 空间复杂度 O(1),时间复杂度 O(n)</p><h3 id="题解-29"><a href="#题解-29" class="headerlink" title="题解"></a>题解</h3><p>两个思路，一是利用栈，栈的最大长度即为二叉树的最大深度，但使用栈会导致空间复杂度为O(n)，不合题意舍弃。</p><p>直接dfs，并在dfs的过程中维护最大深度，但此方法递归调用，空间复杂度也是O(n)，愚以为没有O(1)空间复杂度的方法。</p><h3 id="Java代码实现-28"><a href="#Java代码实现-28" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span> <span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 特殊情况优先考虑</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则就递归求左右子树中比较大的那个 + 1就是答案</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM29-二叉树中和为某一值的路径"><a href="#BM29-二叉树中和为某一值的路径" class="headerlink" title="BM29 二叉树中和为某一值的路径"></a>BM29 <a href="https://www.nowcoder.com/practice/508378c0823c423baa723ce448cbfd0c?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">二叉树中和为某一值的路径</a></h2><h3 id="题目描述-28"><a href="#题目描述-28" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树root和一个值 sum ，判断是否有从根节点到叶子节点的节点值之和等于 sum 的路径。</p><p>1.该题路径定义为从树的根结点开始往下一直到叶子结点所经过的结点</p><p>2.叶子节点是指没有子节点的节点</p><p>3.路径只能从父节点到子节点，不能从子节点到父节点</p><p>4.总节点数目为n</p><p>例如：<br>给出如下的二叉树， sum=22，<br><img src="https://uploadfiles.nowcoder.com/images/20200807/999991351_1596786493913_8BFB3E9513755565DC67D86744BB6159" alt="img"><br>返回true，因为存在一条路径 5→4→11→2的节点值之和为 22 </p><p>数据范围： </p><p>1.树上的节点数满足 0≤n≤10000</p><p>2.每 个节点的值都满足 ∣val∣≤1000</p><p>要求：空间复杂度 O(n)，时间复杂度 O(n)</p><p>进阶：空间复杂度 O(树的高度)，时间复杂度 O(n)</p><h3 id="题解-30"><a href="#题解-30" class="headerlink" title="题解"></a>题解</h3><p>毫无疑问BFS，两种思路，一是直接递归，二是使用栈保存遍历的节点，退出的条件是，当前节点值为需要的值且此节点是叶子节点，若是不是叶子节点那么继续dfs，只不过dfs的变量变为root.left和sum - root.val</p><h3 id="Java代码实现-29"><a href="#Java代码实现-29" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sum int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span> <span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 这里特殊情况先考虑，之后再dfs</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum -= root.val;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; sum == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left, sum) || hasPathSum(root.right, sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里为什么不直接if(root == null &amp;&amp; sum == 0) return true;主要原因是，若是某一个节点左子树或者右子树为null，当遍历到这个节点的时候，sum已经== 0 了但是这不是路径，因此当遍历到它那棵空子树时就会导致此条件成立，但此时并不是路径（考虑用例{1, 2}, sum = 1）</strong></p><h2 id="BM30-二叉搜索树与双向链表"><a href="#BM30-二叉搜索树与双向链表" class="headerlink" title="BM30 二叉搜索树与双向链表"></a>BM30 <a href="https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">二叉搜索树与双向链表</a></h2><h3 id="题目描述-29"><a href="#题目描述-29" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。如下图所示 </p><p><img src="https://uploadfiles.nowcoder.com/images/20210605/557336_1622886924427/E1F1270919D292C9F48F51975FD07CE2" alt="img"></p><p>数据范围：输入二叉树的节点数 0≤n≤1000，二叉树中每个节点的值 0≤val≤1000<br>要求：空间复杂度O(1)（即在原树上操作），时间复杂度 O(n)</p><p>注意: </p><p>1.要求不能创建任何新的结点，只能调整树中结点指针的指向。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继<br>2.返回链表中的第一个节点的指针<br>3.函数返回的TreeNode，有左右指针，其实可以看成一个双向链表的数据结构 </p><p>4.你不用输出双向链表，程序会根据你的返回值自动打印输出</p><h4 id="输入描述：-1"><a href="#输入描述：-1" class="headerlink" title="输入描述："></a>输入描述：</h4><p>二叉树的根节点</p><h4 id="返回值描述：-1"><a href="#返回值描述：-1" class="headerlink" title="返回值描述："></a>返回值描述：</h4><p>双向链表的其中一个头节点。</p><h3 id="题解-31"><a href="#题解-31" class="headerlink" title="题解"></a>题解</h3><p>最简单的方法是二叉树中序遍历得到一个结果数组，再利用数组中的每一个值新建节点构成双向链表，最后返回，但此法需要额外申请空间，空间复杂度为O(n)，不合题意。</p><p>若是需要在原树上进行操作，对于一个节点，其前驱节点（左子树）应为其左子树中序遍历的最后一个值，其后继节点因为其中序遍历的第一个值，而且只有最左的节点没有前驱节点，最右的节点没有后继节点。</p><h3 id="Java代码实现-30"><a href="#Java代码实现-30" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 链表的根</span></span><br><span class="line">    TreeNode root = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 上一次反转得到的链表尾</span></span><br><span class="line">    TreeNode preTail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况优先考虑</span></span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 中序遍历，先左</span></span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            Convert(pRootOfTree.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 保存根节点，这里保存根节点的目的是，每次操作之后就只剩下了当前这课子树的头</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            root = pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 中序遍历，再根，在这里对左右子树进行修改操作</span></span><br><span class="line">        <span class="keyword">if</span>(preTail != <span class="keyword">null</span>)&#123;</span><br><span class="line">            preTail.right = pRootOfTree;</span><br><span class="line">            pRootOfTree.left = preTail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里注意将这个指针移位</span></span><br><span class="line">        preTail = pRootOfTree;</span><br><span class="line">        <span class="comment">// 中序遍历，后右</span></span><br><span class="line">        Convert(pRootOfTree.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了递归版本，那自然也有非递归版本，非递归版本实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况优先考虑</span></span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree == <span class="keyword">null</span> || (pRootOfTree.left == <span class="keyword">null</span> &amp;&amp; pRootOfTree.right == <span class="keyword">null</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">        TreeNode cur = pRootOfTree;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">// 这里一次找到最左边的节点，也就是链表的头</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取出这个最左边的节点并保存，保存的原因是它需要作为头节点</span></span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        pRootOfTree = cur;</span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="comment">// 这里实际上cur = null</span></span><br><span class="line">        cur = cur.right;</span><br><span class="line">        <span class="comment">// 之后将所有的元素一一放入</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// 对于每个节点也是左根右</span></span><br><span class="line">            <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 这里思考一个问题，遍历一次之后其实已经将cur变为cur.right了，因此这里已经将cur.right放入栈中了</span></span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = stack.pop();</span><br><span class="line">            cur.left = pre;</span><br><span class="line">            pre.right = cur;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对于这个栈，先不停地将左节点放入，之后进行根节点的变换(由于第一个元素已经单独拿出来考虑，因此无需担心对pre的空指针操作，也可学习链表，初始时pre是一个虚拟头节点)，最后将当前节点转化为右子树</span></span><br><span class="line">        <span class="keyword">return</span> pRootOfTree;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中序非递归的核心代码是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dfs(TreeNode root)&#123;</span><br><span class="line">  Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span>(root != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">      <span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">          stack.push(root);</span><br><span class="line">          root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//对于根节点进行操作</span></span><br><span class="line">      <span class="keyword">do</span> something;</span><br><span class="line">      root = root.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM31对称的二叉树"><a href="#BM31对称的二叉树" class="headerlink" title="BM31对称的二叉树"></a>BM31<a href="https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">对称的二叉树</a></h2><h3 id="题目描述-30"><a href="#题目描述-30" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一棵二叉树，判断其是否是自身的镜像（即：是否对称）<br>例如：                 下面这棵二叉树是对称的<br><img src="https://uploadfiles.nowcoder.com/images/20210926/382300087_1632642756706/A22A794C036C06431E632F9D5E2E298F" alt="img"><br>下面这棵二叉树不对称。<br><img src="https://uploadfiles.nowcoder.com/images/20210926/382300087_1632642770481/3304ABDD147D8E140B2CEF3201BD8372" alt="img"></p><p>数据范围：节点数满足 0≤n≤1000，节点上的值满足 ∣val∣≤1000</p><p>要求：空间复杂度 O(n)，时间复杂度 O(n)</p><p>备注： </p><p>你可以用递归和迭代两种方法解决这个问题</p><h3 id="题解-32"><a href="#题解-32" class="headerlink" title="题解"></a>题解</h3><p>建立一个辅助函数帮助判断左右子树是否对称。</p><p>当左右子树均为空时返回true，当左右子树有一个为空时返回false；否则判断两个子树根节点的值是否相等以及左子树的左子树是否和右子树的右子树对称以及左子树的右子树是否和右子树的左子树对称。</p><h3 id="Java代码实现-31"><a href="#Java代码实现-31" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(pRoot.left, pRoot.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(TreeNode left, TreeNode right)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 两子树均为空时true</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时已经确定两棵子树不同为空，那么满足条件时只有一棵子树为空</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span> || right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 看当前左右子树根节点是否对称以及左子树的左子树是否和右子树的右子树对称以及左子树的右子树是否和右子树的左子树对称</span></span><br><span class="line">        <span class="keyword">return</span> left.val == right.val &amp;&amp; helper(left.left, right.right) &amp;&amp; helper(left.right, right.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM32-合并二叉树"><a href="#BM32-合并二叉树" class="headerlink" title="BM32 合并二叉树"></a>BM32 <a href="https://www.nowcoder.com/practice/7298353c24cc42e3bd5f0e0bd3d1d759?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">合并二叉树</a></h2><h3 id="题目描述-31"><a href="#题目描述-31" class="headerlink" title="题目描述"></a>题目描述</h3><p>已知两颗二叉树，将它们合并成一颗二叉树。合并规则是：都存在的结点，就将结点值加起来，否则空的位置就由另一个树的结点来代替。例如：<br>两颗二叉树是:<br>                                  Tree 1 </p><p><img src="https://uploadfiles.nowcoder.com/images/20210928/382300087_1632821337680/9E290CFD3730B9B08A5CEFF25799608F" alt="img"></p><p>​                                    Tree 2<br><img src="https://uploadfiles.nowcoder.com/images/20210928/382300087_1632821376266/DD0A63560E770A8510049C5182E6E622" alt="img"><br>​                                  合并后的树为<br><img src="https://uploadfiles.nowcoder.com/images/20210928/382300087_1632821404541/9CB750F8909D5985C0D01D8B71AD58BA" alt="img"></p><p>数据范围：树上节点数量满足 0≤n≤500，树上节点的值一定在32位整型范围内。 </p><p>进阶：空间复杂度 O(1)，时间复杂度 O(n)</p><h3 id="题解-33"><a href="#题解-33" class="headerlink" title="题解"></a>题解</h3><p>对于两个树，都以某种顺序进行遍历，直达左右节点都为null时结束。</p><h3 id="Java代码实现-32"><a href="#Java代码实现-32" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t1 TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t2 TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> TreeNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span> <span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 特殊情况优先考虑</span></span><br><span class="line">        <span class="keyword">if</span>(t1 == <span class="keyword">null</span> || t2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> t1 == <span class="keyword">null</span> ? t2 : t1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时确保两者都不为空</span></span><br><span class="line">        t1.val += t2.val;</span><br><span class="line">      <span class="comment">// t1的左子树为合并t1 t2左子树的结果</span></span><br><span class="line">        t1.left = mergeTrees(t1.left, t2.left);</span><br><span class="line">      <span class="comment">// t1的右子树为合并t1 t2右子树的结果</span></span><br><span class="line">        t1.right = mergeTrees(t1.right, t2.right);</span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM33-二叉树的镜像"><a href="#BM33-二叉树的镜像" class="headerlink" title="BM33 二叉树的镜像"></a>BM33 <a href="https://www.nowcoder.com/practice/a9d0ecbacef9410ca97463e4a5c83be7?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">二叉树的镜像</a></h2><h3 id="题目描述-32"><a href="#题目描述-32" class="headerlink" title="题目描述"></a>题目描述</h3><p>操作给定的二叉树，将其变换为源二叉树的镜像。 </p><p>数据范围：二叉树的节点数 0≤n≤1000， 二叉树每个节点的值 0≤val≤1000</p><p>要求： 空间复杂度 O(n)。本题也有原地操作，即空间复杂度 O(1)的解法，时间复杂度 O(n)</p><p>比如： </p><p>源二叉树</p><p><img src="https://uploadfiles.nowcoder.com/images/20210922/382300087_1632302001586/420B82546CFC9760B45DD65BA9244888" alt="img"></p><p>镜像二叉树 </p><p><img src="https://uploadfiles.nowcoder.com/images/20210922/382300087_1632302036250/AD8C4CC119B15070FA1DBAA1EBE8FC2A" alt="img"></p><h3 id="题解-34"><a href="#题解-34" class="headerlink" title="题解"></a>题解</h3><p>递归实现，先将当前节点的左右子树交换，之后再递归实现左右子树的镜像。</p><h3 id="Java代码实现-33"><a href="#Java代码实现-33" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pRoot TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> TreeNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Mirror</span> <span class="params">(TreeNode pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span> || pRoot.left == <span class="keyword">null</span> &amp;&amp; pRoot.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> pRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode temp = pRoot.left;</span><br><span class="line">        pRoot.left = pRoot.right;</span><br><span class="line">        pRoot.right = temp;</span><br><span class="line">        Mirror(pRoot.left);</span><br><span class="line">        Mirror(pRoot.right);</span><br><span class="line">        <span class="keyword">return</span> pRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM34-判断是不是二叉搜索树"><a href="#BM34-判断是不是二叉搜索树" class="headerlink" title="BM34 判断是不是二叉搜索树"></a>BM34 <a href="https://www.nowcoder.com/practice/a69242b39baf45dea217815c7dedb52b?tpId=295&tqId=2288088&ru=%2Fpractice%2Fa9d0ecbacef9410ca97463e4a5c83be7&qru=%2Fta%2Fformat-top101%2Fquestion-ranking&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">判断是不是二叉搜索树</a></h2><h3 id="题目描述-33"><a href="#题目描述-33" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树根节点，请你判断这棵树是不是二叉搜索树。 </p><p>二叉搜索树满足每个节点的左子树上的所有节点均小于当前节点且右子树上的所有节点均大于当前节点。 </p><p>例： </p><p><img src="https://uploadfiles.nowcoder.com/images/20211109/392807_1636440937987/9C31F319601A5B78D34F62FF77A02A11" alt="img"></p><p>图1 </p><p><img src="https://uploadfiles.nowcoder.com/images/20211109/392807_1636440984427/5E5B576E11CB2C96724680C94755ABCB" alt="img"></p><p>图2 </p><p>数据范围：节点数量满足 1≤n≤104，节点上的值满足 −231≤val≤231−1</p><h3 id="题解-35"><a href="#题解-35" class="headerlink" title="题解"></a>题解</h3><p>最简单的方法是中序遍历二叉树得到数组，看数组中每个元素是否严格小于后一个数</p><h3 id="Java代码实现-34"><a href="#Java代码实现-34" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span> <span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; nums = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(root, nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.size() - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums.get(i) &gt;= nums.get(i + <span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            dfs(root.left, nums);</span><br><span class="line">            nums.add(root.val);</span><br><span class="line">            dfs(root.right, nums);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题解-36"><a href="#题解-36" class="headerlink" title="题解"></a>题解</h3><p>或者就是在中序遍历的过程中直接比较，不使用额外数组</p><h3 id="Java代码实现-35"><a href="#Java代码实现-35" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> pre = Integer.MIN_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span> <span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dfs(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            flag = (flag &amp;&amp; dfs(root.left));</span><br><span class="line">            flag = (flag &amp;&amp; (root.val &gt; pre));</span><br><span class="line">            pre = root.val;</span><br><span class="line">            flag = (flag &amp;&amp; dfs(root.right));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;链表部分&quot;&gt;&lt;a href=&quot;#链表部分&quot; class=&quot;headerlink&quot; title=&quot;链表部分&quot;&gt;&lt;/a&gt;链表部分&lt;/h1&gt;&lt;h2 id=&quot;BM1-反转链表&quot;&gt;&lt;a href=&quot;#BM1-反转链表&quot; class=&quot;headerlink&quot; title=&quot;B</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>leetcode每日一题/2022年1月</title>
    <link href="http://yoursite.com/2022/01/01/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/2022%E5%B9%B41%E6%9C%88/"/>
    <id>http://yoursite.com/2022/01/01/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/2022%E5%B9%B41%E6%9C%88/</id>
    <published>2022-01-01T14:17:57.449Z</published>
    <updated>2022-01-01T14:17:57.512Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2022年1月"><a href="#2022年1月" class="headerlink" title="2022年1月"></a>2022年1月</h1><h2 id="1-1-将一维数组转变成二维数组"><a href="#1-1-将一维数组转变成二维数组" class="headerlink" title="1/1 将一维数组转变成二维数组"></a>1/1 <a href="https://leetcode-cn.com/problems/convert-1d-array-into-2d-array/" target="_blank" rel="noopener">将一维数组转变成二维数组</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个下标从 0 开始的一维整数数组 original 和两个整数 m 和  n 。你需要使用 original 中 所有 元素创建一个 m 行 n 列的二维数组。</p><p>original 中下标从 0 到 n - 1 （都 包含 ）的元素构成二维数组的第一行，下标从 n 到 2 * n - 1 （都 包含 ）的元素构成二维数组的第二行，依此类推。</p><p>请你根据上述过程返回一个 m x n 的二维数组。如果无法构成这样的二维数组，请你返回一个空的二维数组。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：original &#x3D; [1,2,3,4], m &#x3D; 2, n &#x3D; 2</span><br><span class="line">输出：[[1,2],[3,4]]</span><br><span class="line">解释：</span><br><span class="line">构造出的二维数组应该包含 2 行 2 列。</span><br><span class="line">original 中第一个 n&#x3D;2 的部分为 [1,2] ，构成二维数组的第一行。</span><br><span class="line">original 中第二个 n&#x3D;2 的部分为 [3,4] ，构成二维数组的第二行。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：original &#x3D; [1,2,3], m &#x3D; 1, n &#x3D; 3</span><br><span class="line">输出：[[1,2,3]]</span><br><span class="line">解释：</span><br><span class="line">构造出的二维数组应该包含 1 行 3 列。</span><br><span class="line">将 original 中所有三个元素放入第一行中，构成要求的二维数组。</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：original &#x3D; [1,2], m &#x3D; 1, n &#x3D; 1</span><br><span class="line">输出：[]</span><br><span class="line">解释：</span><br><span class="line">original 中有 2 个元素。</span><br><span class="line">无法将 2 个元素放入到一个 1x1 的二维数组中，所以返回一个空的二维数组。</span><br></pre></td></tr></table></figure><p>示例 4：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：original &#x3D; [3], m &#x3D; 1, n &#x3D; 2</span><br><span class="line">输出：[]</span><br><span class="line">解释：</span><br><span class="line">original 中只有 1 个元素。</span><br><span class="line">无法将 1 个元素放满一个 1x2 的二维数组，所以返回一个空的二维数组。</span><br></pre></td></tr></table></figure><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><ul><li><p><code>1 &lt;= original.length &lt;= 5 * 104</code></p></li><li><p><code>1 &lt;= original[i] &lt;= 105</code></p></li><li><p><code>1 &lt;= m, n &lt;= 4 * 104</code></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>2022年，从快乐的简单题开始，这题很简单，就是将一个一位数组按照给定的行列数转换为二维数组，首先需要考虑的就是此一位数组能否被重构为一个二维数组，直接判断一维数组中的元素个数与要求构造的数组的元素个数是否相等即可，之后便是遍历一维数组，每个列数个元素就另起一行即可，总的时间复杂度是O(m * n)，详细题解如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] construct2DArray(<span class="keyword">int</span>[] original, <span class="keyword">int</span> m, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(original.length != m * n)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">int</span> curIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                res[i][j] = original[curIndex++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h4><p>开始写的时候忘记了如何构造一个空数组，看题解发现只需根据数组的维数，利用new int[0]即可，只要第一个维度的大小为0即可，之后的维度大小不用填。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2022年1月&quot;&gt;&lt;a href=&quot;#2022年1月&quot; class=&quot;headerlink&quot; title=&quot;2022年1月&quot;&gt;&lt;/a&gt;2022年1月&lt;/h1&gt;&lt;h2 id=&quot;1-1-将一维数组转变成二维数组&quot;&gt;&lt;a href=&quot;#1-1-将一维数组转变成二维数组&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ccfcsp/22次CCF-CSP认证考试</title>
    <link href="http://yoursite.com/2021/09/21/ccfcsp/22%E6%AC%A1CCF-CSP%E8%AE%A4%E8%AF%81%E8%80%83%E8%AF%95/"/>
    <id>http://yoursite.com/2021/09/21/ccfcsp/22%E6%AC%A1CCF-CSP%E8%AE%A4%E8%AF%81%E8%80%83%E8%AF%95/</id>
    <published>2021-09-21T03:08:44.618Z</published>
    <updated>2021-09-21T07:24:08.077Z</updated>
    
    <content type="html"><![CDATA[<h1 id="22次CCF-CSP认证考试"><a href="#22次CCF-CSP认证考试" class="headerlink" title="22次CCF-CSP认证考试"></a>22次CCF-CSP认证考试</h1><h2 id="灰度直方图"><a href="#灰度直方图" class="headerlink" title="灰度直方图"></a>灰度直方图</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>一幅长宽分别为 n 个像素和 m 个像素的灰度图像可以表示为一个 n×m 大小的矩阵 A。<br>其中每个元素 Aij（0≤i&lt;n、0≤j&lt;m）是一个 [0,L) 范围内的整数，表示对应位置像素的灰度值。<br>具体来说，一个 8 比特的灰度图像中每个像素的灰度范围是 [0,128)。</p><p>一副灰度图像的灰度统计直方图（以下简称“直方图”）可以表示为一个长度为 L 的数组 h，其中 h[x]（0≤x&lt;L）表示该图像中灰度值为 x 的像素个数。显然，h[0] 到 h[L−1] 的总和应等于图像中的像素总数 n⋅m。</p><p>已知一副图像的灰度矩阵 A，试计算其灰度直方图 h[0],h[1],⋯,h[L−1]。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入共 n+1 行。</p><p>输入的第一行包含三个用空格分隔的正整数 n、m 和 L，含义如前文所述。</p><p>第二到第 n+1 行输入矩阵 A。<br>第 i+2（0≤i&lt;n）行包含用空格分隔的 m 个整数，依次为 Ai0,Ai1,⋯,Ai(m−1)。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出仅一行，包含用空格分隔的 L 个整数 h[0],h[1],⋯,h[L−1]，表示输入图像的灰度直方图。</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 4 16</span><br><span class="line">0 1 2 3</span><br><span class="line">4 5 6 7</span><br><span class="line">8 9 10 11</span><br><span class="line">12 13 14 15</span><br></pre></td></tr></table></figure><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1</span><br></pre></td></tr></table></figure><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">7 11 8</span><br><span class="line">0 7 0 0 0 7 0 0 7 7 0</span><br><span class="line">7 0 7 0 7 0 7 0 7 0 7</span><br><span class="line">7 0 0 0 7 0 0 0 7 0 7</span><br><span class="line">7 0 0 0 0 7 0 0 7 7 0</span><br><span class="line">7 0 0 0 0 0 7 0 7 0 0</span><br><span class="line">7 0 7 0 7 0 7 0 7 0 0</span><br><span class="line">0 7 0 0 0 7 0 0 7 0 0</span><br></pre></td></tr></table></figure><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">48 0 0 0 0 0 0 29</span><br></pre></td></tr></table></figure><h3 id="评测用例规模与约定"><a href="#评测用例规模与约定" class="headerlink" title="评测用例规模与约定"></a>评测用例规模与约定</h3><p>全部的测试数据满足 0&lt;n,m≤500 且 4≤L≤256。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> decucin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/9/21 8:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = in.nextInt();</span><br><span class="line">        <span class="keyword">int</span> m = in.nextInt();</span><br><span class="line">        <span class="keyword">int</span> l = in.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] ps = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">260</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = in.nextInt();</span><br><span class="line">                ps[x]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; ++i)&#123;</span><br><span class="line">            System.out.print(ps[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>此题实际需要的是将各个像素对应的频率输出即可，题目中的测试数据L满足4&lt;=l&lt;=256，故考虑额外生成一个N=260的数组，以此数组中的每个位置对应的值作为其出现的次数，之后只需将每个数进行读取，若读到的数字为x，那将新生成矩阵中位置x的值自增1即可，最后进行输出。</p><h2 id="邻域均值"><a href="#邻域均值" class="headerlink" title="邻域均值"></a>邻域均值</h2><h3 id="试题背景"><a href="#试题背景" class="headerlink" title="试题背景"></a>试题背景</h3><p>顿顿在学习了数字图像处理后，想要对手上的一副灰度图像进行降噪处理。不过该图像仅在较暗区域有很多噪点，如果贸然对全图进行降噪，会在抹去噪点的同时也模糊了原有图像。因此顿顿打算先使用<strong>邻域均值</strong>来判断一个像素是否处于<strong>较暗区域</strong>，然后仅对处于<strong>较暗区域</strong>的像素进行降噪处理。</p><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>待处理的灰度图像长宽皆为 n 个像素，可以表示为一个 n×n 大小的矩阵 A，其中每个元素是一个 [0,L) 范围内的整数，表示对应位置像素的灰度值。<br>对于矩阵中任意一个元素 Aij（0≤i,j&lt;n），其<strong>邻域</strong>定义为附近若干元素的集和：</p><p>Neighbor(i,j,r)={Axy|0≤x,y&lt;n and |x−i|≤r and |y−j|≤r}</p><p>这里使用了一个额外的参数 r 来指明 Aij 附近元素的具体范围。根据定义，易知 Neighbor(i,j,r) 最多有 (2r+1)2 个元素。</p><p>如果元素 Aij <strong>邻域</strong>中所有元素的<strong>平均值</strong>小于或等于一个给定的阈值 t，我们就认为该元素对应位置的像素处于<strong>较暗区域</strong>。<br>下图给出了两个例子，左侧图像的较暗区域在右侧图像中展示为黑色，其余区域展示为白色。</p><p><img src="http://118.190.20.162/RequireFile.do?fid=9GqFey2d" alt="example.jpg"></p><p>现给定邻域参数 r 和阈值 t，试统计输入灰度图像中有多少像素处于<strong>较暗区域</strong>。</p><h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入共 n+1 行。</p><p>输入的第一行包含四个用空格分隔的正整数 n、L、r 和 t，含义如前文所述。</p><p>第二到第 n+1 行输入矩阵 A。</p><p>第 i+2（0≤i&lt;n）行包含用空格分隔的 n 个整数，依次为 Ai0,Ai1,⋯,Ai(n−1)。</p><h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数，表示输入灰度图像中处于较暗区域的像素总数。</p><h3 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 16 1 6</span><br><span class="line">0 1 2 3</span><br><span class="line">4 5 6 7</span><br><span class="line">8 9 10 11</span><br><span class="line">12 13 14 15</span><br></pre></td></tr></table></figure><h3 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><h3 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">11 8 2 2</span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0</span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0</span><br><span class="line">0 7 0 0 0 7 0 0 7 7 0</span><br><span class="line">7 0 7 0 7 0 7 0 7 0 7</span><br><span class="line">7 0 0 0 7 0 0 0 7 0 7</span><br><span class="line">7 0 0 0 0 7 0 0 7 7 0</span><br><span class="line">7 0 0 0 0 0 7 0 7 0 0</span><br><span class="line">7 0 7 0 7 0 7 0 7 0 0</span><br><span class="line">0 7 0 0 0 7 0 0 7 0 0</span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0</span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0</span><br></pre></td></tr></table></figure><h3 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">83</span><br></pre></td></tr></table></figure><h3 id="评测用例规模与约定-1"><a href="#评测用例规模与约定-1" class="headerlink" title="评测用例规模与约定"></a>评测用例规模与约定</h3><p>70% 的测试数据满足 n≤100、r≤10。</p><p>全部的测试数据满足 0&lt;n≤600、0&lt;r≤100 且 2≤t&lt;L≤256。</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> decucin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/9/21 8:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = in.nextInt();</span><br><span class="line">        <span class="keyword">int</span> l = in.nextInt();</span><br><span class="line">        <span class="keyword">int</span> r = in.nextInt();</span><br><span class="line">        <span class="keyword">int</span> t = in.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] s = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">610</span>][<span class="number">610</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = in.nextInt();</span><br><span class="line">                s[i][j] = x + s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)&#123;</span><br><span class="line">                <span class="keyword">int</span> x1 = Math.max(<span class="number">1</span>, i - r), y1 = Math.max(<span class="number">1</span>, j - r);</span><br><span class="line">                <span class="keyword">int</span> x2 = Math.min(n, i + r), y2 = Math.min(n, j + r);</span><br><span class="line">                <span class="keyword">if</span>((s[x2][y2] - s[x2][y1 - <span class="number">1</span>] - s[x1 - <span class="number">1</span>][y2] + s[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>]) &lt;= t * ((x2 - x1 + <span class="number">1</span>) * (y2 - y1 + <span class="number">1</span>)))&#123;</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>这里涉及到邻域均值，即数组内矩形的均值，考虑使用二维前缀和进行解决，以此便可遍历一次数组就得到所有位置的前缀和，之后便是遍历数组中的每一个元素，以其作为矩形中心，根据题意求均值，但需要注意的是数组越界问题，因此在坐标选择时可考虑利用最值防止其越界。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>此处由于涉及到前一元素的值，故下标需从1开始，索引为0的位置默认也是0。求前缀和是数组元素从1开始，那么在计算均值时数组也要从1开始数据方为有效数据。</p><h2 id="DHCP服务器"><a href="#DHCP服务器" class="headerlink" title="DHCP服务器"></a>DHCP服务器</h2><h3 id="试题背景-1"><a href="#试题背景-1" class="headerlink" title="试题背景"></a>试题背景</h3><p><strong>动态主机配置协议</strong>（Dynamic Host Configuration Protocol, DHCP）是一种自动为网络客户端分配 IP 地址的网络协议。当支持该协议的计算机刚刚接入网络时，它可以启动一个 DHCP 客户端程序。后者可以通过一定的网络报文交互，从 DHCP 服务器上获得 IP 地址等网络配置参数，从而能够在用户不干预的情况下，自动完成对计算机的网络设置，方便用户连接网络。DHCP 协议的工作过程如下：</p><ol><li>当 DHCP 协议启动的时候，DHCP 客户端向网络中广播发送 Discover 报文，请求 IP 地址配置；</li><li>当 DHCP 服务器收到 Discover 报文时，DHCP 服务器根据报文中的参数选择一个尚未分配的 IP 地址，分配给该客户端。DHCP 服务器用 Offer 报文将这个信息传达给客户端；</li><li>客户端收集收到的 Offer 报文。由于网络中可能存在多于一个 DHCP 服务器，因此客户端可能收集到多个 Offer 报文。客户端从这些报文中选择一个，并向网络中广播 Request 报文，表示选择这个 DHCP 服务器发送的配置；</li><li>DHCP 服务器收到 Request 报文后，首先判断该客户端是否选择本服务器分配的地址：如果不是，则在本服务器上解除对那个 IP 地址的占用；否则则再次确认分配的地址有效，并向客户端发送 Ack 报文，表示确认配置有效，Ack 报文中包括配置的有效时间。如果 DHCP 发现分配的地址无效，则返回 Nak 报文；</li><li>客户端收到 Ack 报文后，确认服务器分配的地址有效，即确认服务器分配的地址未被其它客户端占用，则完成网络配置，同时记录配置的有效时间，出于简化的目的，我们不考虑被占用的情况。若客户端收到 Nak 报文，则从步骤 1 重新开始；</li><li>客户端在到达配置的有效时间前，再次向 DHCP 服务器发送 Request 报文，表示希望延长 IP 地址的有效期。DHCP 服务器按照步骤 4 确定是否延长，客户端按照步骤 5 处理后续的配置；</li></ol><p>在本题目中，你需要理解 DHCP 协议的工作过程，并按照题目的要求实现一个简单的 DHCP 服务器。</p><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><h4 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h4><p>为了便于实现，我们简化地规定 DHCP 数据报文的格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;发送主机&gt; &lt;接收主机&gt; &lt;报文类型&gt; &lt;IP 地址&gt; &lt;过期时刻&gt;</span><br></pre></td></tr></table></figure><p>None</p><p>DHCP 数据报文的各个部分由空格分隔，其各个部分的定义如下：</p><ul><li>发送主机：是发送报文的主机名，<strong>主机名</strong>是由小写字母、数字组成的字符串，唯一地表示了一个主机；</li><li>接收主机：当有特定的接收主机时，是接收报文的主机名；当没有特定的接收主机时，为一个星号（<code>*</code>）；</li><li>报文类型：是三个大写字母，取值如下：<ul><li><code>DIS</code>：表示 Discover 报文；</li><li><code>OFR</code>：表示 Offer 报文；</li><li><code>REQ</code>：表示 Request 报文；</li><li><code>ACK</code>：表示 Ack 报文；</li><li><code>NAK</code>：表示 Nak 报文；</li></ul></li><li>IP 地址，是一个非负整数：<ul><li>对于 Discover 报文，该部分在发送的时候为 0，在接收的时候忽略；</li><li>对于其它报文，为正整数，表示一个 IP 地址；</li></ul></li><li>过期时刻，是一个非负整数：<ul><li>对于 Offer、Ack 报文，是一个正整数，表示服务器授予客户端的 IP 地址的过期时刻；</li><li>对于 Discover、Request 报文，若为正整数，表示客户端期望服务器授予的过期时刻；</li><li>对于其它报文，该部分在发送的时候为 0，在接收的时候忽略。</li></ul></li></ul><p>例如下列都是合法的 DHCP 数据报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a * DIS 0 0</span><br><span class="line">d a ACK 50 1000</span><br></pre></td></tr></table></figure><h4 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h4><p>为了 DHCP 服务器能够正确分配 IP 地址，DHCP 需要接受如下配置：</p><ul><li>地址池大小 N：表示能够分配给客户端的 IP 地址的数目，且能分配的 IP 地址是 1,2,…,N；</li><li>默认过期时间 Tdef：表示分配给客户端的 IP 地址的默认的过期时间长度；</li><li>过期时间的上限和下限 Tmax、Tmin：表示分配给客户端的 IP 地址的最长过期时间长度和最短过期时间长度，客户端不能请求比这个更长或更短的过期时间；</li><li>本机名称 H：表示运行 DHCP 服务器的主机名。</li></ul><h4 id="分配策略"><a href="#分配策略" class="headerlink" title="分配策略"></a>分配策略</h4><p>当客户端请求 IP 地址时，首先检查此前是否给该客户端分配过 IP 地址，且该 IP 地址在此后没有被分配给其它客户端。如果是这样的情况，则直接将 IP 地址分配给它，否则，<br>总是分配给它最小的尚未占用过的那个 IP 地址。如果这样的地址不存在，则分配给它最小的此时未被占用的那个 IP 地址。如果这样的地址也不存在，说明地址池已经分配完毕，因此拒绝分配地址。</p><h4 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h4><p>在 DHCP 启动时，首先初始化 IP 地址池，将所有地址设置状态为未分配，占用者为空，并清零过期时刻。<br>其中地址的状态有未分配、待分配、占用、过期四种。<br>处于未分配状态的 IP 地址没有占用者，而其余三种状态的 IP 地址均有一名占用者。<br>处于待分配和占用状态的 IP 地址拥有一个大于零的过期时刻。在到达该过期时刻时，若该地址的状态是待分配，则该地址的状态会自动变为未分配，且占用者清空，过期时刻清零；否则该地址的状态会由占用自动变为过期，且过期时刻清零。处于未分配和过期状态的 IP 地址过期时刻为零，即没有过期时刻。</p><p>对于收到的报文，设其收到的时刻为 t。处理细节如下：</p><ol><li>判断接收主机是否为本机，或者为 <code>*</code>，若不是，则判断类型是否为 Request，若不是，则不处理；</li><li>若类型不是 Discover、Request 之一，则不处理；</li><li>若接收主机为 <code>*</code>，但类型不是 Discover，或接收主机是本机，但类型是 Discover，则不处理。</li></ol><p>对于 Discover 报文，按照下述方法处理：</p><ol><li>检查是否有占用者为发送主机的 IP 地址：<ul><li>若有，则选取该 IP 地址；</li><li>若没有，则选取最小的状态为未分配的 IP 地址；</li><li>若没有，则选取最小的状态为过期的 IP 地址；</li><li>若没有，则不处理该报文，处理结束；</li></ul></li><li>将该 IP 地址状态设置为待分配，占用者设置为发送主机；</li><li>若报文中过期时刻为 0 ，则设置过期时刻为 t+Tdef；否则根据报文中的过期时刻和收到报文的时刻计算过期时间，判断是否超过上下限：若没有超过，则设置过期时刻为报文中的过期时刻；否则则根据超限情况设置为允许的最早或最晚的过期时刻；</li><li>向发送主机发送 Offer 报文，其中，IP 地址为选定的 IP 地址，过期时刻为所设定的过期时刻。</li></ol><p>对于 Request 报文，按照下述方法处理：</p><ol><li>检查接收主机是否为本机：<ul><li>若不是，则找到占用者为发送主机的所有 IP 地址，对于其中状态为待分配的，将其状态设置为未分配，并清空其占用者，清零其过期时刻，处理结束；</li></ul></li><li>检查报文中的 IP 地址是否在地址池内，且其占用者为发送主机，若不是，则向发送主机发送 Nak 报文，处理结束；</li><li>无论该 IP 地址的状态为何，将该 IP 地址的状态设置为占用；</li><li>与 Discover 报文相同的方法，设置 IP 地址的过期时刻；</li><li>向发送主机发送 Ack 报文。</li></ol><p>上述处理过程中，地址池中地址的状态的变化可以概括为如下图所示的状态转移图。为了简洁，该图中没有涵盖需要回复 Nak 报文的情况。</p><p><img src="http://118.190.20.162/RequireFile.do?fid=qUtXBjol" alt="state_h.jpg"></p><h3 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入的第一行包含用空格分隔的四个正整数和一个字符串，分别是：N、Tdef、Tmax、Tmin 和 H，保证 Tmin≤Tdef≤Tmax。</p><p>输入的第二行是一个正整数 n，表示收到了 n 个报文。</p><p>输入接下来有 n 行，第 (i+2) 行有空格分隔的正整数 ti 和约定格式的报文 Pi。表示收到的第 i 个报文是在 ti 时刻收到的，报文内容是 Pi。保证 ti&lt;ti+1。</p><h3 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出有若干行，每行是一个约定格式的报文。依次输出 DHCP 服务器发送的报文。</p><h3 id="样例输入-4"><a href="#样例输入-4" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">4 5 10 5 dhcp</span><br><span class="line">16</span><br><span class="line">1 a * DIS 0 0</span><br><span class="line">2 a dhcp REQ 1 0</span><br><span class="line">3 b a DIS 0 0</span><br><span class="line">4 b * DIS 3 0</span><br><span class="line">5 b * REQ 2 12</span><br><span class="line">6 b dhcp REQ 2 12</span><br><span class="line">7 c * DIS 0 11</span><br><span class="line">8 c dhcp REQ 3 11</span><br><span class="line">9 d * DIS 0 0</span><br><span class="line">10 d dhcp REQ 4 20</span><br><span class="line">11 a dhcp REQ 1 20</span><br><span class="line">12 c dhcp REQ 3 20</span><br><span class="line">13 e * DIS 0 0</span><br><span class="line">14 e dhcp REQ 2 0</span><br><span class="line">15 b dhcp REQ 2 25</span><br><span class="line">16 b * DIS 0 0</span><br></pre></td></tr></table></figure><h3 id="样例输出-4"><a href="#样例输出-4" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dhcp a OFR 1 6</span><br><span class="line">dhcp a ACK 1 7</span><br><span class="line">dhcp b OFR 2 9</span><br><span class="line">dhcp b ACK 2 12</span><br><span class="line">dhcp c OFR 3 12</span><br><span class="line">dhcp c ACK 3 13</span><br><span class="line">dhcp d OFR 4 14</span><br><span class="line">dhcp d ACK 4 20</span><br><span class="line">dhcp a ACK 1 20</span><br><span class="line">dhcp c ACK 3 20</span><br><span class="line">dhcp e OFR 2 18</span><br><span class="line">dhcp e ACK 2 19</span><br><span class="line">dhcp b NAK 2 0</span><br></pre></td></tr></table></figure><h3 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h3><p>输入第一行，分别设置了 DHCP 的相关参数，并收到了 16 个报文。</p><p>第 1 个报文和第 2 个报文是客户端 <code>a</code> 正常请求地址，服务器为其分配了地址 1，相应地设置了过期时刻是 7（即当前时刻 2 加上默认过期时间 5）。</p><p>第 3 个报文不符合 Discover 报文的要求，不做任何处理。</p><p>第 4 个报文 <code>b</code> 发送的 Discover 报文虽然有 IP 地址 3，但是按照处理规则，这个字段被忽略，因此服务器返回 Offer 报文，过期时刻是 9。</p><p>第 5 个报文中，Request 报文不符合接收主机是 DHCP 服务器本机的要求，因此不做任何处理。</p><p>第 6 个报文是 <code>b</code> 发送的 Request 报文，其中设置了过期时刻是 12，没有超过最长过期时间，因此返回的 Ack 报文中过期时刻也是 12。</p><p>第 7 个报文中，过期时刻 11 小于最短过期时间，因此返回的过期时刻是 12。虽然此时为 <code>a</code> 分配的地址 1 过期，但是由于还有状态为未分配的地址 3，因此为 <code>c</code> 分配地址 3。第 8 个报文同理，为 <code>c</code> 分配的地址过期时刻是 13。</p><p>第 9、10 两个报文中，为 <code>d</code> 分配了地址 4，过期时刻是 20。</p><p>第 11 个报文中，<code>a</code> 请求重新获取此前为其分配的地址 1，虽然为其分配的地址过期，但是由于尚未分配给其它客户端，因此 DHCP 服务器可以直接为其重新分配该地址，并重新设置过期时刻为 20。</p><p>第 12 个报文中，<code>c</code> 请求延长其地址的过期时刻为 20。DHCP 正常向其回复 Ack 报文。</p><p>第 13、14 个报文中，<code>e</code> 试图请求地址。此时地址池中已经没有处于“未分配”状态的地址了，但是有此前分配给 <code>b</code> 的地址 2 的状态是“过期”，因此把该地址重新分配给 <code>e</code>。</p><p>第 15 个报文中，<code>b</code> 试图重新获取此前为其分配的地址 2，但是此时该地址已经被分配给 <code>e</code>，因此返回 Nak 报文。</p><p>第 16 个报文中，<code>b</code> 试图重新请求分配一个 IP 地址，但是此时地址池中已经没有可用的地址了，因此忽略该请求。</p><h3 id="样例输入-5"><a href="#样例输入-5" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">4 70 100 50 dhcp</span><br><span class="line">6</span><br><span class="line">5 a * OFR 2 100</span><br><span class="line">10 b * DIS 0 70</span><br><span class="line">15 b dhcp2 REQ 4 60</span><br><span class="line">20 c * DIS 0 70</span><br><span class="line">70 d * DIS 0 120</span><br><span class="line">75 d dhcp REQ 1 125</span><br></pre></td></tr></table></figure><h3 id="样例输出-5"><a href="#样例输出-5" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dhcp b OFR 1 70</span><br><span class="line">dhcp c OFR 1 70</span><br><span class="line">dhcp d OFR 1 120</span><br><span class="line">dhcp d ACK 1 125</span><br></pre></td></tr></table></figure><h3 id="样例说明-1"><a href="#样例说明-1" class="headerlink" title="样例说明"></a>样例说明</h3><p>在本样例中，DHCP 服务器一共收到了 6 个报文，处理情况如下：</p><p>第 1 个报文不是 DHCP 服务器需要处理的报文，因此不回复任何报文。</p><p>第 2 个报文中，<code>b</code> 请求分配 IP 地址，因此 DHCP 服务器将地址 1 分配给 <code>b</code>，此时，地址 1 进入待分配状态，DHCP 服务器向 <code>b</code> 发送 Offer 报文。</p><p>第 3 个报文中，<code>b</code> 发送的 REQ 报文是发给非本服务器的，因此需要将地址池中所有拥有者是 <code>b</code> 的待分配状态的地址修改为未分配。</p><p>第 4 个报文中，<code>c</code> 请求分配 IP 地址。由于地址 1 此时是未分配状态，因此将该地址分配给它，向它发送 Offer 报文，地址 1 进入待分配状态。</p><p>第 5、6 个报文中，<code>d</code> 请求分配 IP 地址。注意到在收到第 5 个报文时，已经是时刻 70，地址 1 的过期时刻已到，它的状态已经被修改为了未分配，因此 DHCP 服务器仍然将地址 1 分配给 <code>d</code>。</p><h3 id="评测用例规模与约定-2"><a href="#评测用例规模与约定-2" class="headerlink" title="评测用例规模与约定"></a>评测用例规模与约定</h3><p>对于 20% 的数据，有 N≤200，且 n≤N，且输入仅含 Discover 报文，且 t&lt;Tmin；</p><p>对于 50% 的数据，有 N≤200，且 n≤N，且 t&lt;Tmin，且报文的接收主机或为本机，或为 <code>*</code>；</p><p>对于 70% 的数据，有 N≤1000，且 n≤N，且报文的接收主机或为本机，或为 <code>*</code>；</p><p>对于 100% 的数据，有 N≤10000，且 n≤10000，主机名的长度不超过 20，且 t,Tmin,Tdefault,Tmax≤109，输入的报文格式符合题目要求，且数字不超过 109。</p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;22次CCF-CSP认证考试&quot;&gt;&lt;a href=&quot;#22次CCF-CSP认证考试&quot; class=&quot;headerlink&quot; title=&quot;22次CCF-CSP认证考试&quot;&gt;&lt;/a&gt;22次CCF-CSP认证考试&lt;/h1&gt;&lt;h2 id=&quot;灰度直方图&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>第一次将小程序后端部署到服务器时遇到的问题</title>
    <link href="http://yoursite.com/2021/06/02/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%B0%86%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2021/06/02/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%B0%86%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%90%8E%E7%AB%AF%E9%83%A8%E7%BD%B2%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2021-06-02T01:29:20.540Z</published>
    <updated>2021-06-09T11:41:29.785Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一次将小程序后端部署到服务器时遇到的问题"><a href="#第一次将小程序后端部署到服务器时遇到的问题" class="headerlink" title="第一次将小程序后端部署到服务器时遇到的问题"></a>第一次将小程序后端部署到服务器时遇到的问题</h1><p>第一次将小程序后端部署到服务器遇到很多让人头大的问题（因为用到了tesseract），项目是部署在Linux服务器，而Linux下又没有对应的环境。网上的教程大多一致（而且尝试之后并没用），因此记录一下出现的问题以及解决的方案。</p><a id="more"></a><h2 id="首先是Linux下没有tesseract，报错xxx-io在jar包中找不到"><a href="#首先是Linux下没有tesseract，报错xxx-io在jar包中找不到" class="headerlink" title="首先是Linux下没有tesseract，报错xxx.io在jar包中找不到"></a>首先是Linux下没有tesseract，报错xxx.io在jar包中找不到</h2><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>首先就是在Linux服务器下安装tesseract，按照网上的教程安装即可（可参照这两篇博客：<a href="https://www.cnblogs.com/dajianshi/p/4932882.html" target="_blank" rel="noopener">https://www.cnblogs.com/dajianshi/p/4932882.html</a> ，<a href="https://blog.csdn.net/qq_40907977/article/details/103913057），但之后发现依旧报错，找了好久最终找到了解决方案。" target="_blank" rel="noopener">https://blog.csdn.net/qq_40907977/article/details/103913057），但之后发现依旧报错，找了好久最终找到了解决方案。</a></p><p>我选择的解决方法说是讲所需的（即错误提示中显示没有的.io文件拷贝到项目中的resource目录下的linux-x86-64（新建的）再次进行打包），此时问题得到解决。</p><h2 id="上面的问题解决后又报错"><a href="#上面的问题解决后又报错" class="headerlink" title="上面的问题解决后又报错"></a>上面的问题解决后又报错</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Error opening data file &#x2F;tesseract-3.04.00&#x2F;tessdata&#x2F;eng.traineddata</span><br><span class="line">Please make sure the TESSDATA_PREFIX environment variable is set to the parent directory of your &quot;tessdata&quot; directory.</span><br><span class="line">Failed loading language &#39;eng&#39;</span><br><span class="line">Tesseract couldn&#39;t load any languages!</span><br></pre></td></tr></table></figure><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>按照错误的提示内容，这很显然是没有英文识别库，因此到对应目录下下载好英文识别库即可，英文、中文简体、中文繁体的下载文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate https:&#x2F;&#x2F;github.com&#x2F;tesseract-ocr&#x2F;tessdata&#x2F;raw&#x2F;master&#x2F;eng.traineddata</span><br><span class="line">wget --no-check-certificate https:&#x2F;&#x2F;github.com&#x2F;tesseract-ocr&#x2F;tessdata&#x2F;raw&#x2F;master&#x2F;chi_sim.traineddata </span><br><span class="line">wget --no-check-certificate https:&#x2F;&#x2F;github.com&#x2F;tesseract-ocr&#x2F;tessdata&#x2F;raw&#x2F;master&#x2F;chi_tra.traineddata</span><br></pre></td></tr></table></figure><p>至此，问题得到解决！</p><h2 id="部署后发现关闭shell应用立即停止"><a href="#部署后发现关闭shell应用立即停止" class="headerlink" title="部署后发现关闭shell应用立即停止"></a>部署后发现关闭shell应用立即停止</h2><h3 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h3><p>使用screen</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -S yourname</span><br></pre></td></tr></table></figure><h2 id="再次报错"><a href="#再次报错" class="headerlink" title="再次报错"></a>再次报错</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Suppressed: java.lang.UnsatisfiedLinkError: libxxx.so: 无法打开共享对象文件: 没有那个文件或目录</span><br></pre></td></tr></table></figure><h3 id="解决办法-2"><a href="#解决办法-2" class="headerlink" title="解决办法"></a>解决办法</h3><p>1）、直接将路径/usr/local/lib路径加入到文件/etc/ld.so.conf文件的中。在文件/etc/ld.so.conf中末尾直接添加：/usr/local/lib；</p><p>2）、再次运行ldconfig，使所有的库文件都被缓存到文件/etc/ld.so.cache中。</p><h2 id="关闭screen"><a href="#关闭screen" class="headerlink" title="关闭screen"></a>关闭screen</h2><h3 id="解决办法-3"><a href="#解决办法-3" class="headerlink" title="解决办法"></a>解决办法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -S session_name -X quit</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;第一次将小程序后端部署到服务器时遇到的问题&quot;&gt;&lt;a href=&quot;#第一次将小程序后端部署到服务器时遇到的问题&quot; class=&quot;headerlink&quot; title=&quot;第一次将小程序后端部署到服务器时遇到的问题&quot;&gt;&lt;/a&gt;第一次将小程序后端部署到服务器时遇到的问题&lt;/h1&gt;&lt;p&gt;第一次将小程序后端部署到服务器遇到很多让人头大的问题（因为用到了tesseract），项目是部署在Linux服务器，而Linux下又没有对应的环境。网上的教程大多一致（而且尝试之后并没用），因此记录一下出现的问题以及解决的方案。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>leetcode每日一题/leetcode每日一题</title>
    <link href="http://yoursite.com/2021/04/14/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    <id>http://yoursite.com/2021/04/14/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</id>
    <published>2021-04-14T09:47:55.217Z</published>
    <updated>2021-04-25T15:19:11.258Z</updated>
    
    <content type="html"><![CDATA[<p>此处记录我leetcode的每日一题题解，由于是初学，因此很多地方可能会解释不清，所给题解也不一定是最优解（大部分是引用了官方题解）！</p><a id="more"></a><h2 id="2021-4-13"><a href="#2021-4-13" class="headerlink" title="2021/4/13"></a>2021/4/13</h2><h3 id="题目：二叉搜索树节点最小距离"><a href="#题目：二叉搜索树节点最小距离" class="headerlink" title="题目：二叉搜索树节点最小距离"></a>题目：<a href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/" target="_blank" rel="noopener">二叉搜索树节点最小距离</a></h3><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给你一个二叉搜索树的根节点 <code>root</code> ，返回 <strong>树中任意两不同节点值之间的最小差值</strong> 。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>首先应该明白的一点，什么是二叉搜索树，其具有什么特性，这些特性中哪些是能帮助解题的。</p><p>接下来只要回答上面的问题即可。</p><p>首先什么是二叉搜索树：</p><p><a href="https://baike.baidu.com/item/二叉查找树/7077965" target="_blank" rel="noopener">二叉查找树</a>（Binary Search Tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的<a href="https://baike.baidu.com/item/二叉树/1602879" target="_blank" rel="noopener">二叉树</a>： 若它的左子树不空，则左子树上所有结点的值均小于它的<a href="https://baike.baidu.com/item/根结点/9795570" target="_blank" rel="noopener">根结点</a>的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为<a href="https://baike.baidu.com/item/二叉排序树/10905079" target="_blank" rel="noopener">二叉排序树</a>。二叉搜索树作为一种经典的数据结构，它既有链表的快速插入与删除操作的特点，又有数组快速查找的优势；所以应用十分广泛，例如在文件系统和数据库系统一般会采用这种数据结构进行高效率的排序与检索操作。</p><p>之后是其具有的性质：</p><p>1.若任意结点的左子树不空，则左子树上所有结点的值均不大于它的根结点的值。</p><p>2.若任意结点的右子树不空，则右子树上所有结点的值均不小于它的根结点的值。</p><p>3.任意结点的左、右子树也分别为二叉搜索树。</p><p>其中能帮助我们解题的部分：</p><p>由二叉搜索树的性质可知，将二叉搜索树中序遍历能得到一个有序数组，由此相邻两个元素之间差值的最小值即为题目所求。</p><p>经此分析已得到解题方法，现在考虑对其进行优化，若是将遍历结果放到数组中无疑会增加空间，除此之外遍历时也比较繁琐，但如果增加pre指针指向前一个元素，那便可在遍历的同时直接更新相邻元素的最小值，即题目所求。但此方法切记pre的值最初应该设为一个负值，之后更新为节点的数据。</p><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pre;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDiffInBST</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        pre = -<span class="number">1</span>;</span><br><span class="line">        ans = Integer.MAX_VALUE;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        <span class="keyword">if</span>(pre == -<span class="number">1</span>)&#123;</span><br><span class="line">            pre = root.val;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans = Math.min(ans, root.val - pre);</span><br><span class="line">            pre = root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2021-4-14"><a href="#2021-4-14" class="headerlink" title="2021/4/14"></a>2021/4/14</h2><h3 id="题目：实现-Trie-前缀树"><a href="#题目：实现-Trie-前缀树" class="headerlink" title="题目：实现 Trie (前缀树)"></a>题目：<a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/" target="_blank" rel="noopener">实现 Trie (前缀树)</a></h3><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>Trie（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p><p>请你实现 Trie 类：</p><p>Trie() 初始化前缀树对象。<br>void insert(String word) 向前缀树中插入字符串 word 。<br>boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。<br>boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>什么是前缀树？</p><p><a href="https://baike.baidu.com/item/%E5%AD%97%E5%85%B8%E6%A0%91/9825209?fromtitle=%E5%89%8D%E7%BC%80%E6%A0%91&fromid=2501595&fr=aladdin" target="_blank" rel="noopener">字典树</a>，又称单词查找树，<a href="https://baike.baidu.com/item/Trie树" target="_blank" rel="noopener">Trie树</a>，是一种<a href="https://baike.baidu.com/item/树形结构/9663807" target="_blank" rel="noopener">树形结构</a>，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的<a href="https://baike.baidu.com/item/字符" target="_blank" rel="noopener">字符</a>串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。</p><p>前缀树的性质：</p><p>根节点不包含字符，除根节点外每一个节点都只包含一个字符； 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串； 每个节点的所有子节点包含的字符都不相同。</p><p>综上，前缀树的每个节点用于表示单词的一个字母，从根节点开始，每个节点至多有26个节点（26个小写字母），所以得到前缀树应该具有的元素，一个标志其是否为词尾元素的标记符，用于保存子节点的节点数组。</p><p>至于初始化操作，只需要分别初始化标志符（置为false）和节点数组（置为null）。</p><p>插入操作只需将需要插入的字符一个一个放入前缀树中，每放入一个字符，二叉树的节点就向下移动到插入的位置即可，在插入完成后记得将此节点的标志符置为true，表示某个词的结束。</p><p>检索单词是否在前缀树中：按照单词中每个字母出现的顺序探索前缀树，若能一直向下探索并且最后的节点是某个词的结束（标识符为true），那么单词便在前缀树中，反之则不在。</p><p>检索前缀是否为插入的字符串的前缀：与检索单词类似，也是一直向下探索，但最后无需分辨是否是某个词的结束，即能够向下遍历便说明前缀存在，反之不存在。</p><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isEnd;</span><br><span class="line">    <span class="keyword">private</span> Trie[] next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isEnd = <span class="keyword">false</span>;</span><br><span class="line">        next = <span class="keyword">new</span> Trie[<span class="number">26</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        Trie node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.next[word.charAt(i) - <span class="string">'a'</span>] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                node.next[word.charAt(i) - <span class="string">'a'</span>] = <span class="keyword">new</span> Trie();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.next[word.charAt(i)- <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        node.isEnd = <span class="keyword">true</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        Trie node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.next[word.charAt(i) - <span class="string">'a'</span>] != <span class="keyword">null</span>)&#123;</span><br><span class="line">                node = node.next[word.charAt(i) - <span class="string">'a'</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.isEnd == <span class="keyword">true</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        Trie node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.next[prefix.charAt(i) - <span class="string">'a'</span>] != <span class="keyword">null</span>)&#123;</span><br><span class="line">                node = node.next[prefix.charAt(i) - <span class="string">'a'</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2021-4-15"><a href="#2021-4-15" class="headerlink" title="2021/4/15"></a>2021/4/15</h2><h3 id="题目：打家劫舍-II"><a href="#题目：打家劫舍-II" class="headerlink" title="题目：打家劫舍 II"></a>题目：<a href="https://leetcode-cn.com/problems/house-robber-ii/" target="_blank" rel="noopener">打家劫舍 II</a></h3><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，能够偷窃到的最高金额。</p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>首先不考虑房子是否围成一圈，那么这题的情形可分为以下几类：</p><p>1、一间房子都没有，那么很显然小偷啥也偷不到；</p><p>2、只有一间房子，那么小偷只能偷这件房子；</p><p>3、只有两间房子，小偷偷这两件房子中存钱较多的那间；</p><p>4、当房子数上升到三间及以上，不妨设其为k，那就有意思了，你有了两个选择，即是否偷盗最后一间k，如果偷的话，那所求的就是前k-2个房间的可盗窃的最大金额再加上最后一间房的金额，如果不偷的话，那所求的就是前k-1个房间的可盗窃的最大金额</p><p>很显然，这是一个动态规划的问题，若dp[i]表示前i间房的可盗窃的最大金额，那么转移方程为：dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])，由此这个问题就得到解决。</p><p>下面考虑房子围成一圈的情况：前几类并没有什么不同，只是当房间数大于或等于三时，也需要考虑是否偷窃最后一间房，若是偷窃的话，那第一间房就不能偷窃，即偷窃范围是[1, k-1]，若是不偷窃最后一间，那偷窃范围为[0, k-2]，再将此两种情形分别按照房子不围成一圈的情况去讨论，得到两者的最大值，就是题目所求。</p><p>完整题解如下（这里只是参照官方题解，将动态规划单独作为函数，使代码更规范）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums.length==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> Math.max(robPd(nums, <span class="number">0</span>, nums.length - <span class="number">2</span>), robPd(nums, <span class="number">1</span>, nums.length - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">robPd</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> first = nums[start], second = Math.max(nums[start], nums[start + <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start + <span class="number">2</span>; i &lt;= end; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = second;</span><br><span class="line">            second = Math.max(temp, first + nums[ i]);</span><br><span class="line">            first = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2021-4-16"><a href="#2021-4-16" class="headerlink" title="2021/4/16"></a>2021/4/16</h2><h3 id="题目：扰乱字符串"><a href="#题目：扰乱字符串" class="headerlink" title="题目：扰乱字符串"></a>题目：<a href="https://leetcode-cn.com/problems/scramble-string/" target="_blank" rel="noopener">扰乱字符串</a></h3><h3 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h3><p>使用下面描述的算法可以扰乱字符串 s 得到字符串 t ：<br>如果字符串的长度为 1 ，算法停止<br>如果字符串的长度 &gt; 1 ，执行下述步骤：<br>在一个随机下标处将字符串分割成两个非空的子字符串。即，如果已知字符串 s ，则可以将其分成两个子字符串 x 和 y ，且满足 s = x + y 。<br>随机 决定是要「交换两个子字符串」还是要「保持这两个子字符串的顺序不变」。即，在执行这一步骤之后，s 可能是 s = x + y 或者 s = y + x 。<br>在 x 和 y 这两个子字符串上继续从步骤 1 开始递归执行此算法。<br>给你两个 长度相等 的字符串 s1 和 s2，判断 s2 是否是 s1 的扰乱字符串。如果是，返回 true ；否则，返回 false 。</p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>这题完全是一脸懵逼，看到题目的时候完全没有思路，官方给出的题解也是没怎么看懂，这里先照搬<a href="https://leetcode-cn.com/problems/scramble-string/solution/rao-luan-zi-fu-chuan-by-leetcode-solutio-8r9t/" target="_blank" rel="noopener">官方题解</a>，以后若是有思路再回来重写题解。</p><p>完整代码如下（也是来自官方）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记忆化搜索存储状态的数组</span></span><br><span class="line">    <span class="comment">// -1 表示 false，1 表示 true，0 表示未计算</span></span><br><span class="line">    <span class="keyword">int</span>[][][] memo;</span><br><span class="line">    String s1, s2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isScramble</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = s1.length();</span><br><span class="line">        <span class="keyword">this</span>.memo = <span class="keyword">new</span> <span class="keyword">int</span>[length][length][length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">this</span>.s1 = s1;</span><br><span class="line">        <span class="keyword">this</span>.s2 = s2;</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个字符串从 i1 开始，第二个字符串从 i2 开始，子串的长度为 length，是否和谐</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i1, <span class="keyword">int</span> i2, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (memo[i1][i2][length] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[i1][i2][length] == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断两个子串是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (s1.substring(i1, i1 + length).equals(s2.substring(i2, i2 + length))) &#123;</span><br><span class="line">            memo[i1][i2][length] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否存在字符 c 在两个子串中出现的次数不同</span></span><br><span class="line">        <span class="keyword">if</span> (!checkIfSimilar(i1, i2, length)) &#123;</span><br><span class="line">            memo[i1][i2][length] = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 枚举分割位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; ++i) &#123;</span><br><span class="line">            <span class="comment">// 不交换的情况</span></span><br><span class="line">            <span class="keyword">if</span> (dfs(i1, i2, i) &amp;&amp; dfs(i1 + i, i2 + i, length - i)) &#123;</span><br><span class="line">                memo[i1][i2][length] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 交换的情况</span></span><br><span class="line">            <span class="keyword">if</span> (dfs(i1, i2 + length - i, i) &amp;&amp; dfs(i1 + i, i2, length - i)) &#123;</span><br><span class="line">                memo[i1][i2][length] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        memo[i1][i2][length] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkIfSimilar</span><span class="params">(<span class="keyword">int</span> i1, <span class="keyword">int</span> i2, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; freq = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = i1; i &lt; i1 + length; ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s1.charAt(i);</span><br><span class="line">            freq.put(c, freq.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = i2; i &lt; i2 + length; ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s2.charAt(i);</span><br><span class="line">            freq.put(c, freq.getOrDefault(c, <span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : freq.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">int</span> value = entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (value != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2021-4-17"><a href="#2021-4-17" class="headerlink" title="2021/4/17"></a>2021/4/17</h2><h3 id="题目：存在重复元素-III"><a href="#题目：存在重复元素-III" class="headerlink" title="题目：存在重复元素 III"></a>题目：<a href="https://leetcode-cn.com/problems/contains-duplicate-iii/" target="_blank" rel="noopener">存在重复元素 III</a></h3><h3 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h3><p>给你一个整数数组 nums 和两个整数 k 和 t 。请你判断是否存在 两个不同下标 i 和 j，使得 abs(nums[i] - nums[j]) &lt;= t ，同时又满足 abs(i - j) &lt;= k 。</p><p>如果存在则返回 true，不存在返回 false。</p><h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><p>两种思路，一种是滑动窗口，一种是桶排序。</p><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>首先判断是否满足abs(i - j) &lt;= k，若某元素元素下标为i，则满足此条件的下标范围为[i - k, i + k]，其次判断是否满足abs(nums[i] - nums[j]) &lt;= t，满足此条件的元素取值为[nums[i] - t, nums[i] + t]（集合表示，即包含等于），接下来只需进行判断即可。</p><p>完整代码如下（TreeSet中的ceiling()函数返回TreeSet中符合条件的最小值）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line"></span><br><span class="line">        TreeSet&lt;Long&gt; set = <span class="keyword">new</span> TreeSet&lt;Long&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            Long ceiling = set.ceiling((<span class="keyword">long</span>)nums[i] - (<span class="keyword">long</span>)t);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(ceiling != <span class="keyword">null</span> &amp;&amp; ceiling &lt;= (<span class="keyword">long</span>)nums[i] + (<span class="keyword">long</span>)t)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            set.add((<span class="keyword">long</span>)nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k)</span><br><span class="line">                set.remove((<span class="keyword">long</span>)nums[i - k]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><p>按元素的大小进行分桶，假设桶的大小为t + 1，如果两个元素属于一个桶，那这两个元素必然符合条件，若两个元素处于相邻桶，则进一步进行判断，若是不属于相邻桶也不属于一个桶，那必然不符合条件。</p><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        Map&lt;Long, Long&gt; map = <span class="keyword">new</span> HashMap&lt;Long, Long&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> w = (<span class="keyword">long</span>) t + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">long</span> id = getId(nums[i], w);</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(id))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(id - <span class="number">1</span>) &amp;&amp; Math.abs(nums[i] - map.get(id - <span class="number">1</span>)) &lt; w)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(id + <span class="number">1</span>) &amp;&amp; Math.abs(nums[i] - map.get(id + <span class="number">1</span>)) &lt; w)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            map.put(id, (<span class="keyword">long</span>) nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k)</span><br><span class="line">                map.remove(getId(nums[i - k], w));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">long</span> w)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> x/w;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> (x + <span class="number">1</span>)/w - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2021-4-18"><a href="#2021-4-18" class="headerlink" title="2021/4/18"></a>2021/4/18</h2><h3 id="题目：删除有序数组中的重复项"><a href="#题目：删除有序数组中的重复项" class="headerlink" title="题目：删除有序数组中的重复项"></a>题目：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">删除有序数组中的重复项</a></h3><h3 id="描述-5"><a href="#描述-5" class="headerlink" title="描述"></a>描述</h3><p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><p>说明:</p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="line">int len &#x3D; removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">&#x2F;&#x2F; 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span><br><span class="line">for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h3><p>这题使用双指针进行解决，快指针表示遍历数组到达的下标位置，慢指针表示下一个不同元素要填入的下标位置，如果数组长度为0，直接返回0，第一个元素是必须保留的，因此两个指针都从下标1开始。如若快指针和其前一位不相等，那慢指针所在的位置填充快指针所指的内容。</p><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> fast = <span class="number">1</span>, slow = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fast] != nums[fast - <span class="number">1</span>]) &#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                ++slow;</span><br><span class="line">            &#125;</span><br><span class="line">            ++fast;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2021-4-19"><a href="#2021-4-19" class="headerlink" title="2021/4/19"></a>2021/4/19</h2><h3 id="题目：移除元素"><a href="#题目：移除元素" class="headerlink" title="题目：移除元素"></a>题目：<a href="https://leetcode-cn.com/problems/remove-element/" target="_blank" rel="noopener">移除元素</a></h3><h3 id="描述-6"><a href="#描述-6" class="headerlink" title="描述"></a>描述</h3><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><h3 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h3><p>这题和前一天的题是一样的，都可以通过双指针进行解决，左指针表示下一个将要赋值的位置，右指针表示遍历数组到达的下标位置，若是右指针所指的值不为val，那左指针赋值所在的位置赋值右指针的值。</p><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != val)&#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                ++slow;</span><br><span class="line">            &#125;</span><br><span class="line">            ++fast;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>考虑右指针从数组末尾开始向前遍历，若是左指针值为val，那赋值右指针，右指针减一，这样当左右指针相遇时就完成了遍历。</p><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left] == val)</span><br><span class="line">                nums[left] = nums[--right];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ++left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2021-4-20"><a href="#2021-4-20" class="headerlink" title="2021/4/20"></a>2021/4/20</h2><h3 id="题目：实现-strStr"><a href="#题目：实现-strStr" class="headerlink" title="题目：实现 strStr()"></a>题目：<a href="https://leetcode-cn.com/problems/implement-strstr/" target="_blank" rel="noopener">实现 strStr()</a></h3><h3 id="描述-7"><a href="#描述-7" class="headerlink" title="描述"></a>描述</h3><p>实现 strStr() 函数。</p><p>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。</p><p>说明：</p><p>当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p><p>对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。</p><h3 id="题解-7"><a href="#题解-7" class="headerlink" title="题解"></a>题解</h3><p>经典字符串匹配问题，常见的方法有暴力匹配以及KMP算法两种。</p><h4 id="暴力匹配"><a href="#暴力匹配" class="headerlink" title="暴力匹配"></a>暴力匹配</h4><p>这个就比较简单了，逐个查询，找到和所需查找字符串相等的第一个字符所在位置，进行第二层查找，向后进行查找，若是每个都匹配，则将第一个字符所在位置置为true，遍历时只需判断其为true时返回</p><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = haystack.length(), m = needle.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + m &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (haystack.charAt(i + j) != needle.charAt(j)) &#123;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h4><p>这个算法没怎么弄懂，对于字串的处理没理解，这里建议参照<a href="https://leetcode-cn.com/problems/implement-strstr/solution/shi-xian-strstr-by-leetcode-solution-ds6y/" target="_blank" rel="noopener">官方题解</a></p><p>完整代码如下（来自官方）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = haystack.length(), m = needle.length();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] pi = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; needle.charAt(i) != needle.charAt(j)) &#123;</span><br><span class="line">                j = pi[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (needle.charAt(i) == needle.charAt(j)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            pi[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; haystack.charAt(i) != needle.charAt(j)) &#123;</span><br><span class="line">                j = pi[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (haystack.charAt(i) == needle.charAt(j)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2021-4-21"><a href="#2021-4-21" class="headerlink" title="2021/4/21"></a>2021/4/21</h2><h3 id="题目：解码方法"><a href="#题目：解码方法" class="headerlink" title="题目：解码方法"></a>题目：<a href="https://leetcode-cn.com/problems/decode-ways/" target="_blank" rel="noopener">解码方法</a></h3><h3 id="描述-8"><a href="#描述-8" class="headerlink" title="描述"></a>描述</h3><p>一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#39;A&#39; -&gt; 1</span><br><span class="line">&#39;B&#39; -&gt; 2</span><br><span class="line">...</span><br><span class="line">&#39;Z&#39; -&gt; 26</span><br></pre></td></tr></table></figure><p>要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，”11106” 可以映射为：</p><p>“AAJF” ，将消息分组为 (1 1 10 6)<br>“KJF” ，将消息分组为 (11 10 6)<br>注意，消息不能分组为  (1 11 06) ，因为 “06” 不能映射为 “F” ，这是由于 “6” 和 “06” 在映射中并不等价。</p><p>给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。</p><p>题目数据保证答案肯定是一个 32 位 的整数。</p><h3 id="题解-8"><a href="#题解-8" class="headerlink" title="题解"></a>题解</h3><p>这题采用动态规划的思想进行求解，设字符串s前i个字符的解码方法为fi，进行状态转移时需考虑最后一个字符所采用的解码方式，若是仅用了一个字符进行解码，那只要s[i]不为0，即可被解码为A~I中的任何一个，此时前i个字符的解码方式与前i-1个字符的解码方式相同；若是用了两个字符进行解析，那最后一个字符需满足几个要求：首先s[i]不为0，其次s[i - 2]也不能为0，否则无法选择s[i - 2] s[i - 1]两个字符进行解析，最后应满足s[i - 2]与s[i - 1]两个字符拼接而成的字符不大于26，即s[i - 2] * 10 + s[i - 1] &lt;= 26。</p><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> []f = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i - <span class="number">1</span>) != <span class="string">'0'</span>)&#123;</span><br><span class="line">                f[i] += f[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">1</span> &amp;&amp; s.charAt(i - <span class="number">2</span>) != <span class="string">'0'</span> &amp;&amp; (s.charAt(i - <span class="number">2</span>) - <span class="string">'0'</span>) * <span class="number">10</span> + s.charAt(i - <span class="number">1</span>) - <span class="string">'0'</span> &lt;= <span class="number">26</span>)&#123;</span><br><span class="line">                f[i] += f[i - <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h4><p>注意到在状态转移方程中，前i个字符的解码方式仅与前i -2个字符的解码方式以及前i - 1个字符的解码方式有关，因此我们可以使用三个变量进行状态转移，省去数组的空间。</p><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="comment">// a = f[i-2], b = f[i-1], c=f[i]</span></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>, c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            c = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) != <span class="string">'0'</span>) &#123;</span><br><span class="line">                c += b;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">1</span> &amp;&amp; s.charAt(i - <span class="number">2</span>) != <span class="string">'0'</span> &amp;&amp; ((s.charAt(i - <span class="number">2</span>) - <span class="string">'0'</span>) * <span class="number">10</span> + (s.charAt(i - <span class="number">1</span>) - <span class="string">'0'</span>) &lt;= <span class="number">26</span>)) &#123;</span><br><span class="line">                c += a;</span><br><span class="line">            &#125;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2021-4-22"><a href="#2021-4-22" class="headerlink" title="2021/4/22"></a>2021/4/22</h2><h3 id="题目：矩形区域不超过-K-的最大数值和"><a href="#题目：矩形区域不超过-K-的最大数值和" class="headerlink" title="题目：矩形区域不超过 K 的最大数值和"></a>题目：<a href="https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/" target="_blank" rel="noopener">矩形区域不超过 K 的最大数值和</a></h3><h3 id="描述-9"><a href="#描述-9" class="headerlink" title="描述"></a>描述</h3><p>给你一个 m x n 的矩阵 matrix 和一个整数 k ，找出并返回矩阵内部矩形区域的不超过 k 的最大数值和。</p><p>题目数据保证总会存在一个数值和不超过 k 的矩形区域。</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2021/03/18/sum-grid.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,0,1],[0,-2,3]], k &#x3D; 2</span><br><span class="line">输出：2</span><br><span class="line">解释：蓝色边框圈出来的矩形区域 [[0, 1], [-2, 3]] 的数值和是 2，且 2 是不超过 k 的最大数字（k &#x3D; 2）。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix &#x3D; [[2,2,-1]], k &#x3D; 3</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><h3 id="题解-9"><a href="#题解-9" class="headerlink" title="题解"></a>题解</h3><p>来不及解释了，上<a href="https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/solution/" target="_blank" rel="noopener">官方题解</a></p><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSumSubmatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123; <span class="comment">// 枚举上边界</span></span><br><span class="line">            <span class="keyword">int</span>[] sum = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; m; ++j) &#123; <span class="comment">// 枚举下边界</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; n; ++c) &#123;</span><br><span class="line">                    sum[c] += matrix[j][c]; <span class="comment">// 更新每列的元素和</span></span><br><span class="line">                &#125;</span><br><span class="line">                TreeSet&lt;Integer&gt; sumSet = <span class="keyword">new</span> TreeSet&lt;Integer&gt;();</span><br><span class="line">                sumSet.add(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> v : sum) &#123;</span><br><span class="line">                    s += v;</span><br><span class="line">                    Integer ceil = sumSet.ceiling(s - k);</span><br><span class="line">                    <span class="keyword">if</span> (ceil != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        ans = Math.max(ans, s - ceil);</span><br><span class="line">                    &#125;</span><br><span class="line">                    sumSet.add(s);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2021-4-23"><a href="#2021-4-23" class="headerlink" title="2021/4/23"></a>2021/4/23</h2><h3 id="题目：最大整除子集"><a href="#题目：最大整除子集" class="headerlink" title="题目：最大整除子集"></a>题目：<a href="https://leetcode-cn.com/problems/largest-divisible-subset/" target="_blank" rel="noopener">最大整除子集</a></h3><h3 id="描述-10"><a href="#描述-10" class="headerlink" title="描述"></a>描述</h3><p>给你一个由 无重复 正整数组成的集合 nums ，请你找出并返回其中最大的整除子集 answer ，子集中每一元素对 (answer[i], answer[j]) 都应当满足：<br>answer[i] % answer[j] == 0 ，或<br>answer[j] % answer[i] == 0<br>如果存在多个有效解子集，返回其中任何一个均可。</p><h3 id="题解-10"><a href="#题解-10" class="headerlink" title="题解"></a>题解</h3><p><a href="https://leetcode-cn.com/problems/largest-divisible-subset/solution/zui-da-zheng-chu-zi-ji-by-leetcode-solut-t4pz/" target="_blank" rel="noopener">官方题解</a></p><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">largestDivisibleSubset</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 1 步：动态规划找出最大子集的个数、最大子集中的最大整数</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> maxSize = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxVal = dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="comment">// 题目中说「没有重复元素」很重要</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] % nums[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dp[i] &gt; maxSize) &#123;</span><br><span class="line">                maxSize = dp[i];</span><br><span class="line">                maxVal = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 2 步：倒推获得最大子集</span></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span> (maxSize == <span class="number">1</span>) &#123;</span><br><span class="line">            res.add(nums[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; maxSize &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == maxSize &amp;&amp; maxVal % nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                res.add(nums[i]);</span><br><span class="line">                maxVal = nums[i];</span><br><span class="line">                maxSize--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2021-4-24"><a href="#2021-4-24" class="headerlink" title="2021/4/24"></a>2021/4/24</h2><h3 id="题目：组合总和-Ⅳ"><a href="#题目：组合总和-Ⅳ" class="headerlink" title="题目：组合总和 Ⅳ"></a>题目：<a href="https://leetcode-cn.com/problems/combination-sum-iv/" target="_blank" rel="noopener">组合总和 Ⅳ</a></h3><h3 id="描述-11"><a href="#描述-11" class="headerlink" title="描述"></a>描述</h3><p>给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。</p><p>题目数据保证答案符合 32 位整数范围。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3], target &#x3D; 4</span><br><span class="line">输出：7</span><br><span class="line">解释：</span><br><span class="line">所有可能的组合为：</span><br><span class="line">(1, 1, 1, 1)</span><br><span class="line">(1, 1, 2)</span><br><span class="line">(1, 2, 1)</span><br><span class="line">(1, 3)</span><br><span class="line">(2, 1, 1)</span><br><span class="line">(2, 2)</span><br><span class="line">(3, 1)</span><br><span class="line">请注意，顺序不同的序列被视作不同的组合。</span><br></pre></td></tr></table></figure><h3 id="题解-11"><a href="#题解-11" class="headerlink" title="题解"></a>题解</h3><p>首先考虑一个问题，如果用dp[i]表示和为i的组合数，那基准条件应该为dp[0] = 1，因为只有不选取任何元素时和才为0（题目说了nums中的数据全为正数），当1 &lt;= i &lt;= target时，组合中最后一个数num必然小于或等于i，此时dp[i]与dp[i - num]应该是相等的，因为对于任何和为 i - num的组合只要在最后加上num和便为i，由此可得到动态规划的做法：</p><p>首先初始化dp[0] = 1；</p><p>遍历i从1到target，对于每个i，遍历数组nums，对于每个num，判断是否小于等于i，若是小于等于i，则将dp[i - num]的值加到dp[i]；</p><p>最终得到的dp[target]即为答案。</p><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">                <span class="keyword">if</span>(num &lt;= i)&#123;</span><br><span class="line">                    dp[i] += dp[i - num];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2021-4-25"><a href="#2021-4-25" class="headerlink" title="2021/4/25"></a>2021/4/25</h2><h3 id="题目：递增顺序搜索树"><a href="#题目：递增顺序搜索树" class="headerlink" title="题目：递增顺序搜索树"></a>题目：<a href="https://leetcode-cn.com/problems/increasing-order-search-tree/" target="_blank" rel="noopener">递增顺序搜索树</a></h3><h3 id="描述-12"><a href="#描述-12" class="headerlink" title="描述"></a>描述</h3><p>给你一棵二叉搜索树，请你 <strong>按中序遍历</strong> 将其重新排列为一棵递增顺序搜索树，使树中最左边的节点成为树的根节点，并且每个节点没有左子节点，只有一个右子节点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/17/ex1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [5,3,6,2,4,null,8,1,null,null,null,7,9]</span><br><span class="line">输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/17/ex2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [5,1,7]</span><br><span class="line">输出：[1,null,5,null,7]</span><br></pre></td></tr></table></figure><h3 id="题解-12"><a href="#题解-12" class="headerlink" title="题解"></a>题解</h3><p>这题题目都说了是二叉搜索树，因此其中序遍历后必然是递增的，对于递增的序列构造没有左节点的顺序搜索树类似于链表（因为只需要考虑一端）。因此此题的思路便是先中序遍历二叉搜索树，并可将遍历结果存至列表中，之后再根据列表中的数据构造顺序搜索树即可（注意在构造顺序搜索树时每次只需对其右子树申请节点即可）。</p><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">increasingBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        inorderBST(root, res);</span><br><span class="line">        TreeNode headNode = <span class="keyword">new</span> TreeNode(-<span class="number">1</span>);</span><br><span class="line">        TreeNode curNode = headNode;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> val  : res)&#123;</span><br><span class="line">            curNode.right = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">            curNode = curNode.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> headNode.right;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorderBST</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorderBST(root.left, res);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        inorderBST(root.right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;此处记录我leetcode的每日一题题解，由于是初学，因此很多地方可能会解释不清，所给题解也不一定是最优解（大部分是引用了官方题解）！&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>用C或C++语言设计并实现一个可进行复数运算的演示程序</title>
    <link href="http://yoursite.com/2021/04/02/%E7%94%A8C%E6%88%96C++%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E5%B9%B6%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8F%AF%E8%BF%9B%E8%A1%8C%E5%A4%8D%E6%95%B0%E8%BF%90%E7%AE%97%E7%9A%84%E6%BC%94%E7%A4%BA%E7%A8%8B%E5%BA%8F/"/>
    <id>http://yoursite.com/2021/04/02/%E7%94%A8C%E6%88%96C++%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E5%B9%B6%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8F%AF%E8%BF%9B%E8%A1%8C%E5%A4%8D%E6%95%B0%E8%BF%90%E7%AE%97%E7%9A%84%E6%BC%94%E7%A4%BA%E7%A8%8B%E5%BA%8F/</id>
    <published>2021-04-02T15:26:53.861Z</published>
    <updated>2021-04-02T15:43:41.678Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用C或C-语言设计并实现一个可进行复数运算的演示程序"><a href="#用C或C-语言设计并实现一个可进行复数运算的演示程序" class="headerlink" title="用C或C++语言设计并实现一个可进行复数运算的演示程序"></a>用C或C++语言设计并实现一个可进行复数运算的演示程序</h1><p>上学期的编程实践，觉得很有意思，然后这学期新学了c++，便想到利用c++对上学期的编程实践项目进行复原。</p><a id="more"></a><p>第一个程序便是复数运算。首先进行科普（不过我相信能看到这篇博客的人不至于连什么是复数都不知道）：</p><p><strong>我们把形如z=a+bi（a,b均为实数）的数称为复数，其中a称为<a href="https://baike.baidu.com/item/实部/53626919" target="_blank" rel="noopener">实部</a>，b称为虚部，i称为<a href="https://baike.baidu.com/item/虚数" target="_blank" rel="noopener">虚数</a>单位。当z的虚部等于零时，常称z为实数；当z的<a href="https://baike.baidu.com/item/虚部/5231815" target="_blank" rel="noopener">虚部</a>不等于零时，实部等于零时，常称z为<a href="https://baike.baidu.com/item/纯虚数/3386848" target="_blank" rel="noopener">纯虚数</a>。复数域是实数域的代数闭包，即任何复系数多项式在复数域中总有根。</strong></p><p>接下来便是真正的进入程序的分析：</p><h2 id="复数的构造"><a href="#复数的构造" class="headerlink" title="复数的构造"></a>复数的构造</h2><p>在c++中，这便是复数类的构造函数。从复数定义中不难看出，复数分为两部分，实部和虚部，一旦确定了实部和虚部，那复数也就唯一确定了。因此构造函数代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cpxNum(double ral, double imag)&#123;</span><br><span class="line">c_ral &#x3D; ral;</span><br><span class="line">c_imag &#x3D; imag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于构造函数中并未进行内存申请，因此不必考虑重新撰写析构函数。</p><h2 id="复数的四则运算"><a href="#复数的四则运算" class="headerlink" title="复数的四则运算"></a>复数的四则运算</h2><p>最先考虑到的便是c++四则运算符的重载，实现起来也比较简单，参照复数四则运算的公式很容易得出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">cpxNum operator+(const cpxNum&amp; c2) &#123;</span><br><span class="line">cpxNum result;</span><br><span class="line">result.c_ral &#x3D; this-&gt;c_ral + c2.c_ral;</span><br><span class="line">result.c_imag &#x3D; this-&gt;c_imag + c2.c_imag;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cpxNum operator-(const cpxNum&amp; c2) &#123;</span><br><span class="line">cpxNum result;</span><br><span class="line">result.c_ral &#x3D; this-&gt;c_ral - c2.c_ral;</span><br><span class="line">result.c_imag &#x3D; this-&gt;c_imag - c2.c_imag;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cpxNum operator*(const cpxNum&amp; c2) &#123;</span><br><span class="line">cpxNum result;</span><br><span class="line">result.c_ral &#x3D; this-&gt;c_ral * c2.c_ral - this-&gt;c_imag * c2.c_imag;</span><br><span class="line">result.c_imag &#x3D; this-&gt;c_ral * c2.c_imag + this-&gt;c_imag * c2.c_ral;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cpxNum operator&#x2F;(const cpxNum&amp; c2) &#123;</span><br><span class="line">cpxNum result;</span><br><span class="line">result.c_ral &#x3D; 0;</span><br><span class="line">result.c_imag &#x3D; (this-&gt;c_ral * c2.c_ral + this-&gt;c_imag * c2.c_imag) * (this-&gt;c_imag * c2.c_ral - this-&gt;c_ral * c2.c_ral) &#x2F; (c2.c_ral * c2.c_ral + c2.c_imag * c2.c_imag);</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复数的打印"><a href="#复数的打印" class="headerlink" title="复数的打印"></a>复数的打印</h2><p>需要考虑以下几种情况，首先是0（实部虚部均为0），此时直接打印0即可；之后是纯虚数（实部为0），此时不需要打印实部，直接打印虚部即可；再然后是实数（虚部为0），此时不需打印虚部，之后的话再把虚部为负数的情况单独讨论即可，也比较简单，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void print() &#123;</span><br><span class="line">if (c_ral &#x3D;&#x3D; 0.0 &amp;&amp; c_imag &#x3D;&#x3D; 0)</span><br><span class="line">cout &lt;&lt; &#39;0&#39;;</span><br><span class="line">else if (c_imag &#x3D;&#x3D; 0)</span><br><span class="line">cout &lt;&lt; c_ral;</span><br><span class="line">else if (c_ral &#x3D;&#x3D; 0)</span><br><span class="line">cout &lt;&lt; c_imag &lt;&lt; &#39;i&#39;;</span><br><span class="line">else if (c_imag &lt; 0)</span><br><span class="line">cout &lt;&lt; c_ral &lt;&lt; c_imag &lt;&lt; &#39;i&#39;;</span><br><span class="line">else</span><br><span class="line">cout &lt;&lt; c_ral &lt;&lt; &#39;+&#39; &lt;&lt; c_imag &lt;&lt; &#39;i&#39;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>此实验较为简单，毕竟是编程实践1中的第一个实验，主要是为了抽象数据类型ADT的实现，在c++中便是类的体现，算法部分基本没有障碍，只是打印部分需要略微进行考虑。</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>完整代码参考我的<a href="https://github.com/Decucin/-1/tree/main/%E5%A4%8D%E6%95%B0%E8%BF%90%E7%AE%97" target="_blank" rel="noopener">github</a>。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;用C或C-语言设计并实现一个可进行复数运算的演示程序&quot;&gt;&lt;a href=&quot;#用C或C-语言设计并实现一个可进行复数运算的演示程序&quot; class=&quot;headerlink&quot; title=&quot;用C或C++语言设计并实现一个可进行复数运算的演示程序&quot;&gt;&lt;/a&gt;用C或C++语言设计并实现一个可进行复数运算的演示程序&lt;/h1&gt;&lt;p&gt;上学期的编程实践，觉得很有意思，然后这学期新学了c++，便想到利用c++对上学期的编程实践项目进行复原。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>数据结构算法合集（C语言版）</title>
    <link href="http://yoursite.com/2020/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%EF%BC%88C%E8%AF%AD%E8%A8%80%E7%89%88%EF%BC%89/"/>
    <id>http://yoursite.com/2020/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%EF%BC%88C%E8%AF%AD%E8%A8%80%E7%89%88%EF%BC%89/</id>
    <published>2020-11-27T05:19:23.117Z</published>
    <updated>2020-09-27T15:58:12.782Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构算法合集（C语言版）"><a href="#数据结构算法合集（C语言版）" class="headerlink" title="数据结构算法合集（C语言版）"></a>数据结构算法合集（C语言版）</h1><p>在学习《数据结构（C语言版）》一书时，我将其中的算法在此记录，以便有需要时进行查阅。</p><a id="more"></a><p><strong>注：以&amp;开头的参数为引用参数。</strong></p><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><p>定义抽象数据类型的格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ADT 抽象数据类型名&#123;</span><br><span class="line">数据对象：&lt;数据对象的定义&gt;</span><br><span class="line">数据关系：&lt;数据关系的定义&gt;</span><br><span class="line">基本操作：&lt;基本操作的定义&gt;</span><br><span class="line">&#125;ADT 抽象数据类型名</span><br></pre></td></tr></table></figure><p>操作的定义格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">基本操作名（参数表）</span><br><span class="line">初始条件:&lt;初始条件描述&gt;</span><br><span class="line">操作结果:&lt;操作结果描述&gt;</span><br></pre></td></tr></table></figure><p>预定义常量和类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;函数结果状态代码</span><br><span class="line">#defineTRUE1</span><br><span class="line">#defineFALSE0</span><br><span class="line">#defineOK1</span><br><span class="line">#defineERROR0</span><br><span class="line">#defineINFEASIBLE-1</span><br><span class="line">#defineOVERFLOW-2</span><br><span class="line">&#x2F;&#x2F;Status是函数的类型，其值是函数结果的状态代码</span><br><span class="line">typedefintStatus;</span><br></pre></td></tr></table></figure><p>基本操作的算法的函数描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">函数类型函数名（函数参数表）&#123;</span><br><span class="line">&#x2F;&#x2F;算法说明</span><br><span class="line">语句序列</span><br><span class="line">&#125;&#x2F;&#x2F;函数名</span><br></pre></td></tr></table></figure><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>扩大线性表LA，将存在于线性表LB中而不存在于线性表LA中的数据元素插入到线性表LA中去：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void union(List &amp;La, List)&#123;</span><br><span class="line">&#x2F;&#x2F;将所有在线性表Lb中但不在La中的数据元素插入到La中</span><br><span class="line">La_len &#x3D; ListLenth(La);&#x2F;&#x2F;求线性表长度</span><br><span class="line">Lb_len &#x3D; ListLenth(Lb);&#x2F;&#x2F;求线性表长度</span><br><span class="line">for(i &#x3D; 1; i &lt;&#x3D; Lb_len; i++)&#123;</span><br><span class="line">GetElem(Lb,i,e);</span><br><span class="line">if(!LocateElem(La, e, equal))</span><br><span class="line">ListInsert(La, ++La_len, e);&#x2F;&#x2F;La中不存在和e相同的数据元素，则插入之</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F; union</span><br></pre></td></tr></table></figure><p>已知线性表LA，LB中数据元素均按值非递减有序排列，现需将LA，LB归并为新的线性表LC，且LC中的数据元素仍按值非递减有序排列：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void MergeList(List La, List Lb, List &amp;Lc)&#123;</span><br><span class="line">&#x2F;&#x2F;已知线性表La和Lb中的数据元素按值非递减排列</span><br><span class="line">&#x2F;&#x2F;归并La和Lb得到新的线性表Lc，Lc的数据元素也按值非递减排列</span><br><span class="line">InitList(Lc);</span><br><span class="line">i &#x3D; j &#x3D; 1;</span><br><span class="line">k &#x3D; 0;</span><br><span class="line">La_len &#x3D; ListLenth(La);</span><br><span class="line">Lb_len &#x3D; ListLenth(Lb);</span><br><span class="line">while((i &lt;&#x3D; La_len) &amp;&amp; (j &lt;&#x3D; Lb_len))&#123;&#x2F;&#x2F;La与Lb均非空</span><br><span class="line">GetElem(La, i, ai);</span><br><span class="line">GetElem(Lb, j, bj);</span><br><span class="line">if(ai &lt;&#x3D; bj)&#123;</span><br><span class="line">ListInsert(Lc, ++k;, ai);</span><br><span class="line">++i;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">ListInsert(Lc, ++k, bj);</span><br><span class="line">++j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">while(i &lt;&#x3D; La_len)&#123;</span><br><span class="line">GetElem(La, i++, ai);</span><br><span class="line">ListInsert(Lc, ++k, ai);</span><br><span class="line">&#125;</span><br><span class="line">while(j &lt;&#x3D; Lb_len)&#123;</span><br><span class="line">GetElem(Lb, j++, bj);</span><br><span class="line">ListInsert(Lc, ++k,bj);</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;MergeList</span><br></pre></td></tr></table></figure><p>用数组来描述顺序存储结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;-----线性表的动态分配顺序存储结构-----</span><br><span class="line">#define LIST_INIT_SIZE 100  &#x2F;&#x2F;线性表存储空间的初始分配量</span><br><span class="line">#define LISTINCREMENT 10    &#x2F;&#x2F;线性表存储空间的分配增量</span><br><span class="line">typedef struct&#123;</span><br><span class="line">ElemType *elem;   &#x2F;&#x2F;存储空间基址</span><br><span class="line">int lenth;        &#x2F;&#x2F;当前长度</span><br><span class="line">int listsize;     &#x2F;&#x2F;当前分配的存储容量（以sizeof(ElemType)为单位</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure><p>顺序表的初始化（分配一个预定义大小的数组空间，并将线性表的当前长度设为“0”）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Status InitList_Sq(SqList &amp;L)&#123;</span><br><span class="line">&#x2F;&#x2F;构造一个空的线性表L</span><br><span class="line">L.elem &#x3D; (ElemType *)malloc(LIST_INIT_SIZE * sizeof(ElemType));</span><br><span class="line">if(!L.elem)</span><br><span class="line">exit(OVERFLOW);</span><br><span class="line">L.lenth &#x3D; 0;</span><br><span class="line">L.listsize &#x3D; LIST_INIT_SIZE;</span><br><span class="line">return OK;</span><br><span class="line">&#125;&#x2F;&#x2F;InitList_Sq</span><br></pre></td></tr></table></figure><p>线性表的插入（在第i个元素之前插入一个元素）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Status ListInsert_Sq(SqList &amp;L, int i, ElemType e)&#123;</span><br><span class="line">&#x2F;&#x2F;在顺序线性表L中第i个位置之前插入新的元素e</span><br><span class="line">if(i &lt; 1 || i &gt; L.lenth + 1)</span><br><span class="line">retur ERROR;&#x2F;&#x2F;i值不合法</span><br><span class="line">if(L.lenth &gt;&#x3D; L.listsize)&#123;&#x2F;&#x2F;当前存储空间已满，增加分配</span><br><span class="line">newbase &#x3D; (ElemType *)realloc(L.elem, (L.Listsize + LISTINCREMENT) * sizeof(ElemType));</span><br><span class="line">if(!newbase)</span><br><span class="line">exit(OVERFLOW);         &#x2F;&#x2F;存储分配失败</span><br><span class="line">L.elm &#x3D; newbase;            &#x2F;&#x2F;新基址</span><br><span class="line">L.listsize +&#x3D; LISTINCREMENT;&#x2F;&#x2F;增加存储容量</span><br><span class="line">&#125;</span><br><span class="line">q &#x3D; &amp;(L.elem[i-1]);&#x2F;&#x2F;q为插入位置</span><br><span class="line">for(p &#x3D; &amp;(L.elem[L.lenth-1]);</span><br><span class="line">p &gt;&#x3D; q; --p) * (p+1) &#x3D; *p;</span><br><span class="line">&#x2F;&#x2F;插入位置及之后的元素右移</span><br><span class="line">*q &#x3D; e;       &#x2F;&#x2F;插入e</span><br><span class="line">++L.lenth;    &#x2F;&#x2F;表长增1</span><br><span class="line">return OK;</span><br><span class="line">&#125;&#x2F;&#x2F;ListInsert_Sq</span><br><span class="line">&#x2F;&#x2F;先操作地址再操作值，否则无法确定后一数的具体位置</span><br></pre></td></tr></table></figure><p>线性表的删除（删除第i个元素，并用e返回其值）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Status ListDelete_Sq(SqList &amp;L, int i, ElemType &amp;e)&#123;</span><br><span class="line">&#x2F;&#x2F;在顺序线性表L中删除第i个元素，并用e返回其值</span><br><span class="line">if((i &lt; 1) || (i &gt; L.lenth))  &#x2F;&#x2F;i值不合法</span><br><span class="line">return ERROR;    </span><br><span class="line">p &#x3D; &amp;(L.elem[i-1]);  &#x2F;&#x2F;p为被删除元素的位置</span><br><span class="line">e &#x3D; *p;       &#x2F;&#x2F;被删除元素赋值给e</span><br><span class="line">q &#x3D; L.elem + L.lenth - 1;  &#x2F;&#x2F;表尾元素的位置</span><br><span class="line">for(++q; p &lt;&#x3D;q; ++p)  &#x2F;&#x2F;被删除元素之后的元素左移</span><br><span class="line">*(p-1) &#x3D; *p;      </span><br><span class="line">--L.lenth;     &#x2F;&#x2F;表长减1</span><br><span class="line">return OK;     </span><br><span class="line">&#125;&#x2F;&#x2F;ListDelete_Sq</span><br></pre></td></tr></table></figure><p>进行两个元素之间的比较（查找第一个值与e满足compare()的元素的位序）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int LocateElem_Sq(SqList L, ElemType e, Status(*compare)(ElemType, ElemType))&#123;</span><br><span class="line">&#x2F;&#x2F;在顺序表L中查找第一个值与e满足compare()的元素的位序</span><br><span class="line">&#x2F;&#x2F;若找到，返回其在L中的位序，否则返回0</span><br><span class="line">i &#x3D; 1;           &#x2F;&#x2F;i的初值为第1个元素的位序</span><br><span class="line">p &#x3D; L.elem;      &#x2F;&#x2F;p的初值为第1个元素的存储位置</span><br><span class="line">while(i &lt;&#x3D; L.lenth &amp;&amp; !(*compare)(*p++, e))</span><br><span class="line">++i;</span><br><span class="line">if(i &lt;&#x3D; L.lenth)</span><br><span class="line">return i;</span><br><span class="line">else</span><br><span class="line">return 0;</span><br><span class="line">&#125;&#x2F;&#x2F;LocateElem_Sq</span><br></pre></td></tr></table></figure><p>书中算法2.7与之前的算法类似，因此此处不在重复，但书中提到一点：即当*pa = *pb，即两集合中元素相同时，只需将两者其中之一插入Lc，并将两者均后移即可。（合并线性表LA，LB为新表LC算法）</p><p>单链表的表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;-----线性表的单链表存储结构-----</span><br><span class="line">typedef struct LNode&#123;</span><br><span class="line">ElemType data;</span><br><span class="line">struct LNode *next;</span><br><span class="line">&#125;LNode, *LinkList;</span><br></pre></td></tr></table></figure><p>单链表中获取第i个元素的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Status GetElem_L(LinkList L, int i, ElemType &amp;e)&#123;</span><br><span class="line">&#x2F;&#x2F;L为带头结点的单链表的头指针</span><br><span class="line">&#x2F;&#x2F;当第i个元素存在时，其值赋给e并返回OK，否则返回ERROR</span><br><span class="line">p &#x3D; L-&gt;next;  &#x2F;&#x2F;初始化，p指向第1个结点</span><br><span class="line">j &#x3D; 1;    &#x2F;&#x2F;j为计数器</span><br><span class="line">while(p &amp;&amp; j&lt;i)&#123;   &#x2F;&#x2F;顺指针向后查找，直到p指向第i个元素或p为空</span><br><span class="line">p &#x3D; p-&gt;next;</span><br><span class="line">++j;</span><br><span class="line">&#125;</span><br><span class="line">if(!p || j&gt;i)   &#x2F;&#x2F;第i个元素不存在</span><br><span class="line">return ERROR; </span><br><span class="line">e &#x3D; p-&gt;data;    &#x2F;&#x2F;取第i个元素</span><br><span class="line">return OK;</span><br><span class="line">&#125;&#x2F;&#x2F;GetElem_L</span><br></pre></td></tr></table></figure><p>单链表添加元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Status ListInsert_L(LinkList &amp;L, int i, ElemType e)&#123;</span><br><span class="line">&#x2F;&#x2F;在带头结点的单链线性表L中第i个位置之前插入元素</span><br><span class="line">p &#x3D; L;</span><br><span class="line">j &#x3D; 0;</span><br><span class="line">while(p &amp;&amp; j &lt; i-1)&#123;</span><br><span class="line">p &#x3D; p-&gt;next;</span><br><span class="line">++j;</span><br><span class="line">&#125;&#x2F;&#x2F;寻找第i-1个结点</span><br><span class="line">if(!p || j&gt;i-1) &#x2F;&#x2F;i小于1或者大于表长加1</span><br><span class="line">return ERROR;</span><br><span class="line">s &#x3D; (LinkList)malloc(sizeof(LNode)); &#x2F;&#x2F;生成新结点</span><br><span class="line">s-&gt;data &#x3D; e;</span><br><span class="line">s-&gt;next &#x3D; p-&gt;next;</span><br><span class="line">&#x2F;&#x2F;插入L中</span><br><span class="line">p-next &#x3D; s;</span><br><span class="line">return OK;</span><br><span class="line">&#125;&#x2F;&#x2F;ListInsert_L</span><br></pre></td></tr></table></figure><p>单链表删除元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Status ListDelete_L(LinkList &amp;L, int i, ElemType &amp;e)&#123;</span><br><span class="line">&#x2F;&#x2F;在带头结点的单链线性表L中，删除第i个元素，并由e返回其值</span><br><span class="line">p &#x3D; L;</span><br><span class="line">j &#x3D; 0;</span><br><span class="line">while(p-&gt;next &amp;&amp; j &lt; i-1)&#123; &#x2F;&#x2F;寻找第i个结点，并令p指向其前驱</span><br><span class="line">p &#x3D; p-&gt;next;</span><br><span class="line">++j;</span><br><span class="line">&#125;</span><br><span class="line">if(!(p-&gt;next) || j&gt;i-1)</span><br><span class="line">return ERROR;&#x2F;&#x2F;删除位置不合理</span><br><span class="line">q &#x3D; p-&gt;next;</span><br><span class="line">p-&gt;next &#x3D; q-&gt;next;&#x2F;&#x2F;删除并释放结点</span><br><span class="line">e &#x3D; q-&gt;data;</span><br><span class="line">free(q);</span><br><span class="line">return OK;</span><br><span class="line">&#125;&#x2F;&#x2F;ListDelete_L</span><br></pre></td></tr></table></figure><p>从表尾到表头逆向建立单链表的算法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void CreateList_L(LinkLIst &amp;L, int n)&#123;</span><br><span class="line">&#x2F;&#x2F;逆位序输入n个元素的值，建立带头结点的单链线性表L</span><br><span class="line">L &#x3D; (Linklist)malloc(sizeof(LNode));</span><br><span class="line">L-&gt;next &#x3D; NULL;  &#x2F;&#x2F;先建立一个带头结点的单链表</span><br><span class="line">for(i &#x3D; n; i &gt; 0; --i)&#123;</span><br><span class="line">p &#x3D; (LinkList)malloc(sizeof(LNode));  &#x2F;&#x2F;生成新结点</span><br><span class="line">scanf(&amp;p-&gt;data);   &#x2F;&#x2F;输入元素值</span><br><span class="line">p-&gt;next &#x3D; L-&gt;next &#x3D; p;  &#x2F;&#x2F;插入到表头</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;CreateList_L</span><br></pre></td></tr></table></figure><p>将两个有序链表合并为一个有序链表:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void MergeList_L(LinkList &amp;La, LinkList &amp;Lb, LinkList &amp;Lc)&#123;</span><br><span class="line">&#x2F;&#x2F;已知单链线性表La和Lb的元素按值非递减排列</span><br><span class="line">&#x2F;&#x2F;归并La和Lb得到新的单链线性表Lc，Lc的元素也按值非递减排列</span><br><span class="line">pa &#x3D; La-&gt;next;</span><br><span class="line">pb &#x3D; Lb-&gt;next;</span><br><span class="line">Lc &#x3D; pc &#x3D;La;    &#x2F;&#x2F;用La的头结点作为Lc的头结点</span><br><span class="line">while(pa &amp;&amp; pb)&#123;</span><br><span class="line">if(pa-&gt;data &lt;&#x3D; pb-&gt;data)&#123;</span><br><span class="line">pc-&gt;next &#x3D; pa;</span><br><span class="line">pc &#x3D; pa;</span><br><span class="line">pa &#x3D; pa-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">pc-&gt;next &#x3D; pb;</span><br><span class="line">pc &#x3D; pb;</span><br><span class="line">pb &#x3D; pb-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pc-&gt;next &#x3D; pa? pa : pb;  &#x2F;&#x2F;插入剩余段</span><br><span class="line">free(Lb);   &#x2F;&#x2F;释放Lb的头结点</span><br><span class="line">&#125;&#x2F;&#x2F;MergeList_L</span><br></pre></td></tr></table></figure><p>一维数组描述线性链表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;-----线性表的静态单链表存储结构-----</span><br><span class="line">#define MAXSIZE 1000</span><br><span class="line">typedef struct&#123;</span><br><span class="line">ElemType data;</span><br><span class="line">int cur;</span><br><span class="line">&#125;component,SLinkList[MAXSIZE];</span><br></pre></td></tr></table></figure><p>在静态链表中实现定位：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int LocateElem_SL(SLinkList S, ElemType e)&#123;</span><br><span class="line">&#x2F;&#x2F;在静态单链线性表L中查找第1个值为e的元素</span><br><span class="line">&#x2F;&#x2F;若找到，则返回它在L的位序，否则返回0</span><br><span class="line">i &#x3D; S[0].cur;   &#x2F;&#x2F;i指示表中第一个结点</span><br><span class="line">while(i &amp;&amp; S[i].data !&#x3D; e)</span><br><span class="line">i &#x3D; S[i].cur;    &#x2F;&#x2F;在表中顺链查找</span><br><span class="line">return i;</span><br><span class="line">&#125;&#x2F;&#x2F;LOcateElem_SL</span><br></pre></td></tr></table></figure><p><strong>注：为了辨明静态链表（数组）中哪些分量未被使用，可将所有未被使用过以及被删除的分量用游标链成一个备用的链表，需要插入时便可从备用链表上取得第一个结点作为待插入的新结点，需要删除时将从链表中删除下来的结点链接到备用链表上。</strong></p><p>将数组空间初始化为链表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void InitSpace_SL(SLinkList &amp;space)&#123;</span><br><span class="line">&#x2F;&#x2F;将一维数组space中各分量链成一个备用链表，space[0].cur为头指针</span><br><span class="line">&#x2F;&#x2F;“0”表示空指针</span><br><span class="line">for(i &#x3D; 0; i &lt; MAXSIZE - 1; ++i)</span><br><span class="line">space[i].cur &#x3D; i + 1；</span><br><span class="line">space[MAXSIZE-1].cur &#x3D; 0;</span><br><span class="line">&#125;&#x2F;&#x2F;InitSpace_SL</span><br></pre></td></tr></table></figure><p>从备用空间取得一个结点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int Malloc_SL(SLinkList &amp;space)&#123;</span><br><span class="line">&#x2F;&#x2F;若备用空间链表非空，则返回分配的结点下标，否则返回0</span><br><span class="line">i &#x3D; space[0].cur;</span><br><span class="line">if(space[0].cur)</span><br><span class="line">space[0].cur &#x3D; space[i].cur;</span><br><span class="line">return i;</span><br><span class="line">&#125;&#x2F;&#x2F;Malloc_SL</span><br></pre></td></tr></table></figure><p>将空闲结点链接到备用列表上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void Free_SL(SLinkList &amp;space, int k)&#123;</span><br><span class="line">&#x2F;&#x2F;将下标为k的空闲结点回收到备用列表</span><br><span class="line">space[k].cur &#x3D; space[0].cur;</span><br><span class="line">space[0].cur &#x3D; k;</span><br><span class="line">&#125;&#x2F;&#x2F;Free_SL</span><br></pre></td></tr></table></figure><p>已知集合A,B，求集合(A-B)U(B-A)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">void difference(SLinkList &amp;space, int &amp;s)&#123;</span><br><span class="line">&#x2F;&#x2F;依次输入集合A和B的元素，在一维数组space中建立表示集合(A-B)U(B-A)的静态链表，S为其头指针</span><br><span class="line">&#x2F;&#x2F;假设备用空间足够大，space[0].cur为其头指针</span><br><span class="line">InitSpace_SL(space);    &#x2F;&#x2F;初始化备用空间</span><br><span class="line">S &#x3D; Malloc_SL(space);   &#x2F;&#x2F;生成S的头结点</span><br><span class="line">r &#x3D; S;                  &#x2F;&#x2F;r指向S的当前最后一个结点</span><br><span class="line">scanf(m, n);            &#x2F;&#x2F;输入A和B的元素个数</span><br><span class="line">for(j &#x3D; 1; j &lt;&#x3D; m; ++j)&#123;&#x2F;&#x2F;建立集合A的链表</span><br><span class="line">i &#x3D; Malloc_SL(space);&#x2F;&#x2F;分配结点</span><br><span class="line">scanf(space[i].data);&#x2F;&#x2F;输入A的元素值</span><br><span class="line">space[r].cur &#x3D; i;</span><br><span class="line">r &#x3D; i;&#x2F;&#x2F;插入到表尾</span><br><span class="line">&#125;&#x2F;&#x2F;for</span><br><span class="line">space[r].cur &#x3D; 0;        &#x2F;&#x2F;尾结点的指针为空</span><br><span class="line">for(j &#x3D; 1; j &lt;&#x3D; n; ++j)&#123;&#x2F;&#x2F;依次输入B的元素，若不在当前表中，则插入，否则删除</span><br><span class="line">scanf(b);</span><br><span class="line">p &#x3D; S;</span><br><span class="line">k &#x3D; space[S].cur    &#x2F;&#x2F;k指向集合A中第一个结点</span><br><span class="line">while(k !&#x3D; space[r].cur &amp;&amp; space[k].data !&#x3D; b)&#123;&#x2F;&#x2F;在当前表中查找</span><br><span class="line">p &#x3D; k;</span><br><span class="line">k &#x3D; space[k].cur;</span><br><span class="line">&#125;&#x2F;&#x2F;while</span><br><span class="line">if(k &#x3D;&#x3D; space[r].cur)&#123;&#x2F;&#x2F;当前表中不存在该元素，插入在r所指结点之后，且r的位置不变</span><br><span class="line">i &#x3D; Malloc_SL(space);</span><br><span class="line">space[i].data &#x3D; b;</span><br><span class="line">space[i].cur &#x3D; space[r].cur;</span><br><span class="line">space[r].cur &#x3D; i;</span><br><span class="line">&#125;&#x2F;&#x2F;if</span><br><span class="line">else&#123;&#x2F;&#x2F;该元素已在表中，删除之</span><br><span class="line">space[p].cur &#x3D; space[k].cur;</span><br><span class="line">Free_SL(space, k);</span><br><span class="line">if(r &#x3D;&#x3D; k)</span><br><span class="line">r &#x3D; p;      &#x2F;&#x2F;若删除的是r所指结点，则需修改尾指针</span><br><span class="line">&#125;&#x2F;&#x2F;else</span><br><span class="line">&#125;&#x2F;&#x2F;for</span><br><span class="line">&#125;&#x2F;&#x2F;difference</span><br></pre></td></tr></table></figure><p>双向链表的C语言表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;-----线性表的双向链表存储结构-----</span><br><span class="line">typedef struct DuLNode&#123;</span><br><span class="line">ElemType data;</span><br><span class="line">struct DuLNode *prior;</span><br><span class="line">struct DuLNode *next;</span><br><span class="line">&#125;DuLNode, *DuLinkList;</span><br></pre></td></tr></table></figure><p>双向链表插入元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Status ListInsert_DuL(DuLinkList &amp;L, int i, ElemType e)&#123;</span><br><span class="line">&#x2F;&#x2F;在带头结点的双链循环线性表L中第i个位置之前插入元素e</span><br><span class="line">if(!(p &#x3D; GetElemP_DuL(L, i)))    &#x2F;&#x2F;在L中确定插入位置</span><br><span class="line">return ERROR;                &#x2F;&#x2F;p&#x3D;NULL，即插入位置不合法</span><br><span class="line">if(!(s &#x3D; (DuLinkList)malloc(sizeof(DuLNode))))</span><br><span class="line">return ERROR;</span><br><span class="line">s-&gt;data &#x3D; e;</span><br><span class="line">s-&gt;piror &#x3D; p-&gt;piror;</span><br><span class="line">p-&gt;piror-&gt;next &#x3D; s;</span><br><span class="line">s-&gt;next &#x3D; p;</span><br><span class="line">p-&gt;piror &#x3D; s;</span><br><span class="line">return OK;</span><br><span class="line">&#125;&#x2F;&#x2F;ListInsert_DuL</span><br></pre></td></tr></table></figure><p>双向链表删除元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Status ListDelete_DuL(DuLinkList &amp;L, int i, ElemType &amp;e)&#123;</span><br><span class="line">&#x2F;&#x2F;删除带头结点的双链循环线性表L的第i个元素</span><br><span class="line">if(!(p &#x3D; GetElemP_DuL(L, i)))  &#x2F;&#x2F;在L中确定第i个元素的位置指针p</span><br><span class="line">return ERROR;</span><br><span class="line">e &#x3D; p-&gt;data;</span><br><span class="line">p-&gt;piror-&gt;next &#x3D; p-&gt;next;</span><br><span class="line">p-&gt;next-&gt;piror &#x3D; p-&gt;piror;</span><br><span class="line">free(p);</span><br><span class="line">return OK;</span><br><span class="line">&#125;&#x2F;&#x2F;ListDelete_DuL</span><br></pre></td></tr></table></figure><p>一个带头结点的线性链表定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">typedef struct LNode&#123;&#x2F;&#x2F;结点类型</span><br><span class="line">ElemType data;</span><br><span class="line">struct LNode *next;</span><br><span class="line">&#125;*Link, *Position;</span><br><span class="line"></span><br><span class="line">typedef struct&#123;&#x2F;&#x2F;链表类型</span><br><span class="line">Link head, tail;  &#x2F;&#x2F;分别指向线性链表中的头结点和最后一个结点</span><br><span class="line">int len;          &#x2F;&#x2F;指示线性链表中数据元素的个数</span><br><span class="line">&#125; LinkList;</span><br><span class="line"></span><br><span class="line">Status MakeNode(Link &amp;p, ElemType e);</span><br><span class="line">&#x2F;&#x2F;分配由p指向的值为e的结点，并返回OK；若分配失败，则返回ERROR</span><br><span class="line">void FreeNode( Link &amp;p);</span><br><span class="line">&#x2F;&#x2F;释放p所指结点</span><br><span class="line"></span><br><span class="line">Status InitList(LinkList &amp;L);</span><br><span class="line">&#x2F;&#x2F;构造一个空的线性表L</span><br><span class="line">Status DestroyList(LinkList &amp;L);</span><br><span class="line">&#x2F;&#x2F;销毁线性链表L，L不再存在</span><br><span class="line">Status ClearList(LinkList &amp;L);</span><br><span class="line">&#x2F;&#x2F;将线性链表L重置为空表，并释放原链表L的结点空间</span><br><span class="line">Status InsFirst(Link h, Link s);</span><br><span class="line">&#x2F;&#x2F;已知h指向线性链表的头结点，将s所指结点插入在第一个结点之前</span><br><span class="line">Status DelFirst(Link h, Link &amp;q);</span><br><span class="line">&#x2F;&#x2F;已知h指向线性链表的头结点，删除链表中的第一个结点并以q返回</span><br><span class="line">Status Append(LinkList &amp;L,Link s);</span><br><span class="line">&#x2F;&#x2F;将指针s所指（彼此以指针相链）的一串结点链在线性链表L的最后一个结点</span><br><span class="line">&#x2F;&#x2F;之后，并改变链表L的尾指针指向新的尾结点</span><br><span class="line">Status Remove(LinkList &amp;L, Link &amp;q);</span><br><span class="line">&#x2F;&#x2F;删除线性链表L中的尾结点并以q返回，改变链表L的尾指针指向新的尾结点</span><br><span class="line">Status InsBefore(LinkList &amp;L, Link &amp;p, Link s);</span><br><span class="line">&#x2F;&#x2F;已知p指向线性链表L中的一个结点，将s所指结点插入在p所指结点之前，并修改指针p指向新的结点</span><br><span class="line">Status InsAfter(LinkList &amp;L, Link &amp;p, Link s);</span><br><span class="line">&#x2F;&#x2F;已知p指向线性链表L中的一个结点，将s所指结点插入在p所指结点之后，并修改指针p指向新的结点</span><br><span class="line">Status SetCurElem( Link &amp;p, ElemType e);</span><br><span class="line">&#x2F;&#x2F;已知p指向线性链表中的一个结点，用e更新p所指结点中数据元素的值</span><br><span class="line">ElemType GetCurElem(Link p);</span><br><span class="line">&#x2F;&#x2F;已知p指向线性链表中的一个结点，返回p所指结点中数据元素的值</span><br><span class="line">Status ListEmpty(LinkList L);</span><br><span class="line">&#x2F;&#x2F;若线性链表L为空表，则返回TURE，否则返回FALSE</span><br><span class="line">int ListLength(LinkList L);</span><br><span class="line">&#x2F;&#x2F;返回线性链表L中元素个数</span><br><span class="line">Position GetHead(LinkList L);</span><br><span class="line">&#x2F;&#x2F;返回线性链表L中头结点的位置</span><br><span class="line">Position GetLast(LinkList L);</span><br><span class="line">&#x2F;&#x2F;返回线性链表L中最后一个结点的位置</span><br><span class="line">Position PriorPos(LinkList L, Link p);</span><br><span class="line">&#x2F;&#x2F;已知p指向线性链表L中的一个结点，返回p所指结点的直接前驱的位置</span><br><span class="line">&#x2F;&#x2F;若无前驱，则返回NULL</span><br><span class="line">Position NextPos(LinkList L, Link p);</span><br><span class="line">&#x2F;&#x2F;已知p指向线性链表L中的一个结点，返回p所指结点的直接后继的位置</span><br><span class="line">&#x2F;&#x2F;若无后继，则返回NULL</span><br><span class="line">Status LocatePos(LinkList L, int i, Link &amp;p);</span><br><span class="line">&#x2F;&#x2F;返回p指示线性链表L中第i个结点的位置并返回OK；i值不合法时返回ERROR</span><br><span class="line">Position LocateElem(LinkList L, ElemType e, Status (*compare)(ElemType, ElemType));</span><br><span class="line">&#x2F;&#x2F;返回线性链表L中第1个与e满足函数compare()关系的元素的位置</span><br><span class="line">&#x2F;&#x2F;若不存在这样的元素，则返回NULL</span><br><span class="line">Status ListTraverse(LinkList L, Status (*visit)());</span><br><span class="line">&#x2F;&#x2F;依次对L的每个元素调用函数visit()，一旦visit()失败，则操作失败</span><br></pre></td></tr></table></figure><p>在第i个元素之前插入元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Status ListInsert_L(LinkList &amp;L, int i, ElemType e)&#123;</span><br><span class="line">&#x2F;&#x2F;在带头结点的单链线性表L的第i个元素之前插入元素e</span><br><span class="line">if(!LocatePos(L, i-1, h))</span><br><span class="line">return ERROR;    &#x2F;&#x2F;i值不合法</span><br><span class="line">if(!MakeNode(s, e))</span><br><span class="line">return ERROR;    &#x2F;&#x2F;结点存储分配失败</span><br><span class="line">InsFirst(h, s);      &#x2F;&#x2F;对于从第i个结点开始的链表，第i-1个结点是它的头结点</span><br><span class="line">return Ok;</span><br><span class="line">&#125;&#x2F;&#x2F;ListInsert_L</span><br></pre></td></tr></table></figure><p>两按值非递减排列的单链线性表合并为新的按值非递减排列的单链线性表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Status MergeList_L(LinkList &amp;La, LinkList &amp;Lb, LinkList &amp;Lc, int (*compare)(ElemType, Elemtype))&#123;</span><br><span class="line">&#x2F;&#x2F;已知单链线性表La和Lb的元素按值非递减排列</span><br><span class="line">&#x2F;&#x2F;排列La和Lb得到新的单链线性表Lc，Lc的元素也按值非递减排列</span><br><span class="line">if(!InitList(Lc))</span><br><span class="line">return ERROR;</span><br><span class="line">ha &#x3D; GetHead(La);     &#x2F;&#x2F;ha指向La的头结点</span><br><span class="line">hb &#x3D; GetHead(Lb);     &#x2F;&#x2F;hb指向Lb的头结点</span><br><span class="line">pa &#x3D; NextPos(La, ha); &#x2F;&#x2F;pa指向La中当前结点</span><br><span class="line">pb &#x3D; NextPos(Lb, hb); &#x2F;&#x2F;pb指向Lb中当前结点</span><br><span class="line">while(pa&amp;&amp;pb)&#123;        &#x2F;&#x2F;La和Lb均非空</span><br><span class="line">a &#x3D; GetCurElem(pa);</span><br><span class="line">b &#x3D; GetCurElem(pb);  &#x2F;&#x2F;a和b为当前两表中比较元素</span><br><span class="line">if((*compare)(a, b) &lt;&#x3D; 0)&#123;  &#x2F;&#x2F;a&lt;&#x3D;b</span><br><span class="line">DelFirst(ha, q);</span><br><span class="line">Append(Lc, q);</span><br><span class="line">pa &#x3D; NextPos(La, ha);</span><br><span class="line">&#125;</span><br><span class="line">else&#123;  &#x2F;&#x2F;a&gt;&#x3D;b</span><br><span class="line">DelFirst(hb, q);</span><br><span class="line">Append(Lc, q);</span><br><span class="line">pb &#x3D; NextPos(Lb, hb);</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;while</span><br><span class="line">if(pa)</span><br><span class="line">Append(Lc, pa);   &#x2F;&#x2F;链接La中剩余结点</span><br><span class="line">else</span><br><span class="line">Append(Lc, pb);   &#x2F;&#x2F;链接Lb中剩余结点</span><br><span class="line">FreeNode(ha);</span><br><span class="line">FreeNode(hb);         &#x2F;&#x2F;释放La和Lb的头结点</span><br><span class="line">return OK;</span><br><span class="line">&#125;&#x2F;&#x2F;MergeList_L</span><br></pre></td></tr></table></figure><p>抽象数据类型一元多项式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ADT Polynomial&#123;</span><br><span class="line">数据对象：D &#x3D; &#123;ai | ai ∈ TermSet, i &#x3D; 1,2,...,m,  m&gt;&#x3D;0</span><br><span class="line">TermSet中的每个元素包含一个表示系数的实数和表示指数的整数&#125;</span><br><span class="line"></span><br><span class="line">数据关系：R1 &#x3D; &#123;&lt;a(i-1),ai&gt;|a(i-1),ai∈D,且a(i-1)中的指数值&lt;ai中的指数值，i&#x3D;2,...,n&#125;</span><br><span class="line">基本操作：</span><br><span class="line">CreatPolyn( &amp;P, m )</span><br><span class="line">  操作结果：输入m项的系数和指数，建立一元多项式P</span><br><span class="line">  DestroyPolyn( &amp;P )</span><br><span class="line">  初始条件：一元多项式P已存在</span><br><span class="line">  操作结果：销毁一元多项式P</span><br><span class="line">  PrintPolyn( P )</span><br><span class="line">  初始条件：一元多项式P已存在</span><br><span class="line">  操作结果：打印输出一元多项式P</span><br><span class="line">  PolynLength( P )</span><br><span class="line">  初始条件：一元多项式P已存在</span><br><span class="line">  操作结果：返回一元多项式P中的项数</span><br><span class="line">  AddPolyn( &amp;Pa, &amp;Pb )</span><br><span class="line">  初始条件：一元多项式Pa和Pb已存在</span><br><span class="line">  操作结果：完成多项式相加运算，即：Pa &#x3D; Pa + Pb，并销毁一元多项式Pb</span><br><span class="line">  SubtractPolyn( &amp;Pa, &amp;Pb )</span><br><span class="line">  操作结果：完成多项式相减运算，即Pa&#x3D; Pa - Pb，并销毁一元多项式Pb</span><br><span class="line">  MultiplyPolyn( &amp;Pa, &amp;Pb )</span><br><span class="line">  初始条件：一元多项式Pa和Pb已存在</span><br><span class="line">  操作结果：完成多项式相乘运算，即Pa &#x3D; Pa * Pb，并销毁一元多项式Pb</span><br><span class="line">&#125;ADT Polynomial</span><br></pre></td></tr></table></figure><p>LocateElem()函数作用略有不同：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Status LocateElem(LinkList L, Elemtype e, Position &amp;q, int (*compare)(Elemtype, ElemType));</span><br><span class="line">&#x2F;&#x2F;若有序链表L中存在与e满足判定函数compaare()取值为0的元素，则q指示L中第一个值为e的结点的位置</span><br><span class="line">&#x2F;&#x2F;并返回TRUE，否则q指示第一个与e满足判定函数compare()取值&gt;0的元素的前驱位置，并返回FALSE</span><br></pre></td></tr></table></figure><p>OrderInsert()函数作用略有不同：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Status OrderInsert( LinkList &amp;L, ElemType e, int (*compare)(ElemType, ElemType));</span><br><span class="line">&#x2F;&#x2F;按有序判定函数compare()的约定，将值为e的结点插入到有序链表L的 适当位置上</span><br></pre></td></tr></table></figure><p>抽象数据类型Polynomial的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">typedef struct&#123;    &#x2F;&#x2F;项的表示，多项式的项作为LinkList的数据元素</span><br><span class="line">float coef;    &#x2F;&#x2F;系数</span><br><span class="line">int   expn;    &#x2F;&#x2F;指数</span><br><span class="line">&#125;term, ElemType;   &#x2F;&#x2F;两个类型名：term用于本ADT，ElemType为LinkList的数据对象名</span><br><span class="line"></span><br><span class="line">typedef LinkList polynomial;    &#x2F;&#x2F;用带表头结点的有序链表表示多项式</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F;-----基本操作的函数原型说明-----</span><br><span class="line">void CreatPolyn( Polynomial &amp;p, int m )&#123;</span><br><span class="line">&#x2F;&#x2F;输入m项的系数和指数，建立表示一元多项式的有序链表P</span><br><span class="line">InitList(P);</span><br><span class="line">h &#x3D; GetHead(P);</span><br><span class="line">e.coef &#x3D; 0.0;</span><br><span class="line">e.expn &#x3D; -1;</span><br><span class="line">SetCurElem(h,e);   &#x2F;&#x2F;设置头结点的数据元素</span><br><span class="line">for( i &#x3D; 1; i&lt;&#x3D;m; ++i)&#123;  &#x2F;&#x2F;依次输入m个非零项</span><br><span class="line">scanf(e.coef, e.expn);</span><br><span class="line">if(!LocateElem( P, e, q, (*cmp)()))&#123;  &#x2F;&#x2F;当前链表中不存在该指数项</span><br><span class="line">if(MakeNode(s,e))</span><br><span class="line">InsFirst( q, s );  &#x2F;&#x2F;生成结点并插入链表</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;CreatPolyn</span><br></pre></td></tr></table></figure><p>多项式加法实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">void AddPolyn( polynomial &amp;Pa, polynomial &amp;Pb)&#123;</span><br><span class="line">&#x2F;&#x2F;多项式加法：Pa &#x3D; Pa+Pb，利用两个多项式的结点构成“和多项式”</span><br><span class="line">ha &#x3D; GetHead(Pa);   &#x2F;&#x2F;ha指向Pa的头结点</span><br><span class="line">hb &#x3D; GetHead(Pb);   &#x2F;&#x2F;hb指向Pb的头结点</span><br><span class="line">qa &#x3D; NextPos(Pa,ha);   &#x2F;&#x2F;qa指向Pa中当前结点</span><br><span class="line">qb &#x3D; NextPos(Pb,hb);   &#x2F;&#x2F;qb指向Pb中当前结点</span><br><span class="line">while(qa &amp;&amp; Qb)&#123;&#x2F;&#x2F;qa和qb均非空</span><br><span class="line">a &#x3D; GetCurElem(qa);</span><br><span class="line">b &#x3D; GetCurElem(qb);   &#x2F;&#x2F;a和b为两表中当前比较元素</span><br><span class="line">switch( *cmp(a,b))&#123;</span><br><span class="line">case -1:    &#x2F;&#x2F;多项式Pa中当前结点的指数值小</span><br><span class="line">ha &#x3D; qa;</span><br><span class="line">qa &#x3D; NextPos(Pa, qa);</span><br><span class="line">break;</span><br><span class="line">case 0:     &#x2F;&#x2F;两者的指数值相等</span><br><span class="line">sum &#x3D; a.coef + b.coef;</span><br><span class="line">if(sum !&#x3D; 0.0)&#123;&#x2F;&#x2F;修改多项式Pa中当前结点的系数值</span><br><span class="line">SetCurElem(qa,sum);</span><br><span class="line">ha &#x3D; qa;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;&#x2F;&#x2F;删除多项式Pa中当前结点</span><br><span class="line">DelFirst(ha, qa);</span><br><span class="line">FreeNode(qa);</span><br><span class="line">&#125;</span><br><span class="line">DelFirst(hb, qb);</span><br><span class="line">FreeNode(qb);</span><br><span class="line">qb &#x3D; NextPos(Pb, hb);</span><br><span class="line">qa &#x3D; NextPos(Pa, ha);</span><br><span class="line">break;</span><br><span class="line">case 1:&#x2F;&#x2F;多项式Pb中当前结点的指数值小</span><br><span class="line">DelFirst(hb, qb);</span><br><span class="line">InsFirst( ha, qb);</span><br><span class="line">qb &#x3D; NextPos(Pb, hb);</span><br><span class="line">ha &#x3D; NextPos(Pa,ha);</span><br><span class="line">break;</span><br><span class="line">&#125;&#x2F;&#x2F;switch</span><br><span class="line">&#125;&#x2F;&#x2F;while</span><br><span class="line">if(!ListEmpty (Pb))</span><br><span class="line">Append(Pa, qb);&#x2F;&#x2F;链接Pb中剩余结点</span><br><span class="line">FreeNode(hb);&#x2F;&#x2F;释放Pb的头结点</span><br><span class="line">&#125;&#x2F;&#x2F;AddPolyn</span><br></pre></td></tr></table></figure><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><p>栈的抽象数据类型定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">ADTStack&#123;</span><br><span class="line">数据对象：D &#x3D; &#123;ai|ai∈ElemSet, i &#x3D; 1,2,...,n,n&gt;&#x3D;0&#125;</span><br><span class="line">数据关系：R1 &#x3D; &#123; &lt;a(i-1),ai&gt;|a(i-1),ai∈D, i &#x3D; 2,...,n&#125;</span><br><span class="line">约定an端为栈顶，ai端为栈底</span><br><span class="line">基本操作：</span><br><span class="line">InitStack(&amp;S)</span><br><span class="line">操作结果：构造一个空栈S</span><br><span class="line">DestroyStack(&amp;S)</span><br><span class="line">初始条件：栈S已存在</span><br><span class="line">操作结果：栈S被销毁</span><br><span class="line">ClearStack(&amp;S)</span><br><span class="line">初始条件：栈S已存在</span><br><span class="line">操作结果：将S清为空栈</span><br><span class="line">StackEmpty(S)</span><br><span class="line">初始条件：栈S已存在</span><br><span class="line">操作结果：若栈S为空栈，则返回TRUE，否则返回FALSE</span><br><span class="line">StackLength(S)</span><br><span class="line">初始条件：栈S已存在</span><br><span class="line">操作结果：返回S的元素个数，即栈的长度</span><br><span class="line">GetTop(S,&amp;e)</span><br><span class="line">初始条件：栈S已存在且非空</span><br><span class="line">操作结果：用e返回S的栈顶元素</span><br><span class="line">Push(&amp;S, &amp;e)</span><br><span class="line">初始条件：栈S已存在</span><br><span class="line">操作结果：插入元素e为新的栈顶元素</span><br><span class="line">Pop(&amp;S, &amp;e)</span><br><span class="line">初始条件：栈S已存在且非空</span><br><span class="line">操作结果：删除S的栈顶元素，并用e返回其值</span><br><span class="line">StackTraverse(S,visit())</span><br><span class="line">初始条件：栈S已存在且非空</span><br><span class="line">操作结果：从栈底到栈顶依次对S的每个元素调用函数visit()，一旦visit()失败，则操作失败</span><br><span class="line">&#125;ADTStack</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;之后也多为如上定义，并将插入元素操作称为入栈，删除栈顶元素的操作为出栈</span><br></pre></td></tr></table></figure><p>顺序栈的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedefstruct&#123;</span><br><span class="line">SElemType*base;</span><br><span class="line">SElemType*top;</span><br><span class="line">intstacksize;</span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure><p>顺序栈的模块说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;ADT Stack的表示与实现&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-----栈的顺序存储表示-----</span><br><span class="line"></span><br><span class="line">#define STACK_INIT_SIZE100;&#x2F;&#x2F;存储空间初始分配量</span><br><span class="line">#defineSTACKINCREMENT10;&#x2F;&#x2F;存储空间分配增量</span><br><span class="line">typedefstruct&#123;</span><br><span class="line">SElemType*base;&#x2F;&#x2F;在栈构造之前和销毁之后，base的值为NULL</span><br><span class="line">SElemType*top;&#x2F;&#x2F;栈顶指针</span><br><span class="line">intstacksize;&#x2F;&#x2F;当前已分配的存储空间，以元素为单位</span><br><span class="line">&#125;SqStack;</span><br><span class="line">&#x2F;&#x2F;-----基本操作的函数原型说明-----</span><br><span class="line">StatusInitStack(SqStack &amp;S);</span><br><span class="line">&#x2F;&#x2F;构造一个空栈S</span><br><span class="line">StatusDestroyStack(SqStack &amp;S);</span><br><span class="line">&#x2F;&#x2F;销毁栈S，S不在存在</span><br><span class="line">StatusClearStack(SqStack&amp;S);</span><br><span class="line">&#x2F;&#x2F;把S置为空栈</span><br><span class="line">StatusStackEmpty(SqStackS);</span><br><span class="line">&#x2F;&#x2F;若栈S为空栈，则返回TRUE，否则返回FALSE</span><br><span class="line">int StackLength(SqStack S);</span><br><span class="line">&#x2F;&#x2F;返回S的元素个数，即栈的长度</span><br><span class="line">Status GetTop(SqStack S, SElemType &amp;e);</span><br><span class="line">&#x2F;&#x2F;若栈不空，则用e返回S的栈顶元素，并返回OK，否则返回ERROR</span><br><span class="line">Status Push(SqStack &amp;S,SElemType e);</span><br><span class="line">&#x2F;&#x2F;插入元素e为新的栈顶元素</span><br><span class="line">Status Pop(SqStack &amp;S, SElemType &amp;e);</span><br><span class="line">&#x2F;&#x2F;若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK，否则返回ERROR</span><br><span class="line">Status StackTraverse(SqStack S, Status (*visit)());</span><br><span class="line">&#x2F;&#x2F;从栈底到栈顶依次对栈中每个元素调用函数visit()，一旦visit()失败，则操作失败</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-----基本操作的算法描述（部分） -----</span><br><span class="line">Status InitStack (SqStack &amp;S)&#123;</span><br><span class="line">&#x2F;&#x2F;构造一个空栈S</span><br><span class="line">S.base &#x3D; (SElemType*)malloc(STACK_INIT_SIZE * sizeof(SElemType));</span><br><span class="line">if(!S.base)</span><br><span class="line">exit(OVERFLOW);&#x2F;&#x2F;存储分配失败</span><br><span class="line">S.top &#x3D; S.base;</span><br><span class="line">S.stacksize &#x3D; STACK_INIT_SIZE;</span><br><span class="line">return OK;</span><br><span class="line">&#125;&#x2F;&#x2F;InitStack</span><br><span class="line"></span><br><span class="line">StatusGetTop(SqStackS, SElemType &amp;e)&#123;</span><br><span class="line">&#x2F;&#x2F;若栈不空，则用e返回S的栈顶元素，并返回OK，否则返回ERROR</span><br><span class="line">if(S.top &#x3D;&#x3D; S.base)</span><br><span class="line">return ERROR;</span><br><span class="line">e &#x3D; *(S.top - 1);</span><br><span class="line">return OK;</span><br><span class="line">&#125;&#x2F;&#x2F;GetTop</span><br><span class="line"></span><br><span class="line">StatusPush(SqStack &amp;S, SElemType e)&#123;</span><br><span class="line">&#x2F;&#x2F;插入元素e为新的栈顶元素</span><br><span class="line">if(S.top - S.base &gt;&#x3D; S.stacksize)&#123;&#x2F;&#x2F;栈满，追加存储空间</span><br><span class="line">S.base &#x3D; (SElemType*)realloc( S.base, (S.stacksize + STACKINCREMENT) * sizeof(SElemType));</span><br><span class="line">if(!S.base)</span><br><span class="line">exit(OVERFLOW);&#x2F;&#x2F;存储分配失败</span><br><span class="line"></span><br><span class="line">S.top &#x3D; S.base + S.stacksize;</span><br><span class="line">S.stacksize +&#x3D; STACKINCREMENT;</span><br><span class="line">&#125;</span><br><span class="line">*S.top++ &#x3D; e;</span><br><span class="line">return OK;</span><br><span class="line">&#125;&#x2F;&#x2F;Push</span><br><span class="line"></span><br><span class="line">StatusPop(SqStack&amp;S,SEleType &amp;e)&#123;</span><br><span class="line">&#x2F;&#x2F;若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK，否则返回FALSE</span><br><span class="line">if(S.top &#x3D;&#x3D; S.base)</span><br><span class="line">return ERROR;</span><br><span class="line">e &#x3D; * --S.top;</span><br><span class="line">return OK;</span><br><span class="line">&#125;&#x2F;&#x2F;Pop</span><br></pre></td></tr></table></figure><p>十进制转八进制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;进制计算与打印过程刚好相反，满足栈的特性</span><br><span class="line"></span><br><span class="line">void conversion()&#123;</span><br><span class="line">&#x2F;&#x2F;对于输入的任意一个非负十进制整数，打印输出与其等值的八进制数</span><br><span class="line">InitStack(S);&#x2F;&#x2F;构造空栈</span><br><span class="line">scanf(&quot;%d&quot;,N);</span><br><span class="line">while(N)&#123;</span><br><span class="line">Push(S, N % 8);</span><br><span class="line">N &#x3D; N&#x2F;8;</span><br><span class="line">&#125;</span><br><span class="line">while(!StackEmpty(S))&#123;</span><br><span class="line">Pop(S,e);</span><br><span class="line">printf(&quot;%d&quot;,e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;conversion</span><br></pre></td></tr></table></figure><p>行编辑程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void LineEdit()&#123;</span><br><span class="line">&#x2F;&#x2F;利用字符栈S，从终端接受一行并传送至调用过程的数据区</span><br><span class="line">InitStack(S);&#x2F;&#x2F;构造空栈S</span><br><span class="line">ch &#x3D; getchar();&#x2F;&#x2F;从终端接收第一个字符</span><br><span class="line">while(ch !&#x3D; EOF)&#123;&#x2F;&#x2F;EOF为全文结束符</span><br><span class="line">while(ch !&#x3D; EOF &amp;&amp; ch !&#x3D; &#39;\n&#39;)&#123;</span><br><span class="line">switch(ch)&#123;</span><br><span class="line">case &#39;#&#39;:</span><br><span class="line">Pop(S,c);</span><br><span class="line">break;&#x2F;&#x2F;仅当栈非空时退栈</span><br><span class="line">case &#39;@&#39;:</span><br><span class="line">ClearStack(S);</span><br><span class="line">break;&#x2F;&#x2F;重置S为空栈</span><br><span class="line">default:</span><br><span class="line">Push(S,ch);</span><br><span class="line">break;&#x2F;&#x2F;有效字符进栈，未考虑栈满情况</span><br><span class="line">&#125;</span><br><span class="line">ch &#x3D; getchar();&#x2F;&#x2F;从终端接收下一个字符</span><br><span class="line">&#125;</span><br><span class="line">将从栈底到栈顶的栈内字符传送至调用过程的数据区</span><br><span class="line">ClearStack(S);&#x2F;&#x2F;重置S为空栈</span><br><span class="line">if(ch!&#x3D;EOF)</span><br><span class="line">ch &#x3D; getchar();</span><br><span class="line">&#125;</span><br><span class="line">DestroyStack(S);</span><br><span class="line">&#125;&#x2F;&#x2F;LineEdit</span><br></pre></td></tr></table></figure><p>求迷宫中一条从入口到出口的路径的算法描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">do&#123;</span><br><span class="line">若当前位置可通，则&#123;</span><br><span class="line">将当前位置压入栈顶；   &#x2F;&#x2F;  纳入路径</span><br><span class="line">若当前位置是出口位置，则结束；&#x2F;&#x2F;求得路径存放在栈中</span><br><span class="line">否则切换当前位置的东邻方块为新的当前位置；</span><br><span class="line">&#125;</span><br><span class="line">否则&#123;</span><br><span class="line">若栈不空且栈顶位置尚有其他地方尚未探索，则&#123;</span><br><span class="line">设定新的当前位置为沿顺时针方向旋转找到的栈顶位置的下一邻块</span><br><span class="line">&#125;</span><br><span class="line">若栈不空但栈顶位置的四周均不可通，则&#123;</span><br><span class="line">删去栈顶位置； &#x2F;&#x2F;从路径中删去该通道块</span><br><span class="line">若栈不空，则重新测试新的栈顶位置，，</span><br><span class="line">直至找到一个可通的相邻块或出栈至栈空；</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;while(栈不空)</span><br></pre></td></tr></table></figure><p>实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">typedefstruct&#123;</span><br><span class="line">intord;&#x2F;&#x2F;通道块在路径上的“序号”</span><br><span class="line">PosTypeseat;&#x2F;&#x2F;通道块在迷宫中的“坐标位置”</span><br><span class="line">intdi;&#x2F;&#x2F;从此通道块走向下一通道块的“方向”</span><br><span class="line">&#125;SElemType;&#x2F;&#x2F;栈的元素类型</span><br><span class="line"></span><br><span class="line">StatusMazePath( MazeTypemaze, PosType start, PosType end )&#123;</span><br><span class="line">&#x2F;&#x2F;若迷宫maze中存在从入口start到出口end的通道，则求得一条存放在栈中（从栈底到栈顶），并返回TRUE；</span><br><span class="line">&#x2F;&#x2F;否则返回FALSE</span><br><span class="line">InitStack(S);</span><br><span class="line">curpos &#x3D; start;&#x2F;&#x2F;设定“当前位置”为“入口位置”</span><br><span class="line">curstep &#x3D; 1;&#x2F;&#x2F;探索第一步</span><br><span class="line">do&#123;</span><br><span class="line">if(Pass(curpos))&#123;&#x2F;&#x2F;当前位置可以通过，即是未曾走到过的通道块</span><br><span class="line">FootPrint(curpos);&#x2F;&#x2F;留下足迹</span><br><span class="line">e &#x3D; ( curstep, curpos, 1 );&#x2F;&#x2F;此处e为SElemType类型的栈（书中未提及）</span><br><span class="line">Push(S,e);&#x2F;&#x2F;加入路径</span><br><span class="line">if(curpos&#x3D;&#x3D;end)</span><br><span class="line">return(TRUE);&#x2F;&#x2F;到达终点，出口</span><br><span class="line">curpos &#x3D; NextPos( curpos, 1 );&#x2F;&#x2F;下一位置是当前位置的东邻</span><br><span class="line">curstep++;&#x2F;&#x2F;探索下一步</span><br><span class="line">&#125;&#x2F;&#x2F;if</span><br><span class="line">else&#123;&#x2F;&#x2F;当前位置不能通过</span><br><span class="line">if(!StackEmpty(S))&#123;</span><br><span class="line">Pop(S,e);</span><br><span class="line">while(e.di &#x3D;&#x3D; 4 &amp;&amp; !StackEmpty(S))&#123;</span><br><span class="line">MarkPrint(e.seat);</span><br><span class="line">Pop(S,e);&#x2F;&#x2F;留下不能通过的标记，并退回一步</span><br><span class="line">&#125;&#x2F;&#x2F;while</span><br><span class="line">if(e.di&lt;4)&#123;</span><br><span class="line">e.di++;</span><br><span class="line">Push(S,e);&#x2F;&#x2F;换下一个方向探索</span><br><span class="line">curpos &#x3D; NextPos(e.seat, e.di);&#x2F;&#x2F;设定当前位置是该新方向上的相邻块</span><br><span class="line">&#125;&#x2F;&#x2F;if</span><br><span class="line">&#125;&#x2F;&#x2F;if</span><br><span class="line">&#125;&#x2F;&#x2F;else</span><br><span class="line">&#125;while( !StackEmpty(S));</span><br><span class="line">return (FALSE);</span><br><span class="line">&#125;&#x2F;&#x2F;MazePath</span><br></pre></td></tr></table></figure><p>带优先级的算术表达式求值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">OperandTypeEvaluateExpression()&#123;</span><br><span class="line">&#x2F;&#x2F;算数表达式求值的算符优先算法</span><br><span class="line">&#x2F;&#x2F;设OPTR和OPND分别为运算符栈和运算数栈，OP为运算符集合</span><br><span class="line">InitStack(OPTR);</span><br><span class="line">Push(OPTR, &#39;#&#39;);</span><br><span class="line">InitStack(OPND);</span><br><span class="line">c &#x3D; getchar();</span><br><span class="line">while(c!&#x3D;&#39;#&#39; || GetTop(OPTR)!&#x3D;&#39;#&#39;)&#123;</span><br><span class="line">if(!In(c, OP))&#123;</span><br><span class="line">Push(OPND, c);</span><br><span class="line">c &#x3D; getchar();</span><br><span class="line">&#125;&#x2F;&#x2F;不是运算符则进栈</span><br><span class="line">else&#123;</span><br><span class="line">switch(Precede(GetTop(OPTR),c))&#123;&#x2F;&#x2F;Precede()函数用于监测运算符优先级</span><br><span class="line">case &#39;&lt;&#39;:&#x2F;&#x2F;栈顶元素优先权低</span><br><span class="line">Push(OPTR, c);</span><br><span class="line">c &#x3D; getchar();</span><br><span class="line">break;</span><br><span class="line">case &#39;&#x3D;&#39;:&#x2F;&#x2F;脱括号并接受下一字符</span><br><span class="line">Pop(OPTR, x);</span><br><span class="line">c &#x3D; getchar();</span><br><span class="line">break;</span><br><span class="line">case &#39;&gt;&#39;:&#x2F;&#x2F;退栈并将运算结果入栈</span><br><span class="line">Pop(OPTR, theta);</span><br><span class="line">Pop(OPND, b);</span><br><span class="line">Pop(OPND, a);</span><br><span class="line">Push(OPND, Operate(a, theta, b));</span><br><span class="line">break;</span><br><span class="line">&#125;&#x2F;&#x2F;switch</span><br><span class="line">&#125;&#x2F;&#x2F;else</span><br><span class="line">&#125;&#x2F;&#x2F;while</span><br><span class="line">return GetTop(OPND);</span><br><span class="line">&#125;&#x2F;&#x2F;EvaluateExpression</span><br></pre></td></tr></table></figure><p>求解n阶Hanoi塔问题的C函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void hanoi(int n, char x, char y, char z)</span><br><span class="line">&#x2F;&#x2F;将塔座x上按直径由小到大且自上而下编号为1至n的n个圆盘按规则搬动到塔座z上，y可用作辅助塔座</span><br><span class="line">&#x2F;&#x2F;搬动操作move(x, n, z)可定义为（c是初值为0的全局变量，对搬动计数）：</span><br><span class="line">&#x2F;&#x2F;printf(&quot;%i. Move disk %i from %c to %c\n&quot;, ++c, n, x, z);</span><br><span class="line">&#123;</span><br><span class="line">if(n&#x3D;&#x3D;1)</span><br><span class="line">move(x,1,z);</span><br><span class="line">else&#123;</span><br><span class="line">honoi(n-1, x, z,y);&#x2F;&#x2F;将x上编号为1至n-1的圆盘移到y，z作辅助塔</span><br><span class="line">move(x, n, z);&#x2F;&#x2F;将编号为n的圆盘从x移到z</span><br><span class="line">hanoi(n-1, y, x, z);&#x2F;&#x2F;将y上编号为1至n-1的圆盘移到z，x作辅助塔</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>队列的抽象数据类型定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">ADTQueue&#123;</span><br><span class="line">数据对象:D&#x3D;&#123;ai|ai∈ElemSet, i &#x3D; 1,2,...,n, n&gt;&#x3D;0&#125;</span><br><span class="line">数据关系:R1&#x3D;&#123;&lt;a(i-1),ai&gt;|a(i-1),ai∈D, i&#x3D;2,...,n&#125;</span><br><span class="line">约定其中a1端为队列头，an端为队列尾</span><br><span class="line">基本操作：</span><br><span class="line">InitQueue(&amp;Q)</span><br><span class="line">操作结果：构造一个空队列Q</span><br><span class="line">DesTroyQueue(&amp;Q)</span><br><span class="line">初始条件：队列Q已存在</span><br><span class="line">操作结果：队列Q被销毁，不再存在</span><br><span class="line">ClearQueue(&amp;Q)</span><br><span class="line">初始条件：队列Q已存在</span><br><span class="line">操作结果：将Q清为空队列</span><br><span class="line">QueueEmpty(Q)</span><br><span class="line">初始条件：队列Q已存在</span><br><span class="line">操作结果：若Q为空队列，则返回TRUE，否则返回FALSE</span><br><span class="line">QueueLength(Q)</span><br><span class="line">初始条件：队列Q已存在</span><br><span class="line">操作结果：返回Q的元素个数，即队列的长度</span><br><span class="line">GetHead(Q, &amp;e)</span><br><span class="line">初始条件：队列Q已存在</span><br><span class="line">操作结果：用e返回Q的队头元素</span><br><span class="line">EnQueue(&amp;Q, e)</span><br><span class="line">初始条件：队列Q已存在</span><br><span class="line">操作结果：插入元素e为Q的新的队尾元素</span><br><span class="line">DeQueue(&amp;Q, &amp;e)</span><br><span class="line">初始条件：队列Q已存在</span><br><span class="line">操作结果：删除Q的队头元素，并用e返回其值</span><br><span class="line">QueueTraverse(Q,visit())</span><br><span class="line">初始条件：队列Q已存在</span><br><span class="line">操作结果：从队头到队尾，依次对Q的每个数据元素调用函数visit()。一旦visit()失败，则操作失败</span><br><span class="line">&#125;ADT Queue</span><br></pre></td></tr></table></figure><p>单链队列的表示与实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;ADT Queue的表示与实现&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-----单链队列——队列的链式存储结构-----</span><br><span class="line">typedefstructQNode&#123;</span><br><span class="line">QElemTypedata;</span><br><span class="line">structQNode*next;</span><br><span class="line">&#125;QNode, *QueuePtr;</span><br><span class="line">typedefstruct&#123;</span><br><span class="line">QueuePtrfront;&#x2F;&#x2F;队头指针</span><br><span class="line">QueuePtrrear;&#x2F;&#x2F;队尾指针</span><br><span class="line">&#125;&#x2F;&#x2F;LinkQueue;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-----基本操作的函数原型说明-----</span><br><span class="line">StatusInitQueue(LinkQueue&amp;Q)</span><br><span class="line">&#x2F;&#x2F;构造一个空队列Q</span><br><span class="line">StatusDestroyQueue(LinkQueue &amp;Q)</span><br><span class="line">&#x2F;&#x2F;销毁队列Q，Q不再存在</span><br><span class="line">StatusClearQueue(LinkQueue &amp;Q)</span><br><span class="line">&#x2F;&#x2F;将Q清为空队列</span><br><span class="line">StatusQueueEmpty(LinkQueue Q)</span><br><span class="line">&#x2F;&#x2F;若队列Q为空队列，则返回TRUE，否则返回FALSE</span><br><span class="line">intQueueLength(LinkQueue Q)</span><br><span class="line">&#x2F;&#x2F;返回队列Q的元素个数，即队列长度</span><br><span class="line">StatusGetHead(LinkQueue Q, QElemType &amp;e)</span><br><span class="line">&#x2F;&#x2F;若队列不空，则用e返回Q的队头元素，并返回OK，否则返回ERROR</span><br><span class="line">StatusEnQueue(LinkQueue &amp;Q, QElemType &amp;e)</span><br><span class="line">&#x2F;&#x2F;插入元素e为Q新的队尾元素</span><br><span class="line">StatusDeQueue(LinkQueue &amp;Q, QElemType &amp;e)</span><br><span class="line">&#x2F;&#x2F;若队列不空，则删除Q的队头元素，用e返回其值，并返回OK，否则返回ERROR</span><br><span class="line">StatusQueueTraverse(LinkQueue Q, visit())</span><br><span class="line">&#x2F;&#x2F;从队头到队尾依次对队列Q中每个元素调用函数visit()。一旦visit()失败，则操作失败</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-----基本操作的算法描述（部分） -----</span><br><span class="line">StatusInitQueue(LinkQueue&amp;Q)&#123;</span><br><span class="line">&#x2F;&#x2F;构造一个空队列Q</span><br><span class="line">Q.front &#x3D; Q.rear &#x3D; (QueuePtr)malloc(sizeof(QNode));</span><br><span class="line">if(!Q.front)</span><br><span class="line">exit(OVERFLOW);&#x2F;&#x2F;存储分配失败</span><br><span class="line">Q.front-&gt;next &#x3D; NULL;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StatusDestroyQueue(LinkQueue&amp;Q)&#123;</span><br><span class="line">&#x2F;&#x2F;销毁队列Q</span><br><span class="line">while(Q.front)&#123;</span><br><span class="line">Q.rear &#x3D; Q.front-&gt;next;</span><br><span class="line">free(Q.front);</span><br><span class="line">Q.front &#x3D; Q.rear;</span><br><span class="line">&#125;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StatusEnQueue(LinkQueue &amp;Q, QElemTypee)&#123;</span><br><span class="line">&#x2F;&#x2F;插入元素e为Q的新的队尾元素</span><br><span class="line">p &#x3D; (QueuePtr)malloc(sizeof(QNode));</span><br><span class="line">if(!p)</span><br><span class="line">exit(OVERFLOW);&#x2F;&#x2F;存储分配失败</span><br><span class="line">p-&gt;data &#x3D; e;</span><br><span class="line">p-&gt;next &#x3D; NULL;</span><br><span class="line">Q.rear-&gt;next &#x3D; p;</span><br><span class="line">Q.rear &#x3D; p;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StatusDeQueue(LinkQueue &amp;Q, QElemType &amp;e)&#123;</span><br><span class="line">&#x2F;&#x2F;若队列不空，则删除Q的队头元素，用e返回其值，并返回OK，否则返回ERROR</span><br><span class="line">if(Q.front &#x3D;&#x3D; Q.rear)</span><br><span class="line">return ERROR;</span><br><span class="line">p &#x3D; Q.front-&gt;next;</span><br><span class="line">e &#x3D; p-&gt;data;</span><br><span class="line">Q.front-&gt;next &#x3D; p-&gt;next;</span><br><span class="line">if(Q.rear &#x3D;&#x3D; p)&#x2F;&#x2F;队列中最后一个元素被删除，队列尾指针也丢失了，需对其也进行赋值</span><br><span class="line">Q.rear &#x3D; Q.front;</span><br><span class="line">free(p);</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环队列类型说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;-----循环队列——队列的顺序存储结构-----</span><br><span class="line">#defineMAXQSIZE100&#x2F;&#x2F;最大队列长度</span><br><span class="line">typedefstruct&#123;</span><br><span class="line">QElemType*base;&#x2F;&#x2F;初始化的动态分配存储空间</span><br><span class="line">intfront;&#x2F;&#x2F;头指针，若队列不空，指向队列头元素</span><br><span class="line">intrear;&#x2F;&#x2F;尾指针，若队列不空，指向队列尾元素的下一位置</span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-----循环队列的基本操作的算法描述-----</span><br><span class="line">StatusInitQueue(SqQueue &amp;Q)&#123;</span><br><span class="line">&#x2F;&#x2F;构造一个空队列Q</span><br><span class="line">Q.base &#x3D; (QElemType*)malloc(MAXSIZE * sizeof(QElemType));</span><br><span class="line">if(!Q.base)</span><br><span class="line">exit(OVERFLOW);</span><br><span class="line">Q.front &#x3D; Q.rear &#x3D; 0;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">intQueueLength(SqQueueQ)&#123;</span><br><span class="line">&#x2F;&#x2F;返回Q的元素个数，即队列的长度</span><br><span class="line">return (Q.rear - Q.front + MAXSIZE) % MASIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StatusEnQueue(SqQueue&amp;Q, QElemType e)&#123;</span><br><span class="line">&#x2F;&#x2F;插入元素e为Q的新的队尾元素</span><br><span class="line">if((Q.rear + 1) % MAXSIZE &#x3D;&#x3D; Q.front)</span><br><span class="line">return ERROR;&#x2F;&#x2F;队列满</span><br><span class="line">Q.base[Q.rear] &#x3D; e;</span><br><span class="line">Q.rear &#x3D; (Q.rear + 1) % MAXSIZE;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StatusDeQueue(SqQueue&amp;Q, QElemType &amp;e)&#123;</span><br><span class="line">&#x2F;&#x2F;若队列不空，则删除Q的队头元素，用e返回其值，并返回OK，否则返回ERROR</span><br><span class="line">if(Q.front &#x3D;&#x3D; Q.rear)</span><br><span class="line">returnERROR;</span><br><span class="line">e &#x3D; Q.base[Q.front];</span><br><span class="line">Q.front &#x3D; (Q.front + 1) % MAXSIZE;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>银行客户的离散事件驱动模拟程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void Bank_Simulation(int CloseTime)&#123;</span><br><span class="line">&#x2F;&#x2F;银行业务模拟，统计一天内客户在银行逗留的平均时间</span><br><span class="line"></span><br><span class="line">OpenForDay();&#x2F;&#x2F;初始化</span><br><span class="line">while(MoreEvent)&#123;</span><br><span class="line">EventDrived(OccurTime, EventType);&#x2F;&#x2F;事件驱动</span><br><span class="line">switch(EventType)&#123;</span><br><span class="line">case &#39;A&#39;:&#x2F;&#x2F;处理客户到达事件</span><br><span class="line">CustomerArrived();</span><br><span class="line">break;</span><br><span class="line">case &#39;D&#39;:&#x2F;&#x2F;处理客户离开事件</span><br><span class="line">CustomerDeparture();</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">Invalid();</span><br><span class="line">&#125;&#x2F;&#x2F;switch</span><br><span class="line">&#125;&#x2F;&#x2F;while</span><br><span class="line">CloseForDay;&#x2F;&#x2F;计算平均逗留时间</span><br><span class="line">&#125;&#x2F;&#x2F;Bank_Simulation</span><br></pre></td></tr></table></figure><p>所需有序链表和队列的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedefstruct&#123;</span><br><span class="line">intOccurTime;&#x2F;&#x2F;事件发生时刻</span><br><span class="line">intNType;&#x2F;&#x2F;事件类型，0表示到达事件，1至4表示四个窗口的离开事件</span><br><span class="line">&#125;Event, Elemtype;&#x2F;&#x2F;事件类型，有序链表LinkList的数据元素类型</span><br><span class="line"></span><br><span class="line">typedefLinkList EventList;&#x2F;&#x2F;事件链表类型，定义为有序链表</span><br><span class="line"></span><br><span class="line">typedefstruct&#123;</span><br><span class="line">intArrivalTime;&#x2F;&#x2F;到达时刻</span><br><span class="line">intDuration;&#x2F;&#x2F;办理事务所需时间</span><br><span class="line">&#125;QElemType;&#x2F;&#x2F;队列的数据元素类型</span><br></pre></td></tr></table></figure><p>银行事件驱动模拟程序算法实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;程序中用到的主要变量</span><br><span class="line">EventListev;&#x2F;&#x2F;事件表</span><br><span class="line">Eventen;&#x2F;&#x2F;事件</span><br><span class="line">LinkQueueq[5];&#x2F;&#x2F;4个客户队列</span><br><span class="line">QElemTypecustomer;&#x2F;&#x2F;客户记录</span><br><span class="line">intTotalTime, CustomerNum;&#x2F;&#x2F;累计客户逗留时间，客户数</span><br><span class="line"></span><br><span class="line">intcmp(Event a, Event b);</span><br><span class="line">&#x2F;&#x2F;依事件a发生的时刻&lt;,&#x3D;或&gt;事件b的发生时刻分别返回-1，0或1</span><br><span class="line"></span><br><span class="line">void OpenForDay()&#123;</span><br><span class="line">&#x2F;&#x2F;初始化操作</span><br><span class="line">TotalTime &#x3D; 0;&#x2F;&#x2F;初始化累计时间为0</span><br><span class="line">CustomerNum &#x3D; 0;&#x2F;&#x2F;初始化客户数为0</span><br><span class="line">InitList(ev);&#x2F;&#x2F;初始化事件链表为空表</span><br><span class="line">en.OcuurTime &#x3D; 0;</span><br><span class="line">en.NType &#x3D; 0;&#x2F;&#x2F;设定第一个客户到达事件</span><br><span class="line">OrderInsert(ev, en, cmp);&#x2F;&#x2F;插入事件表</span><br><span class="line">for(i&#x3D;1; i&lt;&#x3D;4; ++i)</span><br><span class="line">InitQueue(q[i]);&#x2F;&#x2F;置空队列</span><br><span class="line">&#125;&#x2F;&#x2F;OpenForDay</span><br><span class="line"></span><br><span class="line">void CustomerDeparture()&#123;</span><br><span class="line">&#x2F;&#x2F;处理客户离开事件，en.NType&gt;0</span><br><span class="line">i &#x3D; en.Ntype;</span><br><span class="line">DelQueue(q[i], customer);&#x2F;&#x2F;删除第i队列的排头客户</span><br><span class="line">TotalTime +&#x3D; en.OccurTime - customer.ArrivalTime;&#x2F;&#x2F;累计客户逗留时间</span><br><span class="line">if(!QueueEmpty(q[i]))&#123;&#x2F;&#x2F;设定第i队列的一个离开事件并插入事件表</span><br><span class="line">GetHead(q[i], customer);</span><br><span class="line">OrderInsert(ev, (en.OccurTime + customer.Duration, i),(*cmp)());</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;CustomerDeparture</span><br><span class="line"></span><br><span class="line">void Bank_Simulation(int CloseTime)&#123;</span><br><span class="line">OpenForDay();&#x2F;&#x2F;初始化</span><br><span class="line">while(!ListEmpty(ev))&#123;</span><br><span class="line">DelFirst(GetHead(ev), p);</span><br><span class="line">en 66&#x3D; GetCurElem(p);</span><br><span class="line">if(en.NType &#x3D;&#x3D; 0)</span><br><span class="line">CustomerArrived();&#x2F;&#x2F;处理客户到达事件</span><br><span class="line">else</span><br><span class="line">CustomerDeparture();&#x2F;&#x2F;处理客户离开事件</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;计算并输出平均逗留时间</span><br><span class="line">printf(&quot;The AverageTimeis%f\n&quot;,(float)TotalTime&#x2F;CustomerNum);</span><br><span class="line">&#125;&#x2F;&#x2F;Bank_Simulation</span><br></pre></td></tr></table></figure><h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><p>串的抽象数据类型定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">ADTString&#123;</span><br><span class="line">数据对象：D&#x3D;&#123;ai|ai∈CharacterSet, i &#x3D; 1,2,...,n, n&gt;&#x3D;0&#125;</span><br><span class="line">数据关系：R1&#x3D;&#123;&lt;a(i-1), ai&gt;|a(i-1),ai∈D, i &#x3D; 2,...,n&#125;</span><br><span class="line">基本操作：</span><br><span class="line">StrAssign(&amp;T, chars)</span><br><span class="line">初始条件：chars是字符串常量</span><br><span class="line">操作结果：生成一个其值等于chars的串T</span><br><span class="line">StrCopy(&amp;T, S)</span><br><span class="line">初始条件：串S存在</span><br><span class="line">操作结果：由串S复制得到串T</span><br><span class="line">StrEmpty(S)</span><br><span class="line">初始条件：串S存在</span><br><span class="line">操作结果：若S为空串，返回TRUE，否则返回FALSE</span><br><span class="line">StrCompare(S, T)</span><br><span class="line">初始条件：串S和T存在</span><br><span class="line">操作结果：若S&gt;T，则返回值&gt;0，若S&#x3D;T，则返回值&#x3D;0，若S&lt;T，则返回值&lt;0</span><br><span class="line">StrLength(S)</span><br><span class="line">初始条件：串S存在</span><br><span class="line">操作结果：返回S的元素个数，称为串的长度</span><br><span class="line">ClearString(&amp;S)</span><br><span class="line">初始条件：串S存在</span><br><span class="line">操作结果：将S清空为空串</span><br><span class="line">Concat(&amp;T, S1, S2)</span><br><span class="line">初始条件：串S1和S2存在</span><br><span class="line">操作结果：用T返回由S1和S2联接而成的新串</span><br><span class="line">SubString(&amp;Sub, S, pos, len)</span><br><span class="line">初始条件：串S存在，1&lt;&#x3D;pos&lt;&#x3D;StrLength(S)且0&lt;&#x3D;len&lt;&#x3D;StrLength(S)-pos+1</span><br><span class="line">操作结果：用Sub返回串S的第pos个字符起长度为len的子串</span><br><span class="line">Index(S, T, pos)</span><br><span class="line">初始条件：串S和T存在，T是非空串，1&lt;&#x3D;pos&lt;&#x3D;StrLength(S)</span><br><span class="line">操作结果：若主串S中存在和串T值相同的子串，则返回它在主串S中第pos个字符之后第一次出现的位置，否则函数值为0</span><br><span class="line">Replace(&amp;S, T, V)</span><br><span class="line">初始条件：串S，T和V存在，T是非空串</span><br><span class="line">操作结果：用V替换主串S中出现的所有与T相等的不重叠的子串</span><br><span class="line">StrInsert(&amp;S, pos, T)</span><br><span class="line">初始条件：串S和T存在，1&lt;&#x3D;pos&lt;&#x3D;SreLength(S)+1</span><br><span class="line">操作结果：在串S的第pos个字符之前插入串T</span><br><span class="line">StrDelete(&amp;S, pos, len)</span><br><span class="line">初始条件：串S存在，1&lt;&#x3D;pos&lt;&#x3D;StrLength(S)-len+1</span><br><span class="line">操作结果：从串S中删除第pos个字符起长度为len的字串</span><br><span class="line">DestoryString(&amp;S)</span><br><span class="line">初始条件：串S存在</span><br><span class="line">操作结果：串S被销毁</span><br><span class="line">&#125;ADT String</span><br></pre></td></tr></table></figure><p>利用判定、求串长和求子串等操作实现定位函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int Index(String S, String T, int pos)&#123;</span><br><span class="line">&#x2F;&#x2F;T为非空串。若主串S中第pos个字符之后存在与T相等的子串，则返回第一个这样的子串在S中的位置，否则返回0</span><br><span class="line">if(pos&gt;0)&#123;</span><br><span class="line">n &#x3D; StrLength(S);</span><br><span class="line">m &#x3D; StrLength(T);</span><br><span class="line">i &#x3D; pos;</span><br><span class="line">while(i &lt;&#x3D; n - m + 1)&#123;</span><br><span class="line">SubString(sub, S, i, m);</span><br><span class="line">if(StrCompare(sub,T) !&#x3D; 0)</span><br><span class="line">++i;</span><br><span class="line">else</span><br><span class="line">return i;&#x2F;&#x2F;返回子串在主串中的位置</span><br><span class="line">&#125;&#x2F;&#x2F;while</span><br><span class="line">&#125;&#x2F;&#x2F;if</span><br><span class="line">return 0;&#x2F;&#x2F;S中不存在与T相等的子串</span><br><span class="line">&#125;&#x2F;&#x2F;Index</span><br></pre></td></tr></table></figure><p>定长数组描述串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;-----串的定长顺序存储表示-----</span><br><span class="line">#defineMAXSTRLEN255&#x2F;&#x2F;用户可在255以内定义最大串长</span><br><span class="line">typedefunsigned charSString[MAXSTRLEN + 1];&#x2F;&#x2F;0号单元存放串的长度</span><br></pre></td></tr></table></figure><p>串联接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">StatusConcat(SString &amp;T,SString S1, SString S2)&#123;</span><br><span class="line">&#x2F;&#x2F;用T返回由S1和S2联接而成的新串。若未截断，则返回TRUE，否则返回FALSE</span><br><span class="line">if(S1[0] + S2[0] &lt;&#x3D; MAXSTRLEN)&#123;&#x2F;&#x2F;未截断</span><br><span class="line">T[1..S1[0]] &#x3D; S1[1..S1[0]];</span><br><span class="line">T[S1[0]+1..S1[0]+S2[0]] &#x3D; S2[1..S2[0]];</span><br><span class="line">T[0] &#x3D; S1[0] + S2[0];</span><br><span class="line">uncut &#x3D; TRUE;</span><br><span class="line">&#125;</span><br><span class="line">else if(S1[0] &lt; MAXSTRLEN)&#123;&#x2F;&#x2F;截断</span><br><span class="line">T[1..S1[0]] &#x3D; S1[1..S1[0]];</span><br><span class="line">T[S1[0] + 1..MAXSTRLEN] &#x3D; S2[1..MAXSTRLEN-S1[0]];</span><br><span class="line">T[0] &#x3D; MAXSTRLEN;</span><br><span class="line">uncut &#x3D; FALSE;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">T[0..MAXSTRLEN] &#x3D; S1[0..MAXSTRLEN];</span><br><span class="line">&#x2F;&#x2F;T[0] &#x3D;&#x3D; S1[0] &#x3D;&#x3D;MAXSTRLEN</span><br><span class="line">uncut &#x3D; FALSE;</span><br><span class="line">&#125;</span><br><span class="line">return uncut;</span><br><span class="line">&#125;&#x2F;&#x2F;Concat</span><br><span class="line">&#x2F;&#x2F;因为0位表示长度，故1..S1[0]表示从S1的第一个元素到最后一个元素，1..S2[0]同理</span><br></pre></td></tr></table></figure><p>求子串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">StatusSubString(SString &amp;Sub,SString S, int pos, int len)&#123;</span><br><span class="line">&#x2F;&#x2F;用Sub返回串S的第pos个字符起长度为Len的子串</span><br><span class="line">&#x2F;&#x2F;其中，1&lt;&#x3D;pos&lt;&#x3D;StrLength(S)且0&lt;&#x3D;len&lt;&#x3D;StrLength(S)-pos+1</span><br><span class="line">if(pos &lt; 1 || pos &gt; S[0] || len &lt; 0 || len &gt; S[0]-pos+1)</span><br><span class="line">return ERROR;</span><br><span class="line">Sub[1..len] &#x3D; S[pos..pos+len-1];</span><br><span class="line">Sub[0] &#x3D; len;</span><br><span class="line">returnOK;</span><br><span class="line">&#125;&#x2F;&#x2F;SubString</span><br></pre></td></tr></table></figure><p>堆分配存储表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;-----串的堆分配存储表示 -----</span><br><span class="line">typedefstruct&#123;</span><br><span class="line">char*ch;&#x2F;&#x2F;若是非空串，则按串长分配存储区，否则ch为NULL</span><br><span class="line">intlength;&#x2F;&#x2F;串长度</span><br><span class="line">&#125;HString;</span><br></pre></td></tr></table></figure><p>串的插入操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Status StrInsert(HString &amp;S, int pos, HString T)&#123;</span><br><span class="line">&#x2F;&#x2F;1&lt;&#x3D;pos&lt;&#x3D;Strlength(S)+1。在串的第pos个字符之前插入串T</span><br><span class="line">if(pos&lt;1||pos&gt;S.length+1)</span><br><span class="line">returnERROR;&#x2F;&#x2F;pos不合法</span><br><span class="line">if(T.length)&#123;&#x2F;&#x2F;T非空，则重新分配空间，插入T</span><br><span class="line">if(!(S.ch &#x3D; (char *)realloc(S.ch, (S.length+T.length)*sizeof(char))))</span><br><span class="line">exit(OVERFLOW);</span><br><span class="line">for(i&#x3D;S.length-1; i&gt;&#x3D;pos-1; --i)&#x2F;&#x2F;为插入T而腾出位置</span><br><span class="line">S.ch[i+T.length] &#x3D; S.ch[i];</span><br><span class="line">S.ch[pos-1..pos+T.length-2] &#x3D; T.ch[0..T.length-1];&#x2F;&#x2F;插入T</span><br><span class="line">S.length +&#x3D; T.length;</span><br><span class="line">&#125;</span><br><span class="line">return OK;</span><br><span class="line">&#125;&#x2F;&#x2F;StrInsert</span><br></pre></td></tr></table></figure><p>串的表示与实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;ADT String的表示与实现 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x2F;&#x2F;-----串的堆分配存储表示 -----</span><br><span class="line">typedefstruct&#123;</span><br><span class="line">char*ch;&#x2F;&#x2F;若是非空串，则按串长分配存储区，否则ch为NULL</span><br><span class="line">intlength;&#x2F;&#x2F;串长度</span><br><span class="line">&#125;HString;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-----基本操作的函数原型说明-----</span><br><span class="line">StatusStrAssign(HString &amp;T, char *chars);</span><br><span class="line">&#x2F;&#x2F;生成一个其值为串常量chars的串T</span><br><span class="line">intStrLength(HString S);</span><br><span class="line">&#x2F;&#x2F;返回S的元素个数，称为串的长度</span><br><span class="line">intStrCompare(HString S, HString T);</span><br><span class="line">&#x2F;&#x2F;若S&gt;T，则返回值&gt;0，若S&#x3D;T，则返回值&#x3D;0，若S&lt;T，则返回值&lt;0</span><br><span class="line">StatusClearString(HString &amp;S);</span><br><span class="line">&#x2F;&#x2F;将S清为空串，并释放S所占的空间</span><br><span class="line">StatusConcat(HString &amp;T, HString S1, HString S2);</span><br><span class="line">&#x2F;&#x2F;用T返回由S1和S2联接而成的新串</span><br><span class="line">HStringSubString(HString S, int pos, int len);</span><br><span class="line">&#x2F;&#x2F;1&lt;&#x3D;pos&lt;&#x3D;StrLength(S)且0&lt;&#x3D;len&lt;&#x3D;StrLength(S)-pos+1</span><br><span class="line">&#x2F;&#x2F;返回串S的第pos个字符起长度为len的子串</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-----基本操作的算法描述-----</span><br><span class="line">StatusStrAssign(HString &amp;T, char *chars)&#123;</span><br><span class="line">&#x2F;&#x2F;生成一个其值等于串常量chars的串T</span><br><span class="line">if(T.ch)</span><br><span class="line">free(T.ch);&#x2F;&#x2F;释放T原空间</span><br><span class="line">for(i&#x3D;0, c&#x3D;chars; *c; ++i, ++c)</span><br><span class="line">;&#x2F;&#x2F;求chars的长度i</span><br><span class="line">if(!i)&#123;</span><br><span class="line">T.ch &#x3D; NULL;</span><br><span class="line">T.length &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">if(!(T.ch&#x3D;(char *)malloc(i * sizeof(char))))</span><br><span class="line">exit(OVERFLOW);</span><br><span class="line">T.ch[0..i-1]&#x3D;chars[0..i-1];</span><br><span class="line">T.length &#x3D; i;</span><br><span class="line">&#125;</span><br><span class="line">returnOK;</span><br><span class="line">&#125;&#x2F;&#x2F;StrAssign</span><br><span class="line"></span><br><span class="line">intStrLength(HString S)&#123;</span><br><span class="line">&#x2F;&#x2F;返回S的元素个数，称为串的长度</span><br><span class="line">returnS.length;</span><br><span class="line">&#125;&#x2F;&#x2F;StrLength</span><br><span class="line"></span><br><span class="line">int StrCompare(HStringS, HStringT)&#123;</span><br><span class="line">&#x2F;&#x2F;若S&gt;T，则返回值&gt;0；若S&#x3D;T，则返回值&#x3D;0；若S&lt;T，则返回值&lt;0</span><br><span class="line">for(i&#x3D;0; i&lt;S.length&amp;&amp;S.T.length; ++i)</span><br><span class="line">if(S.ch[i]!&#x3D;T.ch[i])</span><br><span class="line">returnS.ch[i] - T.ch[i];</span><br><span class="line">returnS.length-T.length;</span><br><span class="line">&#125;&#x2F;&#x2F;StrCompare</span><br><span class="line"></span><br><span class="line">StatusClearString(HString&amp;S)&#123;</span><br><span class="line">&#x2F;&#x2F;将S清为空串</span><br><span class="line">if(S.ch)&#123;</span><br><span class="line">free(S.ch);</span><br><span class="line">S.ch &#x3D; NULL;</span><br><span class="line">&#125;</span><br><span class="line">S.length &#x3D; 0;</span><br><span class="line">returnOK;</span><br><span class="line">&#125;&#x2F;&#x2F;ClearString</span><br><span class="line"></span><br><span class="line">StatusConcat(HString&amp;T, HStringS1, HStringS2)&#123;</span><br><span class="line">&#x2F;&#x2F;用T返回由S1和S2联接而成的新串</span><br><span class="line">if(T.ch)</span><br><span class="line">free(T.ch);&#x2F;&#x2F;释放旧空间</span><br><span class="line">if(!(T.ch &#x3D; (char *)malloc((S1.length+S2.length) * sizeof(char))))</span><br><span class="line">exit(OVERFLOW);</span><br><span class="line">T.ch[0..S1.length-1] &#x3D; S1[0..S1.length-1];</span><br><span class="line">T.length &#x3D; S1.length + S2.length;</span><br><span class="line">T.ch[S1.length..T.length-1] &#x3D; S2.ch[0..S2.length-1];</span><br><span class="line">returnOK;</span><br><span class="line">&#125;&#x2F;&#x2F;Concat</span><br><span class="line"></span><br><span class="line">StatusSubString(HString &amp;Sub, HString S, int pos, int len)&#123;</span><br><span class="line">&#x2F;&#x2F;用Sub返回串S的第pos个字符起长度为len的子串</span><br><span class="line">&#x2F;&#x2F;其中，1&lt;&#x3D;pos&lt;&#x3D;StrLength(S)且0&lt;&#x3D;len&lt;&#x3D;StrLength(S)-pos+1</span><br><span class="line">if(pos &lt; 1 || pos &gt; S.length || len &lt; 0 || len &gt; S.length-pos+1)</span><br><span class="line">returnERROR;</span><br><span class="line">if(Sub.ch)</span><br><span class="line">free(Sub.ch);</span><br><span class="line">if(!len)&#123;</span><br><span class="line">Sub.ch &#x3D; NULL;</span><br><span class="line">Sub.length &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">Sub.ch &#x3D; (char *)malloc(len * sizeof(char));</span><br><span class="line">Sub.ch[0..len-1] &#x3D; S.ch[pos-1..pos+len-2];</span><br><span class="line">Sub.length &#x3D; len;</span><br><span class="line">&#125;</span><br><span class="line">returnOK;</span><br><span class="line">&#125;&#x2F;&#x2F;SubString</span><br></pre></td></tr></table></figure><p>串的块链结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;串的块链存储表示 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">#defineCHUNKSIZE80&#x2F;&#x2F;可由用户定义块的大小</span><br><span class="line">typedefstructChunk&#123;</span><br><span class="line">charch[CHUNKSIZE];</span><br><span class="line">structChunk*next;</span><br><span class="line">&#125;Chunk;</span><br><span class="line">typedefstruct&#123;</span><br><span class="line">Chunk*head, *tail;&#x2F;&#x2F;串的头和尾指针</span><br><span class="line">intcurlen;&#x2F;&#x2F;串的当前长度</span><br><span class="line">&#125;LString;</span><br></pre></td></tr></table></figure><p>求子串位置的定位函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">intIndex(SString S, SString T, intpos)&#123;</span><br><span class="line">&#x2F;&#x2F;返回子串T在主串S中第pos个字符之后的位置。若不存在，则函数值为0</span><br><span class="line">&#x2F;&#x2F;其中，T非空，1&lt;&#x3D;pos&lt;&#x3D;StrLength(S)</span><br><span class="line">i &#x3D; pos;</span><br><span class="line">j &#x3D; 1;</span><br><span class="line">while(i &lt;&#x3D; S[0] &amp;&amp; j &lt;&#x3D; T[0])&#123;</span><br><span class="line">if(S[i] &#x3D;&#x3D; T[j])&#123;</span><br><span class="line">++i;</span><br><span class="line">++j;</span><br><span class="line">&#125;&#x2F;&#x2F;继续比较后继字符</span><br><span class="line">else&#123;</span><br><span class="line">i &#x3D; i-j+2;</span><br><span class="line">j &#x3D; 1;</span><br><span class="line">&#125;&#x2F;&#x2F;指针后退重新开始匹配</span><br><span class="line">&#125;</span><br><span class="line">if(j &gt; T[0])</span><br><span class="line">returni-T[0];</span><br><span class="line">else</span><br><span class="line">return0;</span><br><span class="line">&#125;&#x2F;&#x2F;Index</span><br></pre></td></tr></table></figure><p>利用模式串的next()函数的KMP算法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">intIndex_KMP(SString S, SString T, intpos)&#123;</span><br><span class="line">&#x2F;&#x2F;利用模式串T的next函数求T在主串S中第pos个字符之后的位置的KMP算法</span><br><span class="line">&#x2F;&#x2F;其中，T非空，1&lt;&#x3D;pos&lt;&#x3D;StrLength(S)</span><br><span class="line">i &#x3D; pos;</span><br><span class="line">j &#x3D; 1;</span><br><span class="line">while(i &lt;&#x3D; S[0] &amp;&amp; j &lt;&#x3D; T[0])&#123;</span><br><span class="line">if( j &#x3D;&#x3D; 0 || S[i] &#x3D;&#x3D; T[j] )&#123;</span><br><span class="line">++i;</span><br><span class="line">++j;</span><br><span class="line">&#125;&#x2F;&#x2F;继续比较后继字符</span><br><span class="line">else</span><br><span class="line">j &#x3D; next[j];</span><br><span class="line">&#125;</span><br><span class="line">if(j &gt; T[0])</span><br><span class="line">returni - T[0];</span><br><span class="line">else</span><br><span class="line">return0;</span><br><span class="line">&#125;&#x2F;&#x2F;Index_KMP</span><br></pre></td></tr></table></figure><p>KMP算法中的next函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void get_next(SString T, int next[])&#123;</span><br><span class="line">&#x2F;&#x2F;求模式串T的next函数值并存入数组next</span><br><span class="line">i &#x3D; 1;</span><br><span class="line">next[1] &#x3D; 0;</span><br><span class="line">j &#x3D; 0;</span><br><span class="line">while(i &lt; T[0])&#123;</span><br><span class="line">if(j &#x3D;&#x3D; 0 || T[i] &#x3D;&#x3D; T[j])&#123;</span><br><span class="line">++i;</span><br><span class="line">++j;</span><br><span class="line">next[i] &#x3D; j;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">j &#x3D; next[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;get_next</span><br></pre></td></tr></table></figure><p>计算next函数修正值的算法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void get_nextval(SString T, int nextval[])&#123;</span><br><span class="line">&#x2F;&#x2F;求模式串T的next函数修正值并存入数组nextval</span><br><span class="line">i &#x3D; 1;</span><br><span class="line">nextval[1] &#x3D; 0;</span><br><span class="line">j &#x3D; 0;</span><br><span class="line">while(i&lt;T[0])&#123;</span><br><span class="line">if(j &#x3D;&#x3D; 0 || T[i] &#x3D;&#x3D; T[j])&#123;</span><br><span class="line">++i;</span><br><span class="line">++j;</span><br><span class="line">if(T[i] !&#x3D; T[j])</span><br><span class="line">nextval[i] &#x3D; j;</span><br><span class="line">else</span><br><span class="line">nextval[i] &#x3D; nextval[j];</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">j &#x3D; nextval[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;get_nextval</span><br></pre></td></tr></table></figure><p>词典索引表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#defineMaxBookNum1000&#x2F;&#x2F;假设只对1000本书建索引表</span><br><span class="line">#defineMaxKeyNum2500&#x2F;&#x2F;索引表的最大容量</span><br><span class="line">#defineMaxLineLen500&#x2F;&#x2F;书目串的最大长度</span><br><span class="line">#defineMaxWordNum10&#x2F;&#x2F;词表的最大容量</span><br><span class="line"></span><br><span class="line">typedefstruct&#123;</span><br><span class="line">char*item[];&#x2F;&#x2F;字符串的数组</span><br><span class="line">intlast;&#x2F;&#x2F;词表的长度</span><br><span class="line">&#125;WordListType;&#x2F;&#x2F;词表类型（顺序表）</span><br><span class="line">typedefintElemType;&#x2F;&#x2F;定义链表的数据元素类型为整型（书号类型）</span><br><span class="line">typedefstruct&#123;</span><br><span class="line">HStringkey;&#x2F;&#x2F;关键词</span><br><span class="line">LinkList bnolist;&#x2F;&#x2F;存放书号索引的链表</span><br><span class="line">&#125;IdxTermType;&#x2F;&#x2F;索引项类型</span><br><span class="line">typedefstruct&#123;</span><br><span class="line">IdxTermTypeitem[MaxKetNum+1];</span><br><span class="line">intlast;</span><br><span class="line">&#125;IdxListType;&#x2F;&#x2F;索引表类型（有序表）</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;主要变量</span><br><span class="line">char*buf;&#x2F;&#x2F;书目串缓冲区</span><br><span class="line">WordListTypewdlist;&#x2F;&#x2F;词表</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;基本操作</span><br><span class="line">voidInitIdxList(IdxListType&amp;idxlist);</span><br><span class="line">&#x2F;&#x2F;初始化操作，置索引表idxlist为空表，且在idxlist.item[0]设一空串</span><br><span class="line">voidGetLine(FILE f);</span><br><span class="line">&#x2F;&#x2F;从文件f读入一个书目信息到书目缓冲区buf</span><br><span class="line">voidExtractKeyWord(ElemType&amp;bno);</span><br><span class="line">&#x2F;&#x2F;从buf中提取书名关键词到词表wdlist，书号存入bno</span><br><span class="line">StatusInsIdxList(IdxListType &amp;idxlist, ElemType bno);</span><br><span class="line">&#x2F;&#x2F;将书号为bno的书名关键词按词典顺序插入索引表idxlist</span><br><span class="line">void PutText(FILE g, IdxListType idxlist);</span><br><span class="line">&#x2F;&#x2F;将生成的索引表idxlist输出到文件g</span><br><span class="line"></span><br><span class="line">void main()&#123;&#x2F;&#x2F;主函数</span><br><span class="line">if(f &#x3D; openf(&quot;BookInfo.txt&quot;,&quot;r&quot;))&#123;</span><br><span class="line">if(g &#x3D; openf(&quot;BookIdx.txt&quot;,&quot;w&quot;))&#123;</span><br><span class="line">InitIdxList(idxlist);&#x2F;&#x2F;初始化索引表idxlist为空表</span><br><span class="line">while(!feof(f))&#123;</span><br><span class="line">GetLine(f);&#x2F;&#x2F;从文件f读入一个书目信息到buf</span><br><span class="line">ExtractKeyWord(BookNo);&#x2F;&#x2F;从buf提取关键词到词表，书号存入BookNo</span><br><span class="line">InsIdxList(idxlist, BookNo);&#x2F;&#x2F;将书号为BookNo的关键词插入索引表</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">PutText(g, idxlist);&#x2F;&#x2F;将生成的索引表idxlist输出到文件g</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;main</span><br></pre></td></tr></table></figure><p>实现插入操作所必须函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">voidGetWord(int i, HString&amp;wd);</span><br><span class="line">&#x2F;&#x2F;用wd返回词表wdlist中第i个关键词</span><br><span class="line">intLocate(IdxListType idxlist, HString wd, Boolean &amp;b);</span><br><span class="line">&#x2F;&#x2F;在索引表idxlist中查询是否存在与wd相等的关键词</span><br><span class="line">&#x2F;&#x2F;若存在，则返回其在索引表中的位置，且b取值TRUE，否则返回插入位置，且b取值FALSE</span><br><span class="line">void InsertNewKey(IdxListType &amp;idxlist, int i, HString wd);</span><br><span class="line">&#x2F;&#x2F;在索引表idxlist的第i项上插入新关键词wd，并初始化书号索引的链表为空表</span><br><span class="line">StatusInsIdxList(IdxListType&amp;idxlist, int i, int bno);</span><br><span class="line">&#x2F;&#x2F;在索引表idxlist的第i项中插入书号为bno的索引</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;插入算法</span><br><span class="line">StatusInsIdxList(IdxListType &amp;idxlist, int bno)&#123;</span><br><span class="line">for(i&#x3D;0; i&lt;wdlist.last; ++i)&#123;</span><br><span class="line">GetWord(i, wd);</span><br><span class="line">j &#x3D; Locate(idxlist, wd, b);</span><br><span class="line">if(!b)</span><br><span class="line">InsertNewKey(idxlist, j, wd);&#x2F;&#x2F;插入新的索引项</span><br><span class="line">if(!InsertBook(idxlist,j,bno))</span><br><span class="line">returnOVERFLOW；&#x2F;&#x2F;插入书号索引</span><br><span class="line">&#125;</span><br><span class="line">returnOK;</span><br><span class="line">&#125;&#x2F;&#x2F;InsertIdxList</span><br><span class="line"></span><br><span class="line">void GetWord(int i, HString &amp;wd)&#123;</span><br><span class="line">p&#x3D; *(wd.list.item + i);&#x2F;&#x2F;取词表中第i个字符串</span><br><span class="line">StrAssign(wd,p);&#x2F;&#x2F;生成关键字字符串</span><br><span class="line">&#125;&#x2F;&#x2F;GetWord</span><br><span class="line"></span><br><span class="line">int Locate(IdxListType&amp;idxlist, HString wd, Boolean &amp;b)&#123;</span><br><span class="line">for(i &#x3D; idxlist.last - 1; (m &#x3D; StrCompare(idxlist.item[i].key, wd)) &gt; 0; --i)</span><br><span class="line">;</span><br><span class="line">if(m&#x3D;&#x3D;0)&#123;</span><br><span class="line">b &#x3D;TRUE;</span><br><span class="line">returni;&#x2F;&#x2F;找到</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">b &#x3D; FALSE;</span><br><span class="line">return i+1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;Locate</span><br><span class="line"></span><br><span class="line">void InsertNewKey(int i, StrType wd)&#123;</span><br><span class="line">for(j &#x3D; idxlist.last-1; j&gt;&#x3D;1; --j)&#x2F;&#x2F;后移索引项</span><br><span class="line">idxlist.item[j+1] &#x3D; idxlist.item[j];</span><br><span class="line">&#x2F;&#x2F;插入新的索引项</span><br><span class="line">StrCopy(idxlist.item[i].key, wd);&#x2F;&#x2F;串赋值</span><br><span class="line">InitList(idxlist.item[i].bnolist);&#x2F;&#x2F;初始化书号索引表为空表</span><br><span class="line">++idxlist.last;</span><br><span class="line">&#125;&#x2F;&#x2F;InsertNewKey</span><br><span class="line"></span><br><span class="line">StatusInsertBook(IdxListType &amp;idxlist, int i, int bno)&#123;</span><br><span class="line">if(!MakeNode(p, bno))</span><br><span class="line">returnERROR;&#x2F;&#x2F;分配失败</span><br><span class="line">Appand(idxlist.item[i].bnolist, p);&#x2F;&#x2F;插入新的书号索引</span><br><span class="line">returnOK;</span><br><span class="line">&#125;&#x2F;&#x2F;InserBook</span><br></pre></td></tr></table></figure><h2 id="数组与广义表"><a href="#数组与广义表" class="headerlink" title="数组与广义表"></a>数组与广义表</h2><p>数组的抽象数据类型定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ADTArray&#123;</span><br><span class="line">数据对象：ji&#x3D;0,...,bi-1,i &#x3D; 1,2,...,n</span><br><span class="line">D &#x3D; &#123;aj1j2...jn |n(&gt;0)称为数组的维数，bi是数组第i维的长度，ji是数组元素的第i维下标，aj1j2...jn∈ElemSet&#125;</span><br><span class="line">数据关系：R &#x3D; &#123;R1, R2, ..., Rn&#125;</span><br><span class="line">Ri &#x3D; &#123;&lt;aj1...ji...jn , aj1...ji+1...jn&gt;|0&lt;&#x3D;jk&lt;&#x3D;bk-1, 1&lt;&#x3D;k&lt;&#x3D;n且k≠i,0&lt;&#x3D;ji&lt;&#x3D;bi-2,aj1...ji...jn , aj1...ji+1...jn∈D, i&#x3D;2,...,n&#125;</span><br><span class="line">基本操作：</span><br><span class="line">InitArray(&amp;A, n, bound1, ..., boundn)</span><br><span class="line">操作结果：若维数n和各维长度合法，则构造相应数组A，并返回OK</span><br><span class="line">DestroyArray(&amp;A)</span><br><span class="line">操作结果：销毁数组A</span><br><span class="line">value(A, &amp;e, index1, ..., indexn)</span><br><span class="line">初始条件：A是n维数组，e为元素变量，随后是n个下标值</span><br><span class="line">操作结果：若各下标不超界，则e赋值为所指定的A的元素值，并返回OK</span><br><span class="line">Assign(&amp;A, e, index1, ..., indexn)</span><br><span class="line">初始条件：A是n维数组，e为元素变量，随后是n个下标</span><br><span class="line">操作结果：若下标不越界，则将e的值赋给所指定的A的元素，并返回OK</span><br><span class="line">&#125;ADT Array</span><br></pre></td></tr></table></figure><p>数组的顺序存储表示及实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;-----数组的顺序存储表示 -----</span><br><span class="line">#include&lt;stdio.h&gt;&#x2F;&#x2F;标准头文件，提供宏va_start、va_arg和va_end</span><br><span class="line">&#x2F;&#x2F;用于存取变长参数表</span><br><span class="line">#defineMAX_ARRAY_DIM8&#x2F;&#x2F;假设数组维数的最大值为8</span><br><span class="line">typedefstruct&#123;</span><br><span class="line">ElemType*base;&#x2F;&#x2F;数组元素基址，由InitArray分配</span><br><span class="line">intdim;&#x2F;&#x2F;数组维数</span><br><span class="line">int*bounds;&#x2F;&#x2F;数组维数基址，由InitArray分配</span><br><span class="line">int*constanst;&#x2F;&#x2F;数组映像函数常量基址，由InitArray分配</span><br><span class="line">&#125;Array;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-----基本操作的函数原型说明 -----</span><br><span class="line">StatusInitArray(Array&amp;A, intdim, ...);</span><br><span class="line">&#x2F;&#x2F;若维数dim和各维长度合法，则构造相应的数组A，并返回OK</span><br><span class="line">StatusDestroyArray(Array&amp;A);</span><br><span class="line">&#x2F;&#x2F;销毁数组A</span><br><span class="line">StatusValue(ArrayA, ElemType&amp;e, ...);</span><br><span class="line">&#x2F;&#x2F;A是n维数组，e为元素变量，随后是n个下标值</span><br><span class="line">&#x2F;&#x2F;若各下标不超界，则e的赋值给所指定的A的元素值，并返回OK</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-----基本操作的算法描述 -----</span><br><span class="line">StatusInitArray(Array&amp;A, int dim, ...)&#123;</span><br><span class="line">&#x2F;&#x2F;若维数dim和各维长度合法，则构造相应的数组A，并返回OK</span><br><span class="line">if(dim &lt; 1 || dim &gt; MAX_ARRAY_DIM)</span><br><span class="line">returnERROR;</span><br><span class="line">A.dim &#x3D; dim;</span><br><span class="line">A.bounds &#x3D; (int*)malloc(dim * sizeof( int ));</span><br><span class="line">if(!A.bounds)</span><br><span class="line">exit(OVERFLOW);</span><br><span class="line">&#x2F;&#x2F;若各维长度合法，则存入A.bounds，并求出A的元素总数elemtotal</span><br><span class="line">elemtotal &#x3D; 1;</span><br><span class="line">va_start(ap, dim);&#x2F;&#x2F;ap为va_list类型，是存放变长参数表信息的数组</span><br><span class="line">for(i &#x3D; 0; i&lt;dim; ++i)&#123;</span><br><span class="line">A.bounds[i] &#x3D; va_arg(ap, int);</span><br><span class="line">if(A.bounds[i]&lt;0)</span><br><span class="line">returnUNDERFLOW;</span><br><span class="line">elemtotal *&#x3D; A.bounds[i];</span><br><span class="line">&#125;</span><br><span class="line">va_end(ap);</span><br><span class="line">A.base &#x3D; (ElemType*)malloc(elemtotal * sizeof(ElemType));</span><br><span class="line">if(!A.base)</span><br><span class="line">exit(OVERFLOW);</span><br><span class="line">&#x2F;&#x2F;求映像函数的常数c，并存入A.constants[i-1], i &#x3D; 1,...,dim</span><br><span class="line">A.constants &#x3D; (int *)malloc(dim * sizeof(int));</span><br><span class="line">if(!A.constants)</span><br><span class="line">exit(OVERFLOW);</span><br><span class="line">A.constants[dim-1] &#x3D; 1;&#x2F;&#x2F;L&#x3D;1，指针的增减以元素的大小为单位</span><br><span class="line">for( i &#x3D; dim-2; i&gt;&#x3D;0; --i )</span><br><span class="line">A.constants[i] &#x3D; A.bounds[i + 1] * A.constants[i + 1];</span><br><span class="line">returnOK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StatusDestroyArray(Array&amp;A)&#123;</span><br><span class="line">&#x2F;&#x2F;销毁数组A</span><br><span class="line">if(！A.base)</span><br><span class="line">returnERROR;</span><br><span class="line">free(A.base);</span><br><span class="line">A.base &#x3D; NULL;</span><br><span class="line">if(A.bounds)</span><br><span class="line">returnERROR;</span><br><span class="line">free(A.bounds);</span><br><span class="line">A.bounds &#x3D; NULL;</span><br><span class="line">if(!A.constants)</span><br><span class="line">returnERROR;</span><br><span class="line">free(A.constants);</span><br><span class="line">A.constants &#x3D; NULL;</span><br><span class="line">returnOK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StatusLocate(Array A, va_list ap, int&amp;off)&#123;</span><br><span class="line">&#x2F;&#x2F;若ap指示的各下标值合法，则求出该元素在A中的相对地址off</span><br><span class="line">off &#x3D; 0;</span><br><span class="line">for( i &#x3D; 0; i&lt;A.dim; ++i)&#123;</span><br><span class="line">ind &#x3D; va_arg(ap, int);</span><br><span class="line">if(ind&lt;0 || ind&gt;&#x3D;A.bounds[i])</span><br><span class="line">returnOVERFLOW;</span><br><span class="line">off +&#x3D; A.constants[i] * ind;</span><br><span class="line">&#125;</span><br><span class="line">returnOK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StatusValue(Array A, ElemType&amp;e, ...)&#123;</span><br><span class="line">&#x2F;&#x2F;A是n维数组，e为元素变量，随后是n个下标值</span><br><span class="line">&#x2F;&#x2F;若各下标值不超界，则e赋值为所指定的A的元素值，并返回OK</span><br><span class="line">va_start(ap, e);</span><br><span class="line">if((result &#x3D; Locate(A, ap, off))&lt;&#x3D;0)</span><br><span class="line">returnresult;</span><br><span class="line">e &#x3D; *(A.base + off);</span><br><span class="line">returnOK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StatusAssign(Array &amp;A, ElemType e, ...)&#123;</span><br><span class="line">&#x2F;&#x2F;A是n维数组，e为元素变量，随后是n个下标值</span><br><span class="line">&#x2F;&#x2F;若下标不超界，则将e的值赋给所指定的A的元素，并返回OK</span><br><span class="line">va_start(ap, e);</span><br><span class="line">if((result &#x3D; Locate(A, ap, off))&lt;&#x3D;0)</span><br><span class="line">returnresult;</span><br><span class="line">*(A.base + off) &#x3D; e;</span><br><span class="line">returnOK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>稀疏矩阵的抽象数据类型定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">ADTSparseMatrix&#123;</span><br><span class="line">数据对象：D &#x3D; &#123;aij|i &#x3D; 1,2,...,n;ai,j∈ElemSet，m和n分别称为矩阵的行数和列数&#125;</span><br><span class="line">数据关系：R &#x3D; &#123;Row, Col&#125;</span><br><span class="line">Row &#x3D; &#123;&lt;ai,j,ai,j+1&gt;| 1&lt;&#x3D;i&lt;&#x3D;m, 1&lt;&#x3D;j&lt;&#x3D;n-1&#125;</span><br><span class="line">Col &#x3D; &#123;&lt;ai,j,ai+1,j&gt;| 1&lt;&#x3D;i&lt;&#x3D;m-1, 1&lt;&#x3D;j&lt;&#x3D;n&#125; </span><br><span class="line">基本操作：</span><br><span class="line">CreateSMatrix(&amp;M);</span><br><span class="line">操作结果：创建稀疏矩阵M</span><br><span class="line">DestroySMatrix(&amp;M);</span><br><span class="line">初始条件：稀疏矩阵M存在</span><br><span class="line">操作结果：销毁稀疏矩阵M</span><br><span class="line">PrintSMatrix(M);</span><br><span class="line">初始条件：稀疏矩阵M存在</span><br><span class="line">操作结果：输出稀疏矩阵M</span><br><span class="line">CopySMatrix(M, &amp;T);</span><br><span class="line">初始条件：稀疏矩阵M存在</span><br><span class="line">操作结果：由稀疏矩阵M复制得到T</span><br><span class="line">AddSMatrix(M, N, &amp;Q);</span><br><span class="line">初始条件：稀疏矩阵M与N的行数与列数对应相等</span><br><span class="line">操作结果：求稀疏矩阵的和Q &#x3D; M + N</span><br><span class="line">SubSMatrix(M, N, &amp;Q);</span><br><span class="line">初始条件：稀疏矩阵M与N的行数与列数对应相等</span><br><span class="line">操作结果：求稀疏矩阵的差Q &#x3D; M - N</span><br><span class="line">MultSMatrix(M, N, &amp;Q);</span><br><span class="line">初始条件：稀疏矩阵M的列数等于N的行数</span><br><span class="line">操作结果：求稀疏矩阵乘积Q &#x3D; M * N</span><br><span class="line">TransposeSmatrix(M, &amp;T);</span><br><span class="line">初始条件：稀疏矩阵M存在</span><br><span class="line">操作结果：求稀疏矩阵M的转置矩阵T</span><br><span class="line">&#125;ADT SparseMatrix</span><br></pre></td></tr></table></figure><p>稀疏矩阵的三元组表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;-----稀疏矩阵的三元组顺序表存储表示-----</span><br><span class="line">#defineMAXSIZE12500&#x2F;&#x2F;假设非零元个数的最大值为12500</span><br><span class="line">typedefstruct&#123;</span><br><span class="line">inti, j;&#x2F;&#x2F;该非零元的行下标和列下标</span><br><span class="line">ElemTypee;</span><br><span class="line">&#125;Triple</span><br><span class="line">typedefstruct&#123;</span><br><span class="line">Tripledata[MAXSIZE + 1];&#x2F;&#x2F;非零元三元组表，data[0]未用</span><br><span class="line">intmu, nu, tu;&#x2F;&#x2F;矩阵的行数，列数和非零元个数</span><br><span class="line">&#125;TSMatrix;</span><br></pre></td></tr></table></figure><p>三元组表示求稀疏矩阵的转置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">StatusTransposeSMatrix(TSMatrix M, TSMatrix &amp;T)&#123;</span><br><span class="line">&#x2F;&#x2F;采用三元组表存储表示，求稀疏矩阵M的转置矩阵T</span><br><span class="line">T.mu &#x3D; M.nu;</span><br><span class="line">T.nu &#x3D; M.nu;</span><br><span class="line">T.tu &#x3D; M.tu;</span><br><span class="line">if(T.tu)&#123;</span><br><span class="line">q &#x3D; 1;</span><br><span class="line">for(col &#x3D; 1; col&lt;&#x3D;M.nu; ++col)&#123;</span><br><span class="line">for(p &#x3D; 1; p&lt;&#x3D;M.tu; ++p)&#123;</span><br><span class="line">if(M.data[p].j &#x3D;&#x3D; col)&#123;</span><br><span class="line">T.data[q].i &#x3D; M.data[p].j;</span><br><span class="line">T.data[q].j &#x3D; M.data[p].i;</span><br><span class="line">T.data[q].e &#x3D; M.data[p].e;</span><br><span class="line">++q;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">returnOK;</span><br><span class="line">&#125;&#x2F;&#x2F;TransposeSMatrix</span><br></pre></td></tr></table></figure><p>快速转置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">StatusFastTransposeSMatrix(TSMatrix M, TSMatrix &amp;T)&#123;</span><br><span class="line">&#x2F;&#x2F;采用三元组顺序表存储表示，求稀疏矩阵M的转置矩阵T</span><br><span class="line">T.mu &#x3D; M.nu;</span><br><span class="line">T.nu &#x3D; M.mu;</span><br><span class="line">T.tu &#x3D; M.tu;</span><br><span class="line">if(T.tu)&#123;</span><br><span class="line">for(col &#x3D; 1; col&lt;&#x3D;M.nu; ++col)</span><br><span class="line">num[col] &#x3D; 0;</span><br><span class="line">for(t &#x3D; 1; t&lt;&#x3D;M.tu; ++t)</span><br><span class="line">++num[M.data[t].j];&#x2F;&#x2F;求M中每一列含非零元个数</span><br><span class="line">cpot[1] &#x3D; 1;</span><br><span class="line">&#x2F;&#x2F;求第col列中第一个非零元在b.data中的序号</span><br><span class="line">for(col &#x3D; 2; col&lt;&#x3D;M.nu; ++col)</span><br><span class="line">cpot[col] &#x3D; cpot[col - 1] + num[col - 1];</span><br><span class="line">for(p &#x3D; 1; p&lt;&#x3D;M.tu; ++p)&#123;</span><br><span class="line">col &#x3D; M.data[p].j;</span><br><span class="line">q &#x3D; cpot[col];</span><br><span class="line">T.data[q].i &#x3D; M.data[p].j;</span><br><span class="line">T.data[q].j &#x3D; M.data[p].i;</span><br><span class="line">T.data[q].e &#x3D; M.data[p].e;</span><br><span class="line">++cpot[col];</span><br><span class="line">&#125;&#x2F;&#x2F;for</span><br><span class="line">&#125;&#x2F;&#x2F;if</span><br><span class="line">returnOK;</span><br><span class="line">&#125;&#x2F;&#x2F;FastTransposeSmatrix</span><br></pre></td></tr></table></figure><p>行逻辑链接的顺序表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedefstruct&#123;</span><br><span class="line">Tripledata[MAXSIZE + 1];&#x2F;&#x2F;非零元三元组表</span><br><span class="line">intrpos[MAXRC + !];&#x2F;&#x2F;各行第一个非零元的位置表</span><br><span class="line">intmu, nu, tu;&#x2F;&#x2F;矩阵的行数、列数和非零元个数</span><br><span class="line">&#125;RLSMatrix;</span><br></pre></td></tr></table></figure><p>两个矩阵相乘的过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Q初始化;</span><br><span class="line">if(Q是非零矩阵)&#123;&#x2F;&#x2F;逐行压缩</span><br><span class="line">for(arow &#x3D; 1; arow&lt;&#x3D;M.mu; ++arow)&#123;&#x2F;&#x2F;处理M的每一行</span><br><span class="line">ctemp[ ] &#x3D; 0;&#x2F;&#x2F;累加器清零</span><br><span class="line">计算Q中第arow行的积并存入ctemp[ ]中;</span><br><span class="line">将ctemp[ ]中的非零元压缩存储到Q.data;</span><br><span class="line">&#125;&#x2F;&#x2F;forarow</span><br><span class="line">&#125;&#x2F;&#x2F;if</span><br></pre></td></tr></table></figure><p>求精后可得：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">StatusMultSMatrix(RLSMatrix M, RLSMatrix N, RLSMatrix&amp;Q)&#123;</span><br><span class="line">&#x2F;&#x2F;求矩阵乘积Q &#x3D; M * N，采用行逻辑链接存储表示</span><br><span class="line">if(M.nu !&#x3D; N.mu)</span><br><span class="line">returnERROR;</span><br><span class="line">Q.mu &#x3D; M.mu;</span><br><span class="line">Q.nu &#x3D; N.nu;</span><br><span class="line">Q.tu &#x3D; 0;&#x2F;&#x2F;Q初始化</span><br><span class="line">if(M.tu * N.tu !&#x3D; 0)&#123;&#x2F;&#x2F;Q是非零矩阵</span><br><span class="line">for(arow &#x3D; 1; arow&lt;&#x3D;M.mu; ++arow)&#123;&#x2F;&#x2F;处理M的每一行</span><br><span class="line">ctemp[ ] &#x3D; 0;&#x2F;&#x2F;当前行各元素累加器清零</span><br><span class="line">Q.rpos[arow] &#x3D; Q.tu + 1;</span><br><span class="line">if(arow&lt;M.mu)</span><br><span class="line">tp &#x3D; M.rpos[arow + 1];</span><br><span class="line">else&#123;</span><br><span class="line">tp &#x3D; M.tu + 1;</span><br><span class="line">&#125;</span><br><span class="line">for(p &#x3D; M.rpos[arow]; p&lt;tp; ++p)&#123;&#x2F;&#x2F;对当前行中每一个非零元</span><br><span class="line">brow &#x3D; M.data[p].j;&#x2F;&#x2F;找到对应元在N中的行号</span><br><span class="line">if(brow &lt; N.mu)</span><br><span class="line">t &#x3D; N.rpos[brow + 1];</span><br><span class="line">else&#123;</span><br><span class="line">t &#x3D; N.tu + 1;</span><br><span class="line">&#125;</span><br><span class="line">for(q &#x3D; N.rpos[brow]; q&lt;t; ++q)&#123;</span><br><span class="line">ccol &#x3D; N.data[q].j;&#x2F;&#x2F;乘积元素在Q中列号</span><br><span class="line">ctemp[ccol] +&#x3D; M.data[p].e * N.data[q].e;</span><br><span class="line">&#125;&#x2F;&#x2F;for q</span><br><span class="line">&#125;&#x2F;&#x2F;求得Q中第crow( &#x3D;arow)行的非零元</span><br><span class="line">for(ccol &#x3D; 1; ccol&lt;&#x3D;Q.nu; ++ccol)&#x2F;&#x2F;压缩存储该行非零元</span><br><span class="line">if(ctemp[ccol])&#123;</span><br><span class="line">if( ++Q.tu &gt; MAXSIZE)</span><br><span class="line">returnERROR;</span><br><span class="line">Q.data[Q.tu] &#x3D; (arow, ccol, ctemp[ccol]);</span><br><span class="line">&#125;&#x2F;&#x2F;if</span><br><span class="line">&#125;&#x2F;&#x2F;for arow</span><br><span class="line">&#125;&#x2F;&#x2F;if</span><br><span class="line">returnOK;</span><br><span class="line">&#125;&#x2F;&#x2F;MultSMatrix</span><br></pre></td></tr></table></figure><p>稀疏矩阵的十字链表存储表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;-----稀疏矩阵的十字链表存储表示 -----</span><br><span class="line">typedefstruct OLNode&#123;</span><br><span class="line">inti, j;&#x2F;&#x2F;该非零元的行和列下标</span><br><span class="line">ElemTypee;</span><br><span class="line">structOLNode*right, *down;&#x2F;&#x2F;该非零元所在行表和列表的后继链域</span><br><span class="line">&#125;OLNode;*OLink;</span><br><span class="line"></span><br><span class="line">typedefstruct&#123;</span><br><span class="line">Olink*rhead, *chead;&#x2F;&#x2F;行和列链表的头指针向量基址，由CreatSMatrix分配</span><br><span class="line">intmu, nu, tu;&#x2F;&#x2F;稀疏矩阵的行数、列数和非零元个数</span><br><span class="line">&#125;CrossList;</span><br><span class="line"></span><br><span class="line">StatusCreatSMatrix_OL(CrossList &amp;M)&#123;</span><br><span class="line">&#x2F;&#x2F;创建稀疏矩阵，用十字链表存储表示</span><br><span class="line">if(M)</span><br><span class="line">free(M);</span><br><span class="line">scanf(&amp;m, &amp;n, &amp;t);&#x2F;&#x2F;输入m的行数、列数和非零元个数</span><br><span class="line">M.mu :&#x3D; m；</span><br><span class="line">M.nu :&#x3D; n;</span><br><span class="line">M.tu :&#x3D; t;</span><br><span class="line">if(!(M.rhead &#x3D; (OLink *)malloc((m + 1) * sizeof(OLink))))</span><br><span class="line">exit(OVERFLOW);</span><br><span class="line">if(!(M.chead &#x3D; (OLink *)malloc((m + 1) * sizeof(OLink))))</span><br><span class="line">exit(OVERFLOW);</span><br><span class="line">M.rhead[ ] &#x3D; M.chead[ ] &#x3D; NULL;&#x2F;&#x2F;初始化行列头指针向量；各行列链表为空链表</span><br><span class="line">for(scanf(&amp;i, &amp;j, &amp;e); i!&#x3D;0; scanf(&amp;i, &amp;j, &amp;e))&#123;&#x2F;&#x2F;按任意次序输入非零元</span><br><span class="line">if(!(p &#x3D; (OLNode *)malloc(sizeof(OLNode))))</span><br><span class="line">exit(OVERFLOW);</span><br><span class="line">p-&gt;i &#x3D; i;</span><br><span class="line">p-&gt;j &#x3D; j;</span><br><span class="line">p-&gt;e &#x3D; e;&#x2F;&#x2F;生成结点</span><br><span class="line">if(M.rhead[i] &#x3D;&#x3D; NULL || M.rhead[i]-&gt;j&gt;j)&#123;</span><br><span class="line">p-&gt;right &#x3D; M.rhead[i];</span><br><span class="line">M.rhead[i] &#x3D; p;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;&#x2F;&#x2F;巡查在行表中的插入位置</span><br><span class="line">for( q &#x3D; M.rhead[i]; (q-&gt;right) &amp;&amp; q-&gt;right-&gt;j&lt;j; q &#x3D; q-&gt;right)</span><br><span class="line">;</span><br><span class="line">p-&gt;right &#x3D; q-&gt;right;</span><br><span class="line">q-&gt;rignt &#x3D; p;</span><br><span class="line">&#125;&#x2F;&#x2F;完成行插入</span><br><span class="line">if(M.chead[j] &#x3D;&#x3D; NULL || M.chead[j]-&gt;i&gt;i)&#123;</span><br><span class="line">p-&gt;down &#x3D; M.chead[j];</span><br><span class="line">M.chead[j] &#x3D; p;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;&#x2F;&#x2F;巡查在列表中的插入位置</span><br><span class="line">for( q &#x3D; M.chead[i]; (q-&gt;down) &amp;&amp; q-&gt;down-&gt;i&lt;i; q &#x3D; q-&gt;down)</span><br><span class="line">;</span><br><span class="line">p-&gt;down &#x3D; q-&gt;down;</span><br><span class="line">q-&gt;down &#x3D; p;</span><br><span class="line">&#125;&#x2F;&#x2F;完成列插入</span><br><span class="line">&#125;</span><br><span class="line">returnOK;</span><br><span class="line">&#125;&#x2F;&#x2F;CreateSMatrix_OL</span><br></pre></td></tr></table></figure><p>广义表的抽象数据类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">ADTGList&#123;</span><br><span class="line">数据对象：D &#x3D; &#123;ei|i &#x3D; 1,2,...,n;ei∈AtomSet或ei∈GList,AtomSet为某个元素的数据对象&#125;</span><br><span class="line">数据关系：R1 &#x3D; &#123;&lt;ei-1, ei&gt;|ei-1,ei∈D, 2&lt;&#x3D;i&lt;&#x3D;n&#125;</span><br><span class="line">基本操作：</span><br><span class="line">InitGList(&amp;L);</span><br><span class="line">操作结果：创建空间的广义表L</span><br><span class="line">CreateGList(&amp;L, S);</span><br><span class="line">初始条件：S是广义表的书写形式串</span><br><span class="line">操作结果：由S创建广义表L</span><br><span class="line">DestroyGList(&amp;L);</span><br><span class="line">初始条件：广义表L存在</span><br><span class="line">操作结果：销毁广义表L</span><br><span class="line">CopyGList(&amp;T, L);</span><br><span class="line">初始条件：广义表L存在</span><br><span class="line">操作结果：由广义表L复制得到广义表T</span><br><span class="line">GListLength(L);</span><br><span class="line">初始条件：广义表L存在</span><br><span class="line">操作结果：求广义表的长度，即元素个数</span><br><span class="line">GListDepth(L);</span><br><span class="line">初始条件：广义表L存在</span><br><span class="line">操作结果：求广义表的深度</span><br><span class="line">GListEmpty(L);</span><br><span class="line">初始条件：广义表L存在</span><br><span class="line">操作结果：判定广义表L是否为空</span><br><span class="line">GetHead(L);</span><br><span class="line">初始条件：广义表L存在</span><br><span class="line">操作结果：取广义表L的头</span><br><span class="line">GetTail(L);</span><br><span class="line">初始条件：广义表L存在</span><br><span class="line">操作结果：取广义表L的尾</span><br><span class="line">InsertFirst_GL(&amp;L, &amp;e);</span><br><span class="line">初始条件：广义表L存在</span><br><span class="line">操作结果：插入元素e作为广义表的第一元素</span><br><span class="line">DeleteFirst_GL(&amp;L, &amp;e);</span><br><span class="line">初始条件：广义表L存在</span><br><span class="line">操作结果：删除广义表的第一元素，并用e返回其值</span><br><span class="line">Traverse_GL(L, Visit());</span><br><span class="line">初始条件：广义表L存在</span><br><span class="line">操作结果：遍历广义表L，用函数Visit处理每个元素</span><br><span class="line">&#125;ADTGList</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;数据结构算法合集（C语言版）&quot;&gt;&lt;a href=&quot;#数据结构算法合集（C语言版）&quot; class=&quot;headerlink&quot; title=&quot;数据结构算法合集（C语言版）&quot;&gt;&lt;/a&gt;数据结构算法合集（C语言版）&lt;/h1&gt;&lt;p&gt;在学习《数据结构（C语言版）》一书时，我将其中的算法在此记录，以便有需要时进行查阅。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>准备工作</title>
    <link href="http://yoursite.com/2020/11/27/%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/"/>
    <id>http://yoursite.com/2020/11/27/%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/</id>
    <published>2020-11-27T04:30:15.825Z</published>
    <updated>2020-05-11T05:06:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是搭建个人博客的前提，<strong>重中之重</strong>。</p><a id="more"></a><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="git账号的注册"><a href="#git账号的注册" class="headerlink" title="git账号的注册"></a>git账号的注册</h2><p>这一步不必过多赘述，直接到<a href="https://github.com/" target="_blank" rel="noopener">git官网</a>进行注册即可。</p><h2 id="git-bash的安装"><a href="#git-bash的安装" class="headerlink" title="git bash的安装"></a>git bash的安装</h2><p>建议在<a href="https://gitforwindows.org/" target="_blank" rel="noopener">git bash for windows</a>下载并默认安装。</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200507153851645.png" alt="image-20200507153851645"></p><h2 id="node-js的下载安装"><a href="#node-js的下载安装" class="headerlink" title="node.js的下载安装"></a>node.js的下载安装</h2><p>先在<a href="http://nodejs.org/zh-cn" target="_blank" rel="noopener">http://nodejs.org/zh-cn</a>下载，建议下载长期支持版，之后按照提示默认安装即可（也可更改安装目录，取决于自身），win+r打开运行框，输入cmd运行，在命令框中输入node -v,如出现版本号证明已安装好.</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200507153937372.png" alt="image-20200507153937372"></p><h2 id="npm的安装"><a href="#npm的安装" class="headerlink" title="npm的安装"></a>npm的安装</h2><p>在git bash中输入以下代码安装hexo：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo</span><br></pre></td></tr></table></figure><p>至此，准备工作基本完成。</p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>会出现以下结果：</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200507234805322.png" alt="image-20200507234805322"></p><p>如图所示出现版本号证明安装完毕。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是搭建个人博客的前提，&lt;strong&gt;重中之重&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>我在链表中出现的问题</title>
    <link href="http://yoursite.com/2020/11/27/%E6%88%91%E5%9C%A8%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/11/27/%E6%88%91%E5%9C%A8%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2020-11-27T04:30:15.824Z</published>
    <updated>2020-05-19T06:55:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="我在链表中出现的问题："><a href="#我在链表中出现的问题：" class="headerlink" title="我在链表中出现的问题："></a>我在链表中出现的问题：</h1><p>链表是一种比较基础的数据结构，与数组相比，各有优劣，链表更利于删除数据，但数组更便于访问数据。</p><p>当我初学链表时犯过以下错误：</p><a id="more"></a><p>此处以学生成绩系统为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct stuent</span><br><span class="line">&#123;</span><br><span class="line">char name[9];&#x2F;&#x2F;名称</span><br><span class="line">int score;&#x2F;&#x2F;成绩</span><br><span class="line">struct student *next;&#x2F;&#x2F;下一节点</span><br><span class="line">&#125;Stu;</span><br><span class="line">&#x2F;&#x2F;此处用typedef是为了后续方便，可用可不用</span><br></pre></td></tr></table></figure><h2 id="忘记循环申请新节点空间"><a href="#忘记循环申请新节点空间" class="headerlink" title="忘记循环申请新节点空间"></a>忘记循环申请新节点空间</h2><p>在链表的构建中，我将新节点插入到链表之中后，往往会忘记再次为新节点申请空间，这就导致为节点赋值时程序出现bug。</p><h2 id="头插法和尾插法分不清"><a href="#头插法和尾插法分不清" class="headerlink" title="头插法和尾插法分不清"></a>头插法和尾插法分不清</h2><p>头插法是直接将新节点插入到头节点之后，这就导致在使用头插法插入节点的过程中先插入的反而后输出；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;头插法</span><br><span class="line">for(int i &#x3D; 0;i &lt; n;i++)&#x2F;&#x2F;此处n为你要添加的节点个数</span><br><span class="line">&#123;</span><br><span class="line">new &#x3D; (Stu *)malloc(sizeof(Stu));&#x2F;&#x2F;此处的Stu是你定义的结构体类型名称</span><br><span class="line">new-&gt;name &#x3D; x;&#x2F;&#x2F;x代表学生姓名</span><br><span class="line">new-&gt;score &#x3D; y;&#x2F;&#x2F;y代表学生成绩</span><br><span class="line">new-&gt;next &#x3D; head-&gt;next;</span><br><span class="line">head-&gt;next &#x3D; new;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尾插法与头插法相比略微有些麻烦，因为尾插法还需要一个尾节点，插入过程中便是将新节点插入到尾节点之后,但要注意必须首先找到尾节点所在。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">tail &#x3D; head;</span><br><span class="line">while(tail-&gt;next !&#x3D; NULL)&#x2F;&#x2F;找到尾节点所在</span><br><span class="line">&#123;</span><br><span class="line">tail &#x3D; tail-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;尾插法</span><br><span class="line">for(int i &#x3D; 0;i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">new &#x3D; (Stu *)malloc(sizeof(Stu));</span><br><span class="line">new-&gt;name &#x3D; x;</span><br><span class="line">new-&gt;score &#x3D; y;</span><br><span class="line">new-&gt;next &#x3D; tail-&gt;next;&#x2F;&#x2F;连接新节点与NULL(new-&gt;next &#x3D; NULL;)</span><br><span class="line">tail-&gt;next &#x3D; new;&#x2F;&#x2F;连接尾节点与新节点</span><br><span class="line">tail &#x3D; new;&#x2F;&#x2F;之后以新节点作为尾节点(tail &#x3D; tail-&gt;next;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>暂时先写这么多，日后补充。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;我在链表中出现的问题：&quot;&gt;&lt;a href=&quot;#我在链表中出现的问题：&quot; class=&quot;headerlink&quot; title=&quot;我在链表中出现的问题：&quot;&gt;&lt;/a&gt;我在链表中出现的问题：&lt;/h1&gt;&lt;p&gt;链表是一种比较基础的数据结构，与数组相比，各有优劣，链表更利于删除数据，但数组更便于访问数据。&lt;/p&gt;
&lt;p&gt;当我初学链表时犯过以下错误：&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>选取合适主题，美化博客</title>
    <link href="http://yoursite.com/2020/11/27/%E9%80%89%E5%8F%96%E5%90%88%E9%80%82%E4%B8%BB%E9%A2%98%EF%BC%8C%E7%BE%8E%E5%8C%96%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2020/11/27/%E9%80%89%E5%8F%96%E5%90%88%E9%80%82%E4%B8%BB%E9%A2%98%EF%BC%8C%E7%BE%8E%E5%8C%96%E5%8D%9A%E5%AE%A2/</id>
    <published>2020-11-27T04:30:15.824Z</published>
    <updated>2020-05-07T16:17:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>可以看到，我们博客的主题十分单调，并不好看，因此我们需要为我们的博客更换主题，这里我推荐next主题，它是目前应用较多的hexo主题。</p><a id="more"></a><h1 id="选取合适主题，美化博客"><a href="#选取合适主题，美化博客" class="headerlink" title="选取合适主题，美化博客"></a>选取合适主题，美化博客</h1><h2 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h2><p>打开博客根目录进入git bash，输入以下代码下载next主题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure><p>等待安装完成。</p><h2 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h2><h3 id="根目录配置"><a href="#根目录配置" class="headerlink" title="根目录配置"></a>根目录配置</h3><p>打开博客根目录中的_config.yml文件，找到其中的theme字段，将其值改为next，之后可根据需要更改#site字段下的内容，比如title（文章标题），description（简介或格言），author（网站作者），language（主题语言），timezone（时区）。</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200508000724611.png" alt="image-20200508000724611"></p><p>依旧注意冒号后的空格，如果有一对单引号，直接将内容填至单引号中即可，主题语言打开themes/next/language中查看。</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200508000808782.png" alt="image-20200508000808782"></p><h3 id="修改主题配置文件"><a href="#修改主题配置文件" class="headerlink" title="修改主题配置文件"></a>修改主题配置文件</h3><p>在由于next主题有四种类型，Muse、Mist、Pisces、Gemini，默认为Muse，如需更改，只要打开根目录/themes/next下的_config,yml，找到#Scheme字段，将你需要的主题前的#删除即可，记得其它三个主题前必须要有#。</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200508000927983.png" alt="image-20200508000927983"></p><h2 id="展示"><a href="#展示" class="headerlink" title="展示"></a>展示</h2><p>回到根目录打开git bash，输入以下指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><p>完成后你的博客主题便已经更改完毕。</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200508001021436.png" alt="image-20200508001021436"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;可以看到，我们博客的主题十分单调，并不好看，因此我们需要为我们的博客更换主题，这里我推荐next主题，它是目前应用较多的hexo主题。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>使用虚拟机时碰到的问题</title>
    <link href="http://yoursite.com/2020/11/27/%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%97%B6%E7%A2%B0%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/11/27/%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%97%B6%E7%A2%B0%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2020-11-27T04:30:15.823Z</published>
    <updated>2020-06-04T04:34:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>在使用VBOX创建虚拟机的过程中，我发现我的虚拟机无法连接上网络，因此记录下我的解决方法。</p><a id="more"></a><h1 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h1><p>我的VBOX是6.1.8版本，虚拟机安装的系统为CentOS 8.0版本，如果版本不同，解决方式可能略有不同。</p><h1 id="CentOS中常用的进行网络设置的代码"><a href="#CentOS中常用的进行网络设置的代码" class="headerlink" title="CentOS中常用的进行网络设置的代码"></a>CentOS中常用的进行网络设置的代码</h1><p>重启网络服务的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection reload</span><br></pre></td></tr></table></figure><p>查看基本网络参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure><p>检查默认网关地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route -n</span><br></pre></td></tr></table></figure><p>检查DNS服务器地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;resolv.conf</span><br></pre></td></tr></table></figure><p>可视化配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmtui</span><br></pre></td></tr></table></figure><h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><p>我一开始使用的是net连接模式，但尝试了很多次都无法正确连上网，之后我将注意力转移到了桥接模式，这里记录以下我是如何使用仅主机网络模式将虚拟机连上网的。</p><h3 id="虚拟机使用仅主机网络联网"><a href="#虚拟机使用仅主机网络联网" class="headerlink" title="虚拟机使用仅主机网络联网"></a>虚拟机使用仅主机网络联网</h3><h4 id="1-首先将虚拟机网络与计算机已经连接好的网络进行桥接"><a href="#1-首先将虚拟机网络与计算机已经连接好的网络进行桥接" class="headerlink" title="1.首先将虚拟机网络与计算机已经连接好的网络进行桥接"></a>1.首先将虚拟机网络与计算机已经连接好的网络进行桥接</h4><p>依次打开电脑的“控制面板”–&gt;“网络和Internet”–&gt;“网络连接”查看当前计算机的网络连接，之后选择计算机已经连上的网络以及虚拟机的网卡，右键选择桥接。</p><h4 id="2-将虚拟机的网络连接方式设置为仅主机"><a href="#2-将虚拟机的网络连接方式设置为仅主机" class="headerlink" title="2.将虚拟机的网络连接方式设置为仅主机"></a>2.将虚拟机的网络连接方式设置为仅主机</h4><p>打开VBOX虚拟机管理器，右键虚拟机选择设置，选择“网络”，将连接方式改为“仅主机（Host-Only）网络”，点击确定即可。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在使用VBOX创建虚拟机的过程中，我发现我的虚拟机无法连接上网络，因此记录下我的解决方法。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>连接本地计算机和git服务器</title>
    <link href="http://yoursite.com/2020/11/27/%E8%BF%9E%E6%8E%A5%E6%9C%AC%E5%9C%B0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%92%8Cgit%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://yoursite.com/2020/11/27/%E8%BF%9E%E6%8E%A5%E6%9C%AC%E5%9C%B0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%92%8Cgit%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2020-11-27T04:30:15.823Z</published>
    <updated>2020-05-07T16:00:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>只有将两者连接以后我们的git bash才和我们的git账户关联起来，通过密钥进行访问。</p><a id="more"></a><h1 id="连接本地计算机和git服务器"><a href="#连接本地计算机和git服务器" class="headerlink" title="连接本地计算机和git服务器"></a>连接本地计算机和git服务器</h1><h2 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h2><p>打开git bash，在终端配置user.name和user.email信息，输入以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;user.name&quot;&#x2F;&#x2F;user.name处填写你的GitHub用户名</span><br><span class="line">git config --global user.email &quot;user.email&quot;&#x2F;&#x2F;user.email处填写你注册GitHUb是所用的邮箱</span><br></pre></td></tr></table></figure><h2 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h2><p>在git bash中输入以下代码生成ssh密钥文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;YourEmil&quot;&#x2F;&#x2F;YouEmail处填写你注册GitHub的邮箱</span><br></pre></td></tr></table></figure><p>然后输入三个回车即可，即默认不需要设置密码。</p><p>通过以上步骤便得到了两个文件，id_rsa和id_rsa.pub。</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200507235517482.png" alt="image-20200507235517482"></p><h2 id="COPY密钥"><a href="#COPY密钥" class="headerlink" title="COPY密钥"></a>COPY密钥</h2><p>打开id_rsa.pub文件，复制全部内容。</p><h2 id="将密钥粘贴到GitHub的ssh-key处"><a href="#将密钥粘贴到GitHub的ssh-key处" class="headerlink" title="将密钥粘贴到GitHub的ssh key处"></a>将密钥粘贴到GitHub的ssh key处</h2><p>打开GitHub，点击你的GitHub头像，选择Settings，选择SSH and GPG keys，点击New SSH key，Title随便设置，在Key中粘贴刚刚复制的id_rsa.pub的内容。</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200507235601143.png" alt="image-20200507235601143"></p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200507235722777.png" alt="image-20200507235722777"></p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200507235758027.png" alt="image-20200507235758027"></p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200507235835301.png" alt="image-20200507235835301"></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>在git bash中输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>再输入yes，如果看到Hi后面有你的用户名证明连接成功。</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200508000007626.png" alt="image-20200508000007626"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;只有将两者连接以后我们的git bash才和我们的git账户关联起来，通过密钥进行访问。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>利用hexo写出博客框架</title>
    <link href="http://yoursite.com/2020/11/27/%E5%88%A9%E7%94%A8hexo%E5%86%99%E5%87%BA%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2020/11/27/%E5%88%A9%E7%94%A8hexo%E5%86%99%E5%87%BA%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6/</id>
    <published>2020-11-27T04:30:15.822Z</published>
    <updated>2020-05-07T16:02:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo是基于<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fnodejs.org%2Fen%2F" target="_blank" rel="noopener">Nodejs</a>开发的，可以将<code>markdown</code>转换成<code>html</code>的框架，十分适合个人博客的搭建。</p><a id="more"></a><h1 id="利用hexo写出博客框架"><a href="#利用hexo写出博客框架" class="headerlink" title="利用hexo写出博客框架"></a>利用hexo写出博客框架</h1><h2 id="建立myBlog目录"><a href="#建立myBlog目录" class="headerlink" title="建立myBlog目录"></a>建立myBlog目录</h2><p>在计算机的恰当位置建立文件夹（位置任意，名称任意，但建议具有代表性）。</p><h2 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h2><p>进入刚刚建立的文件夹，选择git bash here进入git bash，输入以下代码初始化博客：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init</span><br><span class="line">$ hexo g #生成</span><br><span class="line">$ hexo s #开启本地预览</span><br></pre></td></tr></table></figure><p>此时你可以在浏览器中输入<a href="http://localhost:4000进行访问，本地预览我们的博客。">http://localhost:4000进行访问，本地预览我们的博客。</a></p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200508000155058.png" alt="image-20200508000155058"></p><p>观看完之后CTRL+C关闭。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Hexo是基于&lt;a href=&quot;https://links.jianshu.com/go?to=https%3A%2F%2Fnodejs.org%2Fen%2F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Nodejs&lt;/a&gt;开发的，可以将&lt;code&gt;markdown&lt;/code&gt;转换成&lt;code&gt;html&lt;/code&gt;的框架，十分适合个人博客的搭建。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>创建git仓库</title>
    <link href="http://yoursite.com/2020/11/27/%E5%88%9B%E5%BB%BAgit%E4%BB%93%E5%BA%93/"/>
    <id>http://yoursite.com/2020/11/27/%E5%88%9B%E5%BB%BAgit%E4%BB%93%E5%BA%93/</id>
    <published>2020-11-27T04:30:15.821Z</published>
    <updated>2020-05-07T16:16:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>既然是利用GitHub进行托管，那么必须将其放到相应的库中。</p><a id="more"></a><h1 id="创建git仓库"><a href="#创建git仓库" class="headerlink" title="创建git仓库"></a>创建git仓库</h1><p>打开<a href="https://www.github.com/" target="_blank" rel="noopener">github官网</a>，登录自己申请的账号后，点开右上角的加号，选择New repository，在Repository name下输入仓库名，必须是username.github.io（此处的username必须是你github的用户名），选择Public，勾选Initialize this repository with a README，点击Create repository，仓库至此创建完成。</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200507235203205.png" alt="image-20200507235203205"></p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200507235311764.png" alt="image-20200507235311764"></p><p>由于此处我已经建立过，所以会显示邮箱已存在。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;既然是利用GitHub进行托管，那么必须将其放到相应的库中。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>将该框架上传到github</title>
    <link href="http://yoursite.com/2020/11/27/%E5%B0%86%E8%AF%A5%E6%A1%86%E6%9E%B6%E4%B8%8A%E4%BC%A0%E5%88%B0github/"/>
    <id>http://yoursite.com/2020/11/27/%E5%B0%86%E8%AF%A5%E6%A1%86%E6%9E%B6%E4%B8%8A%E4%BC%A0%E5%88%B0github/</id>
    <published>2020-11-27T04:30:15.821Z</published>
    <updated>2020-05-07T16:06:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>在前面我们搭建好了框架，但只有将其上传到GitHub中才能通过浏览器访问，而不是像之前一样只能本地访问。</p><a id="more"></a><h1 id="将该框架上传到github"><a href="#将该框架上传到github" class="headerlink" title="将该框架上传到github"></a>将该框架上传到github</h1><h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><p>已经配置好SSH Key。</p><h2 id="开始配置"><a href="#开始配置" class="headerlink" title="开始配置"></a>开始配置</h2><p>之后便是打开文件夹中的_config.yml文件（文本编辑器打开即可），找到最后的部分，将其更改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:username&#x2F;username.github.io.git&#x2F;&#x2F;其实就是在repo处填上你的github page地址</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200508000329237.png" alt="image-20200508000329237"></p><p>注意：每个冒号后都有且只有一个半角的空格符，如果type处已有一对单引号，只需将git输到单引号中即可。</p><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>如缺少此步骤，在hexo g命令时会出现“deployer:git not found”。 </p><p>在你的博客文件夹中选择git bash here，输入以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h2 id="提交到GitHub"><a href="#提交到GitHub" class="headerlink" title="提交到GitHub"></a>提交到GitHub</h2><p>输入以下代码将博客在GitHub上托管：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean            ##清除缓存</span><br><span class="line">$ hexo g                ##生成静态网页</span><br><span class="line">$ hexo d                ##将其部署到服务器上</span><br></pre></td></tr></table></figure><p>之后需要输入你GitHub的用户名和密码进行验证。</p><h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><p>在浏览器中输入<a href="https://username.github.io就可以看到你搭建的博客了。" target="_blank" rel="noopener">https://username.github.io就可以看到你搭建的博客了。</a></p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200508000546988.png" alt="image-20200508000546988"></p><p>此处我使用了主题，后面会介绍到。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在前面我们搭建好了框架，但只有将其上传到GitHub中才能通过浏览器访问，而不是像之前一样只能本地访问。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2020/11/27/hello-world/"/>
    <id>http://yoursite.com/2020/11/27/hello-world/</id>
    <published>2020-11-27T04:30:15.820Z</published>
    <updated>2020-05-06T11:50:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>build-a-blog</title>
    <link href="http://yoursite.com/2020/11/27/build-a-blog/"/>
    <id>http://yoursite.com/2020/11/27/build-a-blog/</id>
    <published>2020-11-27T04:30:15.819Z</published>
    <updated>2020-05-07T04:58:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="这篇文章用来记录搭建博客的过程"><a href="#这篇文章用来记录搭建博客的过程" class="headerlink" title="这篇文章用来记录搭建博客的过程"></a><center>这篇文章用来记录搭建博客的过程</center></h3><h4 id="一、准备工作（git账号的注册、node-js、npm的安装）"><a href="#一、准备工作（git账号的注册、node-js、npm的安装）" class="headerlink" title="一、准备工作（git账号的注册、node.js、npm的安装）"></a><a href="https://decucin.github.io/2020/05/07/%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/" target="_blank" rel="noopener">一、准备工作（git账号的注册、node.js、npm的安装）</a></h4><h4 id="二、创建git仓库"><a href="#二、创建git仓库" class="headerlink" title="二、创建git仓库"></a><a href="https://decucin.github.io/2020/05/07/%E5%88%9B%E5%BB%BAgit%E4%BB%93%E5%BA%93/" target="_blank" rel="noopener">二、创建git仓库</a></h4><h4 id="三、连接本地计算机和git服务器"><a href="#三、连接本地计算机和git服务器" class="headerlink" title="三、连接本地计算机和git服务器"></a><a href="https://decucin.github.io/2020/05/07/%E8%BF%9E%E6%8E%A5%E6%9C%AC%E5%9C%B0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%92%8Cgit%E6%9C%8D%E5%8A%A1%E5%99%A8/" target="_blank" rel="noopener">三、连接本地计算机和git服务器</a></h4><h4 id="四、利用hexo写出博客框架"><a href="#四、利用hexo写出博客框架" class="headerlink" title="四、利用hexo写出博客框架"></a><a href="https://decucin.github.io/2020/05/07/%E5%88%A9%E7%94%A8hexo%E5%86%99%E5%87%BA%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6/" target="_blank" rel="noopener">四、利用hexo写出博客框架</a></h4><h4 id="五、将该框架上传到github"><a href="#五、将该框架上传到github" class="headerlink" title="五、将该框架上传到github"></a><a href="https://decucin.github.io/2020/05/07/%E5%B0%86%E8%AF%A5%E6%A1%86%E6%9E%B6%E4%B8%8A%E4%BC%A0%E5%88%B0github/" target="_blank" rel="noopener">五、将该框架上传到github</a></h4><h4 id="六、选取合适主题，美化博客"><a href="#六、选取合适主题，美化博客" class="headerlink" title="六、选取合适主题，美化博客"></a><a href="https://decucin.github.io/2020/05/07/%E9%80%89%E5%8F%96%E5%90%88%E9%80%82%E4%B8%BB%E9%A2%98%EF%BC%8C%E7%BE%8E%E5%8C%96%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">六、选取合适主题，美化博客</a></h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;这篇文章用来记录搭建博客的过程&quot;&gt;&lt;a href=&quot;#这篇文章用来记录搭建博客的过程&quot; class=&quot;headerlink&quot; title=&quot;这篇文章用来记录搭建博客的过程&quot;&gt;&lt;/a&gt;&lt;center&gt;这篇文章用来记录搭建博客的过程&lt;/center&gt;&lt;/h3&gt;&lt;h4 </summary>
      
    
    
    
    
  </entry>
  
</feed>
