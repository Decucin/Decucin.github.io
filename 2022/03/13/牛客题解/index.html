<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="链表BM1 反转链表题目描述给定一个单链表的头结点pHead(该头节点是有值的，比如在下图，它的val是1)，长度为n，反转该链表后，返回新链表的表头。  数据范围： 0≤n≤1000 要求：空间复杂度 O(1) ，时间复杂度 O(n)。  如当输入链表{1,2,3}时，  经反转后，原链表变为{3,2,1}，所以对应的输出为{3,2,1}。  以上转换过程如下图所示：  题解反转链表的基本思">
<meta property="og:type" content="article">
<meta property="og:title" content="牛客TOP101题解">
<meta property="og:url" content="http://yoursite.com/2022/03/13/%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3/index.html">
<meta property="og:site_name" content="Blog of Decucin">
<meta property="og:description" content="链表BM1 反转链表题目描述给定一个单链表的头结点pHead(该头节点是有值的，比如在下图，它的val是1)，长度为n，反转该链表后，返回新链表的表头。  数据范围： 0≤n≤1000 要求：空间复杂度 O(1) ，时间复杂度 O(n)。  如当输入链表{1,2,3}时，  经反转后，原链表变为{3,2,1}，所以对应的输出为{3,2,1}。  以上转换过程如下图所示：  题解反转链表的基本思">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20211014/423483716_1634206291971/4A47A0DB6E60853DEDFCFDF08A5CA249">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20220110/423483716_1641800950920/0710DD5D9C4D4B11A8FA0C06189F9E9C">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20211025/423483716_1635154005498/DA92C945EF643F1143567935F20D6B46">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20211105/423483716_1636084313645/5407F55227804F31F5C5D73558596F2C">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20211104/423483716_1635999204882/394BB7AFD5CEA3DC64D610F62E6647A6">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20211105/423483716_1636084743981/C2DB572B01B0FDC03C097BE7ABA45114">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20211014/423483716_1634212356346/9EB9CD58B9EA5E04C890326B5C1F471F">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20210114/999991351_1610616074120/036DC34FF19FB24652AFFEB00A119A76">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20210717/557336_1626492068888/41FDD435F0BA63A57E274747DE377E05">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20200807/999991351_1596786493913_8BFB3E9513755565DC67D86744BB6159">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20210605/557336_1622886924427/E1F1270919D292C9F48F51975FD07CE2">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20210926/382300087_1632642756706/A22A794C036C06431E632F9D5E2E298F">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20210926/382300087_1632642770481/3304ABDD147D8E140B2CEF3201BD8372">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20210928/382300087_1632821337680/9E290CFD3730B9B08A5CEFF25799608F">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20210928/382300087_1632821376266/DD0A63560E770A8510049C5182E6E622">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20210928/382300087_1632821404541/9CB750F8909D5985C0D01D8B71AD58BA">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20210922/382300087_1632302001586/420B82546CFC9760B45DD65BA9244888">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20210922/382300087_1632302036250/AD8C4CC119B15070FA1DBAA1EBE8FC2A">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20211109/392807_1636440937987/9C31F319601A5B78D34F62FF77A02A11">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20211109/392807_1636440984427/5E5B576E11CB2C96724680C94755ABCB">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20211112/392807_1636687704633/3FDF585A954EFF629B41FD21BA20B0C9">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20211112/392807_1636687742831/942721EB3583D230F79D69B3097D3416">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20211112/392807_1636687774162/1D0ED443BD0A777690EF55BABCD978D5">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20210918/382300087_1631935149594/D55A07912354B3AB7E9F2F5EA27CB7D6">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20211110/301499_1636536407371/36404CF45DDCB5834FC8BBFEA318831A">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20211014/423483716_1634206667843/D2B5CA33BD970F64A6301FA75AE2EB22">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20210910/557336_1631245540483/320409CB186FCD18144519959D510D7E">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20210717/557336_1626504921458/776B0E5E0FAD11A6F15004B29DA5E628">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20211014/423483716_1634208293748/10FB15C77258A991B0028080A64FB42D">
<meta property="og:image" content="http://yoursite.com/2022/03/13/%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3/%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3.png">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20211008/557336_1633676660853/6226390B4185DB132AFFDB10F09F8BEB">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20211204/423483716_1638606211798/CFE342EBEEFB9E6839E6ED216B889F16">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20211201/423483716_1638350164758/A6B05D015D3BE3C77C34DDF224044A1F">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20201210/999991351_1607596327517/873CB1F2327F70DA0CA0FDC797F894A7">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20220122/423483716_1642823916509/06EB123C153852AF55ED51448BEAD1BA">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20211105/301499_1636104759021/B9F3EB6BBC1EE9A63532E7EB494A11A7">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20210416/999991351_1618541247169/26A2E295DEE51749C45B5E8DD671E879">
<meta property="article:published_time" content="2022-03-13T11:08:37.000Z">
<meta property="article:modified_time" content="2022-03-21T06:27:32.429Z">
<meta property="article:author" content="Decucin">
<meta property="article:tag" content="牛客">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://uploadfiles.nowcoder.com/images/20211014/423483716_1634206291971/4A47A0DB6E60853DEDFCFDF08A5CA249">

<link rel="canonical" href="http://yoursite.com/2022/03/13/%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>牛客TOP101题解 | Blog of Decucin</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Blog of Decucin" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Blog of Decucin</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/03/13/%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Decucin">
      <meta itemprop="description" content="喜欢简单的事物和明朗的关系">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of Decucin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          牛客TOP101题解
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-13 19:08:37" itemprop="dateCreated datePublished" datetime="2022-03-13T19:08:37+08:00">2022-03-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-21 14:27:32" itemprop="dateModified" datetime="2022-03-21T14:27:32+08:00">2022-03-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/solution/" itemprop="url" rel="index"><span itemprop="name">solution</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>136k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2:03</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <a id="more"></a>

<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="BM1-反转链表"><a href="#BM1-反转链表" class="headerlink" title="BM1 反转链表"></a>BM1 <a href="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=295&tqId=23286&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">反转链表</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个单链表的头结点pHead(该头节点是有值的，比如在下图，它的val是1)，长度为n，反转该链表后，返回新链表的表头。 </p>
<p>数据范围： 0≤<em>n</em>≤1000</p>
<p>要求：空间复杂度 O(1) ，时间复杂度 O(n)。 </p>
<p>如当输入链表{1,2,3}时， </p>
<p>经反转后，原链表变为{3,2,1}，所以对应的输出为{3,2,1}。 </p>
<p>以上转换过程如下图所示：</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20211014/423483716_1634206291971/4A47A0DB6E60853DEDFCFDF08A5CA249" alt="img"></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>反转链表的基本思想就是利用三个指针，pre，cur，nex分别表示当前节点前一个节点、当前节点以及当前节点后面的节点，之后再令cur.next = pre;其实就完成了反转操作，完成反转操作之后将三个指针依次后移即可。</p>
<h3 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 优先考虑特殊情况，一个节点都没有或是只有一个节点，直接返回即可</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode nex = cur.next;</span><br><span class="line">            <span class="comment">// 这里是反转的核心，令之前在前面的指针挪到后面</span></span><br><span class="line">            cur.next = pre;</span><br><span class="line">            <span class="comment">// 之后依次将各指针后移即可；</span></span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = nex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当退出循环时，其实就是cur == null的情况，这时</span></span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM2-链表内指定区间反转"><a href="#BM2-链表内指定区间反转" class="headerlink" title="BM2 链表内指定区间反转"></a>BM2 <a href="https://www.nowcoder.com/practice/b58434e200a648c589ca2063f1faf58c?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">链表内指定区间反转</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>将一个节点数为 size 链表 m 位置到 n 位置之间的区间反转，要求时间复杂度 O<em>(</em>n<em>)，空间复杂度 *O</em>(1)。<br>例如：<br>给出的链表为 1→2→3→4→5→<em>NULL</em>, m=2,n=4<em>m</em>=2,<em>n</em>=4,<br>返回 1→4→3→2→5→<em>NULL</em>.</p>
<p><strong>数据范围： 链表长度 0&lt;size≤1000，0&lt;m≤n≤size，链表中每个节点的值满足 |val|≤1000|val|≤1000</strong></p>
<p><strong>要求：时间复杂度 <em>O</em>(<em>n</em>) ，空间复杂度 <em>O</em>(<em>n</em>)</strong></p>
<p><strong>进阶：时间复杂度 <em>O</em>(<em>n</em>) ，空间复杂度 <em>O</em>(<em>1</em>)</strong></p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>这题的思想和反转链表实际上是一样的，关键点（与反转整个链表不同之处）在于这里反转的链表只是整个链表中的一部分，故涉及链表的截断(cur.next = null)以及连接(cur.next = head2.next)，考虑方法如下：首先需要将链表的头尾指针进行保存（考虑如下几个指针的保存，原链表截断之前的指针，截断部分的头尾指针以及截断部分之后的头指针），之后将截断部分进行反转，之后再进行链表的拼接即可。</p>
<p><strong>可用一个虚拟头节点防止头节点各种复杂条件判断</strong></p>
<h3 id="Java代码实现-1"><a href="#Java代码实现-1" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span> <span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 首先考虑特殊情况，若是m == n即有一个节点需要反转，那直接无需反转</span></span><br><span class="line">        <span class="keyword">if</span>(m == n)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 首先考虑需要的指针，总共有三条链表，用head1-3以及tail1-3分别表示其头尾</span></span><br><span class="line">        ListNode head2 = <span class="keyword">null</span>;</span><br><span class="line">        ListNode head3 = <span class="keyword">null</span>;</span><br><span class="line">        ListNode tail1 = <span class="keyword">null</span>;</span><br><span class="line">        ListNode tail2 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 此外，链表遍历还用到两个指针</span></span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="comment">// 考虑利用虚指针</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        pre = dummy;</span><br><span class="line">        <span class="comment">// 用于标记索引下标</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == m)&#123;</span><br><span class="line">                <span class="comment">//将链表截断</span></span><br><span class="line">                pre.next = <span class="keyword">null</span>;</span><br><span class="line">                tail1 = pre;</span><br><span class="line">                head2 = cur;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == n + <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//将链表截断</span></span><br><span class="line">                pre.next = <span class="keyword">null</span>;</span><br><span class="line">                tail2 = pre;</span><br><span class="line">                pre.next = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 这里可能只有n个节点，但此时到了第i + 1个节点，为null</span></span><br><span class="line">                <span class="keyword">if</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    head3 = cur;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 无论是否需要截断链表都将指针后移</span></span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将其反转拼接第一二段</span></span><br><span class="line">        tail1.next = reverse(head2);</span><br><span class="line">        <span class="comment">// 拼接二三段</span></span><br><span class="line">        head2 = tail1;</span><br><span class="line">        <span class="keyword">while</span>(head2.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            head2 = head2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        head2.next = head3;</span><br><span class="line"><span class="comment">//         这里的拼接过程，我的原本是，没有连接上，若是要连接链表，需要通过next下标</span></span><br><span class="line"><span class="comment">//         while(tail1 != null)&#123;</span></span><br><span class="line"><span class="comment">//             tail1 = tail1.next;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         tail1 = head3;</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里返回反转后的头指针</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode nex = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = nex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM3-链表中的节点每k个一组翻转"><a href="#BM3-链表中的节点每k个一组翻转" class="headerlink" title="BM3 链表中的节点每k个一组翻转"></a>BM3 <a href="https://www.nowcoder.com/practice/b49c3dc907814e9bbfa8437c251b028e?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">链表中的节点每k个一组翻转</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>将给出的链表中的节点每 k 个一组翻转，返回翻转后的链表<br>如果链表中的节点数不是 k 的倍数，将最后剩下的节点保持原样<br>你不能更改节点中的值，只能更改节点本身。</p>
<p>数据范围：0≤<em>n</em>≤2000 ，1≤<em>k</em>≤2000 ，链表中每个元素都满足 0≤<em>val</em>≤1000</p>
<p>要求空间复杂度<em>O(1)<em>，时间复杂度、</em>O(n)</em></p>
<p>例如： </p>
<p>给定的链表是1→2→3→4→5</p>
<p>对于<em>k</em>=2 , 你应该返回2→1→4→3→5</p>
<p>对于<em>k</em>=3 , 你应该返回 3→2→1→4→5</p>
<h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>先求出链表的长度，然后判断需要分几组，之后对每组进行反转并连接，过程中需要注意保存以下节点：preStart–&gt;需要反转的节点之前的节点，start–&gt;开始反转的节点，afterStart–&gt;反转结束的下一个节点，end–&gt;反转结束的节点，还有就是反转链表需要的三个节点pre，cur以及nex。</p>
<p><strong>可用一个虚拟头节点防止头节点各种复杂条件判断</strong></p>
<p><strong>注意点：每次连接时只连接一端（连接上一个链表和这一个链表），当全部反转都完成之后，再连接这一个链表和下一个链表</strong></p>
<h3 id="Java代码实现-2"><a href="#Java代码实现-2" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span> <span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 特殊情况，每1个为1组进行反转，直接返回即可</span></span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 长度</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 虚拟头节点</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        <span class="comment">// 反转节点之前的节点</span></span><br><span class="line">        ListNode preStart = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 开始反转的节点（反转之后变成了需要和后面链表进行拼接的节点）</span></span><br><span class="line">        ListNode start = dummy;</span><br><span class="line">        <span class="comment">// 反转结束的节点</span></span><br><span class="line">        ListNode end = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 反转结束节点之后的节点</span></span><br><span class="line">        ListNode afterStart = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 反转过程中需要的节点</span></span><br><span class="line">        ListNode pre = dummy;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        ListNode nex = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ++len;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断需要分几组</span></span><br><span class="line">        <span class="keyword">int</span> group = len / k;</span><br><span class="line">        <span class="comment">// 特殊情况，head为空或为1直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span> || len == <span class="number">1</span> || group &lt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; group; ++i)&#123;</span><br><span class="line">            <span class="comment">// 先记录反转之前的节点以及开始节点</span></span><br><span class="line">            preStart = start;    <span class="comment">// 反转之前的节点实际上是上一反转链表的头（第一次反转，其前一个节点为dummy，故对preStart赋初值应为dummy）</span></span><br><span class="line">            start = cur;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++j)&#123;</span><br><span class="line">                nex = cur.next;</span><br><span class="line">                <span class="comment">// 开始进行反转</span></span><br><span class="line">                cur.next = pre;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = nex;</span><br><span class="line">            &#125;</span><br><span class="line">            end = pre;</span><br><span class="line">            afterStart = cur;</span><br><span class="line">            <span class="comment">// 开始进行连接，注意这里只是连接反转之前的头和这一次的尾</span></span><br><span class="line">            preStart.next = end;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当反转全部完成时，再将这一次反转的尾和反转之后的节点进行连接</span></span><br><span class="line">        start.next = afterStart;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM4-合并两个排序的链表"><a href="#BM4-合并两个排序的链表" class="headerlink" title="BM4 合并两个排序的链表"></a>BM4 <a href="https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">合并两个排序的链表</a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两个递增的链表，单个链表的长度为n，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>
<p>数据范围： 0≤n≤10000，−1000≤节点值≤1000<br>要求：空间复杂度 O(1)，时间复杂度 O(n)</p>
<h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>双指针移动即可，但若是想达到O(1)的时间复杂度，则需要原地修改指针，故选择如下方法：将两个链表中的当前节点标记，标记当前节点的作用是，判断本次应该连接哪一个节点（链表1中的节点或是链表2中的节点），之后再将剩下的链表合并即可。</p>
<p><strong>可用一个虚拟头节点防止头节点各种复杂条件判断</strong></p>
<h3 id="Java代码实现-3"><a href="#Java代码实现-3" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 首先考虑特殊情况，即两个链表中一个链表为空时，直接返回另一个链表即可</span></span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="keyword">null</span> || list2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list1 == <span class="keyword">null</span> ? list2 : list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 首先需要两个指针分别记录两个链表走到了哪</span></span><br><span class="line">        ListNode cur1 = list1;</span><br><span class="line">        ListNode cur2 = list2;</span><br><span class="line">        <span class="comment">// 避免考虑头节点，先来个虚拟节点</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode cur = dummy;</span><br><span class="line">        <span class="comment">// 先将两个链表合并</span></span><br><span class="line">        <span class="keyword">while</span>(cur1 != <span class="keyword">null</span> &amp;&amp; cur2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur1.val &lt; cur2.val)&#123;</span><br><span class="line">                cur.next = cur1;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur.next = cur2;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 再合并剩下的部分，此时一个链表已经为空了</span></span><br><span class="line">        cur.next = cur1 == <span class="keyword">null</span> ? cur2 : cur1;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM5-合并k个已排序的链表"><a href="#BM5-合并k个已排序的链表" class="headerlink" title="BM5 合并k个已排序的链表"></a>BM5 <a href="https://www.nowcoder.com/practice/65cfde9e5b9b4cf2b6bafa5f3ef33fa6?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">合并k个已排序的链表</a></h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>合并 k 个升序的链表并将结果作为一个升序的链表返回其头节点。</p>
<p>数据范围：节点总数 0≤n≤5000，每个节点的val满足 ∣val∣&lt;=100</p>
<p>要求：时间复杂度 O(nlogn)</p>
<h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><p>这题只说了要求时间复杂度O(nlogn)，而未要求空间复杂度，我自己的想法是将链表中所有节点的值保存到ArrayList中进行排序，排序之后再依次生成节点即可。</p>
<h3 id="Java代码实现-4"><a href="#Java代码实现-4" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ArrayList&lt;ListNode&gt; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = lists.size();</span><br><span class="line">        <span class="comment">// 当前节点</span></span><br><span class="line">        ListNode cur = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 存储全部元素所用的集合</span></span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="comment">// 将每个链表的每个节点都存入</span></span><br><span class="line">            cur = lists.get(i);</span><br><span class="line">            <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">                res.add(cur.val);</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(res);</span><br><span class="line">        <span class="comment">// 建一个虚拟头指针已防止头节点的误判</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        cur = dummy;</span><br><span class="line">        <span class="keyword">for</span>(Integer num : res)&#123;</span><br><span class="line">            cur.next = <span class="keyword">new</span> ListNode(num);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是注意以上题解并未使用到一个条件–&gt;这n个链表均为有序链表，因此时间复杂度肯定不是最佳，想到用k个指针进行迭代，但经过k - 1次比较之后才能完成1个数的排序，故其时间复杂度为O(kn)，由此想到维护一个一直有序的数组，每次取出下标为0的位置，并将该数所在链表的后一个节点放入数组中（保证其有序–&gt;这里可以使用二分找到对应的下标），但此时出现矛盾，使用二分进行查找，那数组更合适，但若是涉及插入操作，则链表更合适，，，矛盾，故舍弃此思路。</p>
<p>但看题解是发现大部分此思路采用的是优先队列来实现，队列自动维护，每次只需取出队头就行。</p>
<p>看了题解后发现：不是使用k个指针，而是每次合并的时候是两两合并，如有链表1, 2, 3, 4, 5, 6, 7, 8，第一次合并，将12合并，34合并，56合并，78合并，得到四个新链表1, 2, 3, 4，之后再次合并，12合并，34合并，得到链表1, 2，最后再将12合并得到所需的链表，完整题解如下：</p>
<h3 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h3><p>采用分治法的思想（先分后并），将所给的k个链表分成两份，一直持续地分，分到不能再分为止（k个链表被分为k份），之后再依次将两个链表进行合并，直到合并为最后一个链表为止。</p>
<h3 id="Java代码实现-5"><a href="#Java代码实现-5" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ArrayList&lt;ListNode&gt; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = lists.size();</span><br><span class="line">        <span class="comment">// 此函数确定需要合并的下标范围0----n-1</span></span><br><span class="line">        <span class="keyword">return</span> merge(lists, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这个函数的作用是从left合并到right</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">merge</span><span class="params">(ArrayList&lt;ListNode&gt; lists, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 若是无法再分，则直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">            <span class="keyword">return</span> lists.get(left);</span><br><span class="line">            <span class="comment">// left &gt; right表示长度为0，即merge(lists, 0, -1)，数组中有任何一个链表为空时都会产生此情况</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 否则考虑合并left， mid为一个链表，mid +1 到right为一个链表</span></span><br><span class="line">            <span class="keyword">return</span> merge2Lists(merge(lists, left, mid), merge(lists, mid + <span class="number">1</span>, right));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这一部分完全就是合并两个链表的代码</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">merge2Lists</span><span class="params">(ListNode list1, ListNode list2)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 首先考虑特殊情况，即两个链表中一个链表为空时，直接返回另一个链表即可</span></span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="keyword">null</span> || list2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list1 == <span class="keyword">null</span> ? list2 : list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 首先需要两个指针分别记录两个链表走到了哪</span></span><br><span class="line">        ListNode cur1 = list1;</span><br><span class="line">        ListNode cur2 = list2;</span><br><span class="line">        <span class="comment">// 避免考虑头节点，先来个虚拟节点</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode cur = dummy;</span><br><span class="line">        <span class="comment">// 先将两个链表合并</span></span><br><span class="line">        <span class="keyword">while</span>(cur1 != <span class="keyword">null</span> &amp;&amp; cur2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur1.val &lt; cur2.val)&#123;</span><br><span class="line">                cur.next = cur1;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur.next = cur2;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 再合并剩下的部分，此时一个链表已经为空了</span></span><br><span class="line">        cur.next = cur1 == <span class="keyword">null</span> ? cur2 : cur1;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM6-判断链表中是否有环"><a href="#BM6-判断链表中是否有环" class="headerlink" title="BM6 判断链表中是否有环"></a>BM6 <a href="https://www.nowcoder.com/practice/650474f313294468a4ded3ce0f7898b9?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">判断链表中是否有环</a></h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>判断给定的链表中是否有环。如果有环则返回true，否则返回false。 </p>
<p>数据范围：链表长度 0≤n≤10000，链表中任意节点的值满足 ∣val∣&lt;=100000</p>
<p>要求：空间复杂度 O(1)，时间复杂度 O(n)</p>
<p>输入分为两部分，第一部分为链表，第二部分代表是否有环，然后将组成的head头结点传入到函数里面。-1代表无环，其它的数字代表有环，这些参数解释仅仅是为了方便读者自测调试。实际在编程时读入的是链表的头节点。</p>
<p>例如输入{3,2,0,-4},1时，对应的链表结构如下图所示： </p>
<p><img src="https://uploadfiles.nowcoder.com/images/20220110/423483716_1641800950920/0710DD5D9C4D4B11A8FA0C06189F9E9C" alt="img"></p>
<p>可以看出环的入口结点为从头结点开始的第1个结点（注：头结点为第0个结点），所以输出true。</p>
<h3 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h3><p>快慢指针，一个每次走一格，一个每次走两个，若是有环则必会相遇，这里题目中没说任意节点的值均不同，判断两指针是否相遇时最好不只是判断两个节点的val是否相遇而是判断两个指针的地址是否相同</p>
<h3 id="Java代码实现-6"><a href="#Java代码实现-6" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里注意题目中说0 &lt;= n，故有可能为0，特殊情况优先考虑</span></span><br><span class="line">        <span class="comment">// 由于之后的fast和slow都是先赋值，为了防止对空指针进行操作，需要先进行判断</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head.next;</span><br><span class="line">        ListNode fast = head.next.next;</span><br><span class="line">        <span class="comment">// 快慢指针，若是有一个先遍历完，那必然是快指针</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 这里是先比较后移动，因为第一次移动过了</span></span><br><span class="line">            <span class="keyword">if</span>(slow == fast)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="comment">// 增加这个判断是防止当fast到了最后一个元素时，fast.next.next就对空指针进行了操作</span></span><br><span class="line">            <span class="comment">// 也可以将判断条件加在while循环中，即：while(fast != null &amp;&amp; fast.next != null)</span></span><br><span class="line">            <span class="keyword">if</span>(fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">                fast = fast.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM7-链表中环的入口节点"><a href="#BM7-链表中环的入口节点" class="headerlink" title="BM7 链表中环的入口节点"></a>BM7 <a href="https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">链表中环的入口节点</a></h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><p>给一个长度为n链表，若其中包含环，请找出该链表的环的入口结点，否则，返回null。 </p>
<p>数据范围： n≤10000，1&lt;=结点值&lt;=10000</p>
<p>要求：空间复杂度 O(1)，时间复杂度 O(n)</p>
<p>例如，输入{1,2},{3,4,5}时，对应的环形链表如下图所示：</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20211025/423483716_1635154005498/DA92C945EF643F1143567935F20D6B46" alt="img"></p>
<p>可以看到环的入口结点的结点值为3，所以返回结点值为3的结点。</p>
<h4 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h4><p>输入分为2段，第一段是入环前的链表部分，第二段是链表环的部分，后台会根据第二段是否为空将这两段组装成一个无环或者有环单链表</p>
<h4 id="返回值描述"><a href="#返回值描述" class="headerlink" title="返回值描述"></a>返回值描述</h4><p>返回链表的环的入口结点即可，我们后台程序会打印这个结点对应的结点值；若没有，则返回对应编程语言的空结点即可。</p>
<h3 id="题解-7"><a href="#题解-7" class="headerlink" title="题解"></a>题解</h3><p>这题的做法和判断是否有环类似，都是先使用快慢指针找到两个指针重合的位置判定有环，之后注意一个点，此时将其中一个指针移至原链表头并让两个指针以相同的速度移动，那么当两个指针再次相遇时的节点即为入口节点，具体证明如下，图可参考<a href="https://blog.nowcoder.net/n/9d3ffa4b004e43d1aff512141d0d7dac" target="_blank" rel="noopener">官方题解</a>：</p>
<p>首先假设链表中无环的部分（从头节点到环的入口节点）距离为x，从环的入口到相遇节点的距离为y，从相遇节点再次到环的入口距离为m，则由快慢指针的速度可得如下距离方程：</p>
<p>(x + y + m + y) / (x + y) = 2</p>
<p>其中除号左边为快指针走的距离，除号右边为慢指针走的距离，两者走了相同的时间，距离刚好与速度成正比</p>
<h3 id="Java代码实现-7"><a href="#Java代码实现-7" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况优先考虑</span></span><br><span class="line">        <span class="keyword">if</span>(pHead == <span class="keyword">null</span> || pHead.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode fast = pHead.next.next;</span><br><span class="line">        ListNode slow = pHead.next;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">                <span class="comment">// 此时有环，开始第二轮遍历</span></span><br><span class="line">                fast = pHead;</span><br><span class="line">                <span class="keyword">while</span>(fast != slow)&#123;</span><br><span class="line">                    fast = fast.next;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> fast;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 退出了循环证明无环</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM8-链表中倒数最后k个节点"><a href="#BM8-链表中倒数最后k个节点" class="headerlink" title="BM8 链表中倒数最后k个节点"></a>BM8 <a href="https://www.nowcoder.com/practice/886370fe658f41b498d40fb34ae76ff9?tpId=295&tqId=1377477&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">链表中倒数最后k个节点</a></h2><h3 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个长度为 n 的链表，设链表中的元素的值为 ai ，返回该链表中倒数第k个节点。 </p>
<p>如果该链表长度小于k，请返回一个长度为 0 的链表。 </p>
<p>数据范围：0≤n≤105，0≤ai≤109，0≤k≤109</p>
<p>要求：空间复杂度 O(n)，时间复杂度 O(n)</p>
<p>进阶：空间复杂度 O(1)，时间复杂度 O(n)</p>
<p>例如输入{1,2,3,4,5},2时，对应的链表结构如下图所示： </p>
<p><img src="https://uploadfiles.nowcoder.com/images/20211105/423483716_1636084313645/5407F55227804F31F5C5D73558596F2C" alt="img"></p>
<p>其中蓝色部分为该链表的最后2个结点，所以返回倒数第2个结点（也即结点值为4的结点）即可，系统会打印后面所有的节点来比较。</p>
<h3 id="题解-8"><a href="#题解-8" class="headerlink" title="题解"></a>题解</h3><p>两次遍历链表，第一次求出链表长度，第二次直接返回最后k个节点的开始节点</p>
<h3 id="Java代码实现-8"><a href="#Java代码实现-8" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pHead ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span> <span class="params">(ListNode pHead, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        ListNode cur = pHead;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ++len;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 题目中说若是链表长度小于k则返回空链表，这里已经考虑了链表为空的情况(len = 0)</span></span><br><span class="line">        <span class="keyword">if</span>(len &lt; k)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = pHead;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 这里需要稍微考虑下i++到底应该小于多少</span></span><br><span class="line">        <span class="keyword">while</span>(i++ &lt; len - k)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM9-删除链表的倒数第n个节点"><a href="#BM9-删除链表的倒数第n个节点" class="headerlink" title="BM9 删除链表的倒数第n个节点"></a>BM9 <a href="https://www.nowcoder.com/practice/f95dcdafbde44b22a6d741baf71653f6?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">删除链表的倒数第n个节点</a></h2><h3 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个链表，删除链表的倒数第 n 个节点并返回链表的头指针<br>例如， </p>
<p>给出的链表为: 1→2→3→4→5, n=2.<br>删除了链表的倒数第 n<em>n</em> 个节点之后,链表变为1→2→3→5.</p>
<p>数据范围： 链表长度 0≤n≤1000，链表中任意节点的值满足 0≤val≤100</p>
<p>要求：空间复杂度 O(1)，时间复杂度 O(n)<br>备注： </p>
<p>题目保证 n 一定是有效的</p>
<h3 id="题解-9"><a href="#题解-9" class="headerlink" title="题解"></a>题解</h3><p>这里的思路也是两次遍历链表，然后找到需要删除的节点，但要注意保存需要删除的节点之前的节点。</p>
<p><strong>可用一个虚拟头节点防止各种复杂条件判断</strong></p>
<h3 id="Java代码实现-9"><a href="#Java代码实现-9" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span> <span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 虚拟头节点</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        <span class="comment">// 遍历需要的两个节点</span></span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        ListNode pre = dummy;</span><br><span class="line">        <span class="comment">// 开始第一次遍历求出链表长度</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ++len;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 题目中说n符合要求，故无需判断，直接二次遍历即可</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//注意这里将cur指针返回head</span></span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span>(i++ &lt; len - n)&#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里将cur节点删除，实际上就是将cur之前的指针与cur之后的指针进行连接即可</span></span><br><span class="line">        pre.next = cur.next;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM10-两个链表的第一个公共结点"><a href="#BM10-两个链表的第一个公共结点" class="headerlink" title="BM10 两个链表的第一个公共结点"></a>BM10 <a href="https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">两个链表的第一个公共结点</a></h2><h3 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两个无环的单向链表，找出它们的第一个公共结点，如果没有公共节点则返回空。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的） </p>
<p>数据范围： n≤1000<br>要求：空间复杂度 O(1)，时间复杂度 O(n)</p>
<p>例如，输入{1,2,3},{4,5},{6,7}时，两个无环的单向链表的结构如下图所示：</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20211104/423483716_1635999204882/394BB7AFD5CEA3DC64D610F62E6647A6" alt="img"></p>
<p>可以看到它们的第一个公共结点的结点值为6，所以返回结点值为6的结点。</p>
<h4 id="输入描述："><a href="#输入描述：" class="headerlink" title="输入描述："></a>输入描述：</h4><p>输入分为是3段，第一段是第一个链表的非公共部分，第二段是第二个链表的非公共部分，第三段是第一个链表和第二个链表的公共部分。 后台会将这3个参数组装为两个链表，并将这两个链表对应的头节点传入到函数FindFirstCommonNode里面，用户得到的输入只有pHead1和pHead2。</p>
<h4 id="返回值描述："><a href="#返回值描述：" class="headerlink" title="返回值描述："></a>返回值描述：</h4><p>返回传入的pHead1和pHead2的第一个公共结点，后台会打印以该节点为头节点的链表。</p>
<h3 id="题解-10"><a href="#题解-10" class="headerlink" title="题解"></a>题解</h3><p>最简单的方法是先将一个链表中的所有节点放入一个set中，之后对于第二个链表中的每一个节点，若是set中已有，则返回该节点（需要的是第一个公共节点，故只要找到就直接返回），若是遍历完之后仍然没有找到公共节点，那么返回null，但此方法空间复杂度为O(n)，不合题意，若是想要O(1)的时间复杂度可采取如下思路：</p>
<p>两次遍历链表，第一次遍历记载两个链表的长度，然后找到一个链表比另一个链表长多少(len1 - len2)，较长的链表先走(len1 - len2)格，之后两个链表一起走，若是某时刻两个节点相同，那直接返回，之后若是遍历完仍然未找到相同元素，返回null</p>
<h3 id="Java代码实现-10"><a href="#Java代码实现-10" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况，若是两个链表某一个为空，那直接返回null</span></span><br><span class="line">        <span class="keyword">if</span>(pHead1 == <span class="keyword">null</span> || pHead2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len2 = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 当前链表1走到了哪</span></span><br><span class="line">        ListNode cur1 = pHead1;</span><br><span class="line">        <span class="comment">// 当前链表2走到了哪</span></span><br><span class="line">        ListNode cur2 = pHead2;</span><br><span class="line">        <span class="keyword">while</span>(cur1 != <span class="keyword">null</span> || cur2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">                ++len1;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">                ++len2;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将指针放回头部</span></span><br><span class="line">        cur1 = pHead1;</span><br><span class="line">        cur2 = pHead2;</span><br><span class="line">        <span class="keyword">if</span>(len1 &gt;= len2)&#123;</span><br><span class="line">            <span class="keyword">return</span> run(cur1, cur2, len1 - len2);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> run(cur2, cur1, len2 - len1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">run</span><span class="params">(ListNode head1, ListNode head2, <span class="keyword">int</span> lenSub)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 先让head1走lenSub格，已经确保head1不比head2短</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i++ &lt; lenSub)&#123;</span><br><span class="line">            head1 = head1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 之后两个一起走</span></span><br><span class="line">        <span class="keyword">while</span>(head1 != <span class="keyword">null</span> &amp;&amp; head2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head1 == head2)&#123;</span><br><span class="line">                <span class="keyword">return</span> head1;</span><br><span class="line">            &#125;</span><br><span class="line">            head1 = head1.next;</span><br><span class="line">            head2 = head2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 要是退出循环（遍历完）还未找到说明不存在</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM11-链表相加（二）"><a href="#BM11-链表相加（二）" class="headerlink" title="BM11 链表相加（二）"></a>BM11 <a href="https://www.nowcoder.com/practice/c56f6c70fb3f4849bc56e33ff2a50b6b?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">链表相加（二）</a></h2><h3 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h3><p>假设链表中每一个节点的值都在 0 - 9 之间，那么链表整体就可以代表一个整数。 </p>
<p>给定两个这种链表，请生成代表两个整数相加值的结果链表。 </p>
<p>数据范围：0≤n,m≤1000000，链表任意值 0≤val≤9<br>要求：空间复杂度 O(n)，时间复杂度 O(n)</p>
<p>例如：链表 1 为 9-&gt;3-&gt;7，链表 2 为 6-&gt;3，最后生成新的结果链表为 1-&gt;0-&gt;0-&gt;0。 </p>
<p><img src="https://uploadfiles.nowcoder.com/images/20211105/423483716_1636084743981/C2DB572B01B0FDC03C097BE7ABA45114" alt="img"></p>
<h3 id="题解-11"><a href="#题解-11" class="headerlink" title="题解"></a>题解</h3><p>最简单的方法，将链表中的每一个元素取出来，两个数相加之后再返回，但是注意数据范围是0≤n,m≤1000000，此方法无法保存这么大的数据，故舍弃。</p>
<p>考虑直接对链表节点进行相加，但涉及两个问题，一是顺序问题（链表是正序的，但是相加时需要逆序），而是考虑进位问题，对于顺序问题，先进后出考虑用栈解决，进位只需多一个节点进行保存即可。</p>
<h3 id="Java代码实现-11"><a href="#Java代码实现-11" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head1 ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head2 ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addInList</span> <span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 特殊情况优先考虑，若是两个链表一个为空那直接返回另一个即可</span></span><br><span class="line">        <span class="keyword">if</span>(head1 == <span class="keyword">null</span> || head2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head1 == <span class="keyword">null</span> ? head2 : head1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 栈中存节点空间消耗太大，直接存节点中的值即可</span></span><br><span class="line">        <span class="comment">// 保存第一个链表中的数</span></span><br><span class="line">        Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">// 保存第二个链表中的数</span></span><br><span class="line">        Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">// 保存相加之后的结果</span></span><br><span class="line">        Stack&lt;Integer&gt; ans = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        ListNode cur = head1;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack1.push(cur.val);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head2;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack2.push(cur.val);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 进位</span></span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stack1.isEmpty() || !stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> num1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> num2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(!stack1.isEmpty())&#123;</span><br><span class="line">                num1 = stack1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!stack2.isEmpty())&#123;</span><br><span class="line">                num2 = stack2.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> sum = num1 + num2 + carry;</span><br><span class="line">            ans.push(sum % <span class="number">10</span>);</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里最后判断一下进位是否为0，若进位不是0则需要处理</span></span><br><span class="line">        <span class="keyword">if</span>(carry != <span class="number">0</span>)&#123;</span><br><span class="line">            ans.push(carry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 生成链表</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        cur = dummy;</span><br><span class="line">        <span class="keyword">while</span>(!ans.isEmpty())&#123;</span><br><span class="line">            cur.next = <span class="keyword">new</span> ListNode(ans.pop());</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM12-单链表的排序问题"><a href="#BM12-单链表的排序问题" class="headerlink" title="BM12 单链表的排序问题"></a>BM12 <a href="https://www.nowcoder.com/practice/f23604257af94d939848729b1a5cda08?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">单链表的排序问题</a></h2><h3 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个节点数为n的无序单链表，对其按升序排序。</p>
<p>数据范围：0&lt;n≤100000</p>
<p>要求：空间复杂度 O(n)，时间复杂度 O(nlogn)</p>
<h3 id="题解-12"><a href="#题解-12" class="headerlink" title="题解"></a>题解</h3><p>最简单的做法是遍历链表，将链表中每个节点的值放入数组中，对数组进行排序，之后再逐个取出元素并新建链表节点，这里注意将链表的每个节点值存入数组中空间占用更小</p>
<h3 id="Java代码实现-12"><a href="#Java代码实现-12" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 the head node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortInList</span> <span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 特殊情况，只有一个元素时无需排序（题目中说节点数n &gt; 0）</span></span><br><span class="line">        <span class="keyword">if</span>(head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            list.add(cur.val);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        <span class="comment">// 记得把指针回退</span></span><br><span class="line">        cur = dummy;</span><br><span class="line">        <span class="comment">// 逐一构造</span></span><br><span class="line">        <span class="keyword">for</span>(Integer num : list)&#123;</span><br><span class="line">            cur.next = <span class="keyword">new</span> ListNode(num);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM13-判断一个链表是否是回文结构"><a href="#BM13-判断一个链表是否是回文结构" class="headerlink" title="BM13 判断一个链表是否是回文结构"></a>BM13 <a href="https://www.nowcoder.com/practice/3fed228444e740c8be66232ce8b87c2f?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">判断一个链表是否是回文结构</a></h2><h3 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个链表，请判断该链表是否为回文结构。</p>
<p>回文是指该字符串正序逆序完全一致。 </p>
<p>数据范围： 链表节点数 0≤n≤105，链表中每个节点的值满足 ∣val∣≤107</p>
<h3 id="题解-13"><a href="#题解-13" class="headerlink" title="题解"></a>题解</h3><p>很多实惠，直接对链表进行操作不方便，可以借助数组辅助操作，这里只要将节点中的每个数放入数组中进行比较即可，但这里注意一点，题目中说了回文但是每个节点的值满足|val|&lt;=10^7，那{1, 235, 235, 1}算回文还是{1, 235, 532, 1}算回文，若是第一种的话，只要将每个节点的值放入数组中，两个指针同时移动，判断是否相等即可，若是另一种，则建议将整数转化为字符串进行操作，之后对于字符串中的每个字符进行操作。</p>
<h3 id="Java代码实现-13"><a href="#Java代码实现-13" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 the head</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPail</span> <span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 特殊情况head为null</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; nums = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            nums.add(cur.val);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="comment">// 注意这里用的是equals而不是==，用==比较的是地址，只有当两个数都在常量池中时才会成功</span></span><br><span class="line">            <span class="keyword">if</span>(!nums.get(i).equals(nums.get(n - i - <span class="number">1</span>)))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码最终是正确的，因此这里所说的回文是第一种，不过需要注意的是在比较Integer的过程中用equals而不是用==，或者就利用自动装箱机制转换为int，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num1 = nums.get(i);</span><br><span class="line"><span class="keyword">int</span> num2 = nums.get(n - i - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(num1 != num2)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM14-链表的奇偶重拍"><a href="#BM14-链表的奇偶重拍" class="headerlink" title="BM14 链表的奇偶重拍"></a>BM14 <a href="https://www.nowcoder.com/practice/02bf49ea45cd486daa031614f9bd6fc3?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">链表的奇偶重拍</a></h2><h3 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个单链表，请设定一个函数，将链表的奇数位节点和偶数位节点分别放在一起，重排后输出。 </p>
<p>注意是节点的编号而非节点的数值。 </p>
<p>数据范围：节点数量满足 0≤n≤105，节点中的值都满足 0≤val≤1000</p>
<p>要求：空间复杂度 O(n)，时间复杂度 O(n)</p>
<h3 id="题解-14"><a href="#题解-14" class="headerlink" title="题解"></a>题解</h3><p>新建两个链表，一个用于放奇数的节点，一个用于放偶数的节点，再将两个链表连接即可。</p>
<h3 id="Java代码实现-14"><a href="#Java代码实现-14" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">oddEvenList</span> <span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 特殊情况依旧优先考虑，当链表有012个节点时直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结果链表以及奇偶链表的头节点</span></span><br><span class="line">        ListNode dummy1 = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode dummy2 = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 当前的初始链表以及奇偶链表到达的位置</span></span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        ListNode cur1 = dummy1;</span><br><span class="line">        ListNode cur2 = dummy2;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ++len;</span><br><span class="line">            <span class="comment">// 这里是奇偶判断，只不过位运算更快，故选择位运算</span></span><br><span class="line">            <span class="keyword">if</span>((len &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">                cur1.next = cur;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur2.next = cur;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 防止有粘连，先将链表断开</span></span><br><span class="line">        <span class="comment">// 但思考之后发现只需要断开偶数的即可，因为奇数的后一步操作实际上已经断开了</span></span><br><span class="line">        <span class="keyword">if</span>(cur1.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            cur1.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur2.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            cur2.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将奇链表与偶链表连接，cur1即为奇链表的尾</span></span><br><span class="line">        <span class="comment">// 这里其实已经避免了奇数的粘连</span></span><br><span class="line">        cur1.next = dummy2.next;    <span class="comment">// 注意这里偶链表真正开始的节点为dummy2.next（虚节点）</span></span><br><span class="line">        <span class="keyword">return</span> dummy1.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这里有必要提一下我注释中说到的粘连，假设有链表{1, 2, 3, 4, 5, 6}，当进行上述代码的操作之后得到的链表实际是这样的{1, 3, 5, 6} 和{2, 4, 6}，我们需要的只有1 3 5，但6由于在原始链表中是5的next，故也放到了链表中，这对于原链表长度为偶数的时候不影响（因为后面连接的操作实际上已经把粘连部分去除了），但当原链表长度为奇数时就有影响了，假设有链表{1, 2, 3, 4, 5}，操作之后得到的链表是{1, 3, 5}和{2, 4, 5}，此时就无法得到正常结果</strong></p>
<h2 id="BM15-删除有序链表中重复的元素-I"><a href="#BM15-删除有序链表中重复的元素-I" class="headerlink" title="BM15 删除有序链表中重复的元素-I"></a>BM15 <a href="https://www.nowcoder.com/practice/c087914fae584da886a0091e877f2c79?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">删除有序链表中重复的元素-I</a></h2><h3 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h3><p>删除给出链表中的重复元素（链表中元素从小到大有序），使链表中的所有元素都只出现一次<br>例如：<br>给出的链表为1→1→2,返回1→2.<br>给出的链表为1→1→2→3→3,返回1→2→3. </p>
<h3 id="题解-15"><a href="#题解-15" class="headerlink" title="题解"></a>题解</h3><p>去重最简单的办法是利用HashSet，每次将节点的值放入HashSet中，又考虑之后还要有序构建，因此考虑LinedHashSet，但此时空间复杂度为O(n)，不合题意。</p>
<p>想到利用两个指针，一个记录当前位，另一个记录下一位，使用两个指针的目的是，当遇到当前元素与下一位元素相同时，不移动当前位，移动下一位直至当前位与下一位不同时，将当前位与下一位连接，如此遍历数组即可</p>
<h3 id="Java代码实现-15"><a href="#Java代码实现-15" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span> <span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 特殊情况优先考虑</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        ListNode nex = head.next;</span><br><span class="line">        <span class="comment">// 肯定是后一个先到，但存在一种情况就是后面几个元素都相同时需要显式地令cur.nex = null</span></span><br><span class="line">        <span class="keyword">while</span>(nex != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.val == nex.val)&#123;</span><br><span class="line">                nex = nex.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur.next = nex;</span><br><span class="line">                cur = nex;</span><br><span class="line">                nex = nex.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时cur所在的位置可能有多种</span></span><br><span class="line">        <span class="comment">// 一是倒数第一个元素</span></span><br><span class="line">        <span class="comment">// 二是倒数第k个元素（后面k个元素值都相同）</span></span><br><span class="line">        <span class="comment">// 此时只需比较cur以及其后面第一个元素（前提是其后面有元素），要是相同则显式令其next为null，反之则无需操作</span></span><br><span class="line">        <span class="keyword">if</span>(cur.next != <span class="keyword">null</span> &amp;&amp; cur.val == cur.next.val)&#123;</span><br><span class="line">            cur.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM16-删除有序列表中重复的元素-II"><a href="#BM16-删除有序列表中重复的元素-II" class="headerlink" title="BM16 删除有序列表中重复的元素-II"></a>BM16 <a href="https://www.nowcoder.com/practice/71cef9f8b5564579bf7ed93fbe0b2024?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">删除有序列表中重复的元素-II</a></h2><h3 id="题目描述-15"><a href="#题目描述-15" class="headerlink" title="题目描述"></a>题目描述</h3><p>给出一个升序排序的链表，删除链表中的所有重复出现的元素，只保留原链表中只出现一次的元素。<br>例如：<br>给出的链表为1→2→3→3→4→4→5, 返回1→2→5.<br>给出的链表为1→1→1→2→3, 返回2→3. </p>
<h3 id="题解-16"><a href="#题解-16" class="headerlink" title="题解"></a>题解</h3><p>第一种思路是使用两个Set加一个数组实现一个set放全部元素，另一个set放重复的元素，数组按序放节点的值，第一次遍历，若是发现放全部元素的Set中已有这个元素，那么将此元素放入放置重复元素的Set中，此外第一次遍历还需要将链表中的全部节点值放入数组中，第二次遍历数组，若是数组中的元素并不属于放重复元素的Set中，那么以此值新建节点并连接到链表中，但此时空间复杂度为O(n)，不合题意。</p>
<p>正确思路是：使用三个指针，pre表示前一个，cur表示当前，nex表示后一个，若是遇到相同元素，则移动nex指针直到cur与nex值不相同，若是不同则直接pre指向nex，然后三个指针依次后移一位即可</p>
<h3 id="Java代码实现-16"><a href="#Java代码实现-16" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span> <span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 特殊情况优先考虑</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 防止出现第一个元素就需要删除的情况，用虚拟头节点</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode pre = dummy;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        ListNode nex = head.next;</span><br><span class="line">        <span class="keyword">while</span>(nex != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.val == nex.val)&#123;</span><br><span class="line">                <span class="comment">// 元素相同时不断移动nex指针</span></span><br><span class="line">                <span class="keyword">while</span>(nex != <span class="keyword">null</span> &amp;&amp; cur.val == nex.val)&#123;</span><br><span class="line">                    nex = nex.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//此时以及移动完了，修改指针</span></span><br><span class="line">                pre.next = nex;</span><br><span class="line">                cur = nex;</span><br><span class="line">                <span class="comment">// 退出循环还有一种情况是nex为null了，此时不再后移nex指针</span></span><br><span class="line">                <span class="keyword">if</span>(nex != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    nex = nex.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 元素不同时先连接pre和nex，再移动</span></span><br><span class="line">                pre.next = cur;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = nex;</span><br><span class="line">                nex = nex.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二分查找-排序"><a href="#二分查找-排序" class="headerlink" title="二分查找/排序"></a>二分查找/排序</h1><h2 id="BM17-二分查找-I"><a href="#BM17-二分查找-I" class="headerlink" title="BM17 二分查找-I"></a>BM17 <a href="https://www.nowcoder.com/practice/d3df40bd23594118b57554129cadf47b?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">二分查找-I</a></h2><h3 id="题目描述-16"><a href="#题目描述-16" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现无重复数字的升序数组的二分查找 </p>
<p>给定一个 元素升序的、无重复数字的整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标（下标从 0 开始），否则返回 -1 </p>
<p>数据范围：0≤len(nums)≤2×105， 数组中任意值满足 ∣val∣≤109</p>
<p>进阶：时间复杂度 O(log⁡n)，空间复杂度 O(1)</p>
<h3 id="题解-17"><a href="#题解-17" class="headerlink" title="题解"></a>题解</h3><p>二分实际上就是把一个数组分为左右两份，每次比较目标值与中间值，若是中间值比较大那证明在左半部分，若是目标值比较大说明在右半部分，若是最后（那部分只有一个数切这个数不为目标值，那证明此数组中没有该目标值）。</p>
<h3 id="Java代码实现-17"><a href="#Java代码实现-17" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span> <span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">                <span class="comment">// 相等了直接返回</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                <span class="comment">// 比目标值小说明在右半部分</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 否则在左半部分</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM18-二维数组中的查找"><a href="#BM18-二维数组中的查找" class="headerlink" title="BM18 二维数组中的查找"></a>BM18 二维数组中的查找</h2><h3 id="题目描述-17"><a href="#题目描述-17" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个二维数组array中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 </p>
<p>[ </p>
<p>[1,2,8,9],<br>[2,4,9,12],<br>[4,7,10,13],<br>[6,8,11,15]</p>
<p>] </p>
<p>给定 target = 7，返回 true。 </p>
<p>给定 target = 3，返回 false。 </p>
<p>数据范围：矩阵的长宽满足 0≤n,m≤500， 矩阵中的值满足 0≤val≤109<br>进阶：空间复杂度 O(1)，时间复杂度 O(n+m)</p>
<h3 id="题解-18"><a href="#题解-18" class="headerlink" title="题解"></a>题解</h3><p>这题首先保证目标值和当前值大小关系确定时只需向一个方向移动（比如说当前值小于目标值时是应该向下移动或是向右移动），为了保证这一点，我们可以从数组的右上或是左下开始遍历，从右上遍历保证当前数是这一行最大的，当前这一列最小的，若是需要更大的只需要往下找即可，若是需要更小的只需要往左找即可，从左下开始遍历可以保证每个数都是当前这一行最小的，当前这一列最大的，若是需要更大的就往右走，若是需要更小的就往左走。</p>
<h3 id="Java代码实现-18"><a href="#Java代码实现-18" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(array == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 确定行列数</span></span><br><span class="line">        <span class="keyword">int</span> m = array.length;</span><br><span class="line">        <span class="keyword">int</span> n = array[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// 从右上开始遍历，行数为0列数为n-1</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= m - <span class="number">1</span> &amp;&amp; j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i][j] == target)&#123;</span><br><span class="line">                <span class="comment">// 相等返回true</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[i][j] &lt; target)&#123;</span><br><span class="line">                <span class="comment">// 小于就往下找</span></span><br><span class="line">                ++i;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 大于就往左找</span></span><br><span class="line">                --j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时仍未找到就返回false；</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM19-寻找峰值"><a href="#BM19-寻找峰值" class="headerlink" title="BM19 寻找峰值"></a>BM19 <a href="https://www.nowcoder.com/practice/fcf87540c4f347bcb4cf720b5b350c76?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">寻找峰值</a></h2><h3 id="题目描述-18"><a href="#题目描述-18" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个长度为n的数组nums，请你找到峰值并返回其索引。数组可能包含多个峰值，在这种情况下，返回任何一个所在位置即可。 </p>
<p>1.峰值元素是指其值严格大于左右相邻值的元素。严格大于即不能有等于</p>
<p>2.假设 nums[-1] = nums[n] = −∞</p>
<p>3.对于所有有效的 i 都有 nums[i] != nums[i + 1] </p>
<p>4.你可以使用O(logN)的时间复杂度实现此问题吗？ </p>
<p>数据范围： </p>
<p>1≤nums.length≤2×105</p>
<p>−231&lt;=nums[i]&lt;=2^31−1</p>
<p>如输入[2,4,1,2,7,8,4]时，会形成两个山峰，一个是索引为1，峰值为4的山峰，另一个是索引为5，峰值为8的山峰，如下图所示： </p>
<p><img src="https://uploadfiles.nowcoder.com/images/20211014/423483716_1634212356346/9EB9CD58B9EA5E04C890326B5C1F471F" alt="img"></p>
<h3 id="题解-19"><a href="#题解-19" class="headerlink" title="题解"></a>题解</h3><p>题目中已经假定数组之外的部分都为无穷小，那么当发现此时数组是递增的，那么就一定会存在山峰，因为即使递增到数组的边界，那边界值就是山峰（边界之外的部分是无穷小），反之若是递减则不一定存在山峰。</p>
<p>明确了以上问题之后，可以用二分的方式进行查询，但二分的思想需要一个目标值target，让target与中间值比较，在这里我们选择使用中间值的后一位作为target（这里注意只有当left == right == n - 1中间值才取到最后一位的，但此时实际上right即为波峰），那么当target大于中间值时，从中间值到target必有一部分是递增的，当target小于中间值的时候，我们考虑数组的另一部分。</p>
<h3 id="Java代码实现-19"><a href="#Java代码实现-19" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span> <span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 特殊情况只有一个元素时是波峰</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 这里的不同之处在于不能取等号，因为最后面返回的值是最大值，即只要一直在上坡，那么right永远大于mid大于left</span></span><br><span class="line">        <span class="comment">// 反之若是发现在下坡，那就寻找另一半</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[mid + <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="comment">// 此时右侧为上坡，继续寻找即可</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 此时右侧为下坡，为了避免当前值为波峰，这里right应为mid而不是mid - 1</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM20-数组中的逆序对"><a href="#BM20-数组中的逆序对" class="headerlink" title="BM20 数组中的逆序对"></a>BM20 <a href="https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">数组中的逆序对</a></h2><h3 id="题目描述-19"><a href="#题目描述-19" class="headerlink" title="题目描述"></a>题目描述</h3><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P mod 1000000007</p>
<p>数据范围： 对于 50%50% 的数据, size≤104<br>对于 100%100% 的数据, size≤105</p>
<p>数组中所有数字的值满足 0≤val≤1000000</p>
<p>要求：空间复杂度 O(n)，时间复杂度 O(nlogn)</p>
<h2 id="题解-20"><a href="#题解-20" class="headerlink" title="题解"></a>题解</h2><p>这题由于是逆序对（只有两个元素），因此最简单的方法是将数组中所有的数对都表示出来，之后判断是否是逆序对，是的话在逆序对计数的地方加1，如此便能解决问题，但时间复杂度为O(n^2)，题目中要求的是O(nlogn)，不合题意。</p>
<p>这题看时间复杂度想到用合并排序的思想来解决问题，合并排序中需要对两个有序数组进行合并，此时需要移动元素，若是当前元素比其前一个元素小，那么就需要前移元素，此时，一个前移操作就找到了一个逆序对，计算出每次合并需要的元素个数即为逆序对的数目。</p>
<h3 id="Java代码实现-20"><a href="#Java代码实现-20" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOD = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(array == <span class="keyword">null</span> || array.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在分治的过程中求出解</span></span><br><span class="line">        mergeSort(array);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分治算法的思想，先将数组分为有限个子序列，先令子序列有序，再合并有序的字序列</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] nums1 = Arrays.copyOfRange(nums, <span class="number">0</span>, n / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">int</span>[] nums2 = Arrays.copyOfRange(nums, n / <span class="number">2</span>, n);</span><br><span class="line">            mergeSort(nums1);</span><br><span class="line">            mergeSort(nums2);</span><br><span class="line">            merge(nums, nums1, nums2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在这里对两个数组进行合并并在每次合并中查找逆序对</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] sorted, <span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> n2 = nums2.length;</span><br><span class="line">        <span class="comment">// 标记当前两个数组走到了哪</span></span><br><span class="line">        <span class="keyword">int</span> cur1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cur2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sorted.length; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur1 == n1)&#123;</span><br><span class="line">                <span class="comment">// 第一个数组遍历完了</span></span><br><span class="line">                sorted[i] = nums2[cur2];</span><br><span class="line">                ++cur2;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur2 == n2)&#123;</span><br><span class="line">                <span class="comment">// 第二个数组遍历完了</span></span><br><span class="line">                sorted[i] = nums1[cur1];</span><br><span class="line">                ++cur1;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 两个数组都没遍历完</span></span><br><span class="line">                <span class="keyword">if</span>(nums1[cur1] &gt; nums2[cur2])&#123;</span><br><span class="line">                    <span class="comment">// 需要先插入后面的元素</span></span><br><span class="line">                    sorted[i] = nums2[cur2];</span><br><span class="line">                  	<span class="comment">// 特别注意这里，总共有6个元素，当前下标为3表示是第四个元素（这个元素已经后面的全部元素都是逆序对）</span></span><br><span class="line">                    res += n1 - cur1;</span><br><span class="line">                    res %= MOD;</span><br><span class="line">                    ++cur2;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    sorted[i] = nums1[cur1];</span><br><span class="line">                    ++cur1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这个题解跟大部分的思路不同，采用了最原始的Arrays.copyOfRange()方法，因此res += 部分也与其余题解有所不同，但思路一致。</strong></p>
<h2 id="BM21-旋转数组的最小数字"><a href="#BM21-旋转数组的最小数字" class="headerlink" title="BM21 旋转数组的最小数字"></a>BM21 <a href="https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">旋转数组的最小数字</a></h2><h3 id="题目描述-20"><a href="#题目描述-20" class="headerlink" title="题目描述"></a>题目描述</h3><p>有一个长度为 n 的非降序数组，比如[1,2,3,4,5]，将它进行旋转，即把一个数组最开始的若干个元素搬到数组的末尾，变成一个旋转数组，比如变成了[3,4,5,1,2]，或者[4,5,1,2,3]这样的。请问，给定这样一个旋转数组，求数组中的最小值。</p>
<p>数据范围：1≤n≤10000，数组中任意元素的值: 0≤val≤10000</p>
<p>要求：空间复杂度：O(1)，时间复杂度：O(logn)</p>
<h3 id="题解-21"><a href="#题解-21" class="headerlink" title="题解"></a>题解</h3><p>最简单的方法是遍历数组找到最小值，但时间复杂度是O(n)，不合题意。由于数组原始是非降序的之后将最开始的几个元素搬到了末尾，那么数组部分是有序的，可以使用二分，以数组的端点作为target值，当中间值小于target时，证明在左半部分（由于原数组非降序，不可能出现大于最大值之后，从最小值开始仍然大于中间值，即不可能出现mid到target是{6, 7, 1, 4, 8}的情况），当中间值大于target时，证明在右半部分，若是特别特殊，两者相等，即原数组为{5, 5, 5, 5, 5, 1, 2, 3, 4, 5}或者{1, 0, 1, 1, 1}时，无法确定属于哪部分，令target = nums[right - 1]，缩小范围后继续，如此循环便能找到。</p>
<h3 id="Java代码实现-21"><a href="#Java代码实现-21" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(array.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[mid] &lt; array[right])&#123;</span><br><span class="line">                <span class="comment">// 小于表示在左半部分</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[mid] &gt; array[right])&#123;</span><br><span class="line">                <span class="comment">// 大于表示在右半部分</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 等于则缩小范围</span></span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用二分法时，有时题目中没有target，那么需要考虑如何选择target才最优，寻找山峰问题target是中间值的下一位，而这里target是right</strong></p>
<h2 id="BM22-比较版本号"><a href="#BM22-比较版本号" class="headerlink" title="BM22 比较版本号"></a>BM22 <a href="https://www.nowcoder.com/practice/2b317e02f14247a49ffdbdba315459e7?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">比较版本号</a></h2><h3 id="题目描述-21"><a href="#题目描述-21" class="headerlink" title="题目描述"></a>题目描述</h3><p>牛客项目发布项目版本时会有版本号，比如1.02.11，2.14.4等等 </p>
<p>现在给你2个版本号version1和version2，请你比较他们的大小</p>
<p>版本号是由修订号组成，修订号与修订号之间由一个”.”连接。1个修订号可能有多位数字组成，修订号可能包含前导0，且是合法的。例如，1.02.11，0.1，0.2都是合法的版本号</p>
<p>每个版本号至少包含1个修订号。 </p>
<p>修订号从左到右编号，下标从0开始，最左边的修订号下标为0，下一个修订号下标为1，以此类推。 </p>
<p>比较规则： </p>
<p>一. 比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较忽略任何前导零后的整数值。比如”0.1”和”0.01”的版本号是相等的 </p>
<p>二. 如果版本号没有指定某个下标处的修订号，则该修订号视为0。例如，”1.1”的版本号小于”1.1.1”。因为”1.1”的版本号相当于”1.1.0”，第3位修订号的下标为0，小于1 </p>
<p>三. version1 &gt; version2 返回1，如果 version1 &lt; version2 返回-1，不然返回0. </p>
<p>数据范围： </p>
<p>1&lt;=version1.length,version2.length&lt;=1000</p>
<p>version1 和 version2 的修订号不会超过int的表达范围，即不超过 <strong>32 位整数</strong> 的范围</p>
<p>进阶： 空间复杂度 O(1)， 时间复杂度 O(n)</p>
<h3 id="题解-22"><a href="#题解-22" class="headerlink" title="题解"></a>题解</h3><p>最简单的方法是利用.将两个字符串分解为字符数组，之后逐个比较，但此方法需要额外开辟空间，空间复杂度为O(n)，不合题意。</p>
<h3 id="Java代码实现如下"><a href="#Java代码实现如下" class="headerlink" title="Java代码实现如下"></a>Java代码实现如下</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 比较版本号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> version1 string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> version2 string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span> <span class="params">(String version1, String version2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">      	<span class="comment">// 这里注意正则表达式的书写，\需要转译</span></span><br><span class="line">        String[] strs1 = version1.split(<span class="string">"\\."</span>);</span><br><span class="line">        String[] strs2 = version2.split(<span class="string">"\\."</span>);</span><br><span class="line">        <span class="keyword">int</span> len1 = strs1.length;</span><br><span class="line">        <span class="keyword">int</span> len2 = strs2.length;</span><br><span class="line">        <span class="keyword">int</span> minLen = len1 &lt; len2 ? len1 : len2;</span><br><span class="line">      	<span class="comment">// 匹配两者都有的部分</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; minLen; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> num1 = Integer.parseInt(strs1[i]);</span><br><span class="line">            <span class="keyword">int</span> num2 = Integer.parseInt(strs2[i]);</span><br><span class="line">            <span class="keyword">if</span>(num1 &lt; num2)&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num1 &gt; num2)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// 匹配完了开始判断</span></span><br><span class="line">        <span class="keyword">if</span>(len1 == len2)&#123;</span><br><span class="line">            <span class="comment">// 长度相等直接返回0（之前已经能确定全部匹配）</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len1 &gt; len2)&#123;</span><br><span class="line">            <span class="comment">// version1比较长，多出来的和0比较</span></span><br><span class="line">            <span class="keyword">while</span>(minLen &lt; len1)&#123;</span><br><span class="line">                <span class="keyword">if</span>(Integer.parseInt(strs1[minLen]) != <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ++minLen;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// version2长同理，和0比较</span></span><br><span class="line">            <span class="keyword">while</span>(minLen &lt; len2)&#123;</span><br><span class="line">                <span class="keyword">if</span>(Integer.parseInt(strs2[minLen]) != <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ++minLen;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题解-23"><a href="#题解-23" class="headerlink" title="题解"></a>题解</h3><p>若是想达到O(1)的空间复杂度，可以考虑使用双指针，一个指针用于解析version1，一个指针用于解析version2，对于前导0的处理是不处理（因为每次只用处理一个字符，若是当前字符不是’.’，那么直接用已经解析出的值（当前值前面的值） * 10 + 当前的值），遇到前导0，已经解析出的值为0，0 * 10 + 0 = 0，并无影响，此方法主要是逐个读取字符，即：”103”的解析过程为1，1 * 10 + 0 = 10，10 * 10 + 3 = 103。</p>
<h3 id="Java代码实现-22"><a href="#Java代码实现-22" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 比较版本号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> version1 string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> version2 string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span> <span class="params">(String version1, String version2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">char</span>[] str1 = version1.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] str2 = version2.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> len1 = str1.length;</span><br><span class="line">        <span class="keyword">int</span> len2 = str2.length;</span><br><span class="line">        <span class="comment">// 两个遍历指针</span></span><br><span class="line">        <span class="keyword">int</span> cur1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cur2 = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 只要两个字符串中任何一个没有解析完，那就继续解析</span></span><br><span class="line">        <span class="keyword">while</span>(cur1 &lt; len1 || cur2 &lt; len2)&#123;</span><br><span class="line">            <span class="comment">// 设置解析出的元素，初始值为0</span></span><br><span class="line">            <span class="keyword">int</span> num1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> num2 = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 只有str1未解析完才解析，否则其为0</span></span><br><span class="line">            <span class="keyword">if</span>(cur1 &lt; len1)&#123;</span><br><span class="line">                <span class="comment">// 这里必须是cur++，否则会导致解析不到.之前的那个数，而且这样也直接跳过了.</span></span><br><span class="line">                <span class="keyword">while</span>(cur1 &lt; len1 &amp;&amp; str1[cur1++] != <span class="string">'.'</span>)&#123;</span><br><span class="line">                    <span class="comment">// 这里为什么是cur-1呢，因为前面已经自增过一次</span></span><br><span class="line">                    num1 = <span class="number">10</span> * num1 + str1[cur1 - <span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 同理只有str2未解析完才解析，否则为初始值0</span></span><br><span class="line">            <span class="keyword">if</span>(cur2 &lt; len2)&#123;</span><br><span class="line">                <span class="comment">// 这里必须是cur++，否则会导致解析不到.之前的那个数，而且这样也直接跳过了.</span></span><br><span class="line">                <span class="keyword">while</span>(cur2 &lt; len2 &amp;&amp; str2[cur2++] != <span class="string">'.'</span>)&#123;</span><br><span class="line">                    <span class="comment">// 这里为什么是cur-1呢，因为前面已经自增过一次</span></span><br><span class="line">                    num2 = <span class="number">10</span> * num2 + str2[cur2 - <span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 通过以上步骤已经将两个都解析了，这里只需要判断就好</span></span><br><span class="line">            <span class="keyword">if</span>(num1 &gt; num2)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num1 &lt; num2)&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h3 id="BM23-二叉树的前序遍历"><a href="#BM23-二叉树的前序遍历" class="headerlink" title="BM23 二叉树的前序遍历"></a>BM23 <a href="https://www.nowcoder.com/practice/5e2135f4d2b14eb8a5b06fab4c938635?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">二叉树的前序遍历</a></h3><h3 id="题目描述-22"><a href="#题目描述-22" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你二叉树的根节点 root ，返回它节点值的 前序 遍历。</p>
<p>数据范围：二叉树的节点数量满足 1≤n≤100，二叉树节点的值满足 1≤val≤100，树的各节点的值各不相同</p>
<h3 id="题解-24"><a href="#题解-24" class="headerlink" title="题解"></a>题解</h3><p>二叉树的前序遍历就是先访问根节点，再访问左右子树，即“根左右”。</p>
<h3 id="Java代码实现-23"><a href="#Java代码实现-23" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] preorderTraversal (TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 用于保存返回结果</span></span><br><span class="line">        ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(root, ans);</span><br><span class="line">        <span class="comment">// 这里这个方法之前没用过，若是不用此方法也可以，如下：</span></span><br><span class="line">        <span class="comment">// int[] res = new int(ans.size());</span></span><br><span class="line">        <span class="comment">// for(int i = 0; i &lt; ans.size(); ++i)&#123;</span></span><br><span class="line">        <span class="comment">//     res[i] = ans.get(i);</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="keyword">return</span> ans.stream().mapToInt(Integer::valueOf).toArray();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; nums)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 可以不用这个cur变量直接在root上操作，但使用这个变量可以保证root不会变化</span></span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            nums.add(root.val);</span><br><span class="line">            dfs(root.left, nums);</span><br><span class="line">            dfs(root.right, nums);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM24-二叉树的中序遍历"><a href="#BM24-二叉树的中序遍历" class="headerlink" title="BM24 二叉树的中序遍历"></a>BM24 <a href="https://www.nowcoder.com/practice/0bf071c135e64ee2a027783b80bf781d?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">二叉树的中序遍历</a></h2><h3 id="题目描述-23"><a href="#题目描述-23" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树的根节点root，返回它的中序遍历结果。 </p>
<p>数据范围：树上节点数满足 0≤n≤1000，树上每个节点的值满足 0≤val≤1000<br>进阶：空间复杂度 O(n)，时间复杂度 O(n)</p>
<h3 id="题解-25"><a href="#题解-25" class="headerlink" title="题解"></a>题解</h3><p>二叉树的中序遍历就是先访问左子树，再访问根节点，最后访问右子树，即“左根右”。</p>
<h3 id="Java代码实现-24"><a href="#Java代码实现-24" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] inorderTraversal (TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 用于保存返回结果</span></span><br><span class="line">        ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(root, ans);</span><br><span class="line">        <span class="keyword">return</span> ans.stream().mapToInt(Integer::valueOf).toArray();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; nums)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 可以不用这个cur变量直接在root上操作，但使用这个变量可以保证root不会变化</span></span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            dfs(root.left, nums);</span><br><span class="line">            nums.add(root.val);</span><br><span class="line">            dfs(root.right, nums);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM25-二叉树的后序遍历"><a href="#BM25-二叉树的后序遍历" class="headerlink" title="BM25 二叉树的后序遍历"></a>BM25 <a href="https://www.nowcoder.com/practice/1291064f4d5d4bdeaefbf0dd47d78541?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">二叉树的后序遍历</a></h2><h3 id="题目描述-24"><a href="#题目描述-24" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树，返回他的后序遍历的序列。 </p>
<p>后序遍历是值按照 左节点-&gt;右节点-&gt;根节点 的顺序的遍历。 </p>
<p>数据范围：二叉树的节点数量满足 1≤n≤100，二叉树节点的值满足 1≤val≤100，树的各节点的值各不相同</p>
<h3 id="题解-26"><a href="#题解-26" class="headerlink" title="题解"></a>题解</h3><p>二叉树的后序遍历就是先访问左右子树，再访问根节点，即“左右根”。</p>
<h3 id="Java代码实现-25"><a href="#Java代码实现-25" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] postorderTraversal (TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 用于保存返回结果</span></span><br><span class="line">        ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(root, ans);</span><br><span class="line">        <span class="keyword">return</span> ans.stream().mapToInt(Integer::valueOf).toArray();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; nums)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 可以不用这个cur变量直接在root上操作，但使用这个变量可以保证root不会变化</span></span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            dfs(root.left, nums);</span><br><span class="line">            dfs(root.right, nums);</span><br><span class="line">            nums.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>前中后序遍历只有dfs函数的顺序不同，其余操作完全一致</strong></p>
<h2 id="BM26-求二叉树的层序遍历"><a href="#BM26-求二叉树的层序遍历" class="headerlink" title="BM26 求二叉树的层序遍历"></a>BM26 <a href="https://www.nowcoder.com/practice/04a5560e43e24e9db4595865dc9c63a3?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">求二叉树的层序遍历</a></h2><h3 id="题目描述-25"><a href="#题目描述-25" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树，返回该二叉树层序遍历的结果，（从左到右，一层一层地遍历）<br>例如：<br>给定的二叉树是{3,9,20,#,#,15,7},<br><img src="https://uploadfiles.nowcoder.com/images/20210114/999991351_1610616074120/036DC34FF19FB24652AFFEB00A119A76" alt="img"><br>该二叉树层序遍历的结果是<br>[<br>[3],<br>[9,20],<br>[15,7] </p>
<p>] </p>
<p>提示: </p>
<p>0 &lt;= 二叉树的结点数 &lt;= 1500</p>
<h3 id="题解-27"><a href="#题解-27" class="headerlink" title="题解"></a>题解</h3><p>层序遍历实际上就是BFS（广度优先搜索），一般情况下，深度优先遍历用栈辅助操作，广度优先遍历用队列辅助操作，具体操作如下：</p>
<p>首先判断根节点是否为空，若是为空直接返回空，不为空将根节点放入队列中，当队列不为空的时候就不断循环，取出队头，将其左右子树分别插入队尾，直到队列为空时就得到了BFS结果。</p>
<h3 id="Java代码实现-26"><a href="#Java代码实现-26" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型ArrayList&lt;ArrayList&lt;&gt;&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelOrder (TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 用于返回结果</span></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 特殊情况优先考虑</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用于存放每一层的节点</span></span><br><span class="line">        ArrayList&lt;TreeNode&gt; nodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 链表实际上实现了Queue接口</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 将根节点放入队列中</span></span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; nums = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">// 取出当前层所有节点</span></span><br><span class="line">            <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">                TreeNode cur = queue.poll();</span><br><span class="line">                nums.add(cur.val);</span><br><span class="line">                nodes.add(cur);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对于这一层的所有节点，遍历</span></span><br><span class="line">            <span class="keyword">for</span>(TreeNode cur : nodes)&#123;</span><br><span class="line">                <span class="comment">// 左子树不为空，放入队列</span></span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.offer(cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 右子树不为空，放入队列</span></span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.offer(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(nums);</span><br><span class="line">            <span class="comment">// 注意结束后将nodes置空</span></span><br><span class="line">            nodes.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这里的话注意返回的是一个二维数组，故每次都需要将这一层的数据取完，保存在一个中间数组中，之后在每一层新建一个数组用于放置节点值</strong></p>
<h2 id="BM27-按之字形顺序打印二叉树"><a href="#BM27-按之字形顺序打印二叉树" class="headerlink" title="BM27 按之字形顺序打印二叉树"></a>BM27 <a href="https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">按之字形顺序打印二叉树</a></h2><h3 id="题目描述-26"><a href="#题目描述-26" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树，返回该二叉树的之字形层序遍历，（第一层从左向右，下一层从右向左，一直这样交替） </p>
<p>数据范围：0≤n≤1500,树上每个节点的val满足 ∣val∣&lt;=150<br>要求：空间复杂度：O(n)<em>O</em>(<em>n</em>)，时间复杂度：O(n)<em>O</em>(<em>n</em>)</p>
<p>例如：<br>给定的二叉树是{1,2,3,#,#,4,5}<br><img src="https://uploadfiles.nowcoder.com/images/20210717/557336_1626492068888/41FDD435F0BA63A57E274747DE377E05" alt="img"><br>该二叉树之字形层序遍历的结果是 </p>
<p>[ </p>
<p>[1], </p>
<p>[3,2], </p>
<p>[4,5] </p>
<p>]</p>
<h3 id="题解-28"><a href="#题解-28" class="headerlink" title="题解"></a>题解</h3><p>这题也是层序遍历只不过遍历的顺序不一致，这就需要考虑利用辅助变量level外加栈来控制顺序，首先将根节点放入栈中，此时level为1，若是level为奇数则先放左子树后放右子树，因为栈的性质，在下一次遍历时右子树就会优先被输出，若是level为偶数，那么先放右子树后方左子树，那么下次遍历时左子树就会优先被输出，知道栈空位置。</p>
<h3 id="Java代码实现-27"><a href="#Java代码实现-27" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 特殊情况依旧优先考虑</span></span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用于判断层数（奇数先右后左，偶数先左后右）</span></span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 用于存储某一层的全部节点</span></span><br><span class="line">        ArrayList&lt;TreeNode&gt; nodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 先将根节点入栈</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(pRoot);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// 用于保存这一层所有元素</span></span><br><span class="line">            ArrayList&lt;Integer&gt; nums = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">// 取出这一层所有元素</span></span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">                TreeNode cur = stack.pop();</span><br><span class="line">                nums.add(cur.val);</span><br><span class="line">                nodes.add(cur);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((level &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 奇数层，那么表示下一次是偶数层，需要从右到左，因为栈的性质，先放左子树</span></span><br><span class="line">                <span class="keyword">for</span>(TreeNode node : nodes)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        stack.push(node.left);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        stack.push(node.right);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 偶数层，下一层是奇数层，需要从左到右，因为栈的性质，先放右子树</span></span><br><span class="line">                <span class="keyword">for</span>(TreeNode node : nodes)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        stack.push(node.right);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        stack.push(node.left);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将这一层的结果加入结果集中</span></span><br><span class="line">            res.add(nums);</span><br><span class="line">            <span class="comment">// 增加层数</span></span><br><span class="line">            ++level;</span><br><span class="line">            <span class="comment">// 将nodes集置空</span></span><br><span class="line">            nodes.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对于BFS，一般使用队列，对于这种需要确定顺序的，只需要在偶数层反转队列即可，Java中队列没有自带的reverse方法，故不考虑此做法，这里插一句，利用两个队列可以实现一个栈，利用两个栈也可以实现一个队列，具体做法是，只保证其中一个有数据，插入时只查到有数据的那个，删除时将前n-1个数据移到另一部分，再将最后一个元素取出</strong></p>
<p><strong>这里判断奇偶性使用的是或运算而不是对2求余，这样会快一些</strong></p>
<h2 id="BM28-二叉树的最大深度"><a href="#BM28-二叉树的最大深度" class="headerlink" title="BM28 二叉树的最大深度"></a>BM28 <a href="https://www.nowcoder.com/practice/8a2b2bf6c19b4f23a9bdb9b233eefa73?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">二叉树的最大深度</a></h2><h3 id="题目描述-27"><a href="#题目描述-27" class="headerlink" title="题目描述"></a>题目描述</h3><p>求给定二叉树的最大深度， </p>
<p>深度是指树的根节点到任一叶子节点路径上节点的数量。 </p>
<p>最大深度是所有叶子节点的深度的最大值。 </p>
<p>（注：叶子节点是指没有子节点的节点。）</p>
<p>数据范围：0≤n≤100000，树上每个节点的val满足 ∣val∣≤100<br>要求： 空间复杂度 O(1),时间复杂度 O(n)</p>
<h3 id="题解-29"><a href="#题解-29" class="headerlink" title="题解"></a>题解</h3><p>两个思路，一是利用栈，栈的最大长度即为二叉树的最大深度，但使用栈会导致空间复杂度为O(n)，不合题意舍弃。</p>
<p>直接dfs，并在dfs的过程中维护最大深度，但此方法递归调用，空间复杂度也是O(n)，愚以为没有O(1)空间复杂度的方法。</p>
<h3 id="Java代码实现-28"><a href="#Java代码实现-28" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span> <span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 特殊情况优先考虑</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则就递归求左右子树中比较大的那个 + 1就是答案</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM29-二叉树中和为某一值的路径"><a href="#BM29-二叉树中和为某一值的路径" class="headerlink" title="BM29 二叉树中和为某一值的路径"></a>BM29 <a href="https://www.nowcoder.com/practice/508378c0823c423baa723ce448cbfd0c?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">二叉树中和为某一值的路径</a></h2><h3 id="题目描述-28"><a href="#题目描述-28" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树root和一个值 sum ，判断是否有从根节点到叶子节点的节点值之和等于 sum 的路径。</p>
<p>1.该题路径定义为从树的根结点开始往下一直到叶子结点所经过的结点</p>
<p>2.叶子节点是指没有子节点的节点</p>
<p>3.路径只能从父节点到子节点，不能从子节点到父节点</p>
<p>4.总节点数目为n</p>
<p>例如：<br>给出如下的二叉树， sum=22，<br><img src="https://uploadfiles.nowcoder.com/images/20200807/999991351_1596786493913_8BFB3E9513755565DC67D86744BB6159" alt="img"><br>返回true，因为存在一条路径 5→4→11→2的节点值之和为 22 </p>
<p>数据范围： </p>
<p>1.树上的节点数满足 0≤n≤10000</p>
<p>2.每 个节点的值都满足 ∣val∣≤1000</p>
<p>要求：空间复杂度 O(n)，时间复杂度 O(n)</p>
<p>进阶：空间复杂度 O(树的高度)，时间复杂度 O(n)</p>
<h3 id="题解-30"><a href="#题解-30" class="headerlink" title="题解"></a>题解</h3><p>毫无疑问BFS，两种思路，一是直接递归，二是使用栈保存遍历的节点，退出的条件是，当前节点值为需要的值且此节点是叶子节点，若是不是叶子节点那么继续dfs，只不过dfs的变量变为root.left和sum - root.val</p>
<h3 id="Java代码实现-29"><a href="#Java代码实现-29" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sum int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span> <span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 这里特殊情况先考虑，之后再dfs</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum -= root.val;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; sum == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left, sum) || hasPathSum(root.right, sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这里为什么不直接if(root == null &amp;&amp; sum == 0) return true;主要原因是，若是某一个节点左子树或者右子树为null，当遍历到这个节点的时候，sum已经== 0 了但是这不是路径，因此当遍历到它那棵空子树时就会导致此条件成立，但此时并不是路径（考虑用例{1, 2}, sum = 1）</strong></p>
<h2 id="BM30-二叉搜索树与双向链表"><a href="#BM30-二叉搜索树与双向链表" class="headerlink" title="BM30 二叉搜索树与双向链表"></a>BM30 <a href="https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">二叉搜索树与双向链表</a></h2><h3 id="题目描述-29"><a href="#题目描述-29" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。如下图所示 </p>
<p><img src="https://uploadfiles.nowcoder.com/images/20210605/557336_1622886924427/E1F1270919D292C9F48F51975FD07CE2" alt="img"></p>
<p>数据范围：输入二叉树的节点数 0≤n≤1000，二叉树中每个节点的值 0≤val≤1000<br>要求：空间复杂度O(1)（即在原树上操作），时间复杂度 O(n)</p>
<p>注意: </p>
<p>1.要求不能创建任何新的结点，只能调整树中结点指针的指向。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继<br>2.返回链表中的第一个节点的指针<br>3.函数返回的TreeNode，有左右指针，其实可以看成一个双向链表的数据结构 </p>
<p>4.你不用输出双向链表，程序会根据你的返回值自动打印输出</p>
<h4 id="输入描述：-1"><a href="#输入描述：-1" class="headerlink" title="输入描述："></a>输入描述：</h4><p>二叉树的根节点</p>
<h4 id="返回值描述：-1"><a href="#返回值描述：-1" class="headerlink" title="返回值描述："></a>返回值描述：</h4><p>双向链表的其中一个头节点。</p>
<h3 id="题解-31"><a href="#题解-31" class="headerlink" title="题解"></a>题解</h3><p>最简单的方法是二叉树中序遍历得到一个结果数组，再利用数组中的每一个值新建节点构成双向链表，最后返回，但此法需要额外申请空间，空间复杂度为O(n)，不合题意。</p>
<p>若是需要在原树上进行操作，对于一个节点，其前驱节点（左子树）应为其左子树中序遍历的最后一个值，其后继节点因为其中序遍历的第一个值，而且只有最左的节点没有前驱节点，最右的节点没有后继节点。</p>
<h3 id="Java代码实现-30"><a href="#Java代码实现-30" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 链表的根</span></span><br><span class="line">    TreeNode root = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 上一次反转得到的链表尾</span></span><br><span class="line">    TreeNode preTail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况优先考虑</span></span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 中序遍历，先左</span></span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            Convert(pRootOfTree.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 保存根节点，这里保存根节点的目的是，每次操作之后就只剩下了当前这课子树的头</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            root = pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 中序遍历，再根，在这里对左右子树进行修改操作</span></span><br><span class="line">        <span class="keyword">if</span>(preTail != <span class="keyword">null</span>)&#123;</span><br><span class="line">            preTail.right = pRootOfTree;</span><br><span class="line">            pRootOfTree.left = preTail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里注意将这个指针移位</span></span><br><span class="line">        preTail = pRootOfTree;</span><br><span class="line">        <span class="comment">// 中序遍历，后右</span></span><br><span class="line">        Convert(pRootOfTree.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了递归版本，那自然也有非递归版本，非递归版本实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况优先考虑</span></span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree == <span class="keyword">null</span> || (pRootOfTree.left == <span class="keyword">null</span> &amp;&amp; pRootOfTree.right == <span class="keyword">null</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">        TreeNode cur = pRootOfTree;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">// 这里一次找到最左边的节点，也就是链表的头</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取出这个最左边的节点并保存，保存的原因是它需要作为头节点</span></span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        pRootOfTree = cur;</span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="comment">// 这里实际上cur = null</span></span><br><span class="line">        cur = cur.right;</span><br><span class="line">        <span class="comment">// 之后将所有的元素一一放入</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// 对于每个节点也是左根右</span></span><br><span class="line">            <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 这里思考一个问题，遍历一次之后其实已经将cur变为cur.right了，因此这里已经将cur.right放入栈中了</span></span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = stack.pop();</span><br><span class="line">            cur.left = pre;</span><br><span class="line">            pre.right = cur;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对于这个栈，先不停地将左节点放入，之后进行根节点的变换(由于第一个元素已经单独拿出来考虑，因此无需担心对pre的空指针操作，也可学习链表，初始时pre是一个虚拟头节点)，最后将当前节点转化为右子树</span></span><br><span class="line">        <span class="keyword">return</span> pRootOfTree;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中序非递归的核心代码是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dfs(TreeNode root)&#123;</span><br><span class="line">  	Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">		<span class="keyword">while</span>(root != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">      	<span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">          	stack.push(root);</span><br><span class="line">          	root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">//对于根节点进行操作</span></span><br><span class="line">      	<span class="keyword">do</span> something;</span><br><span class="line">      	root = root.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM31对称的二叉树"><a href="#BM31对称的二叉树" class="headerlink" title="BM31对称的二叉树"></a>BM31<a href="https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">对称的二叉树</a></h2><h3 id="题目描述-30"><a href="#题目描述-30" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一棵二叉树，判断其是否是自身的镜像（即：是否对称）<br>例如：                 下面这棵二叉树是对称的<br><img src="https://uploadfiles.nowcoder.com/images/20210926/382300087_1632642756706/A22A794C036C06431E632F9D5E2E298F" alt="img"><br>下面这棵二叉树不对称。<br><img src="https://uploadfiles.nowcoder.com/images/20210926/382300087_1632642770481/3304ABDD147D8E140B2CEF3201BD8372" alt="img"></p>
<p>数据范围：节点数满足 0≤n≤1000，节点上的值满足 ∣val∣≤1000</p>
<p>要求：空间复杂度 O(n)，时间复杂度 O(n)</p>
<p>备注： </p>
<p>你可以用递归和迭代两种方法解决这个问题</p>
<h3 id="题解-32"><a href="#题解-32" class="headerlink" title="题解"></a>题解</h3><p>建立一个辅助函数帮助判断左右子树是否对称。</p>
<p>当左右子树均为空时返回true，当左右子树有一个为空时返回false；否则判断两个子树根节点的值是否相等以及左子树的左子树是否和右子树的右子树对称以及左子树的右子树是否和右子树的左子树对称。</p>
<h3 id="Java代码实现-31"><a href="#Java代码实现-31" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(pRoot.left, pRoot.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(TreeNode left, TreeNode right)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 两子树均为空时true</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时已经确定两棵子树不同为空，那么满足条件时只有一棵子树为空</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span> || right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 看当前左右子树根节点是否对称以及左子树的左子树是否和右子树的右子树对称以及左子树的右子树是否和右子树的左子树对称</span></span><br><span class="line">        <span class="keyword">return</span> left.val == right.val &amp;&amp; helper(left.left, right.right) &amp;&amp; helper(left.right, right.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM32-合并二叉树"><a href="#BM32-合并二叉树" class="headerlink" title="BM32 合并二叉树"></a>BM32 <a href="https://www.nowcoder.com/practice/7298353c24cc42e3bd5f0e0bd3d1d759?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">合并二叉树</a></h2><h3 id="题目描述-31"><a href="#题目描述-31" class="headerlink" title="题目描述"></a>题目描述</h3><p>已知两颗二叉树，将它们合并成一颗二叉树。合并规则是：都存在的结点，就将结点值加起来，否则空的位置就由另一个树的结点来代替。例如：<br>两颗二叉树是:<br>                                  Tree 1 </p>
<p><img src="https://uploadfiles.nowcoder.com/images/20210928/382300087_1632821337680/9E290CFD3730B9B08A5CEFF25799608F" alt="img"></p>
<p>​                                    Tree 2<br><img src="https://uploadfiles.nowcoder.com/images/20210928/382300087_1632821376266/DD0A63560E770A8510049C5182E6E622" alt="img"><br>​                                  合并后的树为<br><img src="https://uploadfiles.nowcoder.com/images/20210928/382300087_1632821404541/9CB750F8909D5985C0D01D8B71AD58BA" alt="img"></p>
<p>数据范围：树上节点数量满足 0≤n≤500，树上节点的值一定在32位整型范围内。 </p>
<p>进阶：空间复杂度 O(1)，时间复杂度 O(n)</p>
<h3 id="题解-33"><a href="#题解-33" class="headerlink" title="题解"></a>题解</h3><p>对于两个树，都以某种顺序进行遍历，直达左右节点都为null时结束。</p>
<h3 id="Java代码实现-32"><a href="#Java代码实现-32" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t1 TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t2 TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> TreeNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span> <span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 特殊情况优先考虑</span></span><br><span class="line">        <span class="keyword">if</span>(t1 == <span class="keyword">null</span> || t2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> t1 == <span class="keyword">null</span> ? t2 : t1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时确保两者都不为空</span></span><br><span class="line">        t1.val += t2.val;</span><br><span class="line">      	<span class="comment">// t1的左子树为合并t1 t2左子树的结果</span></span><br><span class="line">        t1.left = mergeTrees(t1.left, t2.left);</span><br><span class="line">      	<span class="comment">// t1的右子树为合并t1 t2右子树的结果</span></span><br><span class="line">        t1.right = mergeTrees(t1.right, t2.right);</span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM33-二叉树的镜像"><a href="#BM33-二叉树的镜像" class="headerlink" title="BM33 二叉树的镜像"></a>BM33 <a href="https://www.nowcoder.com/practice/a9d0ecbacef9410ca97463e4a5c83be7?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">二叉树的镜像</a></h2><h3 id="题目描述-32"><a href="#题目描述-32" class="headerlink" title="题目描述"></a>题目描述</h3><p>操作给定的二叉树，将其变换为源二叉树的镜像。 </p>
<p>数据范围：二叉树的节点数 0≤n≤1000， 二叉树每个节点的值 0≤val≤1000</p>
<p>要求： 空间复杂度 O(n)。本题也有原地操作，即空间复杂度 O(1)的解法，时间复杂度 O(n)</p>
<p>比如： </p>
<p>源二叉树</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20210922/382300087_1632302001586/420B82546CFC9760B45DD65BA9244888" alt="img"></p>
<p>镜像二叉树 </p>
<p><img src="https://uploadfiles.nowcoder.com/images/20210922/382300087_1632302036250/AD8C4CC119B15070FA1DBAA1EBE8FC2A" alt="img"></p>
<h3 id="题解-34"><a href="#题解-34" class="headerlink" title="题解"></a>题解</h3><p>递归实现，先将当前节点的左右子树交换，之后再递归实现左右子树的镜像。</p>
<h3 id="Java代码实现-33"><a href="#Java代码实现-33" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pRoot TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> TreeNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Mirror</span> <span class="params">(TreeNode pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span> || pRoot.left == <span class="keyword">null</span> &amp;&amp; pRoot.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> pRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode temp = pRoot.left;</span><br><span class="line">        pRoot.left = pRoot.right;</span><br><span class="line">        pRoot.right = temp;</span><br><span class="line">        Mirror(pRoot.left);</span><br><span class="line">        Mirror(pRoot.right);</span><br><span class="line">        <span class="keyword">return</span> pRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM34-判断是不是二叉搜索树"><a href="#BM34-判断是不是二叉搜索树" class="headerlink" title="BM34 判断是不是二叉搜索树"></a>BM34 <a href="https://www.nowcoder.com/practice/a69242b39baf45dea217815c7dedb52b?tpId=295&tqId=2288088&ru=%2Fpractice%2Fa9d0ecbacef9410ca97463e4a5c83be7&qru=%2Fta%2Fformat-top101%2Fquestion-ranking&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">判断是不是二叉搜索树</a></h2><h3 id="题目描述-33"><a href="#题目描述-33" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树根节点，请你判断这棵树是不是二叉搜索树。 </p>
<p>二叉搜索树满足每个节点的左子树上的所有节点均小于当前节点且右子树上的所有节点均大于当前节点。 </p>
<p>例： </p>
<p><img src="https://uploadfiles.nowcoder.com/images/20211109/392807_1636440937987/9C31F319601A5B78D34F62FF77A02A11" alt="img"></p>
<p>图1 </p>
<p><img src="https://uploadfiles.nowcoder.com/images/20211109/392807_1636440984427/5E5B576E11CB2C96724680C94755ABCB" alt="img"></p>
<p>图2 </p>
<p>数据范围：节点数量满足 1≤n≤104，节点上的值满足 −231≤val≤231−1</p>
<h3 id="题解-35"><a href="#题解-35" class="headerlink" title="题解"></a>题解</h3><p>最简单的方法是中序遍历二叉树得到数组，看数组中每个元素是否严格小于后一个数</p>
<h3 id="Java代码实现-34"><a href="#Java代码实现-34" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span> <span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; nums = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(root, nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.size() - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums.get(i) &gt;= nums.get(i + <span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            dfs(root.left, nums);</span><br><span class="line">            nums.add(root.val);</span><br><span class="line">            dfs(root.right, nums);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题解-36"><a href="#题解-36" class="headerlink" title="题解"></a>题解</h3><p>或者就是在中序遍历的过程中直接比较，不使用额外数组</p>
<h3 id="Java代码实现-35"><a href="#Java代码实现-35" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> pre = Integer.MIN_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span> <span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dfs(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            flag = (flag &amp;&amp; dfs(root.left));</span><br><span class="line">            flag = (flag &amp;&amp; (root.val &gt; pre));</span><br><span class="line">            pre = root.val;</span><br><span class="line">            flag = (flag &amp;&amp; dfs(root.right));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM35-判断是不是完全二叉树"><a href="#BM35-判断是不是完全二叉树" class="headerlink" title="BM35 判断是不是完全二叉树"></a>BM35 <a href="https://www.nowcoder.com/practice/8daa4dff9e36409abba2adbe413d6fae?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">判断是不是完全二叉树</a></h2><h3 id="题目描述-34"><a href="#题目描述-34" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树，确定他是否是一个完全二叉树。 </p>
<p>完全二叉树的定义：若二叉树的深度为 h，除第 h 层外，其它各层的结点数都达到最大个数，第 h 层所有的叶子结点都连续集中在最左边，这就是完全二叉树。（第 h 层可能包含 [1~2h] 个节点）</p>
<p>数据范围：节点数满足 1≤n≤100</p>
<p>样例图1： </p>
<p><img src="https://uploadfiles.nowcoder.com/images/20211112/392807_1636687704633/3FDF585A954EFF629B41FD21BA20B0C9" alt="img"></p>
<p>样例图2： </p>
<p><img src="https://uploadfiles.nowcoder.com/images/20211112/392807_1636687742831/942721EB3583D230F79D69B3097D3416" alt="img"></p>
<p>样例图3： </p>
<p><img src="https://uploadfiles.nowcoder.com/images/20211112/392807_1636687774162/1D0ED443BD0A777690EF55BABCD978D5" alt="img"></p>
<h3 id="题解-37"><a href="#题解-37" class="headerlink" title="题解"></a>题解</h3><p>判断是不是完全二叉树，需要层序遍历二叉树，具体实现方式是，维护一个是否结束的标记，将这一层的所有节点放入一个数组，若是发现了之前已经为空并且现在也为空那直接返回，否则继续遍历。</p>
<h3 id="Java代码实现-36"><a href="#Java代码实现-36" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCompleteTree</span> <span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 特殊情况，只有一层直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先将根节点放入</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="comment">// 判断是否为空</span></span><br><span class="line">        <span class="keyword">boolean</span> ifEnd = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            <span class="comment">// 这里只有当节点为空时才标记结束</span></span><br><span class="line">            <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">                ifEnd = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 节点不为空</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 若是队列中还有节点但是之前已经标记结束了，那不是完全二叉树</span></span><br><span class="line">                <span class="keyword">if</span>(!queue.isEmpty() &amp;&amp; ifEnd)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将其左右节点放入</span></span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">                <span class="comment">// 这里思考一个问题：</span></span><br><span class="line">                <span class="comment">// 若是左右子树均为空，</span></span><br><span class="line">                <span class="comment">// 那么其实就会不停的将空节点出栈并把isEnd重复置为true</span></span><br><span class="line">                <span class="comment">// 注意队列中放null元素是可以的</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM36-判断是不是平衡二叉树"><a href="#BM36-判断是不是平衡二叉树" class="headerlink" title="BM36 判断是不是平衡二叉树"></a>BM36 <a href="https://www.nowcoder.com/practice/8b3b95850edb4115918ecebdf1b4d222?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">判断是不是平衡二叉树</a></h2><h3 id="题目描述-35"><a href="#题目描述-35" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一棵节点数为 n 二叉树，判断该二叉树是否是平衡二叉树。 </p>
<p>在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树 </p>
<p><strong>平衡二叉树</strong>（Balanced Binary Tree），具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p>
<p>样例解释： </p>
<p><img src="https://uploadfiles.nowcoder.com/images/20210918/382300087_1631935149594/D55A07912354B3AB7E9F2F5EA27CB7D6" alt="img"></p>
<p>样例二叉树如图，为一颗平衡二叉树</p>
<p>注：我们约定空树是平衡二叉树。</p>
<p>数据范围：n≤100,树上节点的val值满足 0≤n≤1000</p>
<p>要求：空间复杂度O(1)，时间复杂度 O(n)</p>
<h4 id="输入描述：-2"><a href="#输入描述：-2" class="headerlink" title="输入描述："></a>输入描述：</h4><p>输入一棵二叉树的根节点</p>
<h4 id="返回值描述：-2"><a href="#返回值描述：-2" class="headerlink" title="返回值描述："></a>返回值描述：</h4><p>输出一个布尔类型的值</p>
<h3 id="题解-38"><a href="#题解-38" class="headerlink" title="题解"></a>题解</h3><p>题目中已经介绍了平衡二叉树的判断条件，只需要按照条件进行判断即可，选择递归的思想，以当前节点为根的树是否是平衡二叉树的条件是，是一棵空树或者其左右子树的高度差不超过1，我们可以设一个递归函数用于求树的高度，若是为空则高度为0，否则是左右子树最大值+1，最后判断是否平衡即可。</p>
<h3 id="Java代码实现-37"><a href="#Java代码实现-37" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Math.abs(len(root.left) - len(root.right)) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> IsBalanced_Solution(root.left) &amp;&amp; IsBalanced_Solution(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">len</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(len(root.left), len(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是观察之后发现这里递归调用的次数太多了，即每次判断树的高度都需要递归调用获取长度的函数，但好多节点之前已经重复计算过，因此考虑将之前记忆过的数据进行保存，即记忆化搜索具体做法如下：</p>
<p>使用一次dfs函数，计算出全部节点的高度，之后保存在一个HashMap中，每次需要的时候直接从HashMap中取出对应的高度即可。</p>
<h3 id="Java代码实现-38"><a href="#Java代码实现-38" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    HashMap&lt;TreeNode, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先将map初始化</span></span><br><span class="line">        len(root);</span><br><span class="line">        <span class="keyword">return</span> dfs(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(map.get(root.left) - map.get(root.right)) &lt;= <span class="number">1</span> &amp;&amp; dfs(root.left) &amp;&amp; dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">len</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 每次先观察之前有没有这个key</span></span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(root))&#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            map.put(root, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左子树长度计算</span></span><br><span class="line">        <span class="keyword">int</span> lenLeft = len(root.left);</span><br><span class="line">        <span class="comment">// 右子树长度计算</span></span><br><span class="line">        <span class="keyword">int</span> lenRight = len(root.right);</span><br><span class="line">        <span class="comment">// 判断当前长度</span></span><br><span class="line">        <span class="keyword">int</span> curLen = Math.max(lenLeft, lenRight) + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 插入到map中</span></span><br><span class="line">        map.put(root, curLen);</span><br><span class="line">        <span class="comment">// 返回</span></span><br><span class="line">        <span class="keyword">return</span> curLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM37-二叉搜索树的最近公共祖先"><a href="#BM37-二叉搜索树的最近公共祖先" class="headerlink" title="BM37 二叉搜索树的最近公共祖先"></a>BM37 <a href="https://www.nowcoder.com/practice/d9820119321945f588ed6a26f0a6991f?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">二叉搜索树的最近公共祖先</a></h2><h3 id="题目描述-36"><a href="#题目描述-36" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>1.对于该题的最近的公共祖先定义:对于有根树T的两个节点p、q，最近公共祖先LCA(T,p,q)表示一个节点x，满足x是p和q的祖先且x的深度尽可能大。在这里，一个节点也可以是它自己的祖先.</p>
<p>2.二叉搜索树是若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值</p>
<p>3.所有节点的值都是唯一的。</p>
<p>4.p、q 为不同节点且均存在于给定的二叉搜索树中。</p>
<p>数据范围:</p>
<p>3&lt;=节点总数&lt;=10000</p>
<p>0&lt;=节点值&lt;=10000</p>
<p>如果给定以下搜索二叉树: {7,1,12,0,4,11,14,#,#,3,5}，如下图:</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20211110/301499_1636536407371/36404CF45DDCB5834FC8BBFEA318831A" alt="img"></p>
<h3 id="题解-39"><a href="#题解-39" class="headerlink" title="题解"></a>题解</h3><p>题目中已经说了是二叉搜索树，利用二叉搜索树的性质可以发现，中序遍历二叉搜索树，对于二叉树中的节点来说，若是到了某一个节点，所给的两个节点第一次分别位于它的两侧那么这个就是最近公共祖先，直接返回，由于是二叉搜索树，因此此时公共祖先的值比大的值小，比小的值大。</p>
<h3 id="Java代码实现-39"><a href="#Java代码实现-39" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> q int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lowestCommonAncestor</span> <span class="params">(TreeNode root, <span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 保证进入dfs函数中的值都是前小后大，题目中已说两个值不同</span></span><br><span class="line">        <span class="keyword">if</span>(p &gt; q)&#123;</span><br><span class="line">            <span class="keyword">return</span> dfs(root, q, p);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> dfs(root, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode cur, <span class="keyword">int</span> small, <span class="keyword">int</span> large)</span></span>&#123;</span><br><span class="line">      	<span class="comment">// 找到了直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(cur.val &lt;= large &amp;&amp; cur.val &gt;= small)&#123;</span><br><span class="line">            <span class="keyword">return</span> cur.val;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur.val &lt; small)&#123;</span><br><span class="line">            <span class="comment">// 比小的还小，那么去右半部分着</span></span><br><span class="line">            <span class="keyword">return</span> dfs(cur.right, small, large);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 去左半部分找</span></span><br><span class="line">            <span class="keyword">return</span> dfs(cur.left, small, large);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM38-在二叉树中找到两个节点的最近公共祖先"><a href="#BM38-在二叉树中找到两个节点的最近公共祖先" class="headerlink" title="BM38 在二叉树中找到两个节点的最近公共祖先"></a>BM38 <a href="https://www.nowcoder.com/practice/e0cc33a83afe4530bcec46eba3325116?tpId=295&tqId=1024325&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">在二叉树中找到两个节点的最近公共祖先</a></h2><h3 id="题目描述-37"><a href="#题目描述-37" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一棵二叉树(保证非空)以及这棵树上的两个节点对应的val值 o1 和 o2，请找到 o1 和 o2 的最近公共祖先节点。 </p>
<p>数据范围：树上节点数满足 1≤n≤105, 节点值val满足区间 [0,n)</p>
<p>要求：时间复杂度 O(n)</p>
<p>注：本题保证二叉树中每个节点的val值均不相同。</p>
<p>如当输入{3,5,1,6,2,0,8,#,#,7,4},5,1时，二叉树{3,5,1,6,2,0,8,#,#,7,4}如下图所示：</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20211014/423483716_1634206667843/D2B5CA33BD970F64A6301FA75AE2EB22" alt="img"></p>
<p>所以节点值为5和节点值为1的节点的最近公共祖先节点的节点值为3，所以对应的输出为3。</p>
<p>节点本身可以视为自己的祖先</p>
<h3 id="题解-40"><a href="#题解-40" class="headerlink" title="题解"></a>题解</h3><p>递归实现，首先规定此节点为null时返回-1无效值，若是此节点是所给值中的某一个，那么返回此节点的值，若都不满足，则说明所给点在该节点的子树中，分别递归求出是否在左右子树中（-1不在别的在），若不在左子树中就在右子树中，若是不在右子树中就在左子树中，若是即在左子树中又在右子树中则说明此节点即为最近公共祖先。</p>
<h3 id="Java代码实现-40"><a href="#Java代码实现-40" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o1 int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o2 int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lowestCommonAncestor</span> <span class="params">(TreeNode root, <span class="keyword">int</span> o1, <span class="keyword">int</span> o2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 标记不是路径的节点为-1</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此节点是其中的某一个值，那么此节点即为公共祖先</span></span><br><span class="line">        <span class="keyword">if</span>(root.val == o1 || root.val == o2)&#123;</span><br><span class="line">            <span class="keyword">return</span> root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 看是否在左子树中</span></span><br><span class="line">        <span class="keyword">int</span> left = lowestCommonAncestor(root.left, o1, o2);</span><br><span class="line">        <span class="comment">// 看是否在右子树中</span></span><br><span class="line">        <span class="keyword">int</span> right = lowestCommonAncestor(root.right, o1, o2);</span><br><span class="line">        <span class="comment">// left为-1表示在右子树中</span></span><br><span class="line">        <span class="keyword">if</span>(left == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(right == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 此时left不为-1，right为-1，那么在左侧</span></span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 此时左右子树均不为-1，故一个节点在左侧，一个节点在右侧，那么此时就是祖先</span></span><br><span class="line">            <span class="keyword">return</span> root.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM39-序列化二叉树"><a href="#BM39-序列化二叉树" class="headerlink" title="BM39 序列化二叉树"></a>BM39 <a href="https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">序列化二叉树</a></h2><h3 id="题目描述-38"><a href="#题目描述-38" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现两个函数，分别用来序列化和反序列化二叉树，不对序列化之后的字符串进行约束，但要求能够根据序列化之后的字符串重新构造出一棵与原二叉树相同的树。 </p>
<p>二叉树的序列化(Serialize)是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树等遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#）</p>
<p>二叉树的反序列化(Deserialize)是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。</p>
<p>例如，可以根据层序遍历的方案序列化，如下图:</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20210910/557336_1631245540483/320409CB186FCD18144519959D510D7E" alt="img"></p>
<p>层序序列化(即用函数Serialize转化)如上的二叉树转为”{1,2,3,#,#,6,7}”，再能够调用反序列化(Deserialize)将”{1,2,3,#,#,6,7}”构造成如上的二叉树。</p>
<p>当然你也可以根据满二叉树结点位置的标号规律来序列化，还可以根据先序遍历和中序遍历的结果来序列化。不对序列化之后的字符串进行约束，所以欢迎各种奇思妙想。 </p>
<p>数据范围：节点数 n≤100<em>n</em>≤100，树上每个节点的值满足 0≤val≤150</p>
<p>要求：序列化和反序列化都是空间复杂度 O(n)，时间复杂度 O(n)</p>
<h3 id="题解-41"><a href="#题解-41" class="headerlink" title="题解"></a>题解</h3><p>这题建议使用层序遍历保存节点值，因为这样的遍历方式可以确定每一层的元素，之后构造时也比较方便，即每一层的节点数都是2 ^ (n - 1)，而且除了第一层之外，每一层的节点开始位置都是第2 ^ (n - 1) - 1，这里学习了<a href="https://blog.nowcoder.net/n/0a2e49c8412b45c7b4b2d99ad8a83aeb" target="_blank" rel="noopener">三叶大神</a>的一个思路就是使用一个无效节点来表示空节点。</p>
<h3 id="Java代码实现-41"><a href="#Java代码实现-41" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里空节点的取值不能和有效值重复，因为val大于0，故选择-1</span></span><br><span class="line">    TreeNode NULL = <span class="keyword">new</span> TreeNode(-<span class="number">1</span>);</span><br><span class="line">    <span class="function">String <span class="title">Serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根节点为空直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用于保存结果</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">// 用于层序遍历</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 先将根节点放入</span></span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// 取出第一个元素</span></span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            <span class="comment">// 先把此节点值放入</span></span><br><span class="line">            sb.append(node.val + <span class="string">","</span>);</span><br><span class="line">            <span class="comment">// 若是此节点是空节点，那么就不继续放此节点的左右子树</span></span><br><span class="line">            <span class="keyword">if</span>(!node.equals(NULL))&#123;</span><br><span class="line">                <span class="comment">// 若是此节点是非空节点，判断左右节点是否是空节点，若是null用空节点表示</span></span><br><span class="line">                queue.offer(node.left == <span class="keyword">null</span> ? NULL : node.left);</span><br><span class="line">                queue.offer(node.right == <span class="keyword">null</span> ? NULL : node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode <span class="title">Deserialize</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 若是序列化字符为空则直接安排</span></span><br><span class="line">       <span class="keyword">if</span>(str.equals(<span class="string">""</span>))&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="comment">// 先把节点分出来</span></span><br><span class="line">        String[] strs = str.split(<span class="string">","</span>);</span><br><span class="line">        <span class="keyword">int</span> n = strs.length;</span><br><span class="line">        <span class="comment">// 先构造根节点</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(strs[<span class="number">0</span>]));</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="comment">// 这里我原本想的是计算出一共有多少层之后再对每一层的节点进行判断</span></span><br><span class="line">        <span class="comment">// 之后发现这个层次数不方便计算，这里是参照三叶大神的思路</span></span><br><span class="line">        <span class="comment">// 每次取出两个值，对当前队列中的节点构造其左右子树</span></span><br><span class="line">        <span class="comment">// 此外这里已经把根节点构建了，因此从第一个节点开始即可</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i += <span class="number">2</span>)&#123;</span><br><span class="line">            TreeNode cur = queue.poll();</span><br><span class="line">            <span class="comment">// 当前节点左子树的值</span></span><br><span class="line">            <span class="keyword">int</span> left = Integer.parseInt(strs[i]);</span><br><span class="line">            <span class="comment">// 当前节点右子树的值</span></span><br><span class="line">            <span class="keyword">int</span> right = Integer.parseInt(strs[i + <span class="number">1</span>]);</span><br><span class="line">            <span class="comment">// 这里注意left若是为-1那么表示当前的左子树其实是空子树</span></span><br><span class="line">            <span class="keyword">if</span>(left != -<span class="number">1</span>)&#123;</span><br><span class="line">                cur.left = <span class="keyword">new</span> TreeNode(left);</span><br><span class="line">                <span class="comment">// 注意构造节点之后要将其放入队列中防止找不到</span></span><br><span class="line">                queue.offer(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(right != -<span class="number">1</span>)&#123;</span><br><span class="line">                cur.right = <span class="keyword">new</span> TreeNode(right);</span><br><span class="line">                queue.offer(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 构建完之后返回即可</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM40-重建二叉树"><a href="#BM40-重建二叉树" class="headerlink" title="BM40 重建二叉树"></a>BM40 <a href="https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">重建二叉树</a></h2><h3 id="题目描述-39"><a href="#题目描述-39" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定节点数为 n 的二叉树的前序遍历和中序遍历结果，请重建出该二叉树并返回它的头结点。</p>
<p>例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建出如下图所示。 </p>
<p><img src="https://uploadfiles.nowcoder.com/images/20210717/557336_1626504921458/776B0E5E0FAD11A6F15004B29DA5E628" alt="img"></p>
<p>提示: </p>
<p>1.vin.length == pre.length</p>
<p>2.pre 和 vin 均无重复元素</p>
<p>3.vin出现的元素均出现在 pre里</p>
<p>4.只需要返回根结点，系统会自动输出整颗树做答案对比</p>
<p>数据范围：n≤2000，节点的值 −10000≤val≤10000</p>
<p>要求：空间复杂度 O(n)，时间复杂度 O(n)</p>
<h3 id="题解-42"><a href="#题解-42" class="headerlink" title="题解"></a>题解</h3><p>这题抓住谦虚遍历和中序遍历的性质，前序遍历序列中第一个必是根节点，从前序遍历序列中找到这棵子树的根节点，之后中序序列中在根节点左侧的是左子树，在根节点右侧的是右子树，再求左右子树的根节点，如此递归解决便可。</p>
<h3 id="Java代码实现-42"><a href="#Java代码实现-42" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] vin)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 为空树时直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(pre.length == <span class="number">0</span> || vin.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到当前pre的第一个序列就是根节点</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 在中序序列中找到根节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vin.length; ++i)&#123;</span><br><span class="line">            <span class="comment">// 注意这里每次copy之后需要的都是pre的第一个元素</span></span><br><span class="line">            <span class="keyword">if</span>(vin[i] == pre[<span class="number">0</span>])&#123;</span><br><span class="line"> 								<span class="comment">// 这里对于范围的选择，其实关键因素是vin的范围，pre只要和vin长度一致即可</span></span><br><span class="line">                <span class="comment">// 从vin数组的开头到根节点之前的一部分是左子树</span></span><br><span class="line">                <span class="comment">// vin根节点之后到最后的部分是右子树</span></span><br><span class="line">                <span class="comment">// 递归构造左子树</span></span><br><span class="line">                root.left = reConstructBinaryTree(Arrays.copyOfRange(pre, <span class="number">1</span>, i + <span class="number">1</span>), Arrays.copyOfRange(vin, <span class="number">0</span>, i));</span><br><span class="line">                <span class="comment">// 递归构造右子树</span></span><br><span class="line">                root.right = reConstructBinaryTree(Arrays.copyOfRange(pre, i + <span class="number">1</span>, pre.length), Arrays.copyOfRange(vin, i + <span class="number">1</span>, vin.length));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM41-输出二叉树的右试图"><a href="#BM41-输出二叉树的右试图" class="headerlink" title="BM41 输出二叉树的右试图"></a>BM41 <a href="https://www.nowcoder.com/practice/c9480213597e45f4807880c763ddd5f0?tpId=295&tqId=1073834&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">输出二叉树的右试图</a></h2><h3 id="题目描述-40"><a href="#题目描述-40" class="headerlink" title="题目描述"></a>题目描述</h3><p>请根据二叉树的前序遍历，中序遍历恢复二叉树，并打印出二叉树的右视图</p>
<p>数据范围： 0≤n≤10000<br>要求： 空间复杂度 O(n)，时间复杂度 O(n)</p>
<p>如输入[1,2,4,5,3],[4,2,5,1,3]时，通过前序遍历的结果[1,2,4,5,3]和中序遍历的结果[4,2,5,1,3]可重建出以下二叉树：</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20211014/423483716_1634208293748/10FB15C77258A991B0028080A64FB42D" alt="img"></p>
<p>所以对应的输出为[1,3,5]。</p>
<h3 id="题解-43"><a href="#题解-43" class="headerlink" title="题解"></a>题解</h3><p>首先需要明确的是什么树二叉树的右试图，物体的三视图表示物体从三个不同的方向所能看到的物体的样子，在这里二叉树的右试图其实就是每一层的最后一个（最右边）的节点，明白了这一点之后就可以进行操作了。</p>
<p>首先先根据二叉树的先序和中序遍历构造出二叉树，对于这棵二叉树使用层序遍历，遍历完成之后输出每一层最后的节点即为所需的答案。</p>
<h3 id="Java代码实现-43"><a href="#Java代码实现-43" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="comment">//     class TreeNode&#123;</span></span><br><span class="line"><span class="comment">//         int val;</span></span><br><span class="line"><span class="comment">//         TreeNode left;</span></span><br><span class="line"><span class="comment">//         TreeNode right;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     * 求二叉树的右视图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> xianxu int整型一维数组 先序遍历</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> zhongxu int整型一维数组 中序遍历</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] solve (<span class="keyword">int</span>[] xianxu, <span class="keyword">int</span>[] zhongxu) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 首先判断特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(xianxu.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> xianxu;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 保存结果</span></span><br><span class="line">        ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;(); </span><br><span class="line">        <span class="comment">// 构造出二叉树</span></span><br><span class="line">        TreeNode root = dfs(xianxu, zhongxu);</span><br><span class="line">        <span class="comment">// 层序遍历</span></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; nums = levelOrder(root);</span><br><span class="line">        <span class="comment">// 输出每一层的最后一个节点</span></span><br><span class="line">        <span class="keyword">for</span>(ArrayList&lt;Integer&gt; num : nums)&#123;</span><br><span class="line">            ans.add(num.get(num.size() - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.stream().mapToInt(Integer::valueOf).toArray();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] vin)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(vin.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = vin.length;</span><br><span class="line">        <span class="keyword">int</span> num = pre[<span class="number">0</span>];</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(num);</span><br><span class="line">        <span class="comment">// 这里看看这个值对应的位置在vin的什么位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num == vin[i])&#123;</span><br><span class="line">                root.left = dfs(Arrays.copyOfRange(pre, <span class="number">1</span>, i + <span class="number">1</span>), Arrays.copyOfRange(vin, <span class="number">0</span>, i));</span><br><span class="line">                root.right = dfs(Arrays.copyOfRange(pre, i+<span class="number">1</span>, n), Arrays.copyOfRange(vin, i + <span class="number">1</span>, n));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelOrder(TreeNode root)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后的结果</span></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 存放每一层的数据</span></span><br><span class="line">        ArrayList&lt;TreeNode&gt; nodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// 存放每一层中的数据</span></span><br><span class="line">            ArrayList&lt;Integer&gt; nums = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">// 将这一层的节点全部取出放到一个数组中</span></span><br><span class="line">            <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">                nodes.add(queue.poll());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将这一层所有节点数据保存并将其左右子树放入队列中</span></span><br><span class="line">            <span class="keyword">for</span>(TreeNode node : nodes)&#123;</span><br><span class="line">                nums.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(nums);</span><br><span class="line">            <span class="comment">// 记得遍历每一层之后将数组清空</span></span><br><span class="line">            nodes.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是考虑此方法需要先构建出二叉树，再对二叉树进行遍历，实在过于冗长，由于题目中给的是前序遍历和中序遍历的结果，根据两次遍历的性质应该能推出右试图，故考虑出以下题解。</p>
<h3 id="题解-44"><a href="#题解-44" class="headerlink" title="题解"></a>题解</h3><p>首先无论是前序遍历或是中序遍历，其本质上都是深度优先算法，之前在考虑的过程中我们考虑的是右视图其实就是全部层序遍历（广度优先搜索）的最后一个节点，现在考虑右试图如何由深度优先算法得到。</p>
<p>考虑中序遍历是左根右，若是倒过来变成右根左，那实际上就是需要的右试图，换言之，右试图实际上就是中序遍历中从后往前的n个树，这里n为树的深度，因此这里只需要在前序遍历和中序遍历中求出树的深度n，之后逆序返回树的中序遍历的后n位即可。但之后发现如此做法无法确保返回的视图是从上到下的，因此舍弃，但对于题目不要求顺序只需要层序遍历最右端的节点时此法不失为一个好办法。</p>
<p>之后看了部分题解，思路都是一致的不过在构建二叉树的过程中直接将每一层的最后一个节点进行保存，之后只要取出各个节点即可。</p>
<h3 id="Java代码实现-44"><a href="#Java代码实现-44" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="comment">//     class TreeNode&#123;</span></span><br><span class="line"><span class="comment">//         int val;</span></span><br><span class="line"><span class="comment">//         TreeNode left;</span></span><br><span class="line"><span class="comment">//         TreeNode right;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     * 求二叉树的右视图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> xianxu int整型一维数组 先序遍历</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> zhongxu int整型一维数组 中序遍历</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 存放中序中对应元素的下标</span></span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 存放答案</span></span><br><span class="line">    Map&lt;Integer, Integer&gt; ans = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 用于获取level层的根节点</span></span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] solve (<span class="keyword">int</span>[] xianxu, <span class="keyword">int</span>[] zhongxu) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 首先判断特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(xianxu.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> xianxu;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; zhongxu.length; ++i)&#123;</span><br><span class="line">            map.put(zhongxu[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        buildTree(xianxu, zhongxu, <span class="number">0</span>, zhongxu.length - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[ans.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.size(); ++i)&#123;</span><br><span class="line">            res[i] = ans.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里只是虚假的构建，因此实际上只需要那个构建的过程而不需要真正构建，故为void</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] vin, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="comment">// 获取level层根节点所在中序遍历的下标</span></span><br><span class="line">            <span class="keyword">int</span> index = map.get(pre[level++]);</span><br><span class="line">            <span class="comment">// 构建左子树</span></span><br><span class="line">            buildTree(pre, vin, left, index - <span class="number">1</span>, i +<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 构建右子树</span></span><br><span class="line">            buildTree(pre, vin, index + <span class="number">1</span>, right, i +<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 将这一层最右边的节点（所需右试图中的节点）保存</span></span><br><span class="line">            <span class="comment">// 这里为什么vin[index]就是这一层最右边的节点呢，因为构建树的过程中，右树会覆盖子树的结果</span></span><br><span class="line">            <span class="comment">// 对于同一层的左右子树都进行了put操作，但是后面的（右子树）会覆盖前面的（左子树）的操作，因为i相同</span></span><br><span class="line">            ans.put(i, vin[index]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="堆-栈-队列"><a href="#堆-栈-队列" class="headerlink" title="堆/栈/队列"></a>堆/栈/队列</h1><h2 id="BM42-用两个栈实现队列"><a href="#BM42-用两个栈实现队列" class="headerlink" title="BM42 用两个栈实现队列"></a>BM42 <a href="https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">用两个栈实现队列</a></h2><h3 id="题目描述-41"><a href="#题目描述-41" class="headerlink" title="题目描述"></a>题目描述</h3><p>用两个栈来实现一个队列，使用n个元素来完成 n 次在队列尾部插入整数(push)和n次在队列头部删除整数(pop)的功能。 队列中的元素为int类型。保证操作合法，即保证pop操作时队列内已有元素。 </p>
<p>数据范围： n≤1000</p>
<p>要求：存储n个元素的空间复杂度为 O(n) ，插入与删除的时间复杂度都是 O(1)</p>
<h3 id="题解-45"><a href="#题解-45" class="headerlink" title="题解"></a>题解</h3><p>用两个栈实现队列的主要思路是，两个栈中每次只有一个栈中拥有数据，每次移动时将一个栈中的除最后一个元素之外移动到另一个栈中，并将最后一个元素移出，但如此会导致时间复杂度为O(n)，不合题意。</p>
<p>考虑是否需要每次都要将1中的元素转移到2，首先假定stack1只进，stack2只出，那么入栈操作就是直接往stack1里面push即可，对于出操作，若是此时stack2为空，那么需要将stack1中的元素移动到stack2中，不为空则直接将stack2中的元素pop出即可（因为经过两次栈的操作，已经将之前最先放入的元素进行了二次反转，若是stack2中有元素，那必定是在stack1中所有元素之前放入的，因此当stack2中有元素时直接pop即可）。</p>
<h3 id="Java代码实现-45"><a href="#Java代码实现-45" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 只用来存数据</span></span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    <span class="comment">// 只用来取数据</span></span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM43-包含min函数的栈"><a href="#BM43-包含min函数的栈" class="headerlink" title="BM43 包含min函数的栈"></a>BM43 <a href="https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">包含min函数的栈</a></h2><h3 id="题目描述-42"><a href="#题目描述-42" class="headerlink" title="题目描述"></a>题目描述</h3><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的 min 函数，输入操作时保证 pop、top 和 min 函数操作时，栈中一定有元素。</p>
<p>此栈包含的方法有： </p>
<p>push(value):将value压入栈中 </p>
<p>pop():弹出栈顶元素 </p>
<p>top():获取栈顶元素 </p>
<p>min():获取栈中最小元素 </p>
<p>数据范围：操作数量满足 0≤n≤300，输入的元素满足 ∣val∣≤10000<br>进阶：栈的各个操作的时间复杂度是 O(1)，空间复杂度是 O(n)</p>
<p>示例: </p>
<p>输入:  [“PSH-1”,”PSH2”,”MIN”,”TOP”,”POP”,”PSH1”,”TOP”,”MIN”] </p>
<p>输出:  -1,2,1,-1 </p>
<p>解析: </p>
<p>“PSH-1”表示将-1压入栈中，栈中元素为-1</p>
<p>“PSH2”表示将2压入栈中，栈中元素为2，-1</p>
<p>“MIN”表示获取此时栈中最小元素==&gt;返回-1 </p>
<p>“TOP”表示获取栈顶元素==&gt;返回2</p>
<p>“POP”表示弹出栈顶元素，弹出2，栈中元素为-1 </p>
<p>“PSH1”表示将1压入栈中，栈中元素为1，-1</p>
<p>“TOP”表示获取栈顶元素==&gt;返回1</p>
<p>“MIN”表示获取此时栈中最小元素==&gt;返回-1</p>
<h3 id="题解-46"><a href="#题解-46" class="headerlink" title="题解"></a>题解</h3><p>直接在栈中实现min函数即可，对于min函数的实现也只需维护一个min栈用于维护每次操作的min，每次push操作判断是否小于最小值，小于的话将这个值同步更新到最小值栈中，pop时判断是否是最小元素若是是最小元素的话将这个pop操作在最小值栈进行同步pop即可。</p>
<h3 id="Java代码实现-46"><a href="#Java代码实现-46" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用于存放数据</span></span><br><span class="line">    Stack&lt;Integer&gt; nums = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="comment">// 用于实现每次的最小值</span></span><br><span class="line">    Stack&lt;Integer&gt; min = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 加入元素</span></span><br><span class="line">        nums.push(node);</span><br><span class="line">        <span class="comment">// 维护最小值</span></span><br><span class="line">        <span class="keyword">if</span>(!min.isEmpty() &amp;&amp; min.peek() &gt;= node)&#123;</span><br><span class="line">            min.push(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里对min栈记得判空</span></span><br><span class="line">        <span class="keyword">if</span>(min.isEmpty())&#123;</span><br><span class="line">            min.push(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = nums.pop();</span><br><span class="line">        <span class="keyword">if</span>(num == min.peek())&#123;</span><br><span class="line">            min.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nums.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM44-有效括号序列"><a href="#BM44-有效括号序列" class="headerlink" title="BM44 有效括号序列"></a>BM44 <a href="https://www.nowcoder.com/practice/37548e94a270412c8b9fb85643c8ccc2?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">有效括号序列</a></h2><h3 id="题目描述-43"><a href="#题目描述-43" class="headerlink" title="题目描述"></a>题目描述</h3><p>给出一个仅包含字符’(‘,’)’,’{‘,’}’,’[‘和’]’,的字符串，判断给出的字符串是否是合法的括号序列<br>括号必须以正确的顺序关闭，”()”和”()[]{}”都是合法的括号序列，但”(]”和”([)]”不合法。</p>
<p>数据范围：字符串长度 0≤n≤100000≤<em>n</em>≤10000</p>
<p>要求：空间复杂度 O(n)，时间复杂度 O(n)</p>
<h3 id="题解-47"><a href="#题解-47" class="headerlink" title="题解"></a>题解</h3><p>对于匹配问题，一般的选择是使用栈进行匹配，每次遇到左括号就入栈，遇到右括号，首先判断是否是相匹配的括号（”(“ –&gt; “)”, “[“ –&gt; “]”, “{“ –&gt; “}”），若是不匹配直接返回false，若是匹配就继续，直到最后返回true。</p>
<h3 id="Java代码实现-47"><a href="#Java代码实现-47" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span> <span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(s.equals(<span class="string">""</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="comment">// 逐个匹配</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : chars)&#123;</span><br><span class="line">            <span class="comment">// 若是左括号则入栈</span></span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'('</span> || c == <span class="string">'['</span> || c == <span class="string">'&#123;'</span>)&#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">                <span class="comment">// 对右括号进行匹配</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">')'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty() || stack.pop() != <span class="string">'('</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">']'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty() || stack.pop() != <span class="string">'['</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty() || stack.pop() != <span class="string">'&#123;'</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 为空表示所有左括号已被匹配</span></span><br><span class="line">        <span class="comment">// 反之表示有剩余的左括号不匹配</span></span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里防止if else太多也可以选择使用switch–case，但记得使用break。</p>
<h2 id="BM45-滑动窗口的最大值"><a href="#BM45-滑动窗口的最大值" class="headerlink" title="BM45 滑动窗口的最大值"></a>BM45 <a href="https://www.nowcoder.com/practice/1624bc35a45c42c0bc17d17fa0cba788?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">滑动窗口的最大值</a></h2><h3 id="题目描述-44"><a href="#题目描述-44" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个长度为 n 的数组 num 和滑动窗口的大小 size ，找出所有滑动窗口里数值的最大值。 </p>
<p>例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。 </p>
<p>窗口大于数组长度或窗口长度为0的时候，返回空。</p>
<p>数据范围： 1≤n≤10000，0≤size≤10000，数组中每个元素的值满足 ∣val∣≤10000</p>
<p>要求：空间复杂度 O(n)，时间复杂度 O(n)</p>
<h3 id="题解-48"><a href="#题解-48" class="headerlink" title="题解"></a>题解</h3><p>实际上每次滑动窗口在活动的过程中只是做了如下改变，首先是舍弃了之前滑动窗口中的第一个元素，之后又将滑动窗口的后一个元素放入，因此想到如下思路</p>
<p>因此在维护滑动窗口的时候可以考虑如下做法，首先将前size个元素入栈，标记出此时的最大值（最大值数组中第一个元素），之后对剩下的元素做如下操作，把当前值减掉出栈元素，加上入栈元素，判断是否更新最大值以及最大值数组，如此直到没有元素。</p>
<p>对每个元素进行如下操作，需要两个东西进行辅助，一个是栈用来保存这个滑动窗口中的每个值，一个是优先队列用于保存当前的最大值，每次操作需要进行如下行为，先将栈中的元素出栈，再入栈，之后将优先队列中的元素取出，再放入下一个元素，之后返回优先队列中的头元素。</p>
<h3 id="Java代码实现-48"><a href="#Java代码实现-48" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span> [] num, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num.length &lt; size || size &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2)-&gt;o2 - o1);</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(; index &lt; size; ++index)&#123;</span><br><span class="line">            queue.offer(num[index]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(index &lt; num.length)&#123;</span><br><span class="line">            res.add(queue.peek());</span><br><span class="line">            queue.offer(num[index]);</span><br><span class="line">            queue.remove(num[index - size]);</span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里最后一次的还没加入</span></span><br><span class="line">        res.add(queue.peek());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM46-最小的K个树"><a href="#BM46-最小的K个树" class="headerlink" title="BM46 最小的K个树"></a>BM46 <a href="https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">最小的K个树</a></h2><h3 id="题目描述-45"><a href="#题目描述-45" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个长度为 n 的可能有重复值的数组，找出其中不去重的最小的 k 个数。例如数组元素是4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4(任意顺序皆可)。 </p>
<p>数据范围：0≤k,n≤10000，数组中每个数的大小0≤val≤1000</p>
<p>要求：空间复杂度 O(n)，时间复杂度 O(nlogn)</p>
<h3 id="题解-49"><a href="#题解-49" class="headerlink" title="题解"></a>题解</h3><p>先将所给的数组进行排序，排序之后输出前k个即可。</p>
<h3 id="Java代码实现-49"><a href="#Java代码实现-49" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 保存返回结果</span></span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(input.length == <span class="number">0</span> || k == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(input);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">            res.add(input[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题解-50"><a href="#题解-50" class="headerlink" title="题解"></a>题解</h3><p>既然属于队列中的，那就利用队列，创建一个优先队列，值大的在队首，先将前k个值放入，开始遍历之后的元素，若是当前元素大于队首则将队首移除将当前元素放入，循环到最后的元素，将其放入需要的数组中返回即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 保存返回结果</span></span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(input.length &lt; k || k == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 构建优先队列</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);</span><br><span class="line">        <span class="comment">// 先将前k个元素放入</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">            queue.offer(input[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对后面的元素，若是比队首大，那么移除队首并将当前元素入队</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt; input.length; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(input[i] &lt; queue.peek())&#123;</span><br><span class="line">                queue.poll();</span><br><span class="line">                queue.offer(input[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            res.add(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM47-寻找第k大"><a href="#BM47-寻找第k大" class="headerlink" title="BM47 寻找第k大"></a>BM47 <a href="https://www.nowcoder.com/practice/e016ad9b7f0b45048c58a9f27ba618bf?tpId=295&tqId=44581&ru=%2Fpractice%2F8daa4dff9e36409abba2adbe413d6fae&qru=%2Fta%2Fformat-top101%2Fquestion-ranking&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">寻找第k大</a></h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>有一个整数数组，请你根据快速排序的思路，找出数组中第 k 大的数。 </p>
<p>给定一个整数数组 a ,同时给定它的大小n和要找的 k ，请返回第 k 大的数(包括重复的元素，不用去重)，保证答案存在。 </p>
<p>要求：时间复杂度 O(nlogn)，空间复杂度 O(1)</p>
<p>数据范围：0≤n≤1000， 1≤K≤n，数组中每个元素满足 0≤val≤10000000</p>
<h3 id="题解-51"><a href="#题解-51" class="headerlink" title="题解"></a>题解</h3><p>需要的是第k大的数，直接排序并返回即可。</p>
<p>但题目中说是按照快排的思路，首先考虑什么是快排，快速排序使用分治的思想，通过一趟排序将待排序列分割成两部分，其中一部分记录的关键字均比另一部分记录的关键字小。之后分别对这两部分记录继续进行排序，以达到整个序列有序的目的。</p>
<p>具体操作是：</p>
<ol>
<li><p>选择基准：在待排序列中，按照某种方式挑出一个元素，作为 “基准”（pivot），可以利用随机数</p>
</li>
<li><p>分割操作：以该基准在序列中的实际位置，把序列分成两个子序列。此时，在基准左边的元素都比该基准小，在基准右边的元素都比基准大</p>
</li>
<li><p>递归地对两个序列进行快速排序，直到序列为空或者只有一个元素。</p>
</li>
</ol>
<h3 id="Java代码实现-50"><a href="#Java代码实现-50" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKth</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        sortNums(a, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> a[n - K];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sortNums</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="comment">// 初始值为low下标所在的位置（基准）</span></span><br><span class="line">            <span class="keyword">int</span> temp = nums[low];</span><br><span class="line">            <span class="keyword">int</span> i = low;</span><br><span class="line">            <span class="keyword">int</span> j = high;</span><br><span class="line">            <span class="comment">// 移动，某一侧全是小于基准值的，另一侧是大于等于基准值的</span></span><br><span class="line">            <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">                <span class="comment">// 从右到左，位置对了（比temp大）就直接继续</span></span><br><span class="line">                <span class="keyword">while</span>(temp &lt; nums[j] &amp;&amp; i &lt; j)&#123;</span><br><span class="line">                    --j;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 此时发现了小的值（不满足），将其放到左边</span></span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                <span class="comment">// 从左到右，位置对了（小于等于temp）就继续</span></span><br><span class="line">                <span class="keyword">while</span>(temp &gt;= nums[i] &amp;&amp; i &lt; j)&#123;</span><br><span class="line">                    ++i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 此时发现了大的值（不满足），将其放到右边</span></span><br><span class="line">                nums[j] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这里最后是i = j，i,j都可以，因为值被覆盖了，实际上最后的序列中没有temp了，考虑将其放回</span></span><br><span class="line">            nums[i] = temp;</span><br><span class="line">            sortNums(nums, low, i - <span class="number">1</span>);</span><br><span class="line">            sortNums(nums, i + <span class="number">1</span>, high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM48-数据流中的中位数"><a href="#BM48-数据流中的中位数" class="headerlink" title="BM48 数据流中的中位数"></a>BM48 <a href="https://www.nowcoder.com/practice/9be0172896bd43948f8a32fb954e1be1?tpId=295&tqId=23457&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">数据流中的中位数</a></h2><h3 id="题目描述-46"><a href="#题目描述-46" class="headerlink" title="题目描述"></a>题目描述</h3><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。 </p>
<p>数据范围：数据流中数个数满足 1≤n≤1000，大小满足 1≤val≤1000</p>
<p>进阶： 空间复杂度 O(n)， 时间复杂度 O(nlogn)</p>
<h3 id="题解-52"><a href="#题解-52" class="headerlink" title="题解"></a>题解</h3><p>借助一个数组保存数据流，插入时只对数组进行插入操作，获取中位数操作时先排序再获取即可。</p>
<h3 id="Java代码实现-51"><a href="#Java代码实现-51" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; nums = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line">        nums.add(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Collections.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span>((n &amp; <span class="number">1</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 偶数</span></span><br><span class="line">            <span class="keyword">return</span> (nums.get(n / <span class="number">2</span>) + nums.get(n / <span class="number">2</span> - <span class="number">1</span>)) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (nums.get(n / <span class="number">2</span>)) / <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题解-53"><a href="#题解-53" class="headerlink" title="题解"></a>题解</h3><p>考虑什么是中位数，中位数实际上将数据分为了两部分，一部分是比中位数小的，一部分是比中位数大的，求中位数时只需要判断是奇数还是偶数，奇数直接从一边取，偶数则取出比中位数小的部分的最大值和比中位数大的部分的最小值求平均值即可。</p>
<h3 id="Java代码实现-52"><a href="#Java代码实现-52" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保存两个队列中共有多少个元素</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 比中位数小的元素</span></span><br><span class="line">    PriorityQueue&lt;Integer&gt; lessMid = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">    <span class="comment">// 比中位数大的元素</span></span><br><span class="line">    PriorityQueue&lt;Integer&gt; moreMid = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((count &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 若是当前是奇数，那需要放入右边，因此先将放入左边，再把左边的弹到右边</span></span><br><span class="line">            <span class="comment">// 这里为什么是这样，是因为规定了奇数时左边多一个元素，也可另作规定</span></span><br><span class="line">            lessMid.offer(num);</span><br><span class="line">            <span class="keyword">int</span> cur = lessMid.poll();</span><br><span class="line">            moreMid.offer(cur);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 反之若是当前为偶数，那么插入到左边，因此先放右边，再弹一个元素到左边</span></span><br><span class="line">            moreMid.offer(num);</span><br><span class="line">            <span class="keyword">int</span> cur = moreMid.poll();</span><br><span class="line">            lessMid.offer(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((count &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 奇数，直接将左边的元素取出</span></span><br><span class="line">            <span class="keyword">return</span> lessMid.peek() / <span class="number">1.0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (lessMid.peek() + moreMid.peek()) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM49-表达式求值"><a href="#BM49-表达式求值" class="headerlink" title="BM49 表达式求值"></a>BM49 <a href="https://www.nowcoder.com/practice/c215ba61c8b1443b996351df929dc4d4?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">表达式求值</a></h2><h3 id="题目描述-47"><a href="#题目描述-47" class="headerlink" title="题目描述"></a>题目描述</h3><p>请写一个整数计算器，支持加减乘三种运算和括号。 </p>
<p>数据范围：0≤∣s∣≤100，保证计算结果始终在整型范围内</p>
<p>要求：空间复杂度：O(n)，时间复杂度 O(n)</p>
<h3 id="题解-54"><a href="#题解-54" class="headerlink" title="题解"></a>题解</h3><p>对于设计运算符优先性问题，可以考虑用栈处理，首先确定一点，使用两个表达式完成，第一个是nums用于存放数字，ops存放数字之外的操作符，对于字符可能出现下列各种情况，首先是括号，左括号直接入栈ops，等待匹配的右括号，右括号使用现在栈中的nums和ops进行计算，直到遇到左边最近的一个左括号位置，结果放到nums中，之后若是遇到了数字，那么就继续往后遍历直到取出完整字符，存入nums中，+-*号则是放入ops中，在放入栈之前可以先将栈内可以算的都算掉，但是只有运算符更高或是同级的才能计算，知道没有操作或是遇到了左括号，之后将计算结果放到nums中。</p>
<p>这一部分参照了三叶大神的思想，完整版<a href="https://blog.nowcoder.net/n/c8c1ff4ecfb44ca4958b1ecbdcbf2021" target="_blank" rel="noopener">在这里</a></p>
<h3 id="Java代码实现-53"><a href="#Java代码实现-53" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 map 维护一个运算符优先级（其中加减法优先级相同，乘法有着更高的优先级）</span></span><br><span class="line">    Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;()&#123;&#123;</span><br><span class="line">        put(<span class="string">'-'</span>, <span class="number">1</span>);</span><br><span class="line">        put(<span class="string">'+'</span>, <span class="number">1</span>);</span><br><span class="line">        put(<span class="string">'*'</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将所有的空格去掉</span></span><br><span class="line">        s = s.replaceAll(<span class="string">" "</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] cs = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存放所有的数字</span></span><br><span class="line">        Deque&lt;Integer&gt; nums = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="comment">// 为了防止第一个数为负数，先往 nums 加个 0</span></span><br><span class="line">        nums.addLast(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 存放所有「非数字以外」的操作</span></span><br><span class="line">        Deque&lt;Character&gt; ops = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = cs[i];</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'('</span>) &#123;</span><br><span class="line">                ops.addLast(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">')'</span>) &#123;</span><br><span class="line">                <span class="comment">// 计算到最近一个左括号为止</span></span><br><span class="line">                <span class="keyword">while</span> (!ops.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ops.peekLast() != <span class="string">'('</span>) &#123;</span><br><span class="line">                        calc(nums, ops);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        ops.pollLast();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (isNumber(c)) &#123;</span><br><span class="line">                    <span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">int</span> j = i;</span><br><span class="line">                    <span class="comment">// 将从 i 位置开始后面的连续数字整体取出，加入 nums</span></span><br><span class="line">                    <span class="keyword">while</span> (j &lt; n &amp;&amp; isNumber(cs[j])) u = u * <span class="number">10</span> + (cs[j++] - <span class="string">'0'</span>);</span><br><span class="line">                    nums.addLast(u);</span><br><span class="line">                    i = j - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; (cs[i - <span class="number">1</span>] == <span class="string">'('</span> || cs[i - <span class="number">1</span>] == <span class="string">'+'</span> || cs[i - <span class="number">1</span>] == <span class="string">'-'</span>)) &#123;</span><br><span class="line">                        nums.addLast(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 有一个新操作要入栈时，先把栈内可以算的都算了 </span></span><br><span class="line">                    <span class="comment">// 只有满足「栈内运算符」比「当前运算符」优先级高/同等，才进行运算</span></span><br><span class="line">                    <span class="keyword">while</span> (!ops.isEmpty() &amp;&amp; ops.peekLast() != <span class="string">'('</span>) &#123;</span><br><span class="line">                        <span class="keyword">char</span> prev = ops.peekLast();</span><br><span class="line">                        <span class="keyword">if</span> (map.get(prev) &gt;= map.get(c)) &#123;</span><br><span class="line">                            calc(nums, ops);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ops.addLast(c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将剩余的计算完</span></span><br><span class="line">        <span class="keyword">while</span> (!ops.isEmpty() &amp;&amp; ops.peekLast() != <span class="string">'('</span>) calc(nums, ops);</span><br><span class="line">        <span class="keyword">return</span> nums.peekLast();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算逻辑：从 nums 中取出两个操作数，从 ops 中取出运算符，然后根据运算符进行计算即可</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(Deque&lt;Integer&gt; nums, Deque&lt;Character&gt; ops)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.isEmpty() || nums.size() &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (ops.isEmpty()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> b = nums.pollLast(), a = nums.pollLast();</span><br><span class="line">        <span class="keyword">char</span> op = ops.pollLast();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">'+'</span>) ans = a + b;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">'-'</span>) ans = a - b;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">'*'</span>) ans = a * b;    </span><br><span class="line">        nums.addLast(ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Character.isDigit(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h1><h2 id="BM50-两数之和"><a href="#BM50-两数之和" class="headerlink" title="BM50 两数之和"></a>BM50 <a href="https://www.nowcoder.com/practice/20ef0972485e41019e39543e8e895b7f?tpId=295&tqId=745&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">两数之和</a></h2><h3 id="题目描述-48"><a href="#题目描述-48" class="headerlink" title="题目描述"></a>题目描述</h3><p>给出一个整型数组 numbers 和一个目标值 target，请在数组中找出两个加起来等于目标值的数的下标，返回的下标按升序排列。 </p>
<p>（注：<strong>返回</strong>的数组下标从1开始算起，保证target一定可以由数组里面2个数字相加得到） </p>
<p>数据范围：2≤len(numbers)≤10^5，−10≤numbersi≤10^9，0≤target≤10^9</p>
<p>要求：空间复杂度 O(n)，时间复杂度 O(nlogn)</p>
<h3 id="题解-55"><a href="#题解-55" class="headerlink" title="题解"></a>题解</h3><p>这题最简单的做法是两个for循环遍历所有可能的情况，最终找到结果，但此时不满足题目要求的时间复杂度。</p>
<p>这里关键是两个for循环耗费了很多时间，试考虑如下情况，若是有一个数据结构中存着集合中所有的元素，那么在第二次遍历时只需要判断数组中是否有target - nums[i]即可，更优化一些，对于每个元素做如下操作，若是target - nums[i]在这个集合中，那么就返回这两个数的下标，若是target - nums[i]不在这个集合中那么就将这个值和下标放入这个集合中，帮助之后的元素能获取到结果。</p>
<h3 id="Java代码实现-54"><a href="#Java代码实现-54" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> numbers int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum (<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 返回最终结果</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 保存元素及其下标</span></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; ++i)&#123;</span><br><span class="line">            <span class="comment">// 若是已有target - 当前元素，那么这两个元素已能构成结果返回</span></span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target - numbers[i]))&#123;</span><br><span class="line">                <span class="comment">// 这里注意 + 1操作</span></span><br><span class="line">                res[<span class="number">0</span>] = map.get(target - numbers[i]) + <span class="number">1</span>;</span><br><span class="line">                res[<span class="number">1</span>] = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 不是结果或者说暂时不是结果，放入map中等待查询</span></span><br><span class="line">                map.put(numbers[i], i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM51-数组中出现次数超过一半的数字"><a href="#BM51-数组中出现次数超过一半的数字" class="headerlink" title="BM51 数组中出现次数超过一半的数字"></a>BM51 <a href="https://www.nowcoder.com/practice/e8a1b01a2df14cb2b228b30ee6a92163?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">数组中出现次数超过一半的数字</a></h2><h3 id="题目描述-49"><a href="#题目描述-49" class="headerlink" title="题目描述"></a>题目描述</h3><p>给一个长度为 n 的数组，数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。 </p>
<p>例如输入一个长度为9的数组[1,2,3,2,2,2,5,4,2]。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。 </p>
<p>数据范围：n≤50000，数组中元素的值 0≤val≤10000</p>
<p>要求：空间复杂度：O(1)，时间复杂度 O(n)</p>
<h4 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述"></a>输入描述</h4><p>保证数组输入非空，且保证有解</p>
<h3 id="题解-56"><a href="#题解-56" class="headerlink" title="题解"></a>题解</h3><p>需要使用一个HashMap保存元素以及其出现的次数，之后遍历数组，对每个元素进行如下操作：将每个元素放入并将次数进行加1（之前没有此元素默认为0），若是当前元素的key大于数字的一半，那么直接返回，否则一直到所有元素完成遍历。</p>
<h3 id="Java代码实现-55"><a href="#Java代码实现-55" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 题目中说了有解股无需判断</span></span><br><span class="line">        <span class="comment">// 保存元素以及其出现的次数</span></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = array.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : array)&#123;</span><br><span class="line">            <span class="comment">// 初始值为0</span></span><br><span class="line">            map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(map.get(num) &gt; n / <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM52-数组中只出现一次的两个数字"><a href="#BM52-数组中只出现一次的两个数字" class="headerlink" title="BM52 数组中只出现一次的两个数字"></a>BM52 <a href="https://www.nowcoder.com/practice/389fc1c3d3be4479a154f63f495abff8?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">数组中只出现一次的两个数字</a></h2><h3 id="题目描述-50"><a href="#题目描述-50" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个整型数组里除了两个数字只出现一次，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。 </p>
<p>数据范围：数组长度 2≤n≤1000，数组中每个数的大小 0&lt;val≤1000000<br>要求：空间复杂度 O(1)，时间复杂度 O(n)</p>
<p>提示：输出时按非降序排列。</p>
<h3 id="题解-57"><a href="#题解-57" class="headerlink" title="题解"></a>题解</h3><p>可以首先遍历数组中的全部元素，并保存其出现的次数，之后遍历map中的元素，找到只出现了一次的两个元素，使其非降序排序并返回。</p>
<h3 id="Java代码实现-56"><a href="#Java代码实现-56" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] FindNumsAppearOnce (<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 保存数组下标以及其出现的次序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : array)&#123;</span><br><span class="line">            map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : map.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(num) == <span class="number">1</span>)&#123;</span><br><span class="line">                res[index++] = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 排序后输出</span></span><br><span class="line">        <span class="keyword">if</span>(res[<span class="number">0</span>] &lt;= res[<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;res[<span class="number">1</span>], res[<span class="number">0</span>]&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题解-58"><a href="#题解-58" class="headerlink" title="题解"></a>题解</h3><p>但这一题其实存在更好的解法，因为题目中说其余元素都出现了两次，那么你对相同的两个数进行异或运算，得到的是0，你对数组中的全部元素进行按位异或操作，最终得到的数就是两个只出现一次的数的异或结果。现在问题转化为如何从a^b的结果中反推出ab，这显然不现实，但若是只有一个元素出现一次，那只需对所有数据异或即可得到这个数，那有两个元素只出现一次，那直接分成两组即可，但这里出现了一个问题，如何进行分组才能确保两个数在不同的组呢。首先考虑分组对其余元素是没有影响的，无论按何种分法，最终相同的元素异或都会得到0，因此分组只需要将两个只出现一次的不同的元素分开即可，异或运算恰能找到这个不同的元素，使用按位异或的结果分组后分别对两个组按位异或就能得到两个值，分组也比较简单，直接&amp;操作即可。</p>
<h3 id="Java代码实现-57"><a href="#Java代码实现-57" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] FindNumsAppearOnce (<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 分组的标准</span></span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : array)&#123;</span><br><span class="line">            level ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里level是不能直接当作分组标准的，因为有一位为1时才能分组</span></span><br><span class="line">        <span class="comment">// 因此需要找到分组标准</span></span><br><span class="line">        <span class="keyword">int</span> mask = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 若是其和level相与之后的结果是0，证明level该位为0，不符合，继续找</span></span><br><span class="line">        <span class="keyword">while</span>((level &amp; mask) == <span class="number">0</span>)&#123;</span><br><span class="line">            mask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时的mask即为分类标准</span></span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : array)&#123;</span><br><span class="line">            <span class="comment">// 这里注意是0，因为会出现为和不为0（不一定是1）的情况</span></span><br><span class="line">            <span class="keyword">if</span>((num &amp; mask) == <span class="number">0</span>)&#123;</span><br><span class="line">                num1 ^= num;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                num2 ^= num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num1 &lt;= num2)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;num1, num2&#125;;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;num2, num1&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM53-缺失的第一个正整数"><a href="#BM53-缺失的第一个正整数" class="headerlink" title="BM53 缺失的第一个正整数"></a>BM53 <a href="https://www.nowcoder.com/practice/50ec6a5b0e4e45348544348278cdcee5?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">缺失的第一个正整数</a></h2><h3 id="题目描述-51"><a href="#题目描述-51" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个无重复元素的整数数组nums，请你找出其中没有出现的最小的正整数 </p>
<p>进阶： 空间复杂度 O(1)，时间复杂度 O(n)</p>
<p>数据范围: </p>
<p>-2^31&lt;=nums[i]&lt;=^31-1 </p>
<p>0&lt;=len(nums)&lt;=5*105</p>
<h3 id="题解-59"><a href="#题解-59" class="headerlink" title="题解"></a>题解</h3><p>将nums中的数据保存到一个HashSet中，之后从0遍历到nums.length，若是没有此元素就输出。</p>
<h3 id="Java代码实现-58"><a href="#Java代码实现-58" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberDisappeared</span> <span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.contains(i))&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里判断是否包含n是因为可能是由于某个非正数导致前面全部满足，也可能是包含了n导致满足</span></span><br><span class="line">        <span class="keyword">return</span> set.contains(nums.length) ? nums.length + <span class="number">1</span> : nums.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM54-三数之和"><a href="#BM54-三数之和" class="headerlink" title="BM54 三数之和"></a>BM54 <a href="https://www.nowcoder.com/practice/345e2ed5f81d4017bbb8cc6055b0b711?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">三数之和</a></h2><h3 id="题目描述-52"><a href="#题目描述-52" class="headerlink" title="题目描述"></a>题目描述</h3><p>给出一个有n个元素的数组S，S中是否有元素a,b,c满足a+b+c=0？找出数组S中所有满足条件的三元组。 </p>
<p>数据范围：0≤n≤1000，数组中各个元素值满足 ∣val∣≤100</p>
<p>空间复杂度：O(n^2)，时间复杂度 O(n^2)</p>
<p>注意：</p>
<ol>
<li>三元组（a、b、c）中的元素必须按非降序排列。（即a≤b≤c） </li>
<li>解集中不能包含重复的三元组。 </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如，给定的数组 S &#x3D; &#123;-10 0 10 20 -10 -40&#125;,解集为(-10, -10, 20),(-10, 0, 10)</span><br></pre></td></tr></table></figure>

<h3 id="题解-60"><a href="#题解-60" class="headerlink" title="题解"></a>题解</h3><p>最简单的做法是三个for循环，但时间复杂度太高了，因此考虑减少其中的复杂度，首先进行一次遍历，将数组中的全部元素放到一个HashMap中，key为元素，value为出现的次数，之后使用两个for循环计算出两个元素的值，再做判断，若是map中有这两个数的相反数，那么就保存这个序列并输出，反之则继续遍历，直到两个for循环结束，时间复杂度为O(n ^2)</p>
<h3 id="Java代码实现-59"><a href="#Java代码实现-59" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt; <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(num))&#123;</span><br><span class="line">                map.put(num, map.get(num) + <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(num, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先把三个0单独考虑，看0出现了几次</span></span><br><span class="line">        <span class="keyword">int</span> times = map.getOrDefault(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(times &gt;= <span class="number">3</span>)&#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            lists.add(<span class="number">0</span>);</span><br><span class="line">            lists.add(<span class="number">0</span>);</span><br><span class="line">            lists.add(<span class="number">0</span>);</span><br><span class="line">            res.add(lists);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length - <span class="number">1</span>; ++j)&#123;</span><br><span class="line">                ArrayList&lt;Integer&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">int</span> num1 = nums[i];</span><br><span class="line">                <span class="keyword">int</span> num2 = nums[j];</span><br><span class="line">                <span class="comment">// 这个已经计算过了</span></span><br><span class="line">                <span class="keyword">if</span>(num1 == <span class="number">0</span> &amp;&amp; num2 == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> target = <span class="number">0</span> - (num1 + num2);</span><br><span class="line">                <span class="comment">// 计算出的值和两个已给值中任意一个相同</span></span><br><span class="line">                <span class="keyword">if</span>(target == num1 || target == num2)&#123;</span><br><span class="line">                    <span class="comment">// 看是否大于1</span></span><br><span class="line">                    <span class="keyword">if</span>(map.getOrDefault(target, <span class="number">0</span>) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                        lists.add(num2);</span><br><span class="line">                        lists.add(num1);</span><br><span class="line">                        lists.add(target);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 不等于任意数</span></span><br><span class="line">                    <span class="keyword">if</span>(map.containsKey(target))&#123;</span><br><span class="line">                        lists.add(num1);</span><br><span class="line">                        lists.add(num2);</span><br><span class="line">                        lists.add(target);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 只有数组中有元素时才排序后放入最终结果集</span></span><br><span class="line">                <span class="keyword">if</span>(lists.size() == <span class="number">3</span>)&#123;</span><br><span class="line">                    Collections.sort(lists);</span><br><span class="line">                    <span class="keyword">if</span>(res.size() == <span class="number">0</span> || (res.size() &gt; <span class="number">0</span> &amp;&amp; !res.contains(lists)))&#123;</span><br><span class="line">                        res.add(lists);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但此做法会导致如下问题：<img src="%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3.png" alt="image-20220316112412395"></p>
<p>我自己是觉得没问题的（题目只说了三元组中元素非降序，没说三元组间也需要有序），但是用例中需要排序，因此考虑是否最后对数组进行排序或是其他做法。</p>
<p>最后改为这样形式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt; <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(num))&#123;</span><br><span class="line">                map.put(num, map.get(num) + <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(num, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先把三个0单独考虑，看0出现了几次</span></span><br><span class="line">        <span class="keyword">int</span> times = map.getOrDefault(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(times &gt;= <span class="number">3</span>)&#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            lists.add(<span class="number">0</span>);</span><br><span class="line">            lists.add(<span class="number">0</span>);</span><br><span class="line">            lists.add(<span class="number">0</span>);</span><br><span class="line">            res.add(lists);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length - <span class="number">1</span>; ++j)&#123;</span><br><span class="line">                ArrayList&lt;Integer&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">int</span> num1 = nums[i];</span><br><span class="line">                <span class="keyword">int</span> num2 = nums[j];</span><br><span class="line">                <span class="comment">// 这个已经计算过了</span></span><br><span class="line">                <span class="keyword">if</span>(num1 == <span class="number">0</span> &amp;&amp; num2 == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> target = <span class="number">0</span> - (num1 + num2);</span><br><span class="line">                <span class="comment">// 计算出的值和两个已给值中任意一个相同</span></span><br><span class="line">                <span class="keyword">if</span>(target == num1 || target == num2)&#123;</span><br><span class="line">                    <span class="comment">// 看是否大于1</span></span><br><span class="line">                    <span class="keyword">if</span>(map.getOrDefault(target, <span class="number">0</span>) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                        lists.add(num2);</span><br><span class="line">                        lists.add(num1);</span><br><span class="line">                        lists.add(target);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 不等于任意数</span></span><br><span class="line">                    <span class="keyword">if</span>(map.containsKey(target))&#123;</span><br><span class="line">                        lists.add(num1);</span><br><span class="line">                        lists.add(num2);</span><br><span class="line">                        lists.add(target);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 只有数组中有元素时才排序后放入最终结果集</span></span><br><span class="line">                <span class="keyword">if</span>(lists.size() == <span class="number">3</span>)&#123;</span><br><span class="line">                    Collections.sort(lists);</span><br><span class="line">                    <span class="keyword">if</span>(res.size() == <span class="number">0</span> || (res.size() &gt; <span class="number">0</span> &amp;&amp; !res.contains(lists)))&#123;</span><br><span class="line">                        res.add(lists);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里这个很不合理</span></span><br><span class="line">        Collections.sort(res, <span class="keyword">new</span> Comparator&lt;ArrayList&lt;Integer&gt;&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(ArrayList&lt;Integer&gt; list1, ArrayList&lt;Integer&gt; list2)</span></span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(list1.get(<span class="number">0</span>) == list2.get(<span class="number">0</span>))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(list1.get(<span class="number">1</span>) == list2.get(<span class="number">1</span>))&#123;</span><br><span class="line">                        <span class="keyword">return</span> list1.get(<span class="number">2</span>) - list2.get(<span class="number">2</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> list1.get(<span class="number">1</span>) - list2.get(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> list1.get(<span class="number">0</span>) - list2.get(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者也可以先对数组进行排序，之后就不会出现此情况了，这里推荐一份<a href="https://blog.nowcoder.net/n/0f57681a03894fe8a2324cf41f22330f" target="_blank" rel="noopener">题解</a>，里面还有如何使用双指针解决此问题。</p>
<h1 id="递归-回溯"><a href="#递归-回溯" class="headerlink" title="递归/回溯"></a>递归/回溯</h1><h2 id="BM55-没有重复数字的全排列"><a href="#BM55-没有重复数字的全排列" class="headerlink" title="BM55 没有重复数字的全排列"></a>BM55 <a href="https://www.nowcoder.com/practice/4bcf3081067a4d028f95acee3ddcd2b1?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">没有重复数字的全排列</a></h2><h3 id="题目描述-53"><a href="#题目描述-53" class="headerlink" title="题目描述"></a>题目描述</h3><p>给出一组数字，返回该组数字的所有排列 </p>
<p>例如： </p>
<p>[1,2,3]的所有排列如下<br>[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2], [3,2,1].<br>（以数字在数组中的位置靠前为优先级，按字典序排列输出。） </p>
<p>数据范围：数字个数 0&lt;n≤6</p>
<p>要求：空间复杂度 O(n!)，时间复杂度 O(n!）</p>
<h3 id="题解-61"><a href="#题解-61" class="headerlink" title="题解"></a>题解</h3><p>全排列问题，直接回溯求解即可。</p>
<h3 id="Java代码实现-60"><a href="#Java代码实现-60" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 存取全部结果</span></span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] num) &#123;</span><br><span class="line">        <span class="comment">// 确保符合题意</span></span><br><span class="line">        Arrays.sort(num);</span><br><span class="line">        LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 直接递归回溯</span></span><br><span class="line">        backTrack(num, list);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="keyword">int</span>[] nums, LinkedList&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 相等表示找到了一种排列</span></span><br><span class="line">        <span class="keyword">if</span>(list.size() == nums.length)&#123;</span><br><span class="line">            <span class="comment">// 加入结果集</span></span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i)&#123;</span><br><span class="line">            <span class="comment">// 包含当前元素就继续向下</span></span><br><span class="line">            <span class="keyword">if</span>(list.contains(nums[i]))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            list.add(nums[i]);</span><br><span class="line">            backTrack(nums, list);</span><br><span class="line">            list.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM56-有重复项数字的全排列"><a href="#BM56-有重复项数字的全排列" class="headerlink" title="BM56 有重复项数字的全排列"></a>BM56 <a href="https://www.nowcoder.com/practice/a43a2b986ef34843ac4fdd9159b69863?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">有重复项数字的全排列</a></h2><h3 id="题目描述-54"><a href="#题目描述-54" class="headerlink" title="题目描述"></a>题目描述</h3><p>给出一组可能包含重复项的数字，返回该组数字的所有排列。结果以字典序升序排列。 </p>
<p>数据范围： 0&lt;n≤8，数组中的值满足 −1≤val≤5</p>
<p>要求：空间复杂度 O(n!)<em>O</em>(<em>n</em>!)，时间复杂度 O(n!)<em>O</em>(<em>n</em>!)</p>
<h3 id="题解-62"><a href="#题解-62" class="headerlink" title="题解"></a>题解</h3><p>递归，每次加入数据时判断是否已有此排列方式即可，此外维护一个数组表示元素是否被标记过，只有没有被标记过才继续。</p>
<h3 id="Java代码实现-61"><a href="#Java代码实现-61" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 存放是否被访问过的数组</span></span><br><span class="line">    <span class="keyword">boolean</span>[] mark;</span><br><span class="line">    <span class="comment">// 存放结果的数组</span></span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] num) &#123;</span><br><span class="line">        <span class="comment">// 先排列数组</span></span><br><span class="line">        Arrays.sort(num);</span><br><span class="line">        <span class="comment">// 存放每一层的元素，都是加入一个或者移除最后一个，直接用LinkedList</span></span><br><span class="line">        LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        mark = <span class="keyword">new</span> <span class="keyword">boolean</span>[num.length];</span><br><span class="line">        backTrace(num, list, mark);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backTrace</span><span class="params">(<span class="keyword">int</span>[] nums, LinkedList&lt;Integer&gt; list, <span class="keyword">boolean</span>[] mark)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 退出递归的条件</span></span><br><span class="line">        <span class="keyword">if</span>(list.size() == nums.length)&#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; num = <span class="keyword">new</span> ArrayList&lt;&gt;(list);</span><br><span class="line">            <span class="keyword">if</span>(!res.contains(num))&#123;</span><br><span class="line">                res.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有退出就继续递归</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i)&#123;</span><br><span class="line">            <span class="comment">// 如果当前位置已访问过直接退出</span></span><br><span class="line">            <span class="keyword">if</span>(mark[i])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            list.add(nums[i]);</span><br><span class="line">            <span class="comment">// 标记其为已访问过</span></span><br><span class="line">            mark[i] = <span class="keyword">true</span>;</span><br><span class="line">            backTrace(nums, list, mark);</span><br><span class="line">            list.removeLast();</span><br><span class="line">            <span class="comment">// 标记其还未访问过</span></span><br><span class="line">            mark[i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM57-岛屿数量"><a href="#BM57-岛屿数量" class="headerlink" title="BM57 岛屿数量"></a>BM57 <a href="https://www.nowcoder.com/practice/0c9664d1554e466aa107d899418e814e?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">岛屿数量</a></h2><h3 id="题目描述-55"><a href="#题目描述-55" class="headerlink" title="题目描述"></a>题目描述</h3><p>给一个01矩阵，1代表是陆地，0代表海洋， 如果两个1相邻，那么这两个1属于同一个岛。我们只考虑上下左右为相邻。</p>
<p>岛屿: 相邻陆地可以组成一个岛屿（相邻:上下左右） 判断岛屿个数。 </p>
<p>例如： </p>
<p>输入 </p>
<p>[ </p>
<p>[1,1,0,0,0], </p>
<p>[0,1,0,1,1], </p>
<p>[0,0,0,1,1], </p>
<p>[0,0,0,0,0], </p>
<p>[0,0,1,1,1] </p>
<p>] </p>
<p>对应的输出为3</p>
<p>(注：存储的01数据其实是字符’0’,’1’)</p>
<h3 id="题解-63"><a href="#题解-63" class="headerlink" title="题解"></a>题解</h3><p>维护一个二维数组mark表示是否被标记过，遍历回溯，若是找到了1，先判断是否有标记过，标记过就直接跳过继续搜，若是没有标记过，分析其前后左右是否有1，并将所有1所在的位置进行标记并令岛屿数自增1，最终返回岛屿数。</p>
<h3 id="Java代码实现-62"><a href="#Java代码实现-62" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断岛屿数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> grid char字符型二维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span> <span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 岛屿m行n列</span></span><br><span class="line">        <span class="keyword">int</span> m = grid.length;</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">boolean</span>[][] mark = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="comment">// 标记有多少个岛屿</span></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span> &amp;&amp; !mark[i][j])&#123;</span><br><span class="line">                    ++num;</span><br><span class="line">                    <span class="comment">// 每次向上下左右搜索，直到没有为止</span></span><br><span class="line">                    dfs(grid, i, j, mark);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 回溯，使上下左右的1变为true</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">boolean</span>[][] mark)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 若是超出边界值或是当前元素已被标记过就返回</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= grid.length || j &lt; <span class="number">0</span> || j &gt;= grid[<span class="number">0</span>].length || grid[i][j] == <span class="string">'0'</span> || mark[i][j])&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mark[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        dfs(grid, i, j + <span class="number">1</span>, mark);</span><br><span class="line">        dfs(grid, i - <span class="number">1</span>, j, mark);</span><br><span class="line">        dfs(grid, i, j - <span class="number">1</span>, mark);</span><br><span class="line">        dfs(grid, i + <span class="number">1</span>, j, mark);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM58-字符串的排列"><a href="#BM58-字符串的排列" class="headerlink" title="BM58 字符串的排列"></a>BM58 <a href="https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">字符串的排列</a></h2><h3 id="题目描述-56"><a href="#题目描述-56" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个长度为 n 字符串，打印出该字符串中字符的所有排列，你可以以任意顺序返回这个字符串数组。 </p>
<p>例如输入字符串ABC,则输出由字符A,B,C所能排列出来的所有字符串ABC,ACB,BAC,BCA,CBA和CAB。 </p>
<p><img src="https://uploadfiles.nowcoder.com/images/20211008/557336_1633676660853/6226390B4185DB132AFFDB10F09F8BEB" alt="img"></p>
<p>数据范围：n&lt;10<br>要求：空间复杂度 O(n!)，时间复杂度 O(n!)</p>
<h4 id="输入描述-2"><a href="#输入描述-2" class="headerlink" title="输入描述"></a>输入描述</h4><p>输入一个字符串,长度不超过10,字符只包括大小写字母。</p>
<h3 id="题解-64"><a href="#题解-64" class="headerlink" title="题解"></a>题解</h3><p>将字符串直接进行全排即可，和<a href="https://www.nowcoder.com/practice/a43a2b986ef34843ac4fdd9159b69863?tpId=295&tqId=700&ru=%2Fpractice%2Ffe6b651b66ae47d7acce78ffdd9a96c7&qru=%2Fta%2Fformat-top101%2Fquestion-ranking&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">有重复数字全排</a>是一样的。</p>
<h3 id="Java代码实现-63"><a href="#Java代码实现-63" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">Permutation</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 先进行判空</span></span><br><span class="line">        <span class="keyword">if</span>(str.equals(<span class="string">""</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用于保存每次排列出的字符串</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">        <span class="comment">// 用于判断当前字符是否被遍历过</span></span><br><span class="line">        <span class="keyword">boolean</span>[] mask = <span class="keyword">new</span> <span class="keyword">boolean</span>[chars.length];</span><br><span class="line">        backTrace(res, chars, sb, mask);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backTrace</span><span class="params">(ArrayList&lt;String&gt; res, <span class="keyword">char</span>[] chars, StringBuilder sb, <span class="keyword">boolean</span>[] mask)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 退出条件</span></span><br><span class="line">        <span class="keyword">if</span>(sb.length() == chars.length)&#123;</span><br><span class="line">            <span class="comment">// 去重</span></span><br><span class="line">            <span class="keyword">if</span>(!res.contains(sb.toString()))&#123;</span><br><span class="line">                res.add(sb.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; ++i)&#123;</span><br><span class="line">            <span class="comment">// 只有没有遍历过这个元素才继续</span></span><br><span class="line">            <span class="keyword">if</span>(!mask[i])&#123;</span><br><span class="line">                mask[i] = <span class="keyword">true</span>;</span><br><span class="line">                sb.append(chars[i]);</span><br><span class="line">                backTrace(res, chars, sb, mask);</span><br><span class="line">                sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">                mask[i] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM59-N皇后问题"><a href="#BM59-N皇后问题" class="headerlink" title="BM59 N皇后问题"></a>BM59 <a href="https://www.nowcoder.com/practice/c76408782512486d91eea181107293b6?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">N皇后问题</a></h2><h3 id="题目描述-57"><a href="#题目描述-57" class="headerlink" title="题目描述"></a>题目描述</h3><p>N 皇后问题是指在 n * n 的棋盘上要摆 n 个皇后，<br>要求：任何两个皇后不同行，不同列也不在同一条斜线上，<br>求给一个整数 n ，返回 n 皇后的摆法数。</p>
<p>数据范围: 1≤n≤9</p>
<p>要求：空间复杂度 O(1)，时间复杂度 O(n!)</p>
<p>例如当输入4时，对应的返回值为2， </p>
<p>对应的两种四皇后摆位如下图所示： </p>
<p><img src="https://uploadfiles.nowcoder.com/images/20211204/423483716_1638606211798/CFE342EBEEFB9E6839E6ED216B889F16" alt="img"></p>
<h3 id="题解-65"><a href="#题解-65" class="headerlink" title="题解"></a>题解</h3><p>回溯法的经典实例，N皇后问题，对于每个位置进行判断，若是发现了不合题意（任何皇后不能在相同行，相同列或是一条斜线上）的直接放弃这个解（剪枝），若是符合题意继续，直到遍历完。</p>
<p>对于n皇后问题，需要一个辅助函数判断当前的元素是否合法，需要的是二维字符数组chess（需要判断棋局是否合法），返回的结果集List&lt;List &lt; String &gt;&gt; res（需要往其中添加元素），以及当前列数（看到此列为止是否符合题意），判断时需要考虑同一行不能有皇后（每一行只放一个元素故天然满足此条件），同一列不能有皇后，只要看上面有无皇后即可，同一斜线不能有皇后（左上右上分开看，左上横纵坐标减1，右上横坐标加1纵坐标减1），三个条件有一个不满足即不合法，全满足则可以进行下一次遍历。</p>
<h3 id="Java代码实现-64"><a href="#Java代码实现-64" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n int整型 the n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Nqueen</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">return</span> solveNQueens(n).size();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">char</span>[][] chess = <span class="keyword">new</span> <span class="keyword">char</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                chess[i][j] = <span class="string">'.'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        solve(res, chess, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 求解过程</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(List&lt;List&lt;String&gt;&gt; res, <span class="keyword">char</span>[][] chess, <span class="keyword">int</span> row)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 若是满足直接退出</span></span><br><span class="line">        <span class="keyword">if</span>(row == chess.length)&#123;</span><br><span class="line">            res.add(construct(chess));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 之后判断当前位置是否合法，合法则将当前位置变为Q，继续，不合法直接下一个元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; chess.length; ++col)&#123;</span><br><span class="line">            <span class="keyword">if</span>(valid(chess, row, col))&#123;</span><br><span class="line">                chess[row][col] = <span class="string">'Q'</span>;</span><br><span class="line">                solve(res, chess, row + <span class="number">1</span>);</span><br><span class="line">                chess[row][col] = <span class="string">'.'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断当前位置是否合法</span></span><br><span class="line">    <span class="comment">// 天然不在同一行</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">valid</span><span class="params">(<span class="keyword">char</span>[][] chess, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 两个皇后不能在同一列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(chess[i][col] == <span class="string">'Q'</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 两个皇后不能在同一条斜线</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 确保右上角没有</span></span><br><span class="line">        <span class="comment">// 每次就往右上角移一位，判断是否有皇后</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; chess.length; --i, ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(chess[i][j] == <span class="string">'Q'</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 确保左上角没有</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; --i, --j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(chess[i][j] == <span class="string">'Q'</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 都满足的话就证明是合法的</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回棋局</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">construct</span><span class="params">(<span class="keyword">char</span>[][] chess)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chess.length; ++i)&#123;</span><br><span class="line">            path.add(<span class="keyword">new</span> String(chess[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM60-括号生成"><a href="#BM60-括号生成" class="headerlink" title="BM60 括号生成"></a>BM60 <a href="https://www.nowcoder.com/practice/c9addb265cdf4cdd92c092c655d164ca?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">括号生成</a></h2><h3 id="题目描述-58"><a href="#题目描述-58" class="headerlink" title="题目描述"></a>题目描述</h3><p>给出n对括号，请编写一个函数来生成所有的由n对括号组成的合法组合。</p>
<p>例如，给出n=3，解集为： </p>
<p>“((()))”, “(()())”, “(())()”, “()()()”, “()(())”</p>
<p>数据范围：0≤n≤10</p>
<p>要求：空间复杂度 O(n!)，时间复杂度 O(n!)</p>
<h3 id="题解-66"><a href="#题解-66" class="headerlink" title="题解"></a>题解</h3><p>对于每次选择，只有如下几种情况，若是左括号仍有剩余就可以放左括号，但只有当左括号有剩余的同时左括号数量比右括号多才能放右括号，明白了合法性的原理之后只需要递归回溯即可。</p>
<h3 id="Java代码实现-65"><a href="#Java代码实现-65" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串ArrayList</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">generateParenthesis</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 用于保存结果的数组</span></span><br><span class="line">        ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        traceBack(res, n, sb, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里left和right分别是左括号数和右括号数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traceBack</span><span class="params">(ArrayList&lt;String&gt; res, <span class="keyword">int</span> n, StringBuilder sb, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 递归退出条件</span></span><br><span class="line">        <span class="keyword">if</span>(left == n &amp;&amp; right == n)&#123;</span><br><span class="line">            <span class="comment">// 先进行合法性判断</span></span><br><span class="line">            <span class="keyword">if</span>(!res.contains(sb.toString()))</span><br><span class="line">                res.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只要还有左括号就可以一直放</span></span><br><span class="line">        <span class="keyword">if</span>(left &lt; n)&#123;</span><br><span class="line">            sb.append(<span class="string">"("</span>);</span><br><span class="line">            traceBack(res, n, sb, left + <span class="number">1</span>, right);</span><br><span class="line">            <span class="comment">// 记得把放入的元素删除</span></span><br><span class="line">            sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右括号只有在剩余以及左括号数量比右括号数量多时才能放</span></span><br><span class="line">        <span class="keyword">if</span>(right &lt; n &amp;&amp; left &gt; right)&#123;</span><br><span class="line">            sb.append(<span class="string">")"</span>);</span><br><span class="line">            traceBack(res, n, sb, left, right + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 记得把放入的元素删除</span></span><br><span class="line">            sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM61-矩阵最长递增路径"><a href="#BM61-矩阵最长递增路径" class="headerlink" title="BM61 矩阵最长递增路径"></a>BM61 <a href="https://www.nowcoder.com/practice/7a71a88cdf294ce6bdf54c899be967a2?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">矩阵最长递增路径</a></h2><h3 id="题目描述-59"><a href="#题目描述-59" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个 n 行 m 列矩阵 matrix ，矩阵内所有数均为非负整数。 你需要在矩阵中找到一条最长路径，使这条路径上的元素是递增的。并输出这条最长路径的长度。 </p>
<p>这个路径必须满足以下条件：</p>
<ol>
<li><p>对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外。</p>
</li>
<li><p>你不能走重复的单元格。即每个格子最多只能走一次。</p>
</li>
</ol>
<p>数据范围：1≤n,m≤1000，0≤matrix[i][j]≤1000</p>
<p>进阶：空间复杂度 O(nm) ，时间复杂度 O(nm)</p>
<p>例如：当输入为[[1,2,3],[4,5,6],[7,8,9]]时，对应的输出为5， </p>
<p>其中的一条最长递增路径如下图所示： </p>
<p><img src="https://uploadfiles.nowcoder.com/images/20211201/423483716_1638350164758/A6B05D015D3BE3C77C34DDF224044A1F" alt="img"></p>
<h3 id="题解-67"><a href="#题解-67" class="headerlink" title="题解"></a>题解</h3><p>遍历所有值，每次判断是否更新最大长度，继续走（继续走的前提是下一个节点可以走），可以规定先向右走，再向上走，之后向左走，最后向下走。</p>
<h3 id="Java代码实现-66"><a href="#Java代码实现-66" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     * 递增路径的最大长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> matrix int整型二维数组 描述矩阵的每个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 数组n行m列</span></span><br><span class="line">    <span class="keyword">int</span> m,n;</span><br><span class="line">    <span class="comment">// 该往哪走</span></span><br><span class="line">    <span class="keyword">int</span>[][] directions = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span> <span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        n = matrix.length;</span><br><span class="line">        m = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// 对每个元素dfs</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)&#123;</span><br><span class="line">                solveRec(i, j, <span class="number">0</span>, matrix);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">solveRec</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> len, <span class="keyword">int</span>[][] matrix)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 大于就更新全局变量</span></span><br><span class="line">        <span class="comment">// 这里已经将len自增1了</span></span><br><span class="line">        <span class="keyword">if</span>(++len &gt; max)&#123;</span><br><span class="line">            max = len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] dir : directions)&#123;</span><br><span class="line">            <span class="comment">// 看下一个dfs的横纵坐标</span></span><br><span class="line">            <span class="keyword">int</span> rowNext = i + dir[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> colNext = j + dir[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 坐标不符合</span></span><br><span class="line">            <span class="keyword">if</span>(rowNext &lt; <span class="number">0</span> || rowNext &gt;= n || colNext &lt; <span class="number">0</span> || colNext &gt;= m)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 值不符合</span></span><br><span class="line">            <span class="keyword">if</span>(matrix[rowNext][colNext] &lt;= matrix[i][j])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            solveRec(rowNext, colNext, len, matrix);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="BM62-斐波那契数列"><a href="#BM62-斐波那契数列" class="headerlink" title="BM62 斐波那契数列"></a>BM62 <a href="https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">斐波那契数列</a></h2><h3 id="题目描述-60"><a href="#题目描述-60" class="headerlink" title="题目描述"></a>题目描述</h3><p>大家都知道斐波那契数列，现在要求输入一个正整数 n ，请你输出斐波那契数列的第 n 项。 </p>
<p>斐波那契数列是一个满足 fib(x)={1x=1,2fib(x−1)+fib(x−2)x&gt;2<em>f<strong>i</strong>b</em>(<em>x</em>)={1<em>f<strong>i</strong>b</em>(<em>x</em>−1)+<em>f<strong>i</strong>b</em>(<em>x</em>−2)<em>x</em>=1,2<em>x</em>&gt;2 的数列 </p>
<p>数据范围：1≤n≤40</p>
<p>要求：空间复杂度 O(1)，时间复杂度 O(n)，本题也有时间复杂度 O(logn)的解法 </p>
<h4 id="输入描述：-3"><a href="#输入描述：-3" class="headerlink" title="输入描述："></a>输入描述：</h4><p>一个正整数n</p>
<h4 id="返回值描述：-3"><a href="#返回值描述：-3" class="headerlink" title="返回值描述："></a>返回值描述：</h4><p>输出一个正整数。</p>
<h3 id="题解-68"><a href="#题解-68" class="headerlink" title="题解"></a>题解</h3><p>初始化一个用于保存斐波那契数列前n项和的数组，每次求下一个值时只需将前面的值拿出计算即可。也可使用递归函数进行实现。</p>
<h3 id="Java代码实现-67"><a href="#Java代码实现-67" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ublic <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Fibonacci(n - <span class="number">1</span>) + Fibonacci(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但通过此方法，时间复杂度其实已经不是O(n)，这里可以考虑使用动态规划来优化时间。</p>
<h3 id="题解-69"><a href="#题解-69" class="headerlink" title="题解"></a>题解</h3><p>动态规划的核心思想是将大问题分解为小问题解决并保存结果，之后大问题的解决依赖于小问题的解。</p>
<h3 id="Java代码实现-68"><a href="#Java代码实现-68" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 这里dp[2]其实也等于0 +1 = 1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用动态规划的空间压缩技巧（发现这里其实并不需要一整个数组，只需要三个变量分别保存当前元素以及当前元素之前的两个元素即可），空间压缩后代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pre1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> pre2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            cur = pre1 + pre2;</span><br><span class="line">            pre2 = pre1;</span><br><span class="line">            pre1 = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>空间压缩技巧实际上就是将一组数据不断后移，若是一维动态规划，这组数据是有限的几个变量，若是二维动态规划，这组数据是一个数组。</p>
<p><strong>对于O(logn)的算法，涉及到矩阵的运算，可以参考网上的一些博客。</strong></p>
<h2 id="BM63-跳台阶"><a href="#BM63-跳台阶" class="headerlink" title="BM63 跳台阶"></a>BM63 <a href="https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">跳台阶</a></h2><h3 id="题目描述-61"><a href="#题目描述-61" class="headerlink" title="题目描述"></a>题目描述</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 </p>
<p>数据范围：1≤n≤40</p>
<p>要求：时间复杂度：O(n) ，空间复杂度： O(1)</p>
<h3 id="题解-70"><a href="#题解-70" class="headerlink" title="题解"></a>题解</h3><p>这题也是动态规划的典型题目，青蛙每次可以选择跳一阶台阶或是两阶台阶，那么对于第n阶，跳法一共有f(n) = f(n - 2) + f(n - 1)（跳到n - 1阶或是n - 2阶），和斐波那契数列一致，至于题目要求O(1)的空间复杂度，那就进行一维动态规划的空间压缩即可。</p>
<h3 id="Java代码实现-69"><a href="#Java代码实现-69" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 上0阶台阶有0种上法</span></span><br><span class="line">        <span class="keyword">int</span> pre0 = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 上一阶台阶只有一种上法</span></span><br><span class="line">        <span class="keyword">int</span> pre1 = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 当前有几种上法</span></span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= target; ++i)&#123;</span><br><span class="line">            cur = pre1 + pre0;</span><br><span class="line">            pre0 = pre1;</span><br><span class="line">            pre1 = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM64-最小花费爬楼梯"><a href="#BM64-最小花费爬楼梯" class="headerlink" title="BM64 最小花费爬楼梯"></a>BM64 <a href="https://www.nowcoder.com/practice/6fe0302a058a4e4a834ee44af88435c7?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">最小花费爬楼梯</a></h2><h3 id="题目描述-62"><a href="#题目描述-62" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个整数数组 cost，其中 cost[i]是从楼梯第i个台阶向上爬需要支付的费用，下标从0开始。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p>
<p>你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。</p>
<p>请你计算并返回达到楼梯顶部的最低花费。<br>数据范围：数组长度满足 1≤n≤10^5，数组中的值满足 1≤costi≤10^4</p>
<h3 id="题解-71"><a href="#题解-71" class="headerlink" title="题解"></a>题解</h3><p>根据题目描述，很容易想到第n层的话费其实是f(n) = min(cost[n - 3] + f(n - 2), cost[n - 3] + f(n - 1))，因此直接动态规划求解并压缩空间即可</p>
<h3 id="Java代码实现-70"><a href="#Java代码实现-70" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cost int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs</span> <span class="params">(<span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 第0阶的花费</span></span><br><span class="line">        <span class="keyword">int</span> pre0 = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 第一阶的花费</span></span><br><span class="line">        <span class="keyword">int</span> pre1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= cost.length; ++i)&#123;</span><br><span class="line">            <span class="comment">// 本次爬楼梯的花费可以选择两阶前的花费（这次爬两阶）加上爬到两阶前的花费</span></span><br><span class="line">            <span class="comment">// 或者是一阶前的花费（这次爬一阶）加上爬到一阶前的花费</span></span><br><span class="line">            <span class="comment">// 然后二者取最小值</span></span><br><span class="line">            cur = Math.min(pre0 + cost[i - <span class="number">2</span>], pre1 + cost[i - <span class="number">1</span>]);</span><br><span class="line">            pre0 = pre1;</span><br><span class="line">            pre1 = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM65-最长公共子序列（二）"><a href="#BM65-最长公共子序列（二）" class="headerlink" title="BM65 最长公共子序列（二）"></a>BM65 <a href="https://www.nowcoder.com/practice/6d29638c85bb4ffd80c020fe244baf11?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">最长公共子序列（二）</a></h2><h3 id="题目描述-63"><a href="#题目描述-63" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定两个字符串str1和str2，输出两个字符串的最长公共子序列。如果最长公共子序列为空，则返回”-1”。目前给出的数据，仅仅会存在一个最长的公共子序列</p>
<p>数据范围：0≤∣str1∣,∣str2∣≤2000</p>
<p>要求：空间复杂度 O(n^2) ，时间复杂度 O(n^2)</p>
<h3 id="题解-72"><a href="#题解-72" class="headerlink" title="题解"></a>题解</h3><p>假定字符串str1和str2的长度分别为n1和n2，那么令dp[i] [j]表示前str1的前i个字符到str2的前j个字符到最长公共子序列，那么当str1.charAt(i - 1) == str2.charAt(j - 1)时dp[i] [j] = dp[i - 1] [j - 1] + 1；不等时dp[i] [j] = max(dp[i - 1] [j], dp[i] [j - 1])，如此就能找到最大子序列的长度，由于需要最长公共子序列字符串，所以这里从后往前遍历（从前往后遍历可能会出现需要跳过此相同值的情况），若是两个字符相等，就将其加到字符串上，若是两个字符不相等，那么判断后移左指针还是后移右指针能获得最大收益（判断哪个dp大），一直往收益大的地方走即能找到最优解。</p>
<h3 id="Java代码实现-71"><a href="#Java代码实现-71" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * longest common subsequence</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s1 string字符串 the string</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s2 string字符串 the string</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">LCS</span> <span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(s1.equals(<span class="string">""</span>) || s2.equals(<span class="string">""</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"-1"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> str1[] = s1.toCharArray();</span><br><span class="line">        <span class="keyword">char</span> str2[] = s2.toCharArray();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> n1 = str1.length;</span><br><span class="line">        <span class="keyword">int</span> n2 = str2.length;</span><br><span class="line">        String[][] res = <span class="keyword">new</span> String[n1 + <span class="number">1</span>][n2 + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// dp[i][j]表示str1的前i个字符以及str2的前j个字符中最长子序列的长度</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n1 + <span class="number">1</span>][n2 + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 先初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n1; ++i)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            res[i][<span class="number">0</span>] = <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n2; ++i)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">            res[<span class="number">0</span>][i] = <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 之后依次遍历填充dp数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n2; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(str1[i - <span class="number">1</span>] == str2[j - <span class="number">1</span>])&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 填充好数组之后从后往前遍历找到最长公共子序列</span></span><br><span class="line">        <span class="keyword">int</span> cur1 = n1;</span><br><span class="line">        <span class="keyword">int</span> cur2 = n2;</span><br><span class="line">        <span class="comment">// 结果的保存</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span>(cur1 != <span class="number">0</span> &amp;&amp; cur2 != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 若是两者相等则证明是公共序列直接加到sb中，因为是从后往前走，所以此时不需要判断是否跳过</span></span><br><span class="line">            <span class="keyword">if</span>(str1[cur1 - <span class="number">1</span>] == str2[cur2 - <span class="number">1</span>])&#123;</span><br><span class="line">                sb.append(str1[cur1 - <span class="number">1</span>]);</span><br><span class="line">                --cur2;</span><br><span class="line">                --cur1;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 此时两个下标所在的字符不相等</span></span><br><span class="line">                <span class="keyword">if</span>(dp[cur1 - <span class="number">1</span>][cur2] &lt; dp[cur1][cur2 - <span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="comment">// 此时表示左移指针2能得到不差的解</span></span><br><span class="line">                    --cur2;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    --cur1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 看是否是空</span></span><br><span class="line">        <span class="keyword">if</span>(sb.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"-1"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为是从后往前的，因此记得反转</span></span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM66-最长公共子串"><a href="#BM66-最长公共子串" class="headerlink" title="BM66 最长公共子串"></a>BM66 <a href="https://www.nowcoder.com/practice/f33f5adc55f444baa0e0ca87ad8a6aac?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">最长公共子串</a></h2><h3 id="题目描述-64"><a href="#题目描述-64" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定两个字符串str1和str2,输出两个字符串的最长公共子串</p>
<p>题目保证str1和str2的最长公共子串存在且唯一。 </p>
<p>数据范围： 1≤∣str1∣,∣str2∣≤5000<br>要求： 空间复杂度 O(n^2)，时间复杂度 O(n^2)</p>
<h3 id="题解-73"><a href="#题解-73" class="headerlink" title="题解"></a>题解</h3><p>判断最长子串问题，其实就是二维动态规划问题，考虑用dp[i] [j]表示str1前i个字符和str2前j个字符的最长公共子串（这里必须要以str1.charAt(i - 1)结尾），那么状态转移方程即为：dp[i] [j] = dp[i - 1] [j - 1] + 1（当str1.charAt(i - 1) == str2.charAt(j - 1)时），dp[i] [j] = 0，之后就是已知最大子串的长度求最大子串，也可以直接在遍历的过程中存储最长子串。</p>
<h3 id="Java代码实现-72"><a href="#Java代码实现-72" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * longest common substring</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str1 string字符串 the string</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str2 string字符串 the string</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">LCS</span> <span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">char</span>[] chars1 = str1.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] chars2 = str2.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> n1 = chars1.length;</span><br><span class="line">        <span class="keyword">int</span> n2 = chars2.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n1 + <span class="number">1</span>][n2 + <span class="number">1</span>];</span><br><span class="line">        String[][] res = <span class="keyword">new</span> String[n1 + <span class="number">1</span>][n2 + <span class="number">1</span>];</span><br><span class="line">        String max = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n1; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n2; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                    res[i][j] = <span class="string">""</span>;</span><br><span class="line">                    <span class="comment">// 这些肯定不是最长子串无需判断</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(chars1[i - <span class="number">1</span>] == chars2[j - <span class="number">1</span>])&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    res[i][j] = res[i - <span class="number">1</span>][j - <span class="number">1</span>] + chars1[i - <span class="number">1</span>];</span><br><span class="line">                    <span class="comment">// 这里若是增加的话有可能是最长子串</span></span><br><span class="line">                    <span class="keyword">if</span>(dp[i][j] &gt; max.length())&#123;</span><br><span class="line">                        max = res[i][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                    res[i][j] = <span class="string">""</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * longest common substring</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str1 string字符串 the string</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str2 string字符串 the string</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">LCS</span> <span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">char</span>[] chars1 = str1.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] chars2 = str2.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> n1 = chars1.length;</span><br><span class="line">        <span class="keyword">int</span> n2 = chars2.length;</span><br><span class="line">        String[][] res = <span class="keyword">new</span> String[n1 + <span class="number">1</span>][n2 + <span class="number">1</span>];</span><br><span class="line">        String max = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n1; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n2; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>)&#123;</span><br><span class="line">                    res[i][j] = <span class="string">""</span>;</span><br><span class="line">                    <span class="comment">// 这些肯定不是最长子串无需判断</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(chars1[i - <span class="number">1</span>] == chars2[j - <span class="number">1</span>])&#123;</span><br><span class="line">                    res[i][j] = res[i - <span class="number">1</span>][j - <span class="number">1</span>] + chars1[i - <span class="number">1</span>];</span><br><span class="line">                    <span class="comment">// 这里若是增加的话有可能是最长子串</span></span><br><span class="line">                    <span class="keyword">if</span>(res[i][j].length() &gt; max.length())&#123;</span><br><span class="line">                        max = res[i][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    res[i][j] = <span class="string">""</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM67-不同路径的数目（一）"><a href="#BM67-不同路径的数目（一）" class="headerlink" title="BM67 不同路径的数目（一）"></a>BM67 <a href="https://www.nowcoder.com/practice/166eaff8439d4cd898e3ba933fbc6358?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">不同路径的数目（一）</a></h2><h3 id="题目描述-65"><a href="#题目描述-65" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个机器人在m×n大小的地图的左上角（起点）。 </p>
<p>机器人每次可以向下或向右移动。机器人要到达地图的右下角（终点）。</p>
<p>可以有多少种不同的路径从起点走到终点？ </p>
<p><img src="https://uploadfiles.nowcoder.com/images/20201210/999991351_1607596327517/873CB1F2327F70DA0CA0FDC797F894A7" alt="img"></p>
<p>备注：m和n小于等于100,并保证计算结果在int范围内 </p>
<p>数据范围：0&lt;n,m≤100，保证计算结果在32位整型范围内 </p>
<p>要求：空间复杂度 O(nm)，时间复杂度 O(nm)</p>
<p>进阶：空间复杂度 O(1)，时间复杂度 O(min(n,m))</p>
<h3 id="题解-74"><a href="#题解-74" class="headerlink" title="题解"></a>题解</h3><p>对于其中任何一个点来说，到达这个点的路径即为到达其左侧点的路径加上到达其上方点的路径。</p>
<h3 id="Java代码实现-73"><a href="#Java代码实现-73" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span> <span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时时间复杂度和空间复杂度都是O(nm)达到了要求但不满足进阶要求，进阶要求需要空间复杂度为O(1)，时间复杂度为O(min(n, m))。</p>
<h3 id="题解-75"><a href="#题解-75" class="headerlink" title="题解"></a>题解</h3><p>考虑到达位置(m, n)实际上就是先向右走n-1格，再向下走m - 1格，一共需要走m + n - 2格，其实就是从 m + n - 2格中选出向右n - 1格，就是一个组合问题，直接求解组合数即可。</p>
<h3 id="Java代码实现-74"><a href="#Java代码实现-74" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span> <span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = n, y = <span class="number">1</span>; y &lt; m; ++x, ++y)&#123;</span><br><span class="line">            res = res * x / y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM68-矩阵的最小路径和"><a href="#BM68-矩阵的最小路径和" class="headerlink" title="BM68 矩阵的最小路径和"></a>BM68 <a href="https://www.nowcoder.com/practice/7d21b6be4c6b429bb92d219341c4f8bb?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">矩阵的最小路径和</a></h2><h3 id="题目描述-66"><a href="#题目描述-66" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个 n * m 的矩阵 a，从左上角开始每次只能向右或者向下走，最后到达右下角的位置，路径上所有的数字累加起来就是路径和，输出所有的路径中最小的路径和。</p>
<p>数据范围: 1≤n,m≤500，矩阵中任意值都满足 0≤ai,j≤100</p>
<p>要求：时间复杂度 O(nm)</p>
<p>例如：当输入[[1,3,5,9],[8,1,3,4],[5,0,6,1],[8,8,4,0]]时，对应的返回值为12， </p>
<p>所选择的最小累加和路径如下图所示： </p>
<p><img src="https://uploadfiles.nowcoder.com/images/20220122/423483716_1642823916509/06EB123C153852AF55ED51448BEAD1BA" alt="img"></p>
<h3 id="题解-76"><a href="#题解-76" class="headerlink" title="题解"></a>题解</h3><p>对于任意一个位置，其可以由两个位置到达，其正上方或是其正左方，因此到达这个位置的最小路径就是其正上方的路径和跟其正左方的路径和的最小值再加上当前位置的值。</p>
<h3 id="Java代码实现-75"><a href="#Java代码实现-75" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> matrix int整型二维数组 the matrix</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span> <span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="comment">// 先初始化</span></span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="comment">// dp[0][0] = matrix[0][0];</span></span><br><span class="line">                        dp[i][j] = matrix[i][j];</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="comment">// 第一行就是左边总的加上现在的</span></span><br><span class="line">                        dp[i][j] = dp[i][j - <span class="number">1</span>] + matrix[i][j];</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">// 第一列就是上边总的加上现在的</span></span><br><span class="line">                        dp[i][j] = dp[i - <span class="number">1</span>][j] + matrix[i][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 当前的格子就是左边总的和上边总的两者取最小再加上现在的</span></span><br><span class="line">                dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + matrix[i][j]; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM69-把数字翻译成字符串"><a href="#BM69-把数字翻译成字符串" class="headerlink" title="BM69 把数字翻译成字符串"></a>BM69 <a href="https://www.nowcoder.com/practice/046a55e6cd274cffb88fc32dba695668?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">把数字翻译成字符串</a></h2><h3 id="题目描述-67"><a href="#题目描述-67" class="headerlink" title="题目描述"></a>题目描述</h3><p>有一种将字母编码成数字的方式：’a’-&gt;1, ‘b-&gt;2’, … , ‘z-&gt;26’。 </p>
<p>现在给一串数字，返回有多少种可能的译码结果</p>
<p>数据范围：字符串长度满足 0&lt;n≤90</p>
<p>进阶：空间复杂度 O(n)，时间复杂度 O(n)</p>
<h3 id="题解-77"><a href="#题解-77" class="headerlink" title="题解"></a>题解</h3><p>考虑使用动态规划求解此问题，那么当这个元素的值小于7且上一个元素小于3时可以和前面的值结合为一个字母（如26可解析为z），若是前一个数字为1，那么这个数可以是0-9的任意数（16可以解析为p），也可以这个字母单独求解，若是不满足以上任意一个条件，那么就只能单独解析为0-9的一个字母。综上，设dp[i]表示前i个字母可能的译码结果，对于任意一个字符，若是其上一个字符为1，那么不管这个字符是几，都会有dp[i] = dp[i - 1] + dp[i - 2]；其中dp[i - 1]是前i - 1个字符可能的结果（把这个字符单独解析为0 - 9），dp[i - 2]则是前 i - 2个字符可能的结果；此外若是其上一个字符小于3且这一个字符小于6，那么也可以和前一个字符解析，也是dp[i] = dp[i - 1] + dp[i - 2]，否则dp[i] = dp[i - 1]。</p>
<h3 id="Java代码实现-76"><a href="#Java代码实现-76" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums string字符串 数字串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span> <span class="params">(String nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 长度不合法或是存在前导0</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length() == <span class="number">0</span> || nums.charAt(<span class="number">0</span>) == <span class="string">'0'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length()];</span><br><span class="line">        <span class="comment">// 第一个字符只有一种解析方式</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.length; i++)&#123;</span><br><span class="line">            <span class="comment">// 若不是0，那肯定能自己解析，先加上</span></span><br><span class="line">            <span class="keyword">if</span>(nums.charAt(i) != <span class="string">'0'</span>)&#123;</span><br><span class="line">                dp[i] = dp[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 看是否能和前面的一起解析</span></span><br><span class="line">            <span class="keyword">int</span> num = (nums.charAt(i-<span class="number">1</span>)-<span class="string">'0'</span>)*<span class="number">10</span> + (nums.charAt(i)-<span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">if</span>(num &gt;= <span class="number">10</span> &amp;&amp; num &lt;= <span class="number">26</span>)&#123;</span><br><span class="line">                <span class="comment">// 此时能和前面的解析</span></span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">// 若是第一个的话就加一（没有dp[-1]，或者假设dp[-1] = 1）</span></span><br><span class="line">                    dp[i] += <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 反之加上dp[-1]即可</span></span><br><span class="line">                    dp[i] += dp[i-<span class="number">2</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.length()-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里一开始我写了一种<strong>错误代码</strong>但未找到原因，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums string字符串 数字串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span> <span class="params">(String nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 特殊情况优先考虑</span></span><br><span class="line">        <span class="keyword">if</span>(nums.equals(<span class="string">"0"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] str = nums.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> n = str.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 0个字符有一种解法</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 1个字符有一种解法</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="comment">// 有不合法的0</span></span><br><span class="line">            <span class="keyword">if</span>((str[i - <span class="number">2</span>] == <span class="string">'0'</span> || str[i - <span class="number">2</span>] - <span class="string">'0'</span> &gt; <span class="number">2</span>) &amp;&amp; str[i - <span class="number">1</span>] == <span class="string">'0'</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 有合法的0，0只能和前面的一起解析</span></span><br><span class="line">            <span class="keyword">if</span>(str[i - <span class="number">1</span>] == <span class="string">'0'</span>)&#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">2</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[i - <span class="number">2</span>] == <span class="string">'1'</span> || str[i - <span class="number">2</span>] - <span class="string">'0'</span> &lt; <span class="number">3</span> &amp;&amp; str[i - <span class="number">1</span>] - <span class="string">'0'</span> &lt; <span class="number">7</span>)&#123;</span><br><span class="line">                <span class="comment">// 此时能和前面的一起解析</span></span><br><span class="line">                dp[i] = dp[i - <span class="number">2</span>] + dp[i - <span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 否则只能自己解析</span></span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM70-兑换零钱（一）"><a href="#BM70-兑换零钱（一）" class="headerlink" title="BM70 兑换零钱（一）"></a>BM70 <a href="https://www.nowcoder.com/practice/3911a20b3f8743058214ceaa099eeb45?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">兑换零钱（一）</a></h2><h3 id="题目描述-68"><a href="#题目描述-68" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定数组arr，arr中所有的值都为正整数且不重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，再给定一个aim，代表要找的钱数，求组成aim的最少货币数。</p>
<p>如果无解，请返回-1.</p>
<p>数据范围：数组大小满足 0≤n≤10000， 数组中每个数字都满足 0&lt;val≤10000，0≤aim≤5000</p>
<p>要求：时间复杂度 O(n×aim)，空间复杂度 O(aim)。</p>
<h3 id="题解-78"><a href="#题解-78" class="headerlink" title="题解"></a>题解</h3><p>设dp[i]为组成i的最少货币数，那么对于数组中的每个数j，dp[i] += dp[i - j]，当货币数比最小值小时为0。</p>
<h3 id="Java代码实现-77"><a href="#Java代码实现-77" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最少货币数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr int整型一维数组 the array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> aim int整型 the target</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMoney</span> <span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> aim)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(aim == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里需要一个标记，但是不能用Integer.MAX_VALUE，因为+1后会变为负数导致min函数能取到</span></span><br><span class="line">        <span class="keyword">int</span> max = aim + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[aim + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 初始值全为最大值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= aim; ++i)&#123;</span><br><span class="line">            dp[i] = max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找0种钱一共需要0张钱</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= aim; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> currency : arr)&#123;</span><br><span class="line">                <span class="comment">// 只有货币面值小于等于需要找的钱时才有可能能找钱</span></span><br><span class="line">                <span class="keyword">if</span>(currency &lt;= i)&#123;</span><br><span class="line">                    <span class="comment">// 就是当前值和i - currency + 1的最小值（加一是因为要增加一张cureency）</span></span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[i - currency] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 大于aim（max = aim + 1，初始不能补的值）</span></span><br><span class="line">        <span class="keyword">return</span> dp[aim] &gt; aim ? -<span class="number">1</span> : dp[aim];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM71-最长上升子序列（一）"><a href="#BM71-最长上升子序列（一）" class="headerlink" title="BM71 最长上升子序列（一）"></a>BM71 <a href="https://www.nowcoder.com/practice/5164f38b67f846fb8699e9352695cd2f?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">最长上升子序列（一）</a></h2><h3 id="题目描述-69"><a href="#题目描述-69" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个长度为 n 的数组 arr，求它的最长严格上升子序列的长度。 </p>
<p>所谓子序列，指一个数组删掉一些数（也可以不删）之后，形成的新数组。例如 [1,5,3,7,3] 数组，其子序列有：[1,3,3]、[7] 等。但 [1,6]、[1,3,5] 则不是它的子序列。 </p>
<p>我们定义一个序列是 <strong>严格上升</strong> 的，当且仅当该序列<strong>不存在</strong>两个下标 i和 j满足 i&lt;j且 arri≥arrj。</p>
<p>数据范围： 0≤n≤1000</p>
<p>要求：时间复杂度 O(n^2)， 空间复杂度 O(n)</p>
<h3 id="题解-79"><a href="#题解-79" class="headerlink" title="题解"></a>题解</h3><p>使用dp[i]表示前i个字符以i结尾的字序列长度，至于状态转移方程，dp[i] = max(dp[j] + 1, dp[i])，这里dp[i]初始值为0同时num[j]必须小于num[i]同时j &lt; i，即：当前的最长上升子序列是前i - 1个字符最长上升子序列中最大的那个加1（前提是满足上升条件，即只能在小于当前值的值中取最大值），若是没有则初始值为1。</p>
<h3 id="Java代码实现-78"><a href="#Java代码实现-78" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 给定数组的最长严格上升子序列的长度。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr int整型一维数组 给定的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LIS</span> <span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(arr.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(arr.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        <span class="comment">// 用1填充</span></span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j)&#123;</span><br><span class="line">                <span class="comment">// 这里是上升子序列因此不能取=</span></span><br><span class="line">                <span class="keyword">if</span>(arr[j] &lt; arr[i])&#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后需要遍历一次找到最大值（最后一个不一定是最大的，最后一个只是以最后一个数为尾的最长上升字序列）</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(dp).max().getAsInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM72-连续子数组的最大和"><a href="#BM72-连续子数组的最大和" class="headerlink" title="BM72 连续子数组的最大和"></a>BM72 <a href="https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">连续子数组的最大和</a></h2><h3 id="题目描述-70"><a href="#题目描述-70" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个长度为n的整型数组array，数组中的一个或连续多个整数组成一个子数组，子数组最小长度为1。求所有子数组的和的最大值。 </p>
<p>数据范围: </p>
<p>1&lt;=n&lt;=2×10^5</p>
<p>−100&lt;=a[i]&lt;=100</p>
<p>要求:时间复杂度为 O(n)，空间复杂度为 O(n)</p>
<p>进阶:时间复杂度为 O(n)，空间复杂度为 O(1)</p>
<h3 id="题解-80"><a href="#题解-80" class="headerlink" title="题解"></a>题解</h3><p>用dp[i]表示以i结尾的子数组的和，那么若是这个数大于0，那么放入就完全没有影响，直接增大即可，若是这个数是负数就需要考虑，若是当前的数字大于以第i - 1个数字结尾的子数组的和，那么这个就能放入。</p>
<h3 id="Java代码实现-79"><a href="#Java代码实现-79" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = array.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 以第0个字符结尾的子数组不存在，值为0</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">1</span>] + array[i - <span class="number">1</span>], array[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            max = Math.max(max, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM73-最长回文子串"><a href="#BM73-最长回文子串" class="headerlink" title="BM73 最长回文子串"></a>BM73 <a href="https://www.nowcoder.com/practice/b4525d1d84934cf280439aeecc36f4af?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">最长回文子串</a></h2><h3 id="题目描述-71"><a href="#题目描述-71" class="headerlink" title="题目描述"></a>题目描述</h3><p>对于长度为n的一个字符串A（仅包含数字，大小写英文字母），请设计一个高效算法，计算其中最长回文子串的长度。 </p>
<p>数据范围： 1≤n≤1000</p>
<p>要求：空间复杂度 O(1)，时间复杂度 O(n^2)</p>
<p>进阶: 空间复杂度 O(n)，时间复杂度 O(n)</p>
<h3 id="题解-81"><a href="#题解-81" class="headerlink" title="题解"></a>题解</h3><p>首先是暴力解法，两个循环判断从i到j的子串是否是回文子串，若是返回其长度，同时更新最长回文子串长度，若不是则返回1。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> A string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLongestPalindrome</span> <span class="params">(String A)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> n = A.length();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j)&#123;</span><br><span class="line">                String cur = A.substring(i, j);</span><br><span class="line">                <span class="keyword">if</span>(isPalSubString(cur))&#123;</span><br><span class="line">                    max = Math.max(max, cur.length());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalSubString</span><span class="params">(String cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] str = cur.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> n = str.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] != str[n - i - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但此时时间复杂度过高，考虑题目中要求的时间复杂度O(n^2)或是O(n)。</p>
<h3 id="题解-82"><a href="#题解-82" class="headerlink" title="题解"></a>题解</h3><p>若是已知子串(i, j)不为回文串，那么即使str[i - 1] == str[j + 1]也构不成回文串，同时若是str[i - 1] != str[j + 1]，那么必然构成不了回文串。，由此可以将其转化为动态规划。</p>
<h3 id="Java代码实现-80"><a href="#Java代码实现-80" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> A string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLongestPalindrome</span> <span class="params">(String A)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> n = A.length();</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 保存最大长度</span></span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="comment">// 保存从i到j的子串能否构成回文串</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">        <span class="keyword">char</span>[] str = A.toCharArray();</span><br><span class="line">        <span class="comment">// 这里为啥先right后left呢，因为left需要由right约束</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> right = <span class="number">1</span>; right &lt; n; ++right)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> left = <span class="number">0</span>; left &lt;= right; ++left)&#123;</span><br><span class="line">                <span class="comment">// 此时两者无法构成回文串</span></span><br><span class="line">                <span class="keyword">if</span>(str[left] != str[right])&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 此时两者有可能能构成回文串</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 子串长度(right - left + 1)小于4，"a", "aa", "aba"，必是回文串</span></span><br><span class="line">                <span class="keyword">if</span>(right - left &lt; <span class="number">3</span>)&#123;</span><br><span class="line">                    dp[left][right] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 此时子串长度大于三，那么就看前面的是否是回文串</span></span><br><span class="line">                    dp[left][right] = dp[left + <span class="number">1</span>][right - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> len = right - left + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 若是构成了回文子串则判断是否更新长度</span></span><br><span class="line">                <span class="keyword">if</span>(dp[left][right] &amp;&amp; len &gt; max)&#123;</span><br><span class="line">                    max = len;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>两个for循环中先right再left的原因是保证更新dp[left] [right]时用到的dp[left + 1] [right - 1]在之前已经求出。先循环left的话其实left + 1是全部项都没有求出的，但是先right那么right - 1的全部项都已经被求出了</strong></p>
<h3 id="题解-83"><a href="#题解-83" class="headerlink" title="题解"></a>题解</h3><p>可以采用中心扩散的方法，对于任意一个点，使用两个指针向其两边扩散，若是两个指针所指的值相同就继续扩散直到到达了数组的一端或者是两个指针的数值不同了，输出此时的长度判断是否需要更新最大长度即可，这里存在一个问题就是若是以当前数值和其后一个数字共同作为子串的中心（后一个数值与当前的相等），那么就以两个为中心再次判断最长回文串一次，最终输出两种不同方式所得的回文串长度，取其大值即可。</p>
<h3 id="Java代码实现-81"><a href="#Java代码实现-81" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> A string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLongestPalindrome</span> <span class="params">(String A)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> n = A.length();</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] str = A.toCharArray();</span><br><span class="line">        <span class="comment">// 保存最大长度</span></span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="comment">// 以当前元素为中心的回文串长度</span></span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 此时才需要判断是否和后一个是回文串(最后一个元素没有后一个元素)</span></span><br><span class="line">            <span class="keyword">if</span>(i &lt; n - <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 若是此字符和后一个字符相等</span></span><br><span class="line">                <span class="keyword">if</span>(str[i] == str[i + <span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="comment">// 计算出奇数串的长度</span></span><br><span class="line">                    <span class="keyword">int</span> len1 = cal(str, i, i);</span><br><span class="line">                    <span class="comment">// 计算出偶数串的长度</span></span><br><span class="line">                    <span class="keyword">int</span> len2 = cal(str, i, i + <span class="number">1</span>);</span><br><span class="line">                    len = len1 &gt; len2 ? len1 : len2;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 若是不等</span></span><br><span class="line">                    len = cal(str, i, i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这里为啥没有else呢，因为此时只有最后一个字符了，那么其回文串长度只可能是1（初始值）</span></span><br><span class="line">            <span class="keyword">if</span>(len &gt; max)&#123;</span><br><span class="line">                max = len;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算以left right为中心的回文串长度</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt; str.length)&#123;</span><br><span class="line">            <span class="comment">// 相等了继续判断</span></span><br><span class="line">            <span class="keyword">if</span>(str[left] == str[right])&#123;</span><br><span class="line">                ++right;</span><br><span class="line">                --left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 否则就退出循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时leftright已经不相等了，那么left + 1和right - 1才相等</span></span><br><span class="line">        <span class="comment">// 长度是(right - 1) - (left + 1) + 1</span></span><br><span class="line">        <span class="keyword">return</span> right - left - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM74-数字字符串转化成IP地址"><a href="#BM74-数字字符串转化成IP地址" class="headerlink" title="BM74 数字字符串转化成IP地址"></a>BM74 <a href="https://www.nowcoder.com/practice/ce73540d47374dbe85b3125f57727e1e?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">数字字符串转化成IP地址</a></h2><h3 id="题目描述-72"><a href="#题目描述-72" class="headerlink" title="题目描述"></a>题目描述</h3><p>现在有一个只包含数字的字符串，将该字符串转化成IP地址的形式，返回所有可能的情况。</p>
<p>例如：</p>
<p>给出的字符串为”25525522135”,</p>
<p>返回[“255.255.22.135”, “255.255.221.35”]. (顺序没有关系)</p>
<p>数据范围：字符串长度 0≤n≤12</p>
<p>要求：空间复杂度 O(n!),时间复杂度 O(n!)</p>
<p>注意：ip地址是由四段数字组成的数字序列，格式如 “x.x.x.x”，其中 x 的范围应当是 [0,255]。</p>
<h3 id="题解-84"><a href="#题解-84" class="headerlink" title="题解"></a>题解</h3><p>实际上就是一个排列问题，给出的n个字符，求将n个字符分成四组数据的排列数，前提是每个组中的数据都要在[0, 255]，若是其中有任何一个数据不满足则直接剪枝退出。</p>
<p>直接回溯，若是此时还可插入点的个数为0（没有0可以插入了），那么就开始合法性判断，若是还有0可以插入，就继续插入后分析，小数点可以插入的位置是后面一位，后面两位后面三位，由此继续递归。</p>
<h3 id="Java代码实现-82"><a href="#Java代码实现-82" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串ArrayList</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">restoreIpAddresses</span> <span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 用于存放最终的返回结果</span></span><br><span class="line">        ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(s.equals(<span class="string">""</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        backTrace(res, s, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// res存储最终结果</span></span><br><span class="line">    <span class="comment">// s是字符串</span></span><br><span class="line">    <span class="comment">// sb是之前构造的字符串</span></span><br><span class="line">    <span class="comment">// startIndex是本次可以插入点的位置</span></span><br><span class="line">    <span class="comment">// canAdd是还可以加多少个小数点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backTrace</span><span class="params">(ArrayList&lt;String&gt; res, String s, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> canAdd)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 递归退出条件，没有点可以添加了</span></span><br><span class="line">        <span class="keyword">if</span>(canAdd == <span class="number">0</span>)&#123;</span><br><span class="line">            String[] strs = s.split(<span class="string">"\\."</span>);</span><br><span class="line">            <span class="comment">// 不正确的插入</span></span><br><span class="line">            <span class="keyword">if</span>(strs.length != <span class="number">4</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 此时插入倒是正确了，需要判断值是否正确</span></span><br><span class="line">            <span class="keyword">for</span>(String str : strs)&#123;</span><br><span class="line">                <span class="comment">// 大于255或是有前导0且此时不为0直接排除</span></span><br><span class="line">                <span class="keyword">if</span>(Integer.valueOf(str) &gt; <span class="number">255</span> || str.length() &gt; <span class="number">1</span> &amp;&amp; str.charAt(<span class="number">0</span>) == <span class="string">'0'</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 执行到这里说明正确，可以添加到解集中</span></span><br><span class="line">            res.add(s.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="comment">// 此时还有剩余的小数点可以添加，直接递归添加即可(添加在starIndex后一位，后两位和后三位的地方)</span></span><br><span class="line">        <span class="comment">// 多了个点要考虑，所有后面的startIndex需要多加1</span></span><br><span class="line">        <span class="keyword">if</span>(startIndex &lt; n - <span class="number">1</span>)</span><br><span class="line">            backTrace(res, s.substring(<span class="number">0</span>, startIndex + <span class="number">1</span>) + <span class="string">"."</span> + s.substring(startIndex + <span class="number">1</span>, s.length()), startIndex + <span class="number">2</span>, canAdd - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(startIndex &lt; n - <span class="number">2</span>)</span><br><span class="line">            backTrace(res, s.substring(<span class="number">0</span>, startIndex + <span class="number">2</span>) + <span class="string">"."</span> + s.substring(startIndex + <span class="number">2</span>, s.length()), startIndex + <span class="number">3</span>, canAdd - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(startIndex &lt; n - <span class="number">3</span>)</span><br><span class="line">            backTrace(res, s.substring(<span class="number">0</span>, startIndex + <span class="number">3</span>) + <span class="string">"."</span> + s.substring(startIndex + <span class="number">3</span>, s.length()), startIndex + <span class="number">4</span>, canAdd - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM75-编辑距离（一）"><a href="#BM75-编辑距离（一）" class="headerlink" title="BM75 编辑距离（一）"></a>BM75 <a href="https://www.nowcoder.com/practice/6a1483b5be1547b1acd7940f867be0da?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">编辑距离（一）</a></h2><h3 id="题目描述-73"><a href="#题目描述-73" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定两个字符串 str1 和 str2 ，请你算出将 str1 转为 str2 的最少操作数。 </p>
<p>你可以对字符串进行3种操作： </p>
<p>1.插入一个字符 </p>
<p>2.删除一个字符 </p>
<p>3.修改一个字符。 </p>
<p>字符串长度满足 1≤n≤1000，保证字符串中只出现小写英文字母。</p>
<h3 id="题解-85"><a href="#题解-85" class="headerlink" title="题解"></a>题解</h3><p>首先，dp[i] [j]表示str1的第i位变化到str2的第j位所进行的操作数，那么当str1[i] == str2[j]时，dp[i] [j] = dp[i - 1] [j - 1]，若是str1的第i位和str2的第j位不等，那么如何才能将其化等呢，存在三种操作，添加，那么就是考虑在str1[i]后面加一位和str2[j]相同的字符（即添加之前str1[i] 已经和str2[j - 1]匹配了），那么此时dp[i] [j] = dp[i] [j - 1] + 1，修改，那么将当前str1[i]的值变为str2[j]，此时dp[i] [j] = dp[ i - 1] [j - 1] + 1，删除，那么此时将str1[i]删除（即删除之前str[i - 1]已经和str[j]匹配了），此时dp[i] [j] = dp[i - 1] [j] + 1，其中每个转移方程中的+1都指代增删改操作。</p>
<h3 id="Java代码实现-83"><a href="#Java代码实现-83" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str1 string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str2 string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">editDistance</span> <span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">char</span>[] chars1 = str1.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] chars2 = str2.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> n1 = chars1.length;</span><br><span class="line">        <span class="keyword">int</span> n2 = chars2.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n1 + <span class="number">1</span>][n2 + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 记得数组需要初始化</span></span><br><span class="line">        <span class="comment">// dp[i][0]和dp[0][j]分别表示一个是空串</span></span><br><span class="line">        <span class="comment">// 另一个是有非空串时需要的更改次数</span></span><br><span class="line">        <span class="comment">// 第一个字符串有i个字符，str1需要全部删除</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; ++i)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第二个字符串有i个字符，str1需要全部添加</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n2; ++i)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开始填充dp表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n2; ++j)&#123;</span><br><span class="line">                <span class="comment">// 相等直接不需要操作</span></span><br><span class="line">                <span class="keyword">if</span>(chars1[i - <span class="number">1</span>] == chars2[j - <span class="number">1</span>])&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 不相等返回增删改中最小的消耗并加上这次的消耗</span></span><br><span class="line">                    dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], Math.min(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j])) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM76-正则表达式匹配"><a href="#BM76-正则表达式匹配" class="headerlink" title="BM76 正则表达式匹配"></a>BM76 <a href="https://www.nowcoder.com/practice/28970c15befb4ff3a264189087b99ad4?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">正则表达式匹配</a></h2><h3 id="题目描述-74"><a href="#题目描述-74" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数用来匹配包括’.’和’*’的正则表达式。 </p>
<p>1.模式中的字符’.’表示任意一个字符 </p>
<p>2.模式中的字符’*’表示它前面的字符可以出现任意次（包含0次）。 </p>
<p>在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但是与”aa.a”和”ab*a”均不匹配 </p>
<p>数据范围: </p>
<ol>
<li><p>str 只包含从 a-z 的小写字母。</p>
</li>
<li><p>pattern 只包含从 a-z 的小写字母以及字符 . 和 * ，无连续的 ‘*’。</p>
</li>
<li><p>0≤str.length≤26</p>
</li>
<li><p>0≤pattern.length≤26</p>
</li>
</ol>
<h3 id="题解-86"><a href="#题解-86" class="headerlink" title="题解"></a>题解</h3><p>首先利用dp[i] [j]表示字符串str前i个字符和正则表达式前j个字符匹配的情况，那么当str[i]==pattern[j]相同时或者说当前j为’.’时，dp[i] [j] = dp[i - 1] [j - 1]，若是当前j为’*’，注意其前面的字符只有一个和 * 连接后匹配，那么此时存在两种情况，一是这个模式匹配完之后直接丢弃，那么实际上就是假设其出现了0次，此时dp[i] [j] = dp[i] [j - 2]，若是继续使用的话就往前进行匹配，即dp[i] [j] = dp[i - 1] [j]，当然这个操作的前提是必须能够匹配上一次（str[i]和pattern[j - 1]匹配）。</p>
<p>这里比较特殊的就是遇到’ * ‘的情况，此时需要和前面的一起进行考虑，而且会考虑匹配零次或多次的问题，那么当匹配零次时，就相当于将这两个丢弃再匹配，就是dp[i] [j - 2]，若是匹配一次或多次，那么前提是本次能匹配，之后就是考虑和后一个位置进行匹配，即dp[i] [j] = dp[i - 1] [j]，别的普通字符直接匹配，点直接算匹配成功。</p>
<h3 id="Java代码实现-84"><a href="#Java代码实现-84" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pattern string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span> <span class="params">(String str, String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> n1 = str.length();</span><br><span class="line">        <span class="keyword">int</span> n2 = pattern.length();</span><br><span class="line">        <span class="comment">// 可以在两者之前都加入空格来使dp[0][0]为true且得到以下标1开始的字符数组</span></span><br><span class="line">        <span class="comment">// 和三叶大神学的</span></span><br><span class="line">        str = <span class="string">" "</span> + str;</span><br><span class="line">        pattern = <span class="string">" "</span> + pattern;</span><br><span class="line">        <span class="keyword">char</span>[] strs = str.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] patterns = pattern.toCharArray();</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n1 + <span class="number">1</span>][n2 + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n1; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n2; ++j)&#123;</span><br><span class="line">                <span class="comment">// 如果下一个字符是*，则此字符不能单独匹配，跳过</span></span><br><span class="line">                <span class="keyword">if</span>(j + <span class="number">1</span> &lt;= n2 &amp;&amp; patterns[j + <span class="number">1</span>] == <span class="string">'*'</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 否则就开始匹配</span></span><br><span class="line">                <span class="comment">// 考虑不是*的情况（大于等于1才有下一位）</span></span><br><span class="line">                <span class="keyword">if</span>(i &gt;= <span class="number">1</span> &amp;&amp; patterns[j] != <span class="string">'*'</span>)&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; (strs[i] == patterns[j] || patterns[j] == <span class="string">'.'</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(patterns[j] == <span class="string">'*'</span>)&#123;</span><br><span class="line">                    <span class="comment">// 题目说了*不在开头</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// j &gt; 2这串表示匹配0次</span></span><br><span class="line">                    <span class="comment">// j &gt; 1这串表示匹配一次（前提是能匹配）</span></span><br><span class="line">                    dp[i][j] = (dp[i][j - <span class="number">2</span>] &amp;&amp; j &gt;= <span class="number">2</span>) || (i &gt;= <span class="number">1</span> &amp;&amp; dp[i - <span class="number">1</span>][j] &amp;&amp; (strs[i] == patterns[j - <span class="number">1</span>] || patterns[j - <span class="number">1</span>] == <span class="string">'.'</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM77-最长的括号子串"><a href="#BM77-最长的括号子串" class="headerlink" title="BM77 最长的括号子串"></a>BM77 <a href="https://www.nowcoder.com/practice/45fd68024a4c4e97a8d6c45fc61dc6ad?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">最长的括号子串</a></h2><h3 id="题目描述-75"><a href="#题目描述-75" class="headerlink" title="题目描述"></a>题目描述</h3><p>给出一个长度为 n 的，仅包含字符 ‘(‘ 和 ‘)’ 的字符串，计算最长的格式正确的括号子串的长度。 </p>
<p>例1: 对于字符串 “(()” 来说，最长的格式正确的子串是 “()” ，长度为 2 .</p>
<p>例2：对于字符串 “)()())” , 来说, 最长的格式正确的子串是 “()()” ，长度为 4 .</p>
<p>字符串长度：0≤n≤5∗105</p>
<p>要求时间复杂度 O(n),空间复杂度 O(n).</p>
<h3 id="题解-87"><a href="#题解-87" class="headerlink" title="题解"></a>题解</h3><p>使用dp[i]表示前i个字符中以第i个字符结尾的括号子串的长度，对于任意位置，若是该位置为左括号，那么dp[i]=0，因为合法字符不可能以左括号结尾，对于右括号，若是其前一位字符是左括号，那么当前已经多了一对已经匹配的括号，即dp[i] = dp[i - 2] + 2；若是其前一位字符是右括号，那么需要找到以前一个字符为尾的合法字符串之前的那个位置是否是左括号，而当前位置为i，那么以前一个字符为尾的合法字符串之前的那个位置就是i - dp[i - 1] - 1，其中dp[i - 1]表示前面有多少个字符是匹配的，需要全部排除</p>
<h3 id="Java代码实现-85"><a href="#Java代码实现-85" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span> <span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 长度小于2肯定没有</span></span><br><span class="line">        <span class="keyword">if</span>(s.length() &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> n = str.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="comment">// 第一个字符无论是左括号还是右括号都不会有有效的括号子串</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 最长子串长度</span></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="comment">// 注意这里i是从1开始的，因此dp[i - 1]和str[i - 1]肯定存在</span></span><br><span class="line">            <span class="comment">// 只有右括号时才考虑</span></span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">')'</span>)&#123;</span><br><span class="line">                <span class="comment">// 若是前一位是左括号，那么直接匹配成功一对</span></span><br><span class="line">                <span class="keyword">if</span>(str[i - <span class="number">1</span>] == <span class="string">'('</span>)&#123;</span><br><span class="line">                    <span class="comment">// 只有i &gt; 1，从2开始时i - 2才有效</span></span><br><span class="line">                    dp[i] = (i &gt; <span class="number">1</span> ? dp[i - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 此时前面是右括号</span></span><br><span class="line">                    <span class="comment">// 找到前面的未匹配完的那个下标</span></span><br><span class="line">                    <span class="keyword">int</span> noMarry = i - dp[i - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// 若是此下标合法</span></span><br><span class="line">                    <span class="keyword">if</span>(noMarry &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="comment">// 如果是左括号那直接匹配上了</span></span><br><span class="line">                        <span class="keyword">if</span>(str[noMarry] == <span class="string">'('</span>)&#123;</span><br><span class="line">                            <span class="comment">// 三部分组成，现在从noMarry到i已全部匹配</span></span><br><span class="line">                            <span class="comment">// noMarry - 1是noMarray之前的</span></span><br><span class="line">                            <span class="comment">// dp[i - 1]是noMarry + 1到str[i - 1]之前的</span></span><br><span class="line">                            <span class="comment">// 还有就是现在noMarray和i新组成的括号数2</span></span><br><span class="line">                            dp[i] = (noMarry &gt; <span class="number">0</span> ? dp[noMarry - <span class="number">1</span>] : <span class="number">0</span>) + dp[i - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 否则就是没匹配上（naMarry - 1是右括号），此时为0</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 此时是下标不合法，也是0</span></span><br><span class="line">                &#125;</span><br><span class="line">                max = max &lt; dp[i] ? dp[i] : max;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM78-打家劫舍（一）"><a href="#BM78-打家劫舍（一）" class="headerlink" title="BM78 打家劫舍（一）"></a>BM78 <a href="https://www.nowcoder.com/practice/c5fbf7325fbd4c0ea3d0c3ea6bc6cc79?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">打家劫舍（一）</a></h2><h3 id="题目描述-76"><a href="#题目描述-76" class="headerlink" title="题目描述"></a>题目描述</h3><p>你是一个经验丰富的小偷，准备偷沿街的一排房间，每个房间都存有一定的现金，为了防止被发现，你不能偷相邻的两家，即，如果偷了第一家，就不能再偷第二家；如果偷了第二家，那么就不能偷第一家和第三家。 </p>
<p>给定一个整数数组nums，数组中的元素表示每个房间存有的现金数额，请你计算在不被发现的前提下最多的偷窃金额。</p>
<p>数据范围：数组长度满足 1≤n≤2×10^5，数组中每个值满足 1≤num[i]≤5000</p>
<h3 id="题解-88"><a href="#题解-88" class="headerlink" title="题解"></a>题解</h3><p>使用dp[i]表示前i家中能够偷取的最大金额，那么对于第i家，存在下列两种情况，一是不偷这一家，那么能获得的金额就是前i - 1家所能获取的最大金额，即此时dp[i] = dp[i - 1]，二是偷这一家，那么此时前一家就无法偷取，那么此时能获得的最大金额就是前i - 2家获得的最大金额加上这一家的最大金额，对于每间房间，分别使用两种操作判断，两者取最大值即可。</p>
<h3 id="Java代码实现-86"><a href="#Java代码实现-86" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span> <span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="comment">// dp[i]表示前i家（下标以1开始）所能获得的最大金额</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 第0家能获得0</span></span><br><span class="line">        <span class="comment">// 第一家能获得的就是他们家有的</span></span><br><span class="line">        dp[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM79-打家劫舍（二）"><a href="#BM79-打家劫舍（二）" class="headerlink" title="BM79 打家劫舍（二）"></a>BM79 <a href="https://www.nowcoder.com/practice/a5c127769dd74a63ada7bff37d9c5815?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">打家劫舍（二）</a></h2><h3 id="题目描述-77"><a href="#题目描述-77" class="headerlink" title="题目描述"></a>题目描述</h3><p>你是一个经验丰富的小偷，准备偷沿湖的一排房间，每个房间都存有一定的现金，为了防止被发现，你不能偷相邻的两家，即，如果偷了第一家，就不能再偷第二家，如果偷了第二家，那么就不能偷第一家和第三家。沿湖的房间组成一个闭合的圆形，即第一个房间和最后一个房间视为相邻。 </p>
<p>给定一个长度为n的整数数组nums，数组中的元素表示每个房间存有的现金数额，请你计算在不被发现的前提下最多的偷窃金额。 </p>
<p>数据范围：数组长度满足 1≤n≤2×10^5，数组中每个值满足 1≤nums[i]≤5000</p>
<h3 id="题解-89"><a href="#题解-89" class="headerlink" title="题解"></a>题解</h3><p>这一题和<a href="https://www.nowcoder.com/practice/c5fbf7325fbd4c0ea3d0c3ea6bc6cc79?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">上一题</a>相比需要多考虑的一点是房间围成了一个圆形，那么偷了第一家就不能偷最后一家，可以分别考虑偷不偷第一家，若是偷的话，那么将最后一家排除得到最值，若是不偷的话那么将第一家排除得到最值，两者取最大值即可。</p>
<h3 id="Java代码实现-87"><a href="#Java代码实现-87" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span> <span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="comment">// 表示偷第一家能获得的最大金额</span></span><br><span class="line">        <span class="keyword">int</span>[] stole1 = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        stole1[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 表示不偷第一家能获得的最大金额</span></span><br><span class="line">        <span class="keyword">int</span>[] noStole1 = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        noStole1[<span class="number">1</span>] = nums[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 这个和原来一样，不过只考虑前n - 1间房</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            stole1[i] = Math.max(stole1[i - <span class="number">1</span>], stole1[i - <span class="number">2</span>] + nums[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里从第2间房开始考虑，不偷就是noStole1[i - 1]，偷就是noStole1[i - 2] + nums[i]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            noStole1[i] = Math.max(noStole1[i - <span class="number">1</span>], noStole1[i - <span class="number">2</span>] + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 然后二者返回最大值即可。</span></span><br><span class="line">        <span class="keyword">return</span> stole1[n - <span class="number">1</span>] &gt; noStole1[n - <span class="number">1</span>] ? stole1[n - <span class="number">1</span>] : noStole1[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM80-买卖股票的最好时机（一）"><a href="#BM80-买卖股票的最好时机（一）" class="headerlink" title="BM80 买卖股票的最好时机（一）"></a>BM80 <a href="https://www.nowcoder.com/practice/64b4262d4e6d4f6181cd45446a5821ec?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">买卖股票的最好时机（一）</a></h2><h3 id="题目描述-78"><a href="#题目描述-78" class="headerlink" title="题目描述"></a>题目描述</h3><p>假设你有一个数组prices，长度为n，其中prices[i]是股票在第i天的价格，请根据这个价格数组，返回买卖股票能获得的最大收益 </p>
<p>1.你可以买入一次股票和卖出一次股票，并非每天都可以买入或卖出一次，总共只能买入和卖出一次，且买入必须在卖出的前面的某一天 </p>
<p>2.如果不能获取到任何利润，请返回0 </p>
<p>3.假设买入卖出均无手续费</p>
<p>数据范围： 0≤n≤10^5,0≤val≤10^4</p>
<p>要求：空间复杂度 O(1)，时间复杂度 O(n)</p>
<h3 id="题解-90"><a href="#题解-90" class="headerlink" title="题解"></a>题解</h3><p>最简单的解法，两个for循环遍历完买入和卖出的利润取最大值。</p>
<p>其次就是贪心的思想，若是想取得最大利润，那么就在价格最低的时候买入，价格最高的时候卖出，那么遍历数组，维护一个变量表示最大收益和最低价格，每次用今天的价格减去之前的最低价得到今日卖出可得的最大收益，不断更新变量即可。</p>
<h3 id="Java代码实现-88"><a href="#Java代码实现-88" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> prices int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span> <span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 存储前i天的最低价</span></span><br><span class="line">        <span class="keyword">int</span> minPrice = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 存储最大收益</span></span><br><span class="line">        <span class="keyword">int</span> maxPro = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            dp[i] = prices[i] - minPrice;</span><br><span class="line">            <span class="keyword">if</span>(maxPro &lt; dp[i])&#123;</span><br><span class="line">                maxPro = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &lt; minPrice)&#123;</span><br><span class="line">                minPrice = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxPro;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题解-91"><a href="#题解-91" class="headerlink" title="题解"></a>题解</h3><p>考虑使用二维数组dp[i] [j]表示第i天持有股票状态为j时所能够获得的最大收入，其中j只有两个取值，0表示第j天未持有股票（自然也无法卖出），1表示第j天持有股票，两者取最大值即可。若是未持有股票，那么dp[i] [0] = max(dp[i - 1] [0], dp[i - 1] [1] + price[i])，其中dp[i - 1] [0]表示第i - 1天就未持有股票，不进行任何操作，dp[i - 1] [1] + price[i]则是表示第i - 1天持有了股票但是第i天卖出，若是持有股票，那么dp[i] [1] = max(dp[i- 1] [1], -prices[i])，其中dp[i - 1] [1]表示第i - 1天持有股票且不进行任何操作，- price[i]则表示在第i天买入 (因为只能买卖一次，那么只能这次买入)。</p>
<h3 id="Java代码实现-89"><a href="#Java代码实现-89" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> prices int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span> <span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 第一天未持有股票收益为0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 第一天持有股票收益为负（今天卖不了，只能买入）</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="comment">// 第i天未持有股票就取第i - 1天未持有股票的收益以及第i - 1持有股票但在第i天卖出的收益</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            <span class="comment">// 第i天持有股票就取第i - 1天持有股票的收益以及第i天买出的收益</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], -prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 贪心可知最后一天不持有股票收益高</span></span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM81-买卖股票的最好时机（二）"><a href="#BM81-买卖股票的最好时机（二）" class="headerlink" title="BM81 买卖股票的最好时机（二）"></a>BM81 <a href="https://www.nowcoder.com/practice/9e5e3c2603064829b0a0bbfca10594e9?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">买卖股票的最好时机（二）</a></h2><h3 id="题目描述-79"><a href="#题目描述-79" class="headerlink" title="题目描述"></a>题目描述</h3><p>假设你有一个数组prices，长度为n，其中prices[i]是某只股票在第i天的价格，请根据这个价格数组，返回买卖股票能获得的最大收益 </p>
<ol>
<li><p>你可以多次买卖该只股票，但是再次购买前必须卖出之前的股票 </p>
</li>
<li><p>如果不能获取收益，请返回0 </p>
</li>
<li><p>假设买入卖出均无手续费 </p>
</li>
</ol>
<p>数据范围： 1≤n≤1×1^5， 1≤prices[i]≤10^4</p>
<p>要求：空间复杂度 O(n)，时间复杂度 O(n)</p>
<p>进阶：空间复杂度 O(1)，时间复杂度 O(n)</p>
<h3 id="题解-92"><a href="#题解-92" class="headerlink" title="题解"></a>题解</h3><p>这题与上一题的不同之处在于这题能对股票多次买入，因此考虑动态规划的状态转移方程的变化。</p>
<p>依旧考虑使用二维数组dp[i] [j]表示第i天持有股票状态为j时所能够获得的最大收入，其中j只有两个取值，0表示第j天未持有股票（自然也无法卖出），1表示第j天持有股票，两者取最大值即可。若是未持有股票，那么dp[i] [0] = max(dp[i - 1] [0], dp[i - 1] [1] + price[i])，其中dp[i - 1] [0]表示第i - 1天就未持有股票，不进行任何操作，dp[i - 1] [1] + price[i]则是表示第i - 1天持有了股票但是第i天卖出，若是持有股票，那么dp[i] [1] = max(dp[i- 1] [1], dp[i - 1] [0] - prices[i])，其中dp[i - 1] [1]表示第i - 1天持有股票且不进行任何操作，dp[i - 1] [0] - prices[i]则表示在第i - 1天未持有股票而在第i天买入，最终的收益肯定是不持有股票获得的收益较高。</p>
<h3 id="Java代码实现-90"><a href="#Java代码实现-90" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     * 计算最大收益</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> prices int整型一维数组 股票每一天的价格</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span> <span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 只有一天那么当天买当天卖，没有的话就直接0</span></span><br><span class="line">        <span class="keyword">if</span>(prices.length &lt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 不持有收益为0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 买入收益为负</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="comment">// 第i天不持有的收益就是第i - 1天也不持有的收益和在第i天卖出的收益的最大值</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            <span class="comment">// 第i天持有的收益就是第i - 1天也持有的收益和在第i天才买入的收益的最大值</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后肯定是最后一天不持有收益比较高</span></span><br><span class="line">        <span class="keyword">return</span> dp[n -<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题解-93"><a href="#题解-93" class="headerlink" title="题解"></a>题解</h3><p>这里也可以使用贪心，主要思想是，只要有收益了就获得（若是此次价格高于上一次价格，那么此次将股票卖出，若是下一次比这次高那么再买入这次的股票即可，因此收益就是所有次交易的收益之和）。</p>
<h3 id="Java代码实现-91"><a href="#Java代码实现-91" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     * 计算最大收益</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> prices int整型一维数组 股票每一天的价格</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span> <span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="comment">// 只有一天那么当天买当天卖，没有的话就直接0</span></span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 保存全部收益</span></span><br><span class="line">        <span class="keyword">int</span> profile = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="comment">// 只要有收益就进行交易</span></span><br><span class="line">            <span class="keyword">if</span>(prices[i] &gt; prices[i - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="comment">// 加上这次交易获得的利润</span></span><br><span class="line">                profile += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profile;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM82-买卖股票的最好时机（三）"><a href="#BM82-买卖股票的最好时机（三）" class="headerlink" title="BM82 买卖股票的最好时机（三）"></a>BM82 <a href="https://www.nowcoder.com/practice/4892d3ff304a4880b7a89ba01f48daf9?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">买卖股票的最好时机（三）</a></h2><h3 id="题目描述-80"><a href="#题目描述-80" class="headerlink" title="题目描述"></a>题目描述</h3><p>假设你有一个数组prices，长度为n，其中prices[i]是某只股票在第i天的价格，请根据这个价格数组，返回买卖股票能获得的最大收益</p>
<ol>
<li>你最多可以对该股票有两笔交易操作，一笔交易代表着一次买入与一次卖出，但是再次购买前必须卖出之前的股票</li>
<li>如果不能获取收益，请返回0</li>
<li>假设买入卖出均无手续费</li>
</ol>
<p>数据范围：1≤n≤10^5，股票的价格满足 1≤val≤10^4</p>
<p>要求: 空间复杂度 O(n)，时间复杂度 O(n)</p>
<p>进阶：空间复杂度 O(1)，时间复杂度 O(n)</p>
<h3 id="题解-94"><a href="#题解-94" class="headerlink" title="题解"></a>题解</h3><p>这里的不同之处在于每次只能对股票有最多两笔交易，那么一共有如下状态:</p>
<ul>
<li>此时未交易过且受伤没有股票</li>
<li>此时只进行了一次买入操作</li>
<li>此时进行了一次交易后手上没有股票</li>
<li>此时进行了一次交易之外手上还有股票</li>
<li>此时进行了两次交易且手上没有股票</li>
</ul>
<p>考虑以上状态分别用0 - 4表示，那么dp[i] [0] 永远是0；dp[i] [1] = max(dp[i - 1] [1], - price[i])，dp[i - 1] [1]表示今天不进行操作，- price[i]，表示买入今天的股票；dp[i] [2] = max(dp[i - 1] [2], dp[i - 1] [1] + price[i])，dp[i - 1] [2]表示今天不进行操作，dp[i - 1] [1] + price[i]表示昨天持有股票，今天卖出；dp[i] [3] = max(dp[i - 1] [3], dp[i - 1] [2] - price[i])，dp[i - 1] [3]表示今天不进行操作，dp[i - 1] [2] - price[i]，表示买入今天的股票；dp[i] [4] = max(dp[i - 1] [4], dp[i -1] [3] + price[i - 1] [3] + price[i] )，dp[i - 1] [4]表示今天不进行操作，dp[i - 1] [3]表示卖出了股票，最后记得保存过程中的最大值。</p>
<h3 id="Java代码实现-92"><a href="#Java代码实现-92" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     * 两次交易所能获得的最大收益</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> prices int整型一维数组 股票每一天的价格</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span> <span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> profile = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">5</span>];</span><br><span class="line">        <span class="comment">// 这天买入的收益是-price[0]</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 这天也可以又买又卖再卖，收益也是-price[0]</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">3</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], -prices[i]);</span><br><span class="line">            dp[i][<span class="number">2</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">2</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            profile = Math.max(profile, dp[i][<span class="number">2</span>]);</span><br><span class="line">            dp[i][<span class="number">3</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">3</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">4</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">4</span>], dp[i - <span class="number">1</span>][<span class="number">3</span>] + prices[i]);</span><br><span class="line">            profile = Math.max(profile, dp[i][<span class="number">4</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profile;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="BM83-字符串变形"><a href="#BM83-字符串变形" class="headerlink" title="BM83 字符串变形"></a>BM83 <a href="https://www.nowcoder.com/practice/c3120c1c1bc44ad986259c0cf0f0b80e?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">字符串变形</a></h2><h3 id="题目描述-81"><a href="#题目描述-81" class="headerlink" title="题目描述"></a>题目描述</h3><p>对于一个长度为 n 字符串，我们需要对它做一些变形。 </p>
<p>首先这个字符串中包含着一些空格，就像”Hello World”一样，然后我们要做的是把这个字符串中由空格隔开的单词反序，同时反转每个字符的大小写。 </p>
<p>比如”Hello World”变形后就变成了”wORLD hELLO”。 </p>
<p>数据范围: 1≤n≤1061≤<em>n</em>≤106 , 字符串中包括大写英文字母、小写英文字母、空格。</p>
<p>进阶：空间复杂度 O(n)， 时间复杂度 O(n)</p>
<h4 id="输入描述：-4"><a href="#输入描述：-4" class="headerlink" title="输入描述："></a>输入描述：</h4><p>给定一个字符串s以及它的长度n(1 ≤ n ≤ 10^6)</p>
<h4 id="返回值描述：-4"><a href="#返回值描述：-4" class="headerlink" title="返回值描述："></a>返回值描述：</h4><p>请返回变形后的字符串。题目保证给定的字符串均由大小写字母和空格构成。</p>
<h3 id="题解-95"><a href="#题解-95" class="headerlink" title="题解"></a>题解</h3><p>先通过空格对字符串进行拆分，之后对每个字符串倒叙并改变大小写即可。</p>
<h3 id="Java代码实现-93"><a href="#Java代码实现-93" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">trans</span><span class="params">(String s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">// 这里必须要使用这个-1，否则最后一个字符为空的时候无法得到正确结果</span></span><br><span class="line">        <span class="comment">// 如用例"h i ",4</span></span><br><span class="line">        String[] ss = s.split(<span class="string">" "</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = ss.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            sb.append(reverseAndChange(ss[i]));</span><br><span class="line">            <span class="comment">// 只添n - 1个空格，最后一个不加空格，直接退出</span></span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">reverseAndChange</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Character.isLowerCase(str[i]))&#123;</span><br><span class="line">                sb.append(Character.toUpperCase(str[i]));</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(Character.isUpperCase(str[i]))&#123;</span><br><span class="line">                sb.append(Character.toLowerCase(str[i]));</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM84-最长公共前缀"><a href="#BM84-最长公共前缀" class="headerlink" title="BM84 最长公共前缀"></a>BM84 <a href="https://www.nowcoder.com/practice/28eb3175488f4434a4a6207f6f484f47?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">最长公共前缀</a></h2><h3 id="题目描述-82"><a href="#题目描述-82" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个大小为 n 的字符串数组 strs ，其中包含n个字符串 , 编写一个函数来查找字符串数组中的最长公共前缀，返回这个公共前缀。 </p>
<p>数据范围： 0≤n≤5000， 0≤len(strsi)≤5000</p>
<p>进阶：空间复杂度 O(n)，时间复杂度 O(n)</p>
<h3 id="题解-96"><a href="#题解-96" class="headerlink" title="题解"></a>题解</h3><p>遍历这n个字符串，若是发现当前位置所有字符串都是相等的，那么将这个字符添加到公共前缀中并继续直到字符串的边界，否则退出并返回之前的最长公共前缀。</p>
<h3 id="Java代码实现-94"><a href="#Java代码实现-94" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> strs string字符串一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span> <span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> n = strs.length;</span><br><span class="line">        <span class="comment">// 数组为空返回空</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 数组中任意一个字符串为空返回空</span></span><br><span class="line">        <span class="keyword">for</span>(String str : strs)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.equals(<span class="string">""</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 这里必须确保还没过界</span></span><br><span class="line">            <span class="keyword">if</span>(index &gt;= strs[<span class="number">0</span>].length())&#123;</span><br><span class="line">                <span class="keyword">return</span> sb.toString();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> c = strs[<span class="number">0</span>].charAt(index);</span><br><span class="line">            <span class="keyword">for</span>(String str : strs)&#123;</span><br><span class="line">                <span class="comment">// 这里也要确保不过界</span></span><br><span class="line">                <span class="keyword">if</span>(index &gt;= str.length() || str.charAt(index) != c)&#123;</span><br><span class="line">                    <span class="keyword">return</span> sb.toString();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 每个都一样就添加进来</span></span><br><span class="line">            sb.append(c);</span><br><span class="line">            <span class="comment">// 同时索引后移一位</span></span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样写不美观，稍微优化一下，得到</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> strs string字符串一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span> <span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> n = strs.length;</span><br><span class="line">        <span class="comment">// 数组为空返回空</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> m = strs[<span class="number">0</span>].length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = strs[<span class="number">0</span>].charAt(j);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= strs[i].length() || strs[i].charAt(j) != c)&#123;</span><br><span class="line">                    <span class="keyword">return</span> sb.toString();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM85-验证IP地址"><a href="#BM85-验证IP地址" class="headerlink" title="BM85 验证IP地址"></a>BM85 <a href="https://www.nowcoder.com/practice/55fb3c68d08d46119f76ae2df7566880?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">验证IP地址</a></h2><h3 id="题目描述-83"><a href="#题目描述-83" class="headerlink" title="题目描述"></a>题目描述</h3><p>编写一个函数来验证输入的字符串是否是有效的 IPv4 或 IPv6 地址</p>
<p>IPv4 地址由十进制数和点来表示，每个地址包含4个十进制数，其范围为 0 - 255， 用(“.”)分割。比如，172.16.254.1；<br>同时，IPv4 地址内的数不会以 0 开头。比如，地址 172.16.254.01 是不合法的。</p>
<p>IPv6 地址由8组16进制的数字来表示，每组表示 16 比特。这些组数字通过 (“:”)分割。比如, 2001:0db8:85a3:0000:0000:8a2e:0370:7334 是一个有效的地址。而且，我们可以加入一些以 0 开头的数字，字母可以使用大写，也可以是小写。所以， 2001:db8:85a3:0:0:8A2E:0370:7334 也是一个有效的 IPv6 address地址 (即，忽略 0 开头，忽略大小写)。</p>
<p>然而，我们不能因为某个组的值为 0，而使用一个空的组，以至于出现 (::) 的情况。 比如， 2001:0db8:85a3::8A2E:0370:7334 是无效的 IPv6 地址。<br>同时，在 IPv6 地址中，多余的 0 也是不被允许的。比如， 02001:0db8:85a3:0000:0000:8a2e:0370:7334 是无效的。</p>
<p>说明: 你可以认为给定的字符串里没有空格或者其他特殊字符。 </p>
<p>数据范围：字符串长度满足 5≤n≤50</p>
<p>进阶：空间复杂度 O(n)，时间复杂度 O(n)</p>
<h3 id="题解-97"><a href="#题解-97" class="headerlink" title="题解"></a>题解</h3><p>这题首先需要判断出改地址可能是IPv4地址或是IPv6地址，之后根据规则进行判断，若两者都不是，最终返回Neither。</p>
<p>这里我们假设其是IPv4地址，那么我们先用.将其分割，若是没有得到长度为4的数组，那么说明它是错误的，之后逐个进行解析，若是含有前导0那么其只能是0（长度为1），同时数据的范围是0-255，都满足说明是合法的IPv4地址。</p>
<p>若其不是IPv4地址，那么我们判断是否是IPv6地址，前用:分割，长度必须为8，其次对于任何字符串，长度必须小于等于8，若是含有前导0那么其只能是0（长度为1），同时对于每个字符串，不能出现比’f’还大的字母（十六进制中f最大），可以先将其全部转换为大写字母后比较，同时字符串不能为空。</p>
<h3 id="Java代码实现-95"><a href="#Java代码实现-95" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证IP地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> IP string字符串 一个IP地址字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">solve</span> <span class="params">(String IP)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 这里注意要使用 -1，否则最后的符号会判断错误</span></span><br><span class="line">        <span class="keyword">if</span>(IP.split(<span class="string">"\\."</span>, -<span class="number">1</span>).length == <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isValidIPv4(IP.split(<span class="string">"\\."</span>, -<span class="number">1</span>)))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"IPv4"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(IP.split(<span class="string">":"</span>, -<span class="number">1</span>).length == <span class="number">8</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isValidIPv6(IP.split(<span class="string">":"</span>, -<span class="number">1</span>)))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"IPv6"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Neither"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidIPv4</span><span class="params">(String[] ips)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 对于每个ip地址</span></span><br><span class="line">        <span class="keyword">for</span>(String ip : ips)&#123;</span><br><span class="line">            <span class="comment">// IPv4地址不能为空或是前导0</span></span><br><span class="line">            <span class="keyword">if</span>(ip.equals(<span class="string">""</span>) || ip.charAt(<span class="number">0</span>) == <span class="string">'0'</span> &amp;&amp; ip.length() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 每个字符必须都是数字</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> c : ip.toCharArray())&#123;</span><br><span class="line">                <span class="keyword">if</span>(!Character.isDigit(c))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 解析出的数字范围必须再0-255</span></span><br><span class="line">            <span class="keyword">int</span> num = Integer.parseInt(ip);</span><br><span class="line">            <span class="keyword">if</span>(num &gt; <span class="number">255</span> || num &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidIPv6</span><span class="params">(String[] ips)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(String ip : ips)&#123;</span><br><span class="line">            <span class="comment">// IPv6地址不能为空</span></span><br><span class="line">            <span class="keyword">if</span>(ip.equals(<span class="string">""</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 单独有0是可以的</span></span><br><span class="line">            <span class="keyword">if</span>(ip.charAt(<span class="number">0</span>) == <span class="string">'0'</span> &amp;&amp; ip.length() == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 不能有多余的0</span></span><br><span class="line">            <span class="keyword">if</span>(ip.charAt(<span class="number">0</span>) == <span class="string">'0'</span> &amp;&amp; ip.charAt(<span class="number">1</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 每个地址最多只能有4位</span></span><br><span class="line">            <span class="keyword">if</span>(ip.length() &gt; <span class="number">4</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将其全部转换为大写</span></span><br><span class="line">            String upper = ip.toUpperCase();</span><br><span class="line">            <span class="comment">// 十六进制数不能大于f</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> c : upper.toCharArray())&#123;</span><br><span class="line">                <span class="keyword">if</span>(c &gt; <span class="string">'F'</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看了题解后发现有一种比较<a href="https://blog.nowcoder.net/n/a0dd33afccf44555997621c4be25bd73" target="_blank" rel="noopener">优雅的做法</a>就是使用parseInt进行解析，若是捕获到异常则返回false，此外对于IPv6地址使用16进制进行解析。—&gt;   <strong>强推</strong></p>
<h2 id="BM86-大数加法"><a href="#BM86-大数加法" class="headerlink" title="BM86 大数加法"></a>BM86 <a href="https://www.nowcoder.com/practice/11ae12e8c6fe48f883cad618c2e81475?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">大数加法</a></h2><h3 id="题目描述-84"><a href="#题目描述-84" class="headerlink" title="题目描述"></a>题目描述</h3><p>以字符串的形式读入两个数字，编写一个函数计算它们的和，以字符串形式返回。 </p>
<p>数据范围：s.length,t.length≤10000，字符串仅由’0’~‘9’构成 </p>
<p>要求：时间复杂度 O(n)</p>
<h3 id="题解-98"><a href="#题解-98" class="headerlink" title="题解"></a>题解</h3><p>将所给的两个字符串反转，之后相加即可（注意进位的保存），最后将相加的结果反转后返回。</p>
<h3 id="Java代码实现-96"><a href="#Java代码实现-96" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     * 计算两个数之和</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s string字符串 表示第一个整数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t string字符串 表示第二个整数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">solve</span> <span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">// 反转两个字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : s.toCharArray())&#123;</span><br><span class="line">            sb.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] ss = sb.reverse().toString().toCharArray();</span><br><span class="line">        <span class="comment">// 记得每次操作之后将sb情况</span></span><br><span class="line">        sb.delete(<span class="number">0</span>, sb.length());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : t.toCharArray())&#123;</span><br><span class="line">            sb.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] ts = sb.reverse().toString().toCharArray();</span><br><span class="line">        <span class="comment">// 记得每次操作之后将sb情况</span></span><br><span class="line">        sb.delete(<span class="number">0</span>, sb.length());</span><br><span class="line">        <span class="keyword">int</span> n1 = ss.length;</span><br><span class="line">        <span class="keyword">int</span> n2 = ts.length;</span><br><span class="line">        <span class="keyword">int</span> maxLen = n1 &gt; n2 ? n1 : n2;</span><br><span class="line">        <span class="comment">// 进位</span></span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxLen; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> num1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> num2 = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 有的话就更改，没有就使用初始值0</span></span><br><span class="line">            <span class="keyword">if</span>(i &lt; n1)&#123;</span><br><span class="line">                num1 = ss[i] - <span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; n2)&#123;</span><br><span class="line">                num2 = ts[i] - <span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> sum = num1 + num2 + carry;</span><br><span class="line">            <span class="comment">// 将这一位添加</span></span><br><span class="line">            sb.append(sum % <span class="number">10</span>);</span><br><span class="line">            <span class="comment">// 更新进位</span></span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若是最后进位不为0（其实就是1），那么也要加入</span></span><br><span class="line">        <span class="keyword">if</span>(carry != <span class="number">0</span>)&#123;</span><br><span class="line">            sb.append(carry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><h2 id="BM87-合并两个有序的数组"><a href="#BM87-合并两个有序的数组" class="headerlink" title="BM87 合并两个有序的数组"></a>BM87 <a href="https://www.nowcoder.com/practice/89865d4375634fc484f3a24b7fe65665?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">合并两个有序的数组</a></h2><h3 id="题目描述-85"><a href="#题目描述-85" class="headerlink" title="题目描述"></a>题目描述</h3><p>给出一个有序的整数数组 A 和有序的整数数组 B ，请将数组 B 合并到数组 A 中，变成一个有序的升序数组 </p>
<p>数据范围： 0≤n,m≤100，∣Ai∣&lt;=100， ∣Bi∣&lt;=100</p>
<p>注意：</p>
<ol>
<li><p>保证 A 数组有足够的空间存放 B 数组的元素， A 和 B 中初始的元素数目分别为 m 和 n，A的数组空间大小为 m+n </p>
</li>
<li><p>不要返回合并的数组，将数组 B 的数据合并到 A 里面就好了，且后台会自动将合并后的数组 A 的内容打印出来，所以也不需要自己打印 </p>
</li>
<li><p>A 数组在[0,m-1]的范围也是有序的</p>
</li>
</ol>
<h3 id="题解-99"><a href="#题解-99" class="headerlink" title="题解"></a>题解</h3><p>这里题目要求将结果保存到数组A中，那么若是从前往后遍历，那么就不方便了，因此考虑从后往前遍历，使用两个指针cur1, cur2标识AB两个数组当前走到的位置，那么需要放到的位置就是A[cur1 + cur2 +1]，哪个大放哪个即可。</p>
<h3 id="Java代码实现-97"><a href="#Java代码实现-97" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> m, <span class="keyword">int</span> B[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cur1 = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cur2 = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = m + n -<span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="comment">// 给一个初值</span></span><br><span class="line">            <span class="keyword">int</span> num1 = Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">int</span> num2 = Integer.MIN_VALUE;</span><br><span class="line">            <span class="comment">// 可以再这里加一个判断</span></span><br><span class="line">            <span class="comment">// 若是cur1 == i，那么说明B中的元素已全部放入</span></span><br><span class="line">            <span class="comment">// 直接退出即可，快了很多</span></span><br><span class="line">            <span class="keyword">if</span>(cur1 == i)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 表示当前A数组的元素还没取完</span></span><br><span class="line">            <span class="keyword">if</span>(cur1 &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                num1 = A[cur1];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 表示当前B数组的元素还有剩余</span></span><br><span class="line">            <span class="keyword">if</span>(cur2 &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                num2 = B[cur2];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将小的插入</span></span><br><span class="line">            <span class="keyword">if</span>(num1 &lt; num2)&#123;</span><br><span class="line">                A[i] = num2;</span><br><span class="line">                --cur2;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                A[i] = num1;</span><br><span class="line">                --cur1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM88-判断是否为回文字符串"><a href="#BM88-判断是否为回文字符串" class="headerlink" title="BM88 判断是否为回文字符串"></a>BM88 <a href="https://www.nowcoder.com/practice/e297fdd8e9f543059b0b5f05f3a7f3b2?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">判断是否为回文字符串</a></h2><h3 id="题目描述-86"><a href="#题目描述-86" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个长度为 n 的字符串，请编写一个函数判断该字符串是否回文。如果是回文请返回true，否则返回false。 </p>
<p>字符串回文指该字符串正序与其逆序逐字符一致。 </p>
<p>数据范围：0&lt;n≤1000000</p>
<p>要求：空间复杂度 O(1)，时间复杂度 O(n)</p>
<h3 id="题解-100"><a href="#题解-100" class="headerlink" title="题解"></a>题解</h3><p>直接判断正反字符是否相等即可。</p>
<h3 id="Java代码实现-98"><a href="#Java代码实现-98" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str string字符串 待判断的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judge</span> <span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">char</span>[] strs = str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> n = strs.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span> + <span class="number">1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(strs[i] != strs[n - i - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里若是想让空间复杂度为O(1)就不把字符串转换成字符数组直接对str进行charAt()操作并判断即可。</p>
<h2 id="BM89-合并区间"><a href="#BM89-合并区间" class="headerlink" title="BM89 合并区间"></a>BM89 <a href="https://www.nowcoder.com/practice/69f4e5b7ad284a478777cb2a17fb5e6a?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">合并区间</a></h2><h3 id="题目描述-87"><a href="#题目描述-87" class="headerlink" title="题目描述"></a>题目描述</h3><p>给出一组区间，请合并所有重叠的区间。 </p>
<p>请保证合并后的区间按区间起点升序排列。 </p>
<p>数据范围：区间组数 0≤n≤2×10^5，区间内的值都满足 0≤val≤2×10^5</p>
<p>要求：空间复杂度 O(n)，时间复杂度 O(nlogn)</p>
<p>进阶：空间复杂度 O(val)，时间复杂度O(val)</p>
<h3 id="题解-101"><a href="#题解-101" class="headerlink" title="题解"></a>题解</h3><p>最简单的方法将数组先排序，之后判断当前区间是否可以被前一个区间合并，可以被前一个区间合并的条件是此区间和前一个区间存在重复的部分，即此区间的左边界小于或等于上一区间的右边界，那么此时可以合并，合并后的边界的右边界是两个边界中较大的那个，左边界是前一个边界的左边界。</p>
<h3 id="Java代码实现-99"><a href="#Java代码实现-99" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Interval&gt; <span class="title">merge</span><span class="params">(ArrayList&lt;Interval&gt; intervals)</span> </span>&#123;</span><br><span class="line">        Collections.sort(intervals, (o1, o2) -&gt; o1.start - o2.start);</span><br><span class="line">        ArrayList&lt;Interval&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 第几个数组</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 总共有几个区间</span></span><br><span class="line">        <span class="keyword">int</span> len = intervals.size();</span><br><span class="line">        <span class="keyword">while</span>(index &lt; len)&#123;</span><br><span class="line">            <span class="keyword">int</span> left = intervals.get(index).start;</span><br><span class="line">            <span class="keyword">int</span> right = intervals.get(index).end;</span><br><span class="line">            <span class="comment">// 表示之后还有区间且能够合并</span></span><br><span class="line">            <span class="keyword">while</span>(index &lt; len - <span class="number">1</span> &amp;&amp; intervals.get(index + <span class="number">1</span>).start &lt;= right)&#123;</span><br><span class="line">                <span class="comment">// 更新右边界为当前区间和下一个区间中较大的那个</span></span><br><span class="line">                right = Math.max(right, intervals.get(index + <span class="number">1</span>).end);</span><br><span class="line">                <span class="comment">// 更新index值，表示这个区间搜索过了</span></span><br><span class="line">                ++index;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将此区间放入</span></span><br><span class="line">            res.add(<span class="keyword">new</span> Interval(left, right));</span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时时间复杂度是O(nlogn)，至于进阶要求的O(val)的时间复杂度，目前暂未想到改如何做。</p>
<h2 id="BM90-最小覆盖子串"><a href="#BM90-最小覆盖子串" class="headerlink" title="BM90 最小覆盖子串"></a>BM90 <a href="https://www.nowcoder.com/practice/c466d480d20c4c7c9d322d12ca7955ac?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">最小覆盖子串</a></h2><h3 id="题目描述-88"><a href="#题目描述-88" class="headerlink" title="题目描述"></a>题目描述</h3><p>给出两个字符串 s 和 t，要求在 s 中找出最短的包含 t 中所有字符的连续子串。 </p>
<p>数据范围：0≤∣S∣,∣T∣≤10000，保证s和t字符串中仅包含大小写英文字母 </p>
<p>要求：进阶：空间复杂度 O(n)， 时间复杂度 O(n)</p>
<p>例如：</p>
<p>S=”XDOYEZODEYXNZ”<br>T=”XYZ”<br>找出的最短子串为”YXNZ”. </p>
<p>注意：<br>如果 s 中没有包含 t 中所有字符的子串，返回空字符串 “”；<br>满足条件的子串可能有很多，但是题目保证满足条件的最短的子串唯一。</p>
<h3 id="题解-102"><a href="#题解-102" class="headerlink" title="题解"></a>题解</h3><p>最简单的解法是直接枚举出所有可能出现的子串结果，看是否满足，若是满足则可以考虑吧，若是不满足则继续，最终返回可能结果中最小的那一个即可。</p>
<p>但此时时间复杂度较高，不合题意。</p>
<p>可以考虑使用双指针 + 滑动窗口来实现，首先确定一个思想，当不匹配时需要一直增大滑动窗口的大小，当且仅当匹配的时候可以缩小滑动窗口的大小，以左右指针维护滑动窗口大小，维护一个变量表示当前滑动窗口中的匹配的字符，若是已经匹配的字符小于T的长度时，右指针继续后移（直到越界为止），若是已经匹配的字符长度达到了T的长度，那么可以后移左指针来缩小滑动窗口的范围，过程中记得维护表示当前滑动窗口中匹配的字符长度的变量。</p>
<h3 id="Java代码实现-100"><a href="#Java代码实现-100" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> S string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> T string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span> <span class="params">(String S, String T)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">char</span>[] ss = S.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] ts = T.toCharArray();</span><br><span class="line">        <span class="comment">// 子串的长度</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">10001</span>;</span><br><span class="line">        <span class="comment">// 子串开始的下标</span></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(ss.length &lt; ts.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用于保存ts中的元素出现的次数</span></span><br><span class="line">        <span class="comment">// 这里为什么取128呢</span></span><br><span class="line">        <span class="comment">// 因为题目只说了包含大小写字符，其对应的int最大就是128</span></span><br><span class="line">        <span class="keyword">int</span>[] frequency = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="comment">// 统计出现的次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ts.length; ++i)&#123;</span><br><span class="line">            ++frequency[ts[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// left表示窗口左指针</span></span><br><span class="line">        <span class="comment">// right表示窗口右指针</span></span><br><span class="line">        <span class="comment">// count表示已经匹配完的字符数</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; ss.length)&#123;</span><br><span class="line">            <span class="comment">// 大于0表示还没有消完,frequency中对应的位置自减1同时right后移</span></span><br><span class="line">            <span class="keyword">if</span>(frequency[ss[right++]]-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 已匹配字符的个数加一</span></span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(count == ts.length)&#123;</span><br><span class="line">                <span class="comment">// 此时找到了匹配的字符串，看是否需要更新</span></span><br><span class="line">                <span class="keyword">if</span>(len &gt; right - left)&#123;</span><br><span class="line">                    len = right - left;</span><br><span class="line">                    start = left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 之后可以考虑后移左指针</span></span><br><span class="line">                <span class="comment">// 后移左指针的条件是左指针字符出现的次数为0</span></span><br><span class="line">                <span class="comment">// 而不需要的字符来说，他们的值其实已经小于0了</span></span><br><span class="line">                <span class="comment">// 因此等于0的就是需要的</span></span><br><span class="line">                <span class="keyword">if</span>(frequency[ss[left++]]++ == <span class="number">0</span>)&#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len == <span class="number">10001</span> ? <span class="string">""</span> : S.substring(start, start + len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM91-反转字符串"><a href="#BM91-反转字符串" class="headerlink" title="BM91 反转字符串"></a>BM91 <a href="https://www.nowcoder.com/practice/c3a6afee325e472386a1c4eb1ef987f3?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">反转字符串</a></h2><h3 id="题目描述-89"><a href="#题目描述-89" class="headerlink" title="题目描述"></a>题目描述</h3><p>写出一个程序，接受一个字符串，然后输出该字符串反转后的字符串。（字符串长度不超过1000）</p>
<p>数据范围： 0≤n≤1000</p>
<p>要求：空间复杂度 O(n)，时间复杂度 O(n)</p>
<h3 id="题解-103"><a href="#题解-103" class="headerlink" title="题解"></a>题解</h3><p>各种方式反转即可。</p>
<h3 id="Java代码实现-101"><a href="#Java代码实现-101" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反转字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">solve</span> <span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> n = str.length();</span><br><span class="line">        <span class="keyword">char</span>[] strs = str.toCharArray();</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            sb.append(strs[n - i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM92-最长无重复子数组"><a href="#BM92-最长无重复子数组" class="headerlink" title="BM92 最长无重复子数组"></a>BM92 <a href="https://www.nowcoder.com/practice/b56799ebfd684fb394bd315e89324fb4?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">最长无重复子数组</a></h2><h3 id="题目描述-90"><a href="#题目描述-90" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个长度为n的数组arr，返回arr的最长无重复元素子数组的长度，无重复指的是所有数字都不相同。</p>
<p>子数组是连续的，比如[1,3,5,7,9]的子数组有[1,3]，[3,5,7]等等，但是[1,3,7]不是子数组</p>
<p>数据范围：0≤arr.length≤10^5，0&lt;arr[i]≤10^5</p>
<h3 id="题解-104"><a href="#题解-104" class="headerlink" title="题解"></a>题解</h3><p>使用双指针left和right表示子数组的左右边界，若是right和right + 1对应的值不等，那么right指针后移，若是两者相等，此时的right - left值就是长度，判断是否更新最大长度即可，若是两者相等，将左右指针移到右指针的后一位继续遍历，直到遍历完。</p>
<h3 id="Java代码实现-102"><a href="#Java代码实现-102" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr int整型一维数组 the array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxLength</span> <span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 长度小于2时不可能重复</span></span><br><span class="line">        <span class="keyword">if</span>(arr.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> arr.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左右指针分别从0和1开始</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 初始时最大长度为0</span></span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 用于保存滑动窗口中已有的元素</span></span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">// 先将左值加入</span></span><br><span class="line">        set.add(arr[left]);</span><br><span class="line">        <span class="keyword">while</span>(right &lt; arr.length &amp;&amp; left &lt; arr.length)&#123;</span><br><span class="line">            <span class="comment">// 当前右值未被包含，加入集合中并且右指针后移</span></span><br><span class="line">            <span class="keyword">if</span>(!set.contains(arr[right]))&#123;</span><br><span class="line">                set.add(arr[right]);</span><br><span class="line">                ++right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 此时右值已被包含</span></span><br><span class="line">                <span class="comment">// 判断是否需要更新最长子数组长度</span></span><br><span class="line">                <span class="keyword">if</span>(right - left&gt; maxLen)&#123;</span><br><span class="line">                    maxLen = right - left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 改变左右指针</span></span><br><span class="line">                <span class="comment">// 左指针首先后移（需要将集合中的元素也删除）</span></span><br><span class="line">                set.remove(arr[left]);</span><br><span class="line">                <span class="comment">// 右移左指针</span></span><br><span class="line">                left = left + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 若是右移后左右指针位置相同则需要后移右指针。</span></span><br><span class="line">                <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">                    ++right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 没有越界就把这个值加入到set中（这里不用担心已经有这个元素，Set能去重）</span></span><br><span class="line">                <span class="keyword">if</span>(left &lt; arr.length)&#123;</span><br><span class="line">                    set.add(arr[left]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> maxLen;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后一次还未比较</span></span><br><span class="line">        <span class="comment">// 即若是最后两个数值不相等那其实已经直接退出了while循环</span></span><br><span class="line">        <span class="keyword">return</span> right - left&gt; maxLen ? right - left: maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM93-盛水最多的容器"><a href="#BM93-盛水最多的容器" class="headerlink" title="BM93 盛水最多的容器"></a>BM93 <a href="https://www.nowcoder.com/practice/3d8d6a8e516e4633a2244d2934e5aa47?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">盛水最多的容器</a></h2><h3 id="题目描述-91"><a href="#题目描述-91" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个数组height，长度为n，每个数代表坐标轴中的一个点的高度，height[i]是在第i点的高度，请问，从中选2个高度与x轴组成的容器最多能容纳多少水 </p>
<p>1.你不能倾斜容器 </p>
<p>2.当n小于2时，视为不能形成容器，请返回0 </p>
<p>3.数据保证能容纳最多的水不会超过整形范围，即不会超过2^31-1 </p>
<p>数据范围: </p>
<p>0&lt;=height.length&lt;=10^5</p>
<p>0&lt;=height[i]&lt;=10^4</p>
<p>如输入的height为[1,7,3,2,4,5,8,2,7]，那么如下图:</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20211105/301499_1636104759021/B9F3EB6BBC1EE9A63532E7EB494A11A7" alt="img"></p>
<h3 id="题解-105"><a href="#题解-105" class="headerlink" title="题解"></a>题解</h3><p>首先最简单的就是暴力解法，两个for循环遍历出所有可能的容器，取最大值即可。</p>
<p>其次类似接雨水问题都可以通过双指针操作进行实现，但双指针需要考虑移动的是左指针还是移动右指针，首先我们先将两个板子之间的范围取到最大值，即左指针为0，右指针为n - 1，那么每次操作就是左移右指针或者右移左指针，这两个操作都有可能取到比原来更优的解，那么何时才能找到两个解中较优的那一个呢，我们每次贪心的选择移动值较小的那个指针（木桶原理，容器盛水由较低的板决定，你移动较大的指针，容量不可能变大），之后考虑是否更新最值，最好将最值返回即可。</p>
<h3 id="Java代码实现-103"><a href="#Java代码实现-103" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> height int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span> <span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> n = height.length;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left != right)&#123;</span><br><span class="line">            <span class="keyword">int</span> area;</span><br><span class="line">            <span class="comment">// 若是左指针的值较小，则面积就是左指针的值 * 左右指针之差，此时需要移动左指针</span></span><br><span class="line">            <span class="keyword">if</span>(height[left] &lt; height[right])&#123;</span><br><span class="line">                area = (right - left) * height[left];</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 反之则面积是右指针的值 * 左右指针之差，此时移动右指针</span></span><br><span class="line">                area = (right - left) * height[right];</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新最值</span></span><br><span class="line">            max = Math.max(max, area);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM94-接雨水问题"><a href="#BM94-接雨水问题" class="headerlink" title="BM94 接雨水问题"></a>BM94 <a href="https://www.nowcoder.com/practice/31c1aed01b394f0b8b7734de0324e00f?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">接雨水问题</a></h2><h3 id="题目描述-92"><a href="#题目描述-92" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个整形数组arr，已知其中所有的值都是非负的，将这个数组看作一个柱子高度图，计算按此排列的柱子，下雨之后能接多少雨水。(数组以外的区域高度视为0) </p>
<p><img src="https://uploadfiles.nowcoder.com/images/20210416/999991351_1618541247169/26A2E295DEE51749C45B5E8DD671E879" alt="img"></p>
<p>数据范围：数组长度 0≤n≤2×10^5，数组中每个值满足 0&lt;val≤10^9，保证返回结果满足 0≤val≤10^9</p>
<p>要求：时间复杂度 O(n)</p>
<h3 id="题解-106"><a href="#题解-106" class="headerlink" title="题解"></a>题解</h3><p>这一题主要就是要找到有多少个地方能盛水，第一次遍历首先找到盛水边界，方向有两种，一是从左往右，二是从右往左，我们每次找到比当前边界值更大的值我们就将其放入集合中并更新边界，两次的结果求出来之后再求并集，之后再次遍历数组，若是当前的下标是边界值，那么需要将之前的容量算出来(当前容器能装的水 - 容器自身消耗的面积)，求出之后将其加到总雨水中即可。</p>
<h3 id="Java代码实现-104"><a href="#Java代码实现-104" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * max water</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr int整型一维数组 the array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> long长整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">maxWater</span> <span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 存放从左往右找到的边界</span></span><br><span class="line">        HashSet&lt;Integer&gt; leftToRight = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">// 找到左边界的值</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 存放从右往左找到的边界</span></span><br><span class="line">        HashSet&lt;Integer&gt; rightToLeft = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">// 找到右边界的值</span></span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="comment">// 找到了一个边界</span></span><br><span class="line">            <span class="keyword">if</span>(left &lt;= arr[i])&#123;</span><br><span class="line">                leftToRight.add(i);</span><br><span class="line">                left = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; --i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(right &lt;= arr[i])&#123;</span><br><span class="line">                rightToLeft.add(i);</span><br><span class="line">                right = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        leftToRight.addAll(rightToLeft);</span><br><span class="line">        <span class="comment">// 总的可以装的雨水</span></span><br><span class="line">        <span class="keyword">long</span> sumWater = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 当前容器装的雨水（假设其内部为空的情况）</span></span><br><span class="line">        <span class="keyword">int</span> curWater = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 当前容器内部占的体积</span></span><br><span class="line">        <span class="keyword">int</span> curArea = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 容器开始的下标</span></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 第一个和最后一个肯定是边界，不考虑</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">            <span class="comment">// 若当前是边界，那么将当前能容纳的雨水加到总雨水中</span></span><br><span class="line">            <span class="keyword">if</span>(leftToRight.contains(i))&#123;</span><br><span class="line">                <span class="comment">// 计算当前容器可以装的雨水</span></span><br><span class="line">                curWater = (i - start - <span class="number">1</span>) * Math.min(arr[i], arr[start]);</span><br><span class="line">                <span class="comment">// 总共能装的雨水就是之前的加上当前容器能装的再减去当前容器内部的空间</span></span><br><span class="line">                sumWater += curWater - curArea;</span><br><span class="line">                <span class="comment">// 更新curArea</span></span><br><span class="line">                curArea = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 开始下标改变</span></span><br><span class="line">                start = i;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 若当前不是边界，更新内部容量</span></span><br><span class="line">                curArea += arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后一个容器能装的雨水还没算</span></span><br><span class="line">        sumWater += (n - start - <span class="number">2</span>) * Math.min(arr[n - <span class="number">1</span>], arr[start]) - curArea;</span><br><span class="line">        <span class="keyword">return</span> sumWater;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题解-107"><a href="#题解-107" class="headerlink" title="题解"></a>题解</h3><p>这题也可以使用双指针，初始时为左右边边界（假设这个桶是左右边界构成的桶），之后选择两者的较小值作为当前桶的高度，之后一直更新桶高同时更新雨水值以及左右指针位置即可，就是在更新指针的过程中需要防止越界。</p>
<h3 id="Java代码实现-105"><a href="#Java代码实现-105" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * max water</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr int整型一维数组 the array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> long长整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">maxWater</span> <span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 存放结果</span></span><br><span class="line">        <span class="keyword">long</span> sumWater = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> border = Math.min(arr[left], arr[right]);</span><br><span class="line">            <span class="comment">// 更新时记得防止越界</span></span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; arr[left] &lt;= border)&#123;</span><br><span class="line">                <span class="comment">// 此时left能放水</span></span><br><span class="line">                sumWater += border - arr[left];</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; arr[right] &lt;= border)&#123;</span><br><span class="line">                <span class="comment">// 此时right能放水</span></span><br><span class="line">                sumWater += border - arr[right];</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sumWater;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h2 id="BM95-分糖果问题"><a href="#BM95-分糖果问题" class="headerlink" title="BM95 分糖果问题"></a>BM95 <a href="https://www.nowcoder.com/practice/76039109dd0b47e994c08d8319faa352?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">分糖果问题</a></h2><h3 id="题目描述-93"><a href="#题目描述-93" class="headerlink" title="题目描述"></a>题目描述</h3><p>一群孩子做游戏，现在请你根据游戏得分来发糖果，要求如下： </p>
<ol>
<li><p>每个孩子不管得分多少，起码分到一个糖果。</p>
</li>
<li><p>任意两个相邻的孩子之间，得分较多的孩子必须拿多一些糖果。(若相同则无此限制)</p>
</li>
</ol>
<p>给定一个数组 arr代表得分数组，请返回最少需要多少糖果。 </p>
<p>要求: 时间复杂度为 O(n)空间复杂度为 O(n)</p>
<p>数据范围： 1≤n≤100000，1≤ai≤1000</p>
<h3 id="题解-108"><a href="#题解-108" class="headerlink" title="题解"></a>题解</h3><p>贪心的核心：首先给第全部孩子分一个糖，之后从第1个孩子开始遍历，若是得分比前一个孩子多，那么糖果数多1，否则给他一个糖果。这次遍历满足了从前到后的合法性，但从后往前的合法性仍未满足，考虑再次从后往前遍历，若是发现不满足条件的值，就修改其值为当前值 + 1以及原来取最大值。</p>
<h3 id="Java代码实现-106"><a href="#Java代码实现-106" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * pick candy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr int整型一维数组 the array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">candy</span> <span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] everyCandy = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="comment">// 先用1填充</span></span><br><span class="line">        Arrays.fill(everyCandy, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; arr[i - <span class="number">1</span>])&#123;</span><br><span class="line">                everyCandy[i] = everyCandy[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; arr[i + <span class="number">1</span>])&#123;</span><br><span class="line">                everyCandy[i] = Math.max(everyCandy[i], everyCandy[i + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(everyCandy).sum();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM96-主持人调度（二）"><a href="#BM96-主持人调度（二）" class="headerlink" title="BM96 主持人调度（二）"></a>BM96 <a href="https://www.nowcoder.com/practice/4edf6e6d01554870a12f218c94e8a299?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">主持人调度（二）</a></h2><h3 id="题目描述-94"><a href="#题目描述-94" class="headerlink" title="题目描述"></a>题目描述</h3><p>有 n 个活动即将举办，每个活动都有开始时间与活动的结束时间，第 i 个活动的开始时间是 starti ,第 i 个活动的结束时间是 endi ,举办某个活动就需要为该活动准备一个活动主持人。</p>
<p>一位活动主持人在同一时间只能参与一个活动。并且活动主持人需要全程参与活动，换句话说，一个主持人参与了第 i 个活动，那么该主持人在 (starti,endi) 这个时间段不能参与其他任何活动。求为了成功举办这 n 个活动，最少需要多少名主持人。</p>
<p>数据范围: 1≤n≤10^5， −2^32≤starti,endi≤2^31−1</p>
<p>复杂度要求：时间复杂度 O(nlog⁡n)，空间复杂度 O(n)</p>
<h3 id="题解-109"><a href="#题解-109" class="headerlink" title="题解"></a>题解</h3><p>先按开始时间进行排序，之后维护一个队列（队列中存放活动的结束时间），对于每个活动，若是其开始时间在队首（最小的–&gt;结束最早的）的活动之前，那么说明活动还未结束，必须多一个主持人，若是其开始时间在队首活动之后，说明此时活动已经结束，无需再添加主持人。</p>
<h3 id="Java代码实现-107"><a href="#Java代码实现-107" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     * 计算成功举办活动需要多少名主持人</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n int整型 有n个活动</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startEnd int整型二维数组 startEnd[i][0]用于表示第i个活动的开始时间，startEnd[i][1]表示第i个活动的结束时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minmumNumberOfHost</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] startEnd)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先排序</span></span><br><span class="line">        Arrays.sort(startEnd, (o1, o2) -&gt; o1[<span class="number">0</span>] &gt; o2[<span class="number">0</span>] ? <span class="number">1</span>: o1[<span class="number">0</span>] &lt; o2[<span class="number">0</span>] ? -<span class="number">1</span> : o1[<span class="number">1</span>] &gt;= o2[<span class="number">1</span>] ? <span class="number">1</span>: -<span class="number">1</span>);</span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] active : startEnd)&#123;</span><br><span class="line">            <span class="comment">// 把这个活动放到队列中</span></span><br><span class="line">            queue.offer(active[<span class="number">1</span>]);</span><br><span class="line">            <span class="comment">// 若是当前活动开始的时间大于之前的活动结束的时间</span></span><br><span class="line">            <span class="keyword">if</span>(!queue.isEmpty() &amp;&amp; queue.peek() &lt;= active[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="comment">// 继续用上一个主持人</span></span><br><span class="line">                <span class="comment">// 把那个主持人拿掉</span></span><br><span class="line">                queue.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h1><h2 id="BM97-旋转数组"><a href="#BM97-旋转数组" class="headerlink" title="BM97 旋转数组"></a>BM97 <a href="https://www.nowcoder.com/practice/e19927a8fd5d477794dac67096862042?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">旋转数组</a></h2><h3 id="题目描述-95"><a href="#题目描述-95" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个数组A中存有 n 个整数，在不允许使用另外数组的前提下，将每个整数循环向右移 M（ M &gt;=0）个位置，即将A中的数据由（A0 A1 ……AN-1 ）变换为（AN-M …… AN-1 A0A1 ……AN-M-1 ）（最后 M 个数循环移至最前面的 M 个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？ </p>
<p>数据范围：0&lt;n≤100，0≤m≤1000</p>
<p>进阶：空间复杂度 O(1)，时间复杂度 O(n)</p>
<h3 id="题解-110"><a href="#题解-110" class="headerlink" title="题解"></a>题解</h3><p>首先分析问题，要求我们将后面的m个数据放到最前面，可以选择旋转数组的方式，即将数组完全导致过来，这样的话后面的m个元素已经到了前m个位置，大致上满足，但此时顺序不对，因此再分别对m之前的元素及其之后的元素进行反转就得到了题目要求的结果。例如{0, 1, ,2, 3, 4, 5, 6, 7, 8, 9}，m = 3，应得的结果是{7, 8, 9, 0, 1, 2, 3, 4, 5, 6}，按照算法思想，先将数组反转，得到{9, 8, 7, 6, 5, 4, 3, 2, 1, 0}，之后对前三个元素反转，得到{7, 8, 9, 6, 5, 4, 3, 2, 1, 0}，之后对后面的元素进行反转，得到{7, 8, 9, 0, 1, 2, 3, 4, 5, 6}。</p>
<h3 id="Java代码实现-108"><a href="#Java代码实现-108" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 旋转数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n int整型 数组长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m int整型 右移距离</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a int整型一维数组 给定数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] solve (<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span>[] a) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 防止太大了</span></span><br><span class="line">        m %= n;</span><br><span class="line">        <span class="comment">// 首先反转全部</span></span><br><span class="line">        reverse(a, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 之后反转前m个</span></span><br><span class="line">        reverse(a, <span class="number">0</span>, m - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 再反转后面的</span></span><br><span class="line">        reverse(a, m, n -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = num[end];</span><br><span class="line">            num[end] = num[start];</span><br><span class="line">            num[start] = temp;</span><br><span class="line">            ++start;</span><br><span class="line">            --end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对于旋转数组时使用到的反转链表的思想，我只能说女少口阿</strong></p>
<h2 id="BM98-螺旋矩阵"><a href="#BM98-螺旋矩阵" class="headerlink" title="BM98 螺旋矩阵"></a>BM98 <a href="https://www.nowcoder.com/practice/7edf70f2d29c4b599693dc3aaeea1d31?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">螺旋矩阵</a></h2><h3 id="题目描述-96"><a href="#题目描述-96" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个m x n大小的矩阵（m行，n列），按螺旋的顺序返回矩阵中的所有元素。</p>
<p>数据范围：0≤n,m≤10，矩阵中任意元素都满足 ∣val∣≤100</p>
<p>要求：空间复杂度 O(nm)，时间复杂度 O(nm)</p>
<h3 id="题解-111"><a href="#题解-111" class="headerlink" title="题解"></a>题解</h3><p>实际模拟我们大脑求解的过程即可，设立四个边界值，若是未达到边界就进行如下方式遍历先从左往右，再从上到下，之后从右到左，最后从下往上，此四个过程为一个循环，循环结束后更新边界值。</p>
<h3 id="Java代码实现-109"><a href="#Java代码实现-109" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先初始化边界</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> bottom = matrix.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 未到达边界</span></span><br><span class="line">        <span class="keyword">while</span>(top &lt;= bottom &amp;&amp; left &lt;= right)&#123;</span><br><span class="line">            <span class="comment">// 先从左到右(上边界)</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right; ++i)&#123;</span><br><span class="line">                res.add(matrix[top][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 再从上到下(右边界)，注意这里第一个元素已经被访问了</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = top + <span class="number">1</span>; i &lt;= bottom; ++i)&#123;</span><br><span class="line">                res.add(matrix[i][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 再从右往左(下边界)，注意这里第一个元素已经被访问了</span></span><br><span class="line">            <span class="comment">// 若是top = bottom那么就没有从右往左的必要了</span></span><br><span class="line">            <span class="comment">// 只有一行，在从左往右的时候遍历过了</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = right - <span class="number">1</span>; i &gt;= left &amp;&amp; top != bottom; --i)&#123;</span><br><span class="line">                res.add(matrix[bottom][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 再从下往上(左边界)，注意这里第一个元素已经被访问了</span></span><br><span class="line">            <span class="comment">// left = right那么就没有从右往左的必要了</span></span><br><span class="line">            <span class="comment">// 只有一列，在从上往下的时候遍历过了</span></span><br><span class="line">            <span class="comment">// 还有就是注意这里只遍历到了top下面的一行（top这一行已经遍历过了）</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = bottom - <span class="number">1</span>; i &gt;= top + <span class="number">1</span> &amp;&amp; left != right; --i)&#123;</span><br><span class="line">                res.add(matrix[i][left]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 改变边界值</span></span><br><span class="line">            ++left;</span><br><span class="line">            --right;</span><br><span class="line">            ++top;</span><br><span class="line">            --bottom;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM99-顺时针旋转矩阵"><a href="#BM99-顺时针旋转矩阵" class="headerlink" title="BM99 顺时针旋转矩阵"></a>BM99 <a href="https://www.nowcoder.com/practice/2e95333fbdd4451395066957e24909cc?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">顺时针旋转矩阵</a></h2><h3 id="题目描述-97"><a href="#题目描述-97" class="headerlink" title="题目描述"></a>题目描述</h3><p>有一个NxN整数矩阵，请编写一个算法，将矩阵顺时针旋转90度。 </p>
<p>给定一个NxN的矩阵，和矩阵的阶数N,请返回旋转后的NxN矩阵。 </p>
<p>数据范围：0&lt;n&lt;300，矩阵中的值满足 0≤val≤1000</p>
<p>要求：空间复杂度 O(N^2)，时间复杂度 O(N^2)</p>
<p>进阶：空间复杂度 O(1)，时间复杂度 O(N^2)</p>
<h3 id="题解-112"><a href="#题解-112" class="headerlink" title="题解"></a>题解</h3><p>若是想达到O(n^2)的时间复杂度，只需新建一个数组，把反转后的数组修改到新数组上即可。而旋转的过程也比较简单，一开始是从左往右从上往下遍历，那么旋转之后就是从上往下，从右往左遍历，逐个填满数组即可。</p>
<h3 id="java代码实现"><a href="#java代码实现" class="headerlink" title="java代码实现"></a>java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] rotateMatrix(<span class="keyword">int</span>[][] mat, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="comment">// 这里新数组的行和原数组的列对应</span></span><br><span class="line">                <span class="comment">// 新数组的列就是原数组的行反过来</span></span><br><span class="line">                res[j][n - i - <span class="number">1</span>] = mat[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题解-113"><a href="#题解-113" class="headerlink" title="题解"></a>题解</h3><p>若是想达到O(1)的空间复杂度，则必须原地修改指针，考虑矩阵是如何进行旋转的，就是先通过矩阵的对称轴上下交换，再通过矩阵的对角线（左上到右下的对角线）左右交换，通过两次交换就得到了需要的矩阵。</p>
<h3 id="Java代码实现-110"><a href="#Java代码实现-110" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] rotateMatrix(<span class="keyword">int</span>[][] mat, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 先以从左到右的在水平方向的对称轴交换，这里注意i的取值[0, n / 2)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                swap(mat, i, j, n - i - <span class="number">1</span>, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 再以从左上到右下的对称轴交换,注意这里只交换一半</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n; ++j)&#123;</span><br><span class="line">                swap(mat, i, j, j, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mat;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将二维矩阵(i1, j1)的数和(i2, j2)的数交换</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[][] num, <span class="keyword">int</span> i1, <span class="keyword">int</span> j1, <span class="keyword">int</span> i2, <span class="keyword">int</span> j2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = num[i1][j1];</span><br><span class="line">        num[i1][j1] = num[i2][j2];</span><br><span class="line">        num[i2][j2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM100-设计LRU缓存结构"><a href="#BM100-设计LRU缓存结构" class="headerlink" title="BM100 设计LRU缓存结构"></a>BM100 <a href="https://www.nowcoder.com/practice/5dfded165916435d9defb053c63f1e84?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">设计LRU缓存结构</a></h2><h3 id="题目描述-98"><a href="#题目描述-98" class="headerlink" title="题目描述"></a>题目描述</h3><p>设计LRU(最近最少使用)缓存结构，该结构在构造时确定大小，假设大小为 capacity ，操作次数是 n ，并有如下功能:</p>
<ol>
<li>Solution(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存</li>
<li>get(key)：如果关键字 key 存在于缓存中，则返回key对应的value值，否则返回 -1 。</li>
<li>set(key, value)：将记录(key, value)插入该结构，如果关键字 key 已经存在，则变更其数据值 value，如果不存在，则向缓存中插入该组 key-value ，如果key-value的数量超过capacity，弹出最久未使用的key-value</li>
</ol>
<p>提示:<br>1.某个key的set或get操作一旦发生，则认为这个key的记录成了最常使用的，然后都会刷新缓存。<br>2.当缓存的大小超过capacity时，移除最不经常使用的记录。<br>4.返回的value都以字符串形式表达，如果是set，则会返回”null”来表示，方便观察<br>5.函数set和get必须以O(1)的方式运行<br>6.为了方便区分缓存里key与value，下面说明的缓存里key用””号包裹 </p>
<p>数据范围: </p>
<p>1≤capacity&lt;=10^5<br>0≤key,val≤2×10^9<br>1≤n≤10^5</p>
<h3 id="题解-114"><a href="#题解-114" class="headerlink" title="题解"></a>题解</h3><p>这题很显然有key-value对，需要使用HashMap，这是第一个数据结构，此外需要存储优先级，但这里可以使用队列来保存数据，每次get和set操作就将其删除并重新插入到尾部，若是容量过大就将链表头删除。</p>
<h3 id="Java代码实现-111"><a href="#Java代码实现-111" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    LinkedHashMap&lt;Integer, Integer&gt; map;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">         <span class="comment">// write code here</span></span><br><span class="line">        map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">         <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(key))&#123;</span><br><span class="line">            Integer value = map.get(key);</span><br><span class="line">            <span class="comment">// 从头删除</span></span><br><span class="line">            map.remove(key);</span><br><span class="line">            <span class="comment">// 插入到尾</span></span><br><span class="line">            map.put(key, value);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">         <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 先判断是否已经有这个元素了</span></span><br><span class="line">        <span class="comment">// 有的话修改然后更新队列即可</span></span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(key))&#123;</span><br><span class="line">            map.remove(key);</span><br><span class="line">            map.put(key, value);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 原来没有这个元素</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 满了，此时需要移除元素</span></span><br><span class="line">            <span class="keyword">if</span>(capacity == map.size())&#123;</span><br><span class="line">                Integer removeKey = map.keySet().iterator().next();</span><br><span class="line">                map.remove(removeKey);</span><br><span class="line">                map.put(key, value);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 此时直接插入即可</span></span><br><span class="line">                map.put(key, value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM101-设计LFU缓存结构"><a href="#BM101-设计LFU缓存结构" class="headerlink" title="BM101 设计LFU缓存结构"></a>BM101 <a href="https://www.nowcoder.com/practice/93aacb4a887b46d897b00823f30bfea1?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">设计LFU缓存结构</a></h2><h3 id="题目描述-99"><a href="#题目描述-99" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个缓存结构需要实现如下功能。 </p>
<ul>
<li>set(key, value)：将记录(key, value)插入该结构 </li>
<li>get(key)：返回key对应的value值 </li>
</ul>
<p>但是缓存结构中最多放K条记录，如果新的第K+1条记录要加入，就需要根据策略删掉一条记录，然后才能把新记录加入。这个策略为：在缓存结构的K条记录中，哪一个key从进入缓存结构的时刻开始，被调用set或者get的次数最少，就删掉这个key的记录； </p>
<p>如果调用次数最少的key有多个，上次调用发生最早的key被删除 </p>
<p>这就是LFU缓存替换算法。实现这个结构，K作为参数给出</p>
<p>数据范围：0&lt;k≤10^5，∣val∣≤2×10^9</p>
<p>要求：get和set的时间复杂度都是 O(logn)，空间复杂度是 O(n)</p>
<p>若opt=1，接下来两个整数x, y，表示set(x, y)<br>若opt=2，接下来一个整数x，表示get(x)，若x未出现过或已被移除，则返回-1</p>
<p>对于每个操作2，返回一个答案</p>
<h3 id="题解-115"><a href="#题解-115" class="headerlink" title="题解"></a>题解</h3><p>参考了<a href="https://blog.nowcoder.net/n/4ed8a609169e4cdda974d59546e376f5" target="_blank" rel="noopener">别人的题解</a>。</p>
<h3 id="Java代码实现-112"><a href="#Java代码实现-112" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * lfu design</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> operators int整型二维数组 ops</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k int整型 the k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] LFU (<span class="keyword">int</span>[][] operators, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="comment">//记录get调用的次数</span></span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] opera:operators)&#123;</span><br><span class="line">            <span class="keyword">if</span>(opera[<span class="number">0</span>]==<span class="number">2</span>)&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据cnt新建结果数组</span></span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[cnt];</span><br><span class="line">        <span class="keyword">int</span> id=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//新建缓存结构</span></span><br><span class="line">        LFUCache lfu=<span class="keyword">new</span> LFUCache(k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] opera:operators)&#123;</span><br><span class="line">            <span class="comment">//执行set操作</span></span><br><span class="line">            <span class="keyword">if</span>(opera[<span class="number">0</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">                lfu.set(opera[<span class="number">1</span>],opera[<span class="number">2</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//执行get操作</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> value=lfu.get(opera[<span class="number">1</span>]);</span><br><span class="line">                res[id++]=value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义Node结构，包含一个key和一个value，并初始化调用次数freq为1</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">int</span> freq=<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        Node(<span class="keyword">int</span> key,<span class="keyword">int</span> value)&#123;</span><br><span class="line">            <span class="keyword">this</span>.key=key;</span><br><span class="line">            <span class="keyword">this</span>.value=value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用于存储缓存，键为缓存的键，值为key、value组成的Node</span></span><br><span class="line">    Map&lt;Integer,Node&gt; cache;</span><br><span class="line">    <span class="comment">//用于存储频次，键为某个Node调用次数，值为对应频次的双向链表</span></span><br><span class="line">    Map&lt;Integer,LinkedHashSet&lt;Node&gt;&gt; freqMap;</span><br><span class="line">    <span class="comment">//缓存的容量</span></span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="comment">//记录最小调用次数</span></span><br><span class="line">    <span class="keyword">int</span> min;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LFUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity=capacity;</span><br><span class="line">        cache=<span class="keyword">new</span> HashMap&lt;&gt;(capacity);</span><br><span class="line">        freqMap=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回key对应的value值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果缓存中不存在key，直接返回-1</span></span><br><span class="line">        <span class="keyword">if</span>(!cache.containsKey(key))&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到对应的node</span></span><br><span class="line">        Node node=cache.get(key);</span><br><span class="line">        <span class="comment">//更新调用频次</span></span><br><span class="line">        freqInc(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将记录(key,value)插入缓存结构</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> key,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果缓存中已经存在这个key</span></span><br><span class="line">        <span class="keyword">if</span>(cache.containsKey(key))&#123;</span><br><span class="line">            <span class="comment">//找到对应的node，设置值为value，更新频次</span></span><br><span class="line">            Node node=cache.get(key);</span><br><span class="line">            node.value=value;</span><br><span class="line">            freqInc(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果缓存中不存在这个key</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//如果缓存的大小达到了容量capacity</span></span><br><span class="line">            <span class="keyword">if</span>(cache.size()==capacity)&#123;</span><br><span class="line">                <span class="comment">//根据策略从双向链表删掉对应的节点</span></span><br><span class="line">                Node deadNode=removeNode();</span><br><span class="line">                <span class="comment">//从缓存中移除对应的key</span></span><br><span class="line">                cache.remove(deadNode.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//新建一个Node，将其放入缓存，并在双向链表添加该Node</span></span><br><span class="line">            Node newNode=<span class="keyword">new</span> Node(key,value);</span><br><span class="line">            cache.put(key,newNode);</span><br><span class="line">            addNode(newNode);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//更新频次</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">freqInc</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="comment">//找到对应的双向链表，移除掉node</span></span><br><span class="line">        <span class="keyword">int</span> freq=node.freq;</span><br><span class="line">        LinkedHashSet&lt;Node&gt; set=freqMap.get(freq);</span><br><span class="line">        set.remove(node);</span><br><span class="line">        <span class="comment">//如果删掉的刚好是最小频次，并且只存在一个这样的node，需要更新min</span></span><br><span class="line">        <span class="keyword">if</span>(freq==min&amp;&amp;set.size()==<span class="number">0</span>)&#123;</span><br><span class="line">            min=freq+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//node对应的频次加1</span></span><br><span class="line">        node.freq++;</span><br><span class="line">        <span class="comment">//找到node新的频次对应的双向链表</span></span><br><span class="line">        LinkedHashSet&lt;Node&gt; newSet=freqMap.get(node.freq);</span><br><span class="line">        <span class="keyword">if</span>(newSet==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果为空，新建一个，并放到缓存</span></span><br><span class="line">            newSet=<span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">            freqMap.put(node.freq,newSet);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在新的频次对应的双向链表中添加node</span></span><br><span class="line">        newSet.add(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据策略从双向链表删掉对应的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">removeNode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//找到最小频次对应的双向链表</span></span><br><span class="line">        LinkedHashSet&lt;Node&gt; set=freqMap.get(min);</span><br><span class="line">        <span class="comment">//找到该链表中最早进来的node</span></span><br><span class="line">        Node deadNode=set.iterator().next();</span><br><span class="line">        <span class="comment">//移除掉这个node</span></span><br><span class="line">        set.remove(deadNode);</span><br><span class="line">        <span class="keyword">return</span> deadNode;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在频次为1的链表中添加新的node</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNode</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="comment">//找到频次为1的链表</span></span><br><span class="line">        LinkedHashSet&lt;Node&gt; set=freqMap.get(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(set==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果为空，新建一个并放入频次map</span></span><br><span class="line">            set=<span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">            freqMap.put(<span class="number">1</span>,set);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加node，并设置min为1</span></span><br><span class="line">        set.add(node);</span><br><span class="line">        min=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Decucin
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://yoursite.com/2022/03/13/%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3/" title="牛客TOP101题解">http://yoursite.com/2022/03/13/牛客题解/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%89%9B%E5%AE%A2/" rel="tag"># 牛客</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/01/01/2022%E5%B9%B41%E6%9C%88/" rel="prev" title="2022年leetcode每日一题">
      <i class="fa fa-chevron-left"></i> 2022年leetcode每日一题
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  
  


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#链表"><span class="nav-number">1.</span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#BM1-反转链表"><span class="nav-number">1.1.</span> <span class="nav-text">BM1 反转链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述"><span class="nav-number">1.1.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解"><span class="nav-number">1.1.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现"><span class="nav-number">1.1.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM2-链表内指定区间反转"><span class="nav-number">1.2.</span> <span class="nav-text">BM2 链表内指定区间反转</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-1"><span class="nav-number">1.2.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-1"><span class="nav-number">1.2.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-1"><span class="nav-number">1.2.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM3-链表中的节点每k个一组翻转"><span class="nav-number">1.3.</span> <span class="nav-text">BM3 链表中的节点每k个一组翻转</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-2"><span class="nav-number">1.3.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-2"><span class="nav-number">1.3.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-2"><span class="nav-number">1.3.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM4-合并两个排序的链表"><span class="nav-number">1.4.</span> <span class="nav-text">BM4 合并两个排序的链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-3"><span class="nav-number">1.4.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-3"><span class="nav-number">1.4.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-3"><span class="nav-number">1.4.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM5-合并k个已排序的链表"><span class="nav-number">1.5.</span> <span class="nav-text">BM5 合并k个已排序的链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-4"><span class="nav-number">1.5.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-4"><span class="nav-number">1.5.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-4"><span class="nav-number">1.5.3.</span> <span class="nav-text">Java代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-5"><span class="nav-number">1.5.4.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-5"><span class="nav-number">1.5.5.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM6-判断链表中是否有环"><span class="nav-number">1.6.</span> <span class="nav-text">BM6 判断链表中是否有环</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-5"><span class="nav-number">1.6.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-6"><span class="nav-number">1.6.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-6"><span class="nav-number">1.6.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM7-链表中环的入口节点"><span class="nav-number">1.7.</span> <span class="nav-text">BM7 链表中环的入口节点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-6"><span class="nav-number">1.7.1.</span> <span class="nav-text">题目描述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#输入描述"><span class="nav-number">1.7.1.1.</span> <span class="nav-text">输入描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值描述"><span class="nav-number">1.7.1.2.</span> <span class="nav-text">返回值描述</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-7"><span class="nav-number">1.7.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-7"><span class="nav-number">1.7.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM8-链表中倒数最后k个节点"><span class="nav-number">1.8.</span> <span class="nav-text">BM8 链表中倒数最后k个节点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-7"><span class="nav-number">1.8.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-8"><span class="nav-number">1.8.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-8"><span class="nav-number">1.8.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM9-删除链表的倒数第n个节点"><span class="nav-number">1.9.</span> <span class="nav-text">BM9 删除链表的倒数第n个节点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-8"><span class="nav-number">1.9.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-9"><span class="nav-number">1.9.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-9"><span class="nav-number">1.9.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM10-两个链表的第一个公共结点"><span class="nav-number">1.10.</span> <span class="nav-text">BM10 两个链表的第一个公共结点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-9"><span class="nav-number">1.10.1.</span> <span class="nav-text">题目描述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#输入描述："><span class="nav-number">1.10.1.1.</span> <span class="nav-text">输入描述：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值描述："><span class="nav-number">1.10.1.2.</span> <span class="nav-text">返回值描述：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-10"><span class="nav-number">1.10.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-10"><span class="nav-number">1.10.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM11-链表相加（二）"><span class="nav-number">1.11.</span> <span class="nav-text">BM11 链表相加（二）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-10"><span class="nav-number">1.11.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-11"><span class="nav-number">1.11.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-11"><span class="nav-number">1.11.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM12-单链表的排序问题"><span class="nav-number">1.12.</span> <span class="nav-text">BM12 单链表的排序问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-11"><span class="nav-number">1.12.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-12"><span class="nav-number">1.12.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-12"><span class="nav-number">1.12.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM13-判断一个链表是否是回文结构"><span class="nav-number">1.13.</span> <span class="nav-text">BM13 判断一个链表是否是回文结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-12"><span class="nav-number">1.13.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-13"><span class="nav-number">1.13.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-13"><span class="nav-number">1.13.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM14-链表的奇偶重拍"><span class="nav-number">1.14.</span> <span class="nav-text">BM14 链表的奇偶重拍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-13"><span class="nav-number">1.14.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-14"><span class="nav-number">1.14.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-14"><span class="nav-number">1.14.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM15-删除有序链表中重复的元素-I"><span class="nav-number">1.15.</span> <span class="nav-text">BM15 删除有序链表中重复的元素-I</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-14"><span class="nav-number">1.15.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-15"><span class="nav-number">1.15.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-15"><span class="nav-number">1.15.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM16-删除有序列表中重复的元素-II"><span class="nav-number">1.16.</span> <span class="nav-text">BM16 删除有序列表中重复的元素-II</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-15"><span class="nav-number">1.16.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-16"><span class="nav-number">1.16.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-16"><span class="nav-number">1.16.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二分查找-排序"><span class="nav-number">2.</span> <span class="nav-text">二分查找&#x2F;排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#BM17-二分查找-I"><span class="nav-number">2.1.</span> <span class="nav-text">BM17 二分查找-I</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-16"><span class="nav-number">2.1.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-17"><span class="nav-number">2.1.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-17"><span class="nav-number">2.1.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM18-二维数组中的查找"><span class="nav-number">2.2.</span> <span class="nav-text">BM18 二维数组中的查找</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-17"><span class="nav-number">2.2.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-18"><span class="nav-number">2.2.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-18"><span class="nav-number">2.2.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM19-寻找峰值"><span class="nav-number">2.3.</span> <span class="nav-text">BM19 寻找峰值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-18"><span class="nav-number">2.3.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-19"><span class="nav-number">2.3.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-19"><span class="nav-number">2.3.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM20-数组中的逆序对"><span class="nav-number">2.4.</span> <span class="nav-text">BM20 数组中的逆序对</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-19"><span class="nav-number">2.4.1.</span> <span class="nav-text">题目描述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解-20"><span class="nav-number">2.5.</span> <span class="nav-text">题解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-20"><span class="nav-number">2.5.1.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM21-旋转数组的最小数字"><span class="nav-number">2.6.</span> <span class="nav-text">BM21 旋转数组的最小数字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-20"><span class="nav-number">2.6.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-21"><span class="nav-number">2.6.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-21"><span class="nav-number">2.6.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM22-比较版本号"><span class="nav-number">2.7.</span> <span class="nav-text">BM22 比较版本号</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-21"><span class="nav-number">2.7.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-22"><span class="nav-number">2.7.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现如下"><span class="nav-number">2.7.3.</span> <span class="nav-text">Java代码实现如下</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-23"><span class="nav-number">2.7.4.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-22"><span class="nav-number">2.7.5.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二叉树"><span class="nav-number">3.</span> <span class="nav-text">二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BM23-二叉树的前序遍历"><span class="nav-number">3.0.1.</span> <span class="nav-text">BM23 二叉树的前序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-22"><span class="nav-number">3.0.2.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-24"><span class="nav-number">3.0.3.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-23"><span class="nav-number">3.0.4.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM24-二叉树的中序遍历"><span class="nav-number">3.1.</span> <span class="nav-text">BM24 二叉树的中序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-23"><span class="nav-number">3.1.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-25"><span class="nav-number">3.1.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-24"><span class="nav-number">3.1.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM25-二叉树的后序遍历"><span class="nav-number">3.2.</span> <span class="nav-text">BM25 二叉树的后序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-24"><span class="nav-number">3.2.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-26"><span class="nav-number">3.2.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-25"><span class="nav-number">3.2.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM26-求二叉树的层序遍历"><span class="nav-number">3.3.</span> <span class="nav-text">BM26 求二叉树的层序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-25"><span class="nav-number">3.3.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-27"><span class="nav-number">3.3.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-26"><span class="nav-number">3.3.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM27-按之字形顺序打印二叉树"><span class="nav-number">3.4.</span> <span class="nav-text">BM27 按之字形顺序打印二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-26"><span class="nav-number">3.4.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-28"><span class="nav-number">3.4.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-27"><span class="nav-number">3.4.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM28-二叉树的最大深度"><span class="nav-number">3.5.</span> <span class="nav-text">BM28 二叉树的最大深度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-27"><span class="nav-number">3.5.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-29"><span class="nav-number">3.5.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-28"><span class="nav-number">3.5.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM29-二叉树中和为某一值的路径"><span class="nav-number">3.6.</span> <span class="nav-text">BM29 二叉树中和为某一值的路径</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-28"><span class="nav-number">3.6.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-30"><span class="nav-number">3.6.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-29"><span class="nav-number">3.6.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM30-二叉搜索树与双向链表"><span class="nav-number">3.7.</span> <span class="nav-text">BM30 二叉搜索树与双向链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-29"><span class="nav-number">3.7.1.</span> <span class="nav-text">题目描述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#输入描述：-1"><span class="nav-number">3.7.1.1.</span> <span class="nav-text">输入描述：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值描述：-1"><span class="nav-number">3.7.1.2.</span> <span class="nav-text">返回值描述：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-31"><span class="nav-number">3.7.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-30"><span class="nav-number">3.7.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM31对称的二叉树"><span class="nav-number">3.8.</span> <span class="nav-text">BM31对称的二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-30"><span class="nav-number">3.8.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-32"><span class="nav-number">3.8.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-31"><span class="nav-number">3.8.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM32-合并二叉树"><span class="nav-number">3.9.</span> <span class="nav-text">BM32 合并二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-31"><span class="nav-number">3.9.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-33"><span class="nav-number">3.9.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-32"><span class="nav-number">3.9.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM33-二叉树的镜像"><span class="nav-number">3.10.</span> <span class="nav-text">BM33 二叉树的镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-32"><span class="nav-number">3.10.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-34"><span class="nav-number">3.10.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-33"><span class="nav-number">3.10.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM34-判断是不是二叉搜索树"><span class="nav-number">3.11.</span> <span class="nav-text">BM34 判断是不是二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-33"><span class="nav-number">3.11.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-35"><span class="nav-number">3.11.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-34"><span class="nav-number">3.11.3.</span> <span class="nav-text">Java代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-36"><span class="nav-number">3.11.4.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-35"><span class="nav-number">3.11.5.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM35-判断是不是完全二叉树"><span class="nav-number">3.12.</span> <span class="nav-text">BM35 判断是不是完全二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-34"><span class="nav-number">3.12.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-37"><span class="nav-number">3.12.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-36"><span class="nav-number">3.12.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM36-判断是不是平衡二叉树"><span class="nav-number">3.13.</span> <span class="nav-text">BM36 判断是不是平衡二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-35"><span class="nav-number">3.13.1.</span> <span class="nav-text">题目描述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#输入描述：-2"><span class="nav-number">3.13.1.1.</span> <span class="nav-text">输入描述：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值描述：-2"><span class="nav-number">3.13.1.2.</span> <span class="nav-text">返回值描述：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-38"><span class="nav-number">3.13.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-37"><span class="nav-number">3.13.3.</span> <span class="nav-text">Java代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-38"><span class="nav-number">3.13.4.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM37-二叉搜索树的最近公共祖先"><span class="nav-number">3.14.</span> <span class="nav-text">BM37 二叉搜索树的最近公共祖先</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-36"><span class="nav-number">3.14.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-39"><span class="nav-number">3.14.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-39"><span class="nav-number">3.14.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM38-在二叉树中找到两个节点的最近公共祖先"><span class="nav-number">3.15.</span> <span class="nav-text">BM38 在二叉树中找到两个节点的最近公共祖先</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-37"><span class="nav-number">3.15.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-40"><span class="nav-number">3.15.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-40"><span class="nav-number">3.15.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM39-序列化二叉树"><span class="nav-number">3.16.</span> <span class="nav-text">BM39 序列化二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-38"><span class="nav-number">3.16.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-41"><span class="nav-number">3.16.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-41"><span class="nav-number">3.16.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM40-重建二叉树"><span class="nav-number">3.17.</span> <span class="nav-text">BM40 重建二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-39"><span class="nav-number">3.17.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-42"><span class="nav-number">3.17.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-42"><span class="nav-number">3.17.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM41-输出二叉树的右试图"><span class="nav-number">3.18.</span> <span class="nav-text">BM41 输出二叉树的右试图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-40"><span class="nav-number">3.18.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-43"><span class="nav-number">3.18.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-43"><span class="nav-number">3.18.3.</span> <span class="nav-text">Java代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-44"><span class="nav-number">3.18.4.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-44"><span class="nav-number">3.18.5.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#堆-栈-队列"><span class="nav-number">4.</span> <span class="nav-text">堆&#x2F;栈&#x2F;队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#BM42-用两个栈实现队列"><span class="nav-number">4.1.</span> <span class="nav-text">BM42 用两个栈实现队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-41"><span class="nav-number">4.1.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-45"><span class="nav-number">4.1.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-45"><span class="nav-number">4.1.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM43-包含min函数的栈"><span class="nav-number">4.2.</span> <span class="nav-text">BM43 包含min函数的栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-42"><span class="nav-number">4.2.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-46"><span class="nav-number">4.2.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-46"><span class="nav-number">4.2.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM44-有效括号序列"><span class="nav-number">4.3.</span> <span class="nav-text">BM44 有效括号序列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-43"><span class="nav-number">4.3.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-47"><span class="nav-number">4.3.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-47"><span class="nav-number">4.3.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM45-滑动窗口的最大值"><span class="nav-number">4.4.</span> <span class="nav-text">BM45 滑动窗口的最大值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-44"><span class="nav-number">4.4.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-48"><span class="nav-number">4.4.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-48"><span class="nav-number">4.4.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM46-最小的K个树"><span class="nav-number">4.5.</span> <span class="nav-text">BM46 最小的K个树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-45"><span class="nav-number">4.5.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-49"><span class="nav-number">4.5.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-49"><span class="nav-number">4.5.3.</span> <span class="nav-text">Java代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-50"><span class="nav-number">4.5.4.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM47-寻找第k大"><span class="nav-number">4.6.</span> <span class="nav-text">BM47 寻找第k大</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#描述"><span class="nav-number">4.6.1.</span> <span class="nav-text">描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-51"><span class="nav-number">4.6.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-50"><span class="nav-number">4.6.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM48-数据流中的中位数"><span class="nav-number">4.7.</span> <span class="nav-text">BM48 数据流中的中位数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-46"><span class="nav-number">4.7.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-52"><span class="nav-number">4.7.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-51"><span class="nav-number">4.7.3.</span> <span class="nav-text">Java代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-53"><span class="nav-number">4.7.4.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-52"><span class="nav-number">4.7.5.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM49-表达式求值"><span class="nav-number">4.8.</span> <span class="nav-text">BM49 表达式求值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-47"><span class="nav-number">4.8.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-54"><span class="nav-number">4.8.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-53"><span class="nav-number">4.8.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#哈希"><span class="nav-number">5.</span> <span class="nav-text">哈希</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#BM50-两数之和"><span class="nav-number">5.1.</span> <span class="nav-text">BM50 两数之和</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-48"><span class="nav-number">5.1.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-55"><span class="nav-number">5.1.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-54"><span class="nav-number">5.1.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM51-数组中出现次数超过一半的数字"><span class="nav-number">5.2.</span> <span class="nav-text">BM51 数组中出现次数超过一半的数字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-49"><span class="nav-number">5.2.1.</span> <span class="nav-text">题目描述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#输入描述-1"><span class="nav-number">5.2.1.1.</span> <span class="nav-text">输入描述</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-56"><span class="nav-number">5.2.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-55"><span class="nav-number">5.2.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM52-数组中只出现一次的两个数字"><span class="nav-number">5.3.</span> <span class="nav-text">BM52 数组中只出现一次的两个数字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-50"><span class="nav-number">5.3.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-57"><span class="nav-number">5.3.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-56"><span class="nav-number">5.3.3.</span> <span class="nav-text">Java代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-58"><span class="nav-number">5.3.4.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-57"><span class="nav-number">5.3.5.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM53-缺失的第一个正整数"><span class="nav-number">5.4.</span> <span class="nav-text">BM53 缺失的第一个正整数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-51"><span class="nav-number">5.4.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-59"><span class="nav-number">5.4.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-58"><span class="nav-number">5.4.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM54-三数之和"><span class="nav-number">5.5.</span> <span class="nav-text">BM54 三数之和</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-52"><span class="nav-number">5.5.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-60"><span class="nav-number">5.5.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-59"><span class="nav-number">5.5.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#递归-回溯"><span class="nav-number">6.</span> <span class="nav-text">递归&#x2F;回溯</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#BM55-没有重复数字的全排列"><span class="nav-number">6.1.</span> <span class="nav-text">BM55 没有重复数字的全排列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-53"><span class="nav-number">6.1.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-61"><span class="nav-number">6.1.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-60"><span class="nav-number">6.1.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM56-有重复项数字的全排列"><span class="nav-number">6.2.</span> <span class="nav-text">BM56 有重复项数字的全排列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-54"><span class="nav-number">6.2.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-62"><span class="nav-number">6.2.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-61"><span class="nav-number">6.2.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM57-岛屿数量"><span class="nav-number">6.3.</span> <span class="nav-text">BM57 岛屿数量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-55"><span class="nav-number">6.3.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-63"><span class="nav-number">6.3.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-62"><span class="nav-number">6.3.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM58-字符串的排列"><span class="nav-number">6.4.</span> <span class="nav-text">BM58 字符串的排列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-56"><span class="nav-number">6.4.1.</span> <span class="nav-text">题目描述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#输入描述-2"><span class="nav-number">6.4.1.1.</span> <span class="nav-text">输入描述</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-64"><span class="nav-number">6.4.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-63"><span class="nav-number">6.4.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM59-N皇后问题"><span class="nav-number">6.5.</span> <span class="nav-text">BM59 N皇后问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-57"><span class="nav-number">6.5.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-65"><span class="nav-number">6.5.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-64"><span class="nav-number">6.5.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM60-括号生成"><span class="nav-number">6.6.</span> <span class="nav-text">BM60 括号生成</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-58"><span class="nav-number">6.6.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-66"><span class="nav-number">6.6.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-65"><span class="nav-number">6.6.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM61-矩阵最长递增路径"><span class="nav-number">6.7.</span> <span class="nav-text">BM61 矩阵最长递增路径</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-59"><span class="nav-number">6.7.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-67"><span class="nav-number">6.7.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-66"><span class="nav-number">6.7.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#动态规划"><span class="nav-number">7.</span> <span class="nav-text">动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#BM62-斐波那契数列"><span class="nav-number">7.1.</span> <span class="nav-text">BM62 斐波那契数列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-60"><span class="nav-number">7.1.1.</span> <span class="nav-text">题目描述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#输入描述：-3"><span class="nav-number">7.1.1.1.</span> <span class="nav-text">输入描述：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值描述：-3"><span class="nav-number">7.1.1.2.</span> <span class="nav-text">返回值描述：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-68"><span class="nav-number">7.1.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-67"><span class="nav-number">7.1.3.</span> <span class="nav-text">Java代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-69"><span class="nav-number">7.1.4.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-68"><span class="nav-number">7.1.5.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM63-跳台阶"><span class="nav-number">7.2.</span> <span class="nav-text">BM63 跳台阶</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-61"><span class="nav-number">7.2.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-70"><span class="nav-number">7.2.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-69"><span class="nav-number">7.2.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM64-最小花费爬楼梯"><span class="nav-number">7.3.</span> <span class="nav-text">BM64 最小花费爬楼梯</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-62"><span class="nav-number">7.3.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-71"><span class="nav-number">7.3.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-70"><span class="nav-number">7.3.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM65-最长公共子序列（二）"><span class="nav-number">7.4.</span> <span class="nav-text">BM65 最长公共子序列（二）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-63"><span class="nav-number">7.4.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-72"><span class="nav-number">7.4.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-71"><span class="nav-number">7.4.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM66-最长公共子串"><span class="nav-number">7.5.</span> <span class="nav-text">BM66 最长公共子串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-64"><span class="nav-number">7.5.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-73"><span class="nav-number">7.5.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-72"><span class="nav-number">7.5.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM67-不同路径的数目（一）"><span class="nav-number">7.6.</span> <span class="nav-text">BM67 不同路径的数目（一）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-65"><span class="nav-number">7.6.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-74"><span class="nav-number">7.6.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-73"><span class="nav-number">7.6.3.</span> <span class="nav-text">Java代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-75"><span class="nav-number">7.6.4.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-74"><span class="nav-number">7.6.5.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM68-矩阵的最小路径和"><span class="nav-number">7.7.</span> <span class="nav-text">BM68 矩阵的最小路径和</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-66"><span class="nav-number">7.7.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-76"><span class="nav-number">7.7.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-75"><span class="nav-number">7.7.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM69-把数字翻译成字符串"><span class="nav-number">7.8.</span> <span class="nav-text">BM69 把数字翻译成字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-67"><span class="nav-number">7.8.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-77"><span class="nav-number">7.8.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-76"><span class="nav-number">7.8.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM70-兑换零钱（一）"><span class="nav-number">7.9.</span> <span class="nav-text">BM70 兑换零钱（一）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-68"><span class="nav-number">7.9.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-78"><span class="nav-number">7.9.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-77"><span class="nav-number">7.9.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM71-最长上升子序列（一）"><span class="nav-number">7.10.</span> <span class="nav-text">BM71 最长上升子序列（一）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-69"><span class="nav-number">7.10.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-79"><span class="nav-number">7.10.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-78"><span class="nav-number">7.10.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM72-连续子数组的最大和"><span class="nav-number">7.11.</span> <span class="nav-text">BM72 连续子数组的最大和</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-70"><span class="nav-number">7.11.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-80"><span class="nav-number">7.11.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-79"><span class="nav-number">7.11.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM73-最长回文子串"><span class="nav-number">7.12.</span> <span class="nav-text">BM73 最长回文子串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-71"><span class="nav-number">7.12.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-81"><span class="nav-number">7.12.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-82"><span class="nav-number">7.12.3.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-80"><span class="nav-number">7.12.4.</span> <span class="nav-text">Java代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-83"><span class="nav-number">7.12.5.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-81"><span class="nav-number">7.12.6.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM74-数字字符串转化成IP地址"><span class="nav-number">7.13.</span> <span class="nav-text">BM74 数字字符串转化成IP地址</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-72"><span class="nav-number">7.13.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-84"><span class="nav-number">7.13.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-82"><span class="nav-number">7.13.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM75-编辑距离（一）"><span class="nav-number">7.14.</span> <span class="nav-text">BM75 编辑距离（一）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-73"><span class="nav-number">7.14.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-85"><span class="nav-number">7.14.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-83"><span class="nav-number">7.14.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM76-正则表达式匹配"><span class="nav-number">7.15.</span> <span class="nav-text">BM76 正则表达式匹配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-74"><span class="nav-number">7.15.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-86"><span class="nav-number">7.15.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-84"><span class="nav-number">7.15.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM77-最长的括号子串"><span class="nav-number">7.16.</span> <span class="nav-text">BM77 最长的括号子串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-75"><span class="nav-number">7.16.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-87"><span class="nav-number">7.16.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-85"><span class="nav-number">7.16.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM78-打家劫舍（一）"><span class="nav-number">7.17.</span> <span class="nav-text">BM78 打家劫舍（一）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-76"><span class="nav-number">7.17.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-88"><span class="nav-number">7.17.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-86"><span class="nav-number">7.17.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM79-打家劫舍（二）"><span class="nav-number">7.18.</span> <span class="nav-text">BM79 打家劫舍（二）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-77"><span class="nav-number">7.18.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-89"><span class="nav-number">7.18.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-87"><span class="nav-number">7.18.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM80-买卖股票的最好时机（一）"><span class="nav-number">7.19.</span> <span class="nav-text">BM80 买卖股票的最好时机（一）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-78"><span class="nav-number">7.19.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-90"><span class="nav-number">7.19.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-88"><span class="nav-number">7.19.3.</span> <span class="nav-text">Java代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-91"><span class="nav-number">7.19.4.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-89"><span class="nav-number">7.19.5.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM81-买卖股票的最好时机（二）"><span class="nav-number">7.20.</span> <span class="nav-text">BM81 买卖股票的最好时机（二）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-79"><span class="nav-number">7.20.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-92"><span class="nav-number">7.20.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-90"><span class="nav-number">7.20.3.</span> <span class="nav-text">Java代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-93"><span class="nav-number">7.20.4.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-91"><span class="nav-number">7.20.5.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM82-买卖股票的最好时机（三）"><span class="nav-number">7.21.</span> <span class="nav-text">BM82 买卖股票的最好时机（三）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-80"><span class="nav-number">7.21.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-94"><span class="nav-number">7.21.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-92"><span class="nav-number">7.21.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#字符串"><span class="nav-number">8.</span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#BM83-字符串变形"><span class="nav-number">8.1.</span> <span class="nav-text">BM83 字符串变形</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-81"><span class="nav-number">8.1.1.</span> <span class="nav-text">题目描述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#输入描述：-4"><span class="nav-number">8.1.1.1.</span> <span class="nav-text">输入描述：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值描述：-4"><span class="nav-number">8.1.1.2.</span> <span class="nav-text">返回值描述：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-95"><span class="nav-number">8.1.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-93"><span class="nav-number">8.1.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM84-最长公共前缀"><span class="nav-number">8.2.</span> <span class="nav-text">BM84 最长公共前缀</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-82"><span class="nav-number">8.2.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-96"><span class="nav-number">8.2.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-94"><span class="nav-number">8.2.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM85-验证IP地址"><span class="nav-number">8.3.</span> <span class="nav-text">BM85 验证IP地址</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-83"><span class="nav-number">8.3.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-97"><span class="nav-number">8.3.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-95"><span class="nav-number">8.3.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM86-大数加法"><span class="nav-number">8.4.</span> <span class="nav-text">BM86 大数加法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-84"><span class="nav-number">8.4.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-98"><span class="nav-number">8.4.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-96"><span class="nav-number">8.4.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#双指针"><span class="nav-number">9.</span> <span class="nav-text">双指针</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#BM87-合并两个有序的数组"><span class="nav-number">9.1.</span> <span class="nav-text">BM87 合并两个有序的数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-85"><span class="nav-number">9.1.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-99"><span class="nav-number">9.1.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-97"><span class="nav-number">9.1.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM88-判断是否为回文字符串"><span class="nav-number">9.2.</span> <span class="nav-text">BM88 判断是否为回文字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-86"><span class="nav-number">9.2.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-100"><span class="nav-number">9.2.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-98"><span class="nav-number">9.2.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM89-合并区间"><span class="nav-number">9.3.</span> <span class="nav-text">BM89 合并区间</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-87"><span class="nav-number">9.3.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-101"><span class="nav-number">9.3.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-99"><span class="nav-number">9.3.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM90-最小覆盖子串"><span class="nav-number">9.4.</span> <span class="nav-text">BM90 最小覆盖子串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-88"><span class="nav-number">9.4.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-102"><span class="nav-number">9.4.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-100"><span class="nav-number">9.4.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM91-反转字符串"><span class="nav-number">9.5.</span> <span class="nav-text">BM91 反转字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-89"><span class="nav-number">9.5.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-103"><span class="nav-number">9.5.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-101"><span class="nav-number">9.5.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM92-最长无重复子数组"><span class="nav-number">9.6.</span> <span class="nav-text">BM92 最长无重复子数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-90"><span class="nav-number">9.6.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-104"><span class="nav-number">9.6.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-102"><span class="nav-number">9.6.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM93-盛水最多的容器"><span class="nav-number">9.7.</span> <span class="nav-text">BM93 盛水最多的容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-91"><span class="nav-number">9.7.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-105"><span class="nav-number">9.7.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-103"><span class="nav-number">9.7.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM94-接雨水问题"><span class="nav-number">9.8.</span> <span class="nav-text">BM94 接雨水问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-92"><span class="nav-number">9.8.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-106"><span class="nav-number">9.8.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-104"><span class="nav-number">9.8.3.</span> <span class="nav-text">Java代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-107"><span class="nav-number">9.8.4.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-105"><span class="nav-number">9.8.5.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#贪心算法"><span class="nav-number">10.</span> <span class="nav-text">贪心算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#BM95-分糖果问题"><span class="nav-number">10.1.</span> <span class="nav-text">BM95 分糖果问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-93"><span class="nav-number">10.1.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-108"><span class="nav-number">10.1.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-106"><span class="nav-number">10.1.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM96-主持人调度（二）"><span class="nav-number">10.2.</span> <span class="nav-text">BM96 主持人调度（二）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-94"><span class="nav-number">10.2.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-109"><span class="nav-number">10.2.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-107"><span class="nav-number">10.2.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#模拟"><span class="nav-number">11.</span> <span class="nav-text">模拟</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#BM97-旋转数组"><span class="nav-number">11.1.</span> <span class="nav-text">BM97 旋转数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-95"><span class="nav-number">11.1.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-110"><span class="nav-number">11.1.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-108"><span class="nav-number">11.1.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM98-螺旋矩阵"><span class="nav-number">11.2.</span> <span class="nav-text">BM98 螺旋矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-96"><span class="nav-number">11.2.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-111"><span class="nav-number">11.2.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-109"><span class="nav-number">11.2.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM99-顺时针旋转矩阵"><span class="nav-number">11.3.</span> <span class="nav-text">BM99 顺时针旋转矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-97"><span class="nav-number">11.3.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-112"><span class="nav-number">11.3.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java代码实现"><span class="nav-number">11.3.3.</span> <span class="nav-text">java代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-113"><span class="nav-number">11.3.4.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-110"><span class="nav-number">11.3.5.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM100-设计LRU缓存结构"><span class="nav-number">11.4.</span> <span class="nav-text">BM100 设计LRU缓存结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-98"><span class="nav-number">11.4.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-114"><span class="nav-number">11.4.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-111"><span class="nav-number">11.4.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM101-设计LFU缓存结构"><span class="nav-number">11.5.</span> <span class="nav-text">BM101 设计LFU缓存结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-99"><span class="nav-number">11.5.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-115"><span class="nav-number">11.5.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-112"><span class="nav-number">11.5.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Decucin"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Decucin</p>
  <div class="site-description" itemprop="description">喜欢简单的事物和明朗的关系</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/decucin" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;decucin" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1690406856@qq.com" title="E-Mail → mailto:1690406856@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/decucin" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;decucin" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020-05 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Decucin</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">219k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">3:19</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>


	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
	<span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
	<span class="post-meta-divider">|</span>
	<span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
	<span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值矫正 -->
<script>
$(document).ready(function() {

	var int = setInterval(fixCount, 50);
	var count0ffset = 20000;
	
	function fixCount(){
		if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
		{
			$("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + count0ffset);
			clearInterval(int);
		}
		if ($("#busuanzi_value_site_pv").css("display") != "none")
		{
			$("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) +count0ffset);
			clearInterval(int);
		}
	}
});
</script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  <script type="text/javascript" src="/js/love.js"></script>
</body>
</html>
