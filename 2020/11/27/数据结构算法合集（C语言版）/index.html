<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="数据结构算法合集（C语言版）在学习《数据结构（C语言版）》一书时，我将其中的算法在此记录，以便有需要时进行查阅。">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构算法合集（C语言版）">
<meta property="og:url" content="http://yoursite.com/2020/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%EF%BC%88C%E8%AF%AD%E8%A8%80%E7%89%88%EF%BC%89/index.html">
<meta property="og:site_name" content="Blog of Decucin">
<meta property="og:description" content="数据结构算法合集（C语言版）在学习《数据结构（C语言版）》一书时，我将其中的算法在此记录，以便有需要时进行查阅。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-11-27T05:19:23.117Z">
<meta property="article:modified_time" content="2020-09-27T15:58:12.782Z">
<meta property="article:author" content="Decucin">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2020/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%EF%BC%88C%E8%AF%AD%E8%A8%80%E7%89%88%EF%BC%89/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>数据结构算法合集（C语言版） | Blog of Decucin</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Blog of Decucin" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Blog of Decucin</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%EF%BC%88C%E8%AF%AD%E8%A8%80%E7%89%88%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Decucin">
      <meta itemprop="description" content="喜欢简单的事物和明朗的关系">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of Decucin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据结构算法合集（C语言版）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-27 13:19:23" itemprop="dateCreated datePublished" datetime="2020-11-27T13:19:23+08:00">2020-11-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-27 23:58:12" itemprop="dateModified" datetime="2020-09-27T23:58:12+08:00">2020-09-27</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>50k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>46 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="数据结构算法合集（C语言版）"><a href="#数据结构算法合集（C语言版）" class="headerlink" title="数据结构算法合集（C语言版）"></a>数据结构算法合集（C语言版）</h1><p>在学习《数据结构（C语言版）》一书时，我将其中的算法在此记录，以便有需要时进行查阅。</p>
<a id="more"></a>

<p><strong>注：以&amp;开头的参数为引用参数。</strong></p>
<h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><p>定义抽象数据类型的格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ADT 抽象数据类型名&#123;</span><br><span class="line">	数据对象：&lt;数据对象的定义&gt;</span><br><span class="line">	数据关系：&lt;数据关系的定义&gt;</span><br><span class="line">	基本操作：&lt;基本操作的定义&gt;</span><br><span class="line">&#125;ADT 抽象数据类型名</span><br></pre></td></tr></table></figure>

<p>操作的定义格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">基本操作名（参数表）</span><br><span class="line">	初始条件:&lt;初始条件描述&gt;</span><br><span class="line">	操作结果:&lt;操作结果描述&gt;</span><br></pre></td></tr></table></figure>

<p>预定义常量和类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;函数结果状态代码</span><br><span class="line">#define	TRUE	1</span><br><span class="line">#define	FALSE	0</span><br><span class="line">#define	OK		1</span><br><span class="line">#define	ERROR	0</span><br><span class="line">#define	INFEASIBLE	-1</span><br><span class="line">#define	OVERFLOW	-2</span><br><span class="line">&#x2F;&#x2F;Status是函数的类型，其值是函数结果的状态代码</span><br><span class="line">typedef	int	Status;</span><br></pre></td></tr></table></figure>

<p>基本操作的算法的函数描述：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">函数类型	函数名（函数参数表）&#123;</span><br><span class="line">	&#x2F;&#x2F;算法说明</span><br><span class="line">	语句序列</span><br><span class="line">&#125;&#x2F;&#x2F;函数名</span><br></pre></td></tr></table></figure>



<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>扩大线性表LA，将存在于线性表LB中而不存在于线性表LA中的数据元素插入到线性表LA中去：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void union(List &amp;La, List)&#123;</span><br><span class="line">	&#x2F;&#x2F;将所有在线性表Lb中但不在La中的数据元素插入到La中</span><br><span class="line">	La_len &#x3D; ListLenth(La);&#x2F;&#x2F;求线性表长度</span><br><span class="line">	Lb_len &#x3D; ListLenth(Lb);&#x2F;&#x2F;求线性表长度</span><br><span class="line">	for(i &#x3D; 1; i &lt;&#x3D; Lb_len; i++)&#123;</span><br><span class="line">		GetElem(Lb,i,e);</span><br><span class="line">		if(!LocateElem(La, e, equal))</span><br><span class="line">			ListInsert(La, ++La_len, e);&#x2F;&#x2F;La中不存在和e相同的数据元素，则插入之</span><br><span class="line">	&#125;</span><br><span class="line">&#125;&#x2F;&#x2F; union</span><br></pre></td></tr></table></figure>

<p>已知线性表LA，LB中数据元素均按值非递减有序排列，现需将LA，LB归并为新的线性表LC，且LC中的数据元素仍按值非递减有序排列：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void MergeList(List La, List Lb, List &amp;Lc)&#123;</span><br><span class="line">	&#x2F;&#x2F;已知线性表La和Lb中的数据元素按值非递减排列</span><br><span class="line">	&#x2F;&#x2F;归并La和Lb得到新的线性表Lc，Lc的数据元素也按值非递减排列</span><br><span class="line">	InitList(Lc);</span><br><span class="line">	i &#x3D; j &#x3D; 1;</span><br><span class="line">	k &#x3D; 0;</span><br><span class="line">	La_len &#x3D; ListLenth(La);</span><br><span class="line">	Lb_len &#x3D; ListLenth(Lb);</span><br><span class="line">	while((i &lt;&#x3D; La_len) &amp;&amp; (j &lt;&#x3D; Lb_len))&#123;&#x2F;&#x2F;La与Lb均非空</span><br><span class="line">	GetElem(La, i, ai);</span><br><span class="line">	GetElem(Lb, j, bj);</span><br><span class="line">	if(ai &lt;&#x3D; bj)&#123;</span><br><span class="line">		ListInsert(Lc, ++k;, ai);</span><br><span class="line">		++i;</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		ListInsert(Lc, ++k, bj);</span><br><span class="line">		++j;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	while(i &lt;&#x3D; La_len)&#123;</span><br><span class="line">		GetElem(La, i++, ai);</span><br><span class="line">		ListInsert(Lc, ++k, ai);</span><br><span class="line">	&#125;</span><br><span class="line">	while(j &lt;&#x3D; Lb_len)&#123;</span><br><span class="line">		GetElem(Lb, j++, bj);</span><br><span class="line">		ListInsert(Lc, ++k,bj);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;MergeList</span><br></pre></td></tr></table></figure>

<p>用数组来描述顺序存储结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;-----线性表的动态分配顺序存储结构-----</span><br><span class="line">#define LIST_INIT_SIZE 100  &#x2F;&#x2F;线性表存储空间的初始分配量</span><br><span class="line">#define LISTINCREMENT 10    &#x2F;&#x2F;线性表存储空间的分配增量</span><br><span class="line">typedef struct&#123;</span><br><span class="line">	ElemType *elem;   &#x2F;&#x2F;存储空间基址</span><br><span class="line">	int lenth;        &#x2F;&#x2F;当前长度</span><br><span class="line">	int listsize;     &#x2F;&#x2F;当前分配的存储容量（以sizeof(ElemType)为单位</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>

<p>顺序表的初始化（分配一个预定义大小的数组空间，并将线性表的当前长度设为“0”）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Status InitList_Sq(SqList &amp;L)&#123;</span><br><span class="line">	&#x2F;&#x2F;构造一个空的线性表L</span><br><span class="line">	L.elem &#x3D; (ElemType *)malloc(LIST_INIT_SIZE * sizeof(ElemType));</span><br><span class="line">	if(!L.elem)</span><br><span class="line">		exit(OVERFLOW);</span><br><span class="line">	L.lenth &#x3D; 0;</span><br><span class="line">	L.listsize &#x3D; LIST_INIT_SIZE;</span><br><span class="line">	return OK;</span><br><span class="line">&#125;&#x2F;&#x2F;InitList_Sq</span><br></pre></td></tr></table></figure>

<p>线性表的插入（在第i个元素之前插入一个元素）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Status ListInsert_Sq(SqList &amp;L, int i, ElemType e)&#123;</span><br><span class="line">	&#x2F;&#x2F;在顺序线性表L中第i个位置之前插入新的元素e</span><br><span class="line">	if(i &lt; 1 || i &gt; L.lenth + 1)</span><br><span class="line">		retur ERROR;&#x2F;&#x2F;i值不合法</span><br><span class="line">	if(L.lenth &gt;&#x3D; L.listsize)&#123;&#x2F;&#x2F;当前存储空间已满，增加分配</span><br><span class="line">		newbase &#x3D; (ElemType *)realloc(L.elem, (L.Listsize + LISTINCREMENT) * sizeof(ElemType));</span><br><span class="line">	if(!newbase)</span><br><span class="line">		exit(OVERFLOW);         &#x2F;&#x2F;存储分配失败</span><br><span class="line">	L.elm &#x3D; newbase;            &#x2F;&#x2F;新基址</span><br><span class="line">	L.listsize +&#x3D; LISTINCREMENT;&#x2F;&#x2F;增加存储容量</span><br><span class="line">	&#125;</span><br><span class="line">	q &#x3D; &amp;(L.elem[i-1]);&#x2F;&#x2F;q为插入位置</span><br><span class="line">	for(p &#x3D; &amp;(L.elem[L.lenth-1]);</span><br><span class="line">		p &gt;&#x3D; q; --p) * (p+1) &#x3D; *p;</span><br><span class="line">	&#x2F;&#x2F;插入位置及之后的元素右移</span><br><span class="line">	*q &#x3D; e;       &#x2F;&#x2F;插入e</span><br><span class="line">	++L.lenth;    &#x2F;&#x2F;表长增1</span><br><span class="line">	return OK;</span><br><span class="line">&#125;&#x2F;&#x2F;ListInsert_Sq</span><br><span class="line">&#x2F;&#x2F;先操作地址再操作值，否则无法确定后一数的具体位置</span><br></pre></td></tr></table></figure>

<p>线性表的删除（删除第i个元素，并用e返回其值）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Status ListDelete_Sq(SqList &amp;L, int i, ElemType &amp;e)&#123;</span><br><span class="line">	&#x2F;&#x2F;在顺序线性表L中删除第i个元素，并用e返回其值</span><br><span class="line">	if((i &lt; 1) || (i &gt; L.lenth))  &#x2F;&#x2F;i值不合法</span><br><span class="line">		return ERROR;    </span><br><span class="line">	p &#x3D; &amp;(L.elem[i-1]);  &#x2F;&#x2F;p为被删除元素的位置</span><br><span class="line">	e &#x3D; *p;       &#x2F;&#x2F;被删除元素赋值给e</span><br><span class="line">	q &#x3D; L.elem + L.lenth - 1;  &#x2F;&#x2F;表尾元素的位置</span><br><span class="line">	for(++q; p &lt;&#x3D;q; ++p)  &#x2F;&#x2F;被删除元素之后的元素左移</span><br><span class="line">		*(p-1) &#x3D; *p;      </span><br><span class="line">	--L.lenth;     &#x2F;&#x2F;表长减1</span><br><span class="line">	return OK;     </span><br><span class="line">&#125;&#x2F;&#x2F;ListDelete_Sq</span><br></pre></td></tr></table></figure>

<p>进行两个元素之间的比较（查找第一个值与e满足compare()的元素的位序）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int LocateElem_Sq(SqList L, ElemType e, Status(*compare)(ElemType, ElemType))&#123;</span><br><span class="line">	&#x2F;&#x2F;在顺序表L中查找第一个值与e满足compare()的元素的位序</span><br><span class="line">	&#x2F;&#x2F;若找到，返回其在L中的位序，否则返回0</span><br><span class="line">	i &#x3D; 1;           &#x2F;&#x2F;i的初值为第1个元素的位序</span><br><span class="line">	p &#x3D; L.elem;      &#x2F;&#x2F;p的初值为第1个元素的存储位置</span><br><span class="line">	while(i &lt;&#x3D; L.lenth &amp;&amp; !(*compare)(*p++, e))</span><br><span class="line">		++i;</span><br><span class="line">	if(i &lt;&#x3D; L.lenth)</span><br><span class="line">		return i;</span><br><span class="line">	else</span><br><span class="line">		return 0;</span><br><span class="line">&#125;&#x2F;&#x2F;LocateElem_Sq</span><br></pre></td></tr></table></figure>

<p>书中算法2.7与之前的算法类似，因此此处不在重复，但书中提到一点：即当*pa = *pb，即两集合中元素相同时，只需将两者其中之一插入Lc，并将两者均后移即可。（合并线性表LA，LB为新表LC算法）</p>
<p>单链表的表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;-----线性表的单链表存储结构-----</span><br><span class="line">typedef struct LNode&#123;</span><br><span class="line">	ElemType data;</span><br><span class="line">	struct LNode *next;</span><br><span class="line">&#125;LNode, *LinkList;</span><br></pre></td></tr></table></figure>

<p>单链表中获取第i个元素的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Status GetElem_L(LinkList L, int i, ElemType &amp;e)&#123;</span><br><span class="line">	&#x2F;&#x2F;L为带头结点的单链表的头指针</span><br><span class="line">	&#x2F;&#x2F;当第i个元素存在时，其值赋给e并返回OK，否则返回ERROR</span><br><span class="line">	p &#x3D; L-&gt;next;  &#x2F;&#x2F;初始化，p指向第1个结点</span><br><span class="line">	j &#x3D; 1;    &#x2F;&#x2F;j为计数器</span><br><span class="line">	while(p &amp;&amp; j&lt;i)&#123;   &#x2F;&#x2F;顺指针向后查找，直到p指向第i个元素或p为空</span><br><span class="line">		p &#x3D; p-&gt;next;</span><br><span class="line">		++j;</span><br><span class="line">	&#125;</span><br><span class="line">	if(!p || j&gt;i)   &#x2F;&#x2F;第i个元素不存在</span><br><span class="line">		return ERROR; </span><br><span class="line">	e &#x3D; p-&gt;data;    &#x2F;&#x2F;取第i个元素</span><br><span class="line">	return OK;</span><br><span class="line">&#125;&#x2F;&#x2F;GetElem_L</span><br></pre></td></tr></table></figure>

<p>单链表添加元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Status ListInsert_L(LinkList &amp;L, int i, ElemType e)&#123;</span><br><span class="line">	&#x2F;&#x2F;在带头结点的单链线性表L中第i个位置之前插入元素</span><br><span class="line">	p &#x3D; L;</span><br><span class="line">	j &#x3D; 0;</span><br><span class="line">	while(p &amp;&amp; j &lt; i-1)&#123;</span><br><span class="line">		p &#x3D; p-&gt;next;</span><br><span class="line">		++j;</span><br><span class="line">	&#125;&#x2F;&#x2F;寻找第i-1个结点</span><br><span class="line">	if(!p || j&gt;i-1) &#x2F;&#x2F;i小于1或者大于表长加1</span><br><span class="line">		return ERROR;</span><br><span class="line">	s &#x3D; (LinkList)malloc(sizeof(LNode)); &#x2F;&#x2F;生成新结点</span><br><span class="line">	s-&gt;data &#x3D; e;</span><br><span class="line">	s-&gt;next &#x3D; p-&gt;next;</span><br><span class="line">	&#x2F;&#x2F;插入L中</span><br><span class="line">	p-next &#x3D; s;</span><br><span class="line">	return OK;</span><br><span class="line">&#125;&#x2F;&#x2F;ListInsert_L</span><br></pre></td></tr></table></figure>

<p>单链表删除元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Status ListDelete_L(LinkList &amp;L, int i, ElemType &amp;e)&#123;</span><br><span class="line">	&#x2F;&#x2F;在带头结点的单链线性表L中，删除第i个元素，并由e返回其值</span><br><span class="line">	p &#x3D; L;</span><br><span class="line">	j &#x3D; 0;</span><br><span class="line">	while(p-&gt;next &amp;&amp; j &lt; i-1)&#123; &#x2F;&#x2F;寻找第i个结点，并令p指向其前驱</span><br><span class="line">		p &#x3D; p-&gt;next;</span><br><span class="line">		++j;</span><br><span class="line">	&#125;</span><br><span class="line">	if(!(p-&gt;next) || j&gt;i-1)</span><br><span class="line">		return ERROR;&#x2F;&#x2F;删除位置不合理</span><br><span class="line">	q &#x3D; p-&gt;next;</span><br><span class="line">	p-&gt;next &#x3D; q-&gt;next;&#x2F;&#x2F;删除并释放结点</span><br><span class="line">	e &#x3D; q-&gt;data;</span><br><span class="line">	free(q);</span><br><span class="line">	return OK;</span><br><span class="line">&#125;&#x2F;&#x2F;ListDelete_L</span><br></pre></td></tr></table></figure>

<p>从表尾到表头逆向建立单链表的算法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void CreateList_L(LinkLIst &amp;L, int n)&#123;</span><br><span class="line">	&#x2F;&#x2F;逆位序输入n个元素的值，建立带头结点的单链线性表L</span><br><span class="line">	L &#x3D; (Linklist)malloc(sizeof(LNode));</span><br><span class="line">	L-&gt;next &#x3D; NULL;  &#x2F;&#x2F;先建立一个带头结点的单链表</span><br><span class="line">	for(i &#x3D; n; i &gt; 0; --i)&#123;</span><br><span class="line">		p &#x3D; (LinkList)malloc(sizeof(LNode));  &#x2F;&#x2F;生成新结点</span><br><span class="line">		scanf(&amp;p-&gt;data);   &#x2F;&#x2F;输入元素值</span><br><span class="line">		p-&gt;next &#x3D; L-&gt;next &#x3D; p;  &#x2F;&#x2F;插入到表头</span><br><span class="line">	&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;CreateList_L</span><br></pre></td></tr></table></figure>

<p>将两个有序链表合并为一个有序链表:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void MergeList_L(LinkList &amp;La, LinkList &amp;Lb, LinkList &amp;Lc)&#123;</span><br><span class="line">	&#x2F;&#x2F;已知单链线性表La和Lb的元素按值非递减排列</span><br><span class="line">	&#x2F;&#x2F;归并La和Lb得到新的单链线性表Lc，Lc的元素也按值非递减排列</span><br><span class="line">	pa &#x3D; La-&gt;next;</span><br><span class="line">	pb &#x3D; Lb-&gt;next;</span><br><span class="line">	Lc &#x3D; pc &#x3D;La;    &#x2F;&#x2F;用La的头结点作为Lc的头结点</span><br><span class="line">	while(pa &amp;&amp; pb)&#123;</span><br><span class="line">		if(pa-&gt;data &lt;&#x3D; pb-&gt;data)&#123;</span><br><span class="line">			pc-&gt;next &#x3D; pa;</span><br><span class="line">			pc &#x3D; pa;</span><br><span class="line">			pa &#x3D; pa-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			pc-&gt;next &#x3D; pb;</span><br><span class="line">			pc &#x3D; pb;</span><br><span class="line">			pb &#x3D; pb-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	pc-&gt;next &#x3D; pa? pa : pb;  &#x2F;&#x2F;插入剩余段</span><br><span class="line">	free(Lb);   &#x2F;&#x2F;释放Lb的头结点</span><br><span class="line">&#125;&#x2F;&#x2F;MergeList_L</span><br></pre></td></tr></table></figure>

<p>一维数组描述线性链表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;-----线性表的静态单链表存储结构-----</span><br><span class="line">#define MAXSIZE 1000</span><br><span class="line">typedef struct&#123;</span><br><span class="line">	ElemType data;</span><br><span class="line">	int cur;</span><br><span class="line">&#125;component,SLinkList[MAXSIZE];</span><br></pre></td></tr></table></figure>

<p>在静态链表中实现定位：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int LocateElem_SL(SLinkList S, ElemType e)&#123;</span><br><span class="line">	&#x2F;&#x2F;在静态单链线性表L中查找第1个值为e的元素</span><br><span class="line">	&#x2F;&#x2F;若找到，则返回它在L的位序，否则返回0</span><br><span class="line">	i &#x3D; S[0].cur;   &#x2F;&#x2F;i指示表中第一个结点</span><br><span class="line">	while(i &amp;&amp; S[i].data !&#x3D; e)</span><br><span class="line">		i &#x3D; S[i].cur;    &#x2F;&#x2F;在表中顺链查找</span><br><span class="line">	return i;</span><br><span class="line">&#125;&#x2F;&#x2F;LOcateElem_SL</span><br></pre></td></tr></table></figure>

<p><strong>注：为了辨明静态链表（数组）中哪些分量未被使用，可将所有未被使用过以及被删除的分量用游标链成一个备用的链表，需要插入时便可从备用链表上取得第一个结点作为待插入的新结点，需要删除时将从链表中删除下来的结点链接到备用链表上。</strong></p>
<p>将数组空间初始化为链表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void InitSpace_SL(SLinkList &amp;space)&#123;</span><br><span class="line">	&#x2F;&#x2F;将一维数组space中各分量链成一个备用链表，space[0].cur为头指针</span><br><span class="line">	&#x2F;&#x2F;“0”表示空指针</span><br><span class="line">	for(i &#x3D; 0; i &lt; MAXSIZE - 1; ++i)</span><br><span class="line">		space[i].cur &#x3D; i + 1；</span><br><span class="line">	space[MAXSIZE-1].cur &#x3D; 0;</span><br><span class="line">&#125;&#x2F;&#x2F;InitSpace_SL</span><br></pre></td></tr></table></figure>

<p>从备用空间取得一个结点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int Malloc_SL(SLinkList &amp;space)&#123;</span><br><span class="line">	&#x2F;&#x2F;若备用空间链表非空，则返回分配的结点下标，否则返回0</span><br><span class="line">	i &#x3D; space[0].cur;</span><br><span class="line">	if(space[0].cur)</span><br><span class="line">		space[0].cur &#x3D; space[i].cur;</span><br><span class="line">	return i;</span><br><span class="line">&#125;&#x2F;&#x2F;Malloc_SL</span><br></pre></td></tr></table></figure>

<p>将空闲结点链接到备用列表上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void Free_SL(SLinkList &amp;space, int k)&#123;</span><br><span class="line">	&#x2F;&#x2F;将下标为k的空闲结点回收到备用列表</span><br><span class="line">	space[k].cur &#x3D; space[0].cur;</span><br><span class="line">	space[0].cur &#x3D; k;</span><br><span class="line">&#125;&#x2F;&#x2F;Free_SL</span><br></pre></td></tr></table></figure>

<p>已知集合A,B，求集合(A-B)U(B-A)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">void difference(SLinkList &amp;space, int &amp;s)&#123;</span><br><span class="line">	&#x2F;&#x2F;依次输入集合A和B的元素，在一维数组space中建立表示集合(A-B)U(B-A)的静态链表，S为其头指针</span><br><span class="line">	&#x2F;&#x2F;假设备用空间足够大，space[0].cur为其头指针</span><br><span class="line">	InitSpace_SL(space);    &#x2F;&#x2F;初始化备用空间</span><br><span class="line">	S &#x3D; Malloc_SL(space);   &#x2F;&#x2F;生成S的头结点</span><br><span class="line">	r &#x3D; S;                  &#x2F;&#x2F;r指向S的当前最后一个结点</span><br><span class="line">	scanf(m, n);            &#x2F;&#x2F;输入A和B的元素个数</span><br><span class="line">	for(j &#x3D; 1; j &lt;&#x3D; m; ++j)&#123;&#x2F;&#x2F;建立集合A的链表</span><br><span class="line">		i &#x3D; Malloc_SL(space);&#x2F;&#x2F;分配结点</span><br><span class="line">		scanf(space[i].data);&#x2F;&#x2F;输入A的元素值</span><br><span class="line">		space[r].cur &#x3D; i;</span><br><span class="line">		r &#x3D; i;&#x2F;&#x2F;插入到表尾</span><br><span class="line">	&#125;&#x2F;&#x2F;for</span><br><span class="line">	space[r].cur &#x3D; 0;        &#x2F;&#x2F;尾结点的指针为空</span><br><span class="line">	for(j &#x3D; 1; j &lt;&#x3D; n; ++j)&#123;&#x2F;&#x2F;依次输入B的元素，若不在当前表中，则插入，否则删除</span><br><span class="line">		scanf(b);</span><br><span class="line">		p &#x3D; S;</span><br><span class="line">		k &#x3D; space[S].cur    &#x2F;&#x2F;k指向集合A中第一个结点</span><br><span class="line">		while(k !&#x3D; space[r].cur &amp;&amp; space[k].data !&#x3D; b)&#123;&#x2F;&#x2F;在当前表中查找</span><br><span class="line">			p &#x3D; k;</span><br><span class="line">			k &#x3D; space[k].cur;</span><br><span class="line">		&#125;&#x2F;&#x2F;while</span><br><span class="line">		if(k &#x3D;&#x3D; space[r].cur)&#123;&#x2F;&#x2F;当前表中不存在该元素，插入在r所指结点之后，且r的位置不变</span><br><span class="line">			i &#x3D; Malloc_SL(space);</span><br><span class="line">			space[i].data &#x3D; b;</span><br><span class="line">			space[i].cur &#x3D; space[r].cur;</span><br><span class="line">			space[r].cur &#x3D; i;</span><br><span class="line">		&#125;&#x2F;&#x2F;if</span><br><span class="line">		else&#123;&#x2F;&#x2F;该元素已在表中，删除之</span><br><span class="line">			space[p].cur &#x3D; space[k].cur;</span><br><span class="line">			Free_SL(space, k);</span><br><span class="line">			if(r &#x3D;&#x3D; k)</span><br><span class="line">				r &#x3D; p;      &#x2F;&#x2F;若删除的是r所指结点，则需修改尾指针</span><br><span class="line">		&#125;&#x2F;&#x2F;else</span><br><span class="line">	&#125;&#x2F;&#x2F;for</span><br><span class="line">&#125;&#x2F;&#x2F;difference</span><br></pre></td></tr></table></figure>

<p>双向链表的C语言表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;-----线性表的双向链表存储结构-----</span><br><span class="line">typedef struct DuLNode&#123;</span><br><span class="line">	ElemType data;</span><br><span class="line">	struct DuLNode *prior;</span><br><span class="line">	struct DuLNode *next;</span><br><span class="line">&#125;DuLNode, *DuLinkList;</span><br></pre></td></tr></table></figure>

<p>双向链表插入元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Status ListInsert_DuL(DuLinkList &amp;L, int i, ElemType e)&#123;</span><br><span class="line">	&#x2F;&#x2F;在带头结点的双链循环线性表L中第i个位置之前插入元素e</span><br><span class="line">	if(!(p &#x3D; GetElemP_DuL(L, i)))    &#x2F;&#x2F;在L中确定插入位置</span><br><span class="line">		return ERROR;                &#x2F;&#x2F;p&#x3D;NULL，即插入位置不合法</span><br><span class="line">	if(!(s &#x3D; (DuLinkList)malloc(sizeof(DuLNode))))</span><br><span class="line">		return ERROR;</span><br><span class="line">	s-&gt;data &#x3D; e;</span><br><span class="line">	s-&gt;piror &#x3D; p-&gt;piror;</span><br><span class="line">	p-&gt;piror-&gt;next &#x3D; s;</span><br><span class="line">	s-&gt;next &#x3D; p;</span><br><span class="line">	p-&gt;piror &#x3D; s;</span><br><span class="line">	return OK;</span><br><span class="line">&#125;&#x2F;&#x2F;ListInsert_DuL</span><br></pre></td></tr></table></figure>

<p>双向链表删除元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Status ListDelete_DuL(DuLinkList &amp;L, int i, ElemType &amp;e)&#123;</span><br><span class="line">	&#x2F;&#x2F;删除带头结点的双链循环线性表L的第i个元素</span><br><span class="line">	if(!(p &#x3D; GetElemP_DuL(L, i)))  &#x2F;&#x2F;在L中确定第i个元素的位置指针p</span><br><span class="line">		return ERROR;</span><br><span class="line">	e &#x3D; p-&gt;data;</span><br><span class="line">	p-&gt;piror-&gt;next &#x3D; p-&gt;next;</span><br><span class="line">	p-&gt;next-&gt;piror &#x3D; p-&gt;piror;</span><br><span class="line">	free(p);</span><br><span class="line">	return OK;</span><br><span class="line">&#125;&#x2F;&#x2F;ListDelete_DuL</span><br></pre></td></tr></table></figure>

<p>一个带头结点的线性链表定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">typedef struct LNode&#123;&#x2F;&#x2F;结点类型</span><br><span class="line">	ElemType data;</span><br><span class="line">	struct LNode *next;</span><br><span class="line">&#125;*Link, *Position;</span><br><span class="line"></span><br><span class="line">typedef struct&#123;&#x2F;&#x2F;链表类型</span><br><span class="line">	Link head, tail;  &#x2F;&#x2F;分别指向线性链表中的头结点和最后一个结点</span><br><span class="line">	int len;          &#x2F;&#x2F;指示线性链表中数据元素的个数</span><br><span class="line">&#125; LinkList;</span><br><span class="line"></span><br><span class="line">Status MakeNode(Link &amp;p, ElemType e);</span><br><span class="line">	&#x2F;&#x2F;分配由p指向的值为e的结点，并返回OK；若分配失败，则返回ERROR</span><br><span class="line">void FreeNode( Link &amp;p);</span><br><span class="line">	&#x2F;&#x2F;释放p所指结点</span><br><span class="line"></span><br><span class="line">Status InitList(LinkList &amp;L);</span><br><span class="line">	&#x2F;&#x2F;构造一个空的线性表L</span><br><span class="line">Status DestroyList(LinkList &amp;L);</span><br><span class="line">	&#x2F;&#x2F;销毁线性链表L，L不再存在</span><br><span class="line">Status ClearList(LinkList &amp;L);</span><br><span class="line">	&#x2F;&#x2F;将线性链表L重置为空表，并释放原链表L的结点空间</span><br><span class="line">Status InsFirst(Link h, Link s);</span><br><span class="line">	&#x2F;&#x2F;已知h指向线性链表的头结点，将s所指结点插入在第一个结点之前</span><br><span class="line">Status DelFirst(Link h, Link &amp;q);</span><br><span class="line">	&#x2F;&#x2F;已知h指向线性链表的头结点，删除链表中的第一个结点并以q返回</span><br><span class="line">Status Append(LinkList &amp;L,Link s);</span><br><span class="line">	&#x2F;&#x2F;将指针s所指（彼此以指针相链）的一串结点链在线性链表L的最后一个结点</span><br><span class="line">	&#x2F;&#x2F;之后，并改变链表L的尾指针指向新的尾结点</span><br><span class="line">Status Remove(LinkList &amp;L, Link &amp;q);</span><br><span class="line">	&#x2F;&#x2F;删除线性链表L中的尾结点并以q返回，改变链表L的尾指针指向新的尾结点</span><br><span class="line">Status InsBefore(LinkList &amp;L, Link &amp;p, Link s);</span><br><span class="line">	&#x2F;&#x2F;已知p指向线性链表L中的一个结点，将s所指结点插入在p所指结点之前，并修改指针p指向新的结点</span><br><span class="line">Status InsAfter(LinkList &amp;L, Link &amp;p, Link s);</span><br><span class="line">	&#x2F;&#x2F;已知p指向线性链表L中的一个结点，将s所指结点插入在p所指结点之后，并修改指针p指向新的结点</span><br><span class="line">Status SetCurElem( Link &amp;p, ElemType e);</span><br><span class="line">	&#x2F;&#x2F;已知p指向线性链表中的一个结点，用e更新p所指结点中数据元素的值</span><br><span class="line">ElemType GetCurElem(Link p);</span><br><span class="line">	&#x2F;&#x2F;已知p指向线性链表中的一个结点，返回p所指结点中数据元素的值</span><br><span class="line">Status ListEmpty(LinkList L);</span><br><span class="line">	&#x2F;&#x2F;若线性链表L为空表，则返回TURE，否则返回FALSE</span><br><span class="line">int ListLength(LinkList L);</span><br><span class="line">	&#x2F;&#x2F;返回线性链表L中元素个数</span><br><span class="line">Position GetHead(LinkList L);</span><br><span class="line">	&#x2F;&#x2F;返回线性链表L中头结点的位置</span><br><span class="line">Position GetLast(LinkList L);</span><br><span class="line">	&#x2F;&#x2F;返回线性链表L中最后一个结点的位置</span><br><span class="line">Position PriorPos(LinkList L, Link p);</span><br><span class="line">	&#x2F;&#x2F;已知p指向线性链表L中的一个结点，返回p所指结点的直接前驱的位置</span><br><span class="line">	&#x2F;&#x2F;若无前驱，则返回NULL</span><br><span class="line">Position NextPos(LinkList L, Link p);</span><br><span class="line">	&#x2F;&#x2F;已知p指向线性链表L中的一个结点，返回p所指结点的直接后继的位置</span><br><span class="line">	&#x2F;&#x2F;若无后继，则返回NULL</span><br><span class="line">Status LocatePos(LinkList L, int i, Link &amp;p);</span><br><span class="line">	&#x2F;&#x2F;返回p指示线性链表L中第i个结点的位置并返回OK；i值不合法时返回ERROR</span><br><span class="line">Position LocateElem(LinkList L, ElemType e, Status (*compare)(ElemType, ElemType));</span><br><span class="line">	&#x2F;&#x2F;返回线性链表L中第1个与e满足函数compare()关系的元素的位置</span><br><span class="line">	&#x2F;&#x2F;若不存在这样的元素，则返回NULL</span><br><span class="line">Status ListTraverse(LinkList L, Status (*visit)());</span><br><span class="line">	&#x2F;&#x2F;依次对L的每个元素调用函数visit()，一旦visit()失败，则操作失败</span><br></pre></td></tr></table></figure>

<p>在第i个元素之前插入元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Status ListInsert_L(LinkList &amp;L, int i, ElemType e)&#123;</span><br><span class="line">	&#x2F;&#x2F;在带头结点的单链线性表L的第i个元素之前插入元素e</span><br><span class="line">	if(!LocatePos(L, i-1, h))</span><br><span class="line">		return ERROR;    &#x2F;&#x2F;i值不合法</span><br><span class="line">	if(!MakeNode(s, e))</span><br><span class="line">		return ERROR;    &#x2F;&#x2F;结点存储分配失败</span><br><span class="line">	InsFirst(h, s);      &#x2F;&#x2F;对于从第i个结点开始的链表，第i-1个结点是它的头结点</span><br><span class="line">		return Ok;</span><br><span class="line">&#125;&#x2F;&#x2F;ListInsert_L</span><br></pre></td></tr></table></figure>

<p>两按值非递减排列的单链线性表合并为新的按值非递减排列的单链线性表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Status MergeList_L(LinkList &amp;La, LinkList &amp;Lb, LinkList &amp;Lc, int (*compare)(ElemType, Elemtype))&#123;</span><br><span class="line">	&#x2F;&#x2F;已知单链线性表La和Lb的元素按值非递减排列</span><br><span class="line">	&#x2F;&#x2F;排列La和Lb得到新的单链线性表Lc，Lc的元素也按值非递减排列</span><br><span class="line">	if(!InitList(Lc))</span><br><span class="line">		return ERROR;</span><br><span class="line">	ha &#x3D; GetHead(La);     &#x2F;&#x2F;ha指向La的头结点</span><br><span class="line">	hb &#x3D; GetHead(Lb);     &#x2F;&#x2F;hb指向Lb的头结点</span><br><span class="line">	pa &#x3D; NextPos(La, ha); &#x2F;&#x2F;pa指向La中当前结点</span><br><span class="line">	pb &#x3D; NextPos(Lb, hb); &#x2F;&#x2F;pb指向Lb中当前结点</span><br><span class="line">	while(pa&amp;&amp;pb)&#123;        &#x2F;&#x2F;La和Lb均非空</span><br><span class="line">		a &#x3D; GetCurElem(pa);</span><br><span class="line">		b &#x3D; GetCurElem(pb);  &#x2F;&#x2F;a和b为当前两表中比较元素</span><br><span class="line">		if((*compare)(a, b) &lt;&#x3D; 0)&#123;  &#x2F;&#x2F;a&lt;&#x3D;b</span><br><span class="line">			DelFirst(ha, q);</span><br><span class="line">			Append(Lc, q);</span><br><span class="line">			pa &#x3D; NextPos(La, ha);</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;  &#x2F;&#x2F;a&gt;&#x3D;b</span><br><span class="line">			DelFirst(hb, q);</span><br><span class="line">			Append(Lc, q);</span><br><span class="line">			pb &#x3D; NextPos(Lb, hb);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;&#x2F;&#x2F;while</span><br><span class="line">	if(pa)</span><br><span class="line">		Append(Lc, pa);   &#x2F;&#x2F;链接La中剩余结点</span><br><span class="line">	else</span><br><span class="line">		Append(Lc, pb);   &#x2F;&#x2F;链接Lb中剩余结点</span><br><span class="line">	FreeNode(ha);</span><br><span class="line">	FreeNode(hb);         &#x2F;&#x2F;释放La和Lb的头结点</span><br><span class="line">	return OK;</span><br><span class="line">&#125;&#x2F;&#x2F;MergeList_L</span><br></pre></td></tr></table></figure>

<p>抽象数据类型一元多项式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ADT Polynomial&#123;</span><br><span class="line">	数据对象：D &#x3D; &#123;ai | ai ∈ TermSet, i &#x3D; 1,2,...,m,  m&gt;&#x3D;0</span><br><span class="line">			TermSet中的每个元素包含一个表示系数的实数和表示指数的整数&#125;</span><br><span class="line">			</span><br><span class="line">	数据关系：R1 &#x3D; &#123;&lt;a(i-1),ai&gt;|a(i-1),ai∈D,且a(i-1)中的指数值&lt;ai中的指数值，i&#x3D;2,...,n&#125;</span><br><span class="line">	基本操作：</span><br><span class="line">		CreatPolyn( &amp;P, m )</span><br><span class="line">	  操作结果：输入m项的系数和指数，建立一元多项式P</span><br><span class="line">	  	DestroyPolyn( &amp;P )</span><br><span class="line">	  初始条件：一元多项式P已存在</span><br><span class="line">	  操作结果：销毁一元多项式P</span><br><span class="line">	  	PrintPolyn( P )</span><br><span class="line">	  初始条件：一元多项式P已存在</span><br><span class="line">	  操作结果：打印输出一元多项式P</span><br><span class="line">	  	PolynLength( P )</span><br><span class="line">	  初始条件：一元多项式P已存在</span><br><span class="line">	  操作结果：返回一元多项式P中的项数</span><br><span class="line">	  	AddPolyn( &amp;Pa, &amp;Pb )</span><br><span class="line">	  初始条件：一元多项式Pa和Pb已存在</span><br><span class="line">	  操作结果：完成多项式相加运算，即：Pa &#x3D; Pa + Pb，并销毁一元多项式Pb</span><br><span class="line">	  	SubtractPolyn( &amp;Pa, &amp;Pb )</span><br><span class="line">	  操作结果：完成多项式相减运算，即Pa&#x3D; Pa - Pb，并销毁一元多项式Pb</span><br><span class="line">	  	MultiplyPolyn( &amp;Pa, &amp;Pb )</span><br><span class="line">	  初始条件：一元多项式Pa和Pb已存在</span><br><span class="line">	  操作结果：完成多项式相乘运算，即Pa &#x3D; Pa * Pb，并销毁一元多项式Pb</span><br><span class="line">&#125;ADT Polynomial</span><br></pre></td></tr></table></figure>

<p>LocateElem()函数作用略有不同：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Status LocateElem(LinkList L, Elemtype e, Position &amp;q, int (*compare)(Elemtype, ElemType));</span><br><span class="line">	&#x2F;&#x2F;若有序链表L中存在与e满足判定函数compaare()取值为0的元素，则q指示L中第一个值为e的结点的位置</span><br><span class="line">	&#x2F;&#x2F;并返回TRUE，否则q指示第一个与e满足判定函数compare()取值&gt;0的元素的前驱位置，并返回FALSE</span><br></pre></td></tr></table></figure>

<p>OrderInsert()函数作用略有不同：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Status OrderInsert( LinkList &amp;L, ElemType e, int (*compare)(ElemType, ElemType));</span><br><span class="line">	&#x2F;&#x2F;按有序判定函数compare()的约定，将值为e的结点插入到有序链表L的 适当位置上</span><br></pre></td></tr></table></figure>

<p>抽象数据类型Polynomial的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">typedef struct&#123;    &#x2F;&#x2F;项的表示，多项式的项作为LinkList的数据元素</span><br><span class="line">	float coef;    &#x2F;&#x2F;系数</span><br><span class="line">	int   expn;    &#x2F;&#x2F;指数</span><br><span class="line">&#125;term, ElemType;   &#x2F;&#x2F;两个类型名：term用于本ADT，ElemType为LinkList的数据对象名</span><br><span class="line"></span><br><span class="line">typedef LinkList polynomial;    &#x2F;&#x2F;用带表头结点的有序链表表示多项式</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F;-----基本操作的函数原型说明-----</span><br><span class="line">void CreatPolyn( Polynomial &amp;p, int m )&#123;</span><br><span class="line">	&#x2F;&#x2F;输入m项的系数和指数，建立表示一元多项式的有序链表P</span><br><span class="line">	InitList(P);</span><br><span class="line">	h &#x3D; GetHead(P);</span><br><span class="line">	e.coef &#x3D; 0.0;</span><br><span class="line">	e.expn &#x3D; -1;</span><br><span class="line">	SetCurElem(h,e);   &#x2F;&#x2F;设置头结点的数据元素</span><br><span class="line">	for( i &#x3D; 1; i&lt;&#x3D;m; ++i)&#123;  &#x2F;&#x2F;依次输入m个非零项</span><br><span class="line">		scanf(e.coef, e.expn);</span><br><span class="line">		if(!LocateElem( P, e, q, (*cmp)()))&#123;  &#x2F;&#x2F;当前链表中不存在该指数项</span><br><span class="line">			if(MakeNode(s,e))</span><br><span class="line">				InsFirst( q, s );  &#x2F;&#x2F;生成结点并插入链表</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;CreatPolyn</span><br></pre></td></tr></table></figure>

<p>多项式加法实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">void AddPolyn( polynomial &amp;Pa, polynomial &amp;Pb)&#123;</span><br><span class="line">	&#x2F;&#x2F;多项式加法：Pa &#x3D; Pa+Pb，利用两个多项式的结点构成“和多项式”</span><br><span class="line">	ha &#x3D; GetHead(Pa);   &#x2F;&#x2F;ha指向Pa的头结点</span><br><span class="line">	hb &#x3D; GetHead(Pb);   &#x2F;&#x2F;hb指向Pb的头结点</span><br><span class="line">	qa &#x3D; NextPos(Pa,ha);   &#x2F;&#x2F;qa指向Pa中当前结点</span><br><span class="line">	qb &#x3D; NextPos(Pb,hb);   &#x2F;&#x2F;qb指向Pb中当前结点</span><br><span class="line">	while(qa &amp;&amp; Qb)&#123;	&#x2F;&#x2F;qa和qb均非空</span><br><span class="line">		a &#x3D; GetCurElem(qa);</span><br><span class="line">		b &#x3D; GetCurElem(qb);   &#x2F;&#x2F;a和b为两表中当前比较元素</span><br><span class="line">		switch( *cmp(a,b))&#123;</span><br><span class="line">			case -1:    &#x2F;&#x2F;多项式Pa中当前结点的指数值小</span><br><span class="line">				ha &#x3D; qa;</span><br><span class="line">				qa &#x3D; NextPos(Pa, qa);</span><br><span class="line">				break;</span><br><span class="line">			case 0:     &#x2F;&#x2F;两者的指数值相等</span><br><span class="line">				sum &#x3D; a.coef + b.coef;</span><br><span class="line">				if(sum !&#x3D; 0.0)&#123;	&#x2F;&#x2F;修改多项式Pa中当前结点的系数值</span><br><span class="line">					SetCurElem(qa,sum);</span><br><span class="line">					ha &#x3D; qa;</span><br><span class="line">				&#125;</span><br><span class="line">				else&#123;	&#x2F;&#x2F;删除多项式Pa中当前结点</span><br><span class="line">					DelFirst(ha, qa);</span><br><span class="line">					FreeNode(qa);</span><br><span class="line">				&#125;</span><br><span class="line">				DelFirst(hb, qb);</span><br><span class="line">				FreeNode(qb);</span><br><span class="line">				qb &#x3D; NextPos(Pb, hb);</span><br><span class="line">				qa &#x3D; NextPos(Pa, ha);</span><br><span class="line">				break;</span><br><span class="line">			case 1:	&#x2F;&#x2F;多项式Pb中当前结点的指数值小</span><br><span class="line">				DelFirst(hb, qb);</span><br><span class="line">				InsFirst( ha, qb);</span><br><span class="line">				qb &#x3D; NextPos(Pb, hb);</span><br><span class="line">				ha &#x3D; NextPos(Pa,ha);</span><br><span class="line">				break;</span><br><span class="line">		&#125;&#x2F;&#x2F;switch</span><br><span class="line">	&#125;&#x2F;&#x2F;while</span><br><span class="line">	if(!ListEmpty (Pb))</span><br><span class="line">		Append(Pa, qb);	&#x2F;&#x2F;链接Pb中剩余结点</span><br><span class="line">		FreeNode(hb);	&#x2F;&#x2F;释放Pb的头结点</span><br><span class="line">&#125;&#x2F;&#x2F;AddPolyn</span><br></pre></td></tr></table></figure>

<h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><p>栈的抽象数据类型定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">ADT	Stack&#123;</span><br><span class="line">	数据对象：D &#x3D; &#123;ai|ai∈ElemSet, i &#x3D; 1,2,...,n,	n&gt;&#x3D;0&#125;</span><br><span class="line">	数据关系：R1 &#x3D; &#123; &lt;a(i-1),ai&gt;|a(i-1),ai∈D, i &#x3D; 2,...,n&#125;</span><br><span class="line">			约定an端为栈顶，ai端为栈底</span><br><span class="line">	基本操作：</span><br><span class="line">		InitStack(&amp;S)</span><br><span class="line">	操作结果：构造一个空栈S</span><br><span class="line">		DestroyStack(&amp;S)</span><br><span class="line">	初始条件：栈S已存在</span><br><span class="line">	操作结果：栈S被销毁</span><br><span class="line">		ClearStack(&amp;S)</span><br><span class="line">	初始条件：栈S已存在</span><br><span class="line">	操作结果：将S清为空栈</span><br><span class="line">		StackEmpty(S)</span><br><span class="line">	初始条件：栈S已存在</span><br><span class="line">	操作结果：若栈S为空栈，则返回TRUE，否则返回FALSE</span><br><span class="line">		StackLength(S)</span><br><span class="line">	初始条件：栈S已存在</span><br><span class="line">	操作结果：返回S的元素个数，即栈的长度</span><br><span class="line">		GetTop(S,&amp;e)</span><br><span class="line">	初始条件：栈S已存在且非空</span><br><span class="line">	操作结果：用e返回S的栈顶元素</span><br><span class="line">		Push(&amp;S, &amp;e)</span><br><span class="line">	初始条件：栈S已存在</span><br><span class="line">	操作结果：插入元素e为新的栈顶元素</span><br><span class="line">		Pop(&amp;S, &amp;e)</span><br><span class="line">	初始条件：栈S已存在且非空</span><br><span class="line">	操作结果：删除S的栈顶元素，并用e返回其值</span><br><span class="line">		StackTraverse(S,visit())</span><br><span class="line">	初始条件：栈S已存在且非空</span><br><span class="line">	操作结果：从栈底到栈顶依次对S的每个元素调用函数visit()，一旦visit()失败，则操作失败</span><br><span class="line">&#125;ADT	Stack</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;之后也多为如上定义，并将插入元素操作称为入栈，删除栈顶元素的操作为出栈</span><br></pre></td></tr></table></figure>

<p>顺序栈的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef	struct&#123;</span><br><span class="line">	SElemType	*base;</span><br><span class="line">	SElemType	*top;</span><br><span class="line">	int		stacksize;</span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure>

<p>顺序栈的模块说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;ADT Stack的表示与实现&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;-----栈的顺序存储表示-----</span><br><span class="line">	</span><br><span class="line">#define STACK_INIT_SIZE	100;	&#x2F;&#x2F;存储空间初始分配量</span><br><span class="line">#define	STACKINCREMENT	10;		&#x2F;&#x2F;存储空间分配增量</span><br><span class="line">typedef	struct&#123;</span><br><span class="line">	SElemType	*base;	&#x2F;&#x2F;在栈构造之前和销毁之后，base的值为NULL</span><br><span class="line">	SElemType	*top;	&#x2F;&#x2F;栈顶指针</span><br><span class="line">	int	stacksize;		&#x2F;&#x2F;当前已分配的存储空间，以元素为单位</span><br><span class="line">&#125;SqStack;</span><br><span class="line">&#x2F;&#x2F;-----	基本操作的函数原型说明	-----</span><br><span class="line">Status	InitStack(SqStack &amp;S);</span><br><span class="line">	&#x2F;&#x2F;构造一个空栈S</span><br><span class="line">Status	DestroyStack(SqStack &amp;S);</span><br><span class="line">	&#x2F;&#x2F;销毁栈S，S不在存在</span><br><span class="line">Status	ClearStack(SqStack	&amp;S);</span><br><span class="line">	&#x2F;&#x2F;把S置为空栈</span><br><span class="line">Status	StackEmpty(SqStack	S);</span><br><span class="line">	&#x2F;&#x2F;若栈S为空栈，则返回TRUE，否则返回FALSE</span><br><span class="line">int StackLength(SqStack S);</span><br><span class="line">	&#x2F;&#x2F;返回S的元素个数，即栈的长度</span><br><span class="line">Status GetTop(SqStack S, SElemType &amp;e);</span><br><span class="line">	&#x2F;&#x2F;若栈不空，则用e返回S的栈顶元素，并返回OK，否则返回ERROR</span><br><span class="line">Status Push(SqStack &amp;S,SElemType e);</span><br><span class="line">	&#x2F;&#x2F;插入元素e为新的栈顶元素</span><br><span class="line">Status Pop(SqStack &amp;S, SElemType &amp;e);</span><br><span class="line">	&#x2F;&#x2F;若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK，否则返回ERROR</span><br><span class="line">Status StackTraverse(SqStack S, Status (*visit)());</span><br><span class="line">	&#x2F;&#x2F;从栈底到栈顶依次对栈中每个元素调用函数visit()，一旦visit()失败，则操作失败</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;-----	基本操作的算法描述（部分） -----</span><br><span class="line">Status InitStack (SqStack &amp;S)&#123;</span><br><span class="line">	&#x2F;&#x2F;构造一个空栈S</span><br><span class="line">	S.base &#x3D; (SElemType	*)malloc(STACK_INIT_SIZE * sizeof(SElemType));</span><br><span class="line">	if(!S.base)</span><br><span class="line">		exit(OVERFLOW);	&#x2F;&#x2F;存储分配失败</span><br><span class="line">		S.top &#x3D; S.base;</span><br><span class="line">		S.stacksize &#x3D; STACK_INIT_SIZE;</span><br><span class="line">		return OK;</span><br><span class="line">&#125;&#x2F;&#x2F;InitStack</span><br><span class="line"></span><br><span class="line">Status	GetTop(SqStack	S, SElemType &amp;e)&#123;</span><br><span class="line">	&#x2F;&#x2F;若栈不空，则用e返回S的栈顶元素，并返回OK，否则返回ERROR</span><br><span class="line">	if(S.top &#x3D;&#x3D; S.base)</span><br><span class="line">		return ERROR;</span><br><span class="line">	e &#x3D; *(S.top - 1);</span><br><span class="line">	return OK;</span><br><span class="line">&#125;&#x2F;&#x2F;GetTop</span><br><span class="line"></span><br><span class="line">Status	Push(SqStack &amp;S, SElemType e)&#123;</span><br><span class="line">	&#x2F;&#x2F;插入元素e为新的栈顶元素</span><br><span class="line">	if(S.top - S.base &gt;&#x3D; S.stacksize)&#123;	&#x2F;&#x2F;栈满，追加存储空间</span><br><span class="line">		S.base &#x3D; (SElemType	*)realloc( S.base, (S.stacksize + STACKINCREMENT) * sizeof(SElemType));</span><br><span class="line">		if(!S.base)</span><br><span class="line">			exit(OVERFLOW);	&#x2F;&#x2F;存储分配失败</span><br><span class="line">		</span><br><span class="line">		S.top &#x3D; S.base + S.stacksize;</span><br><span class="line">		S.stacksize +&#x3D; STACKINCREMENT;</span><br><span class="line">	&#125;</span><br><span class="line">	*S.top++ &#x3D; e;</span><br><span class="line">	return OK;</span><br><span class="line">&#125;&#x2F;&#x2F;Push</span><br><span class="line"></span><br><span class="line">Status	Pop(SqStack	&amp;S,	SEleType &amp;e)&#123;</span><br><span class="line">	&#x2F;&#x2F;若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK，否则返回FALSE</span><br><span class="line">	if(S.top &#x3D;&#x3D; S.base)</span><br><span class="line">		return ERROR;</span><br><span class="line">	e &#x3D; * --S.top;</span><br><span class="line">	return OK;</span><br><span class="line">&#125;&#x2F;&#x2F;Pop</span><br></pre></td></tr></table></figure>

<p>十进制转八进制：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;进制计算与打印过程刚好相反，满足栈的特性</span><br><span class="line"></span><br><span class="line">void conversion()&#123;</span><br><span class="line">	&#x2F;&#x2F;对于输入的任意一个非负十进制整数，打印输出与其等值的八进制数</span><br><span class="line">	InitStack(S);	&#x2F;&#x2F;构造空栈</span><br><span class="line">	scanf(&quot;%d&quot;,N);</span><br><span class="line">	while(N)&#123;</span><br><span class="line">		Push(S, N % 8);</span><br><span class="line">		N &#x3D; N&#x2F;8;</span><br><span class="line">	&#125;</span><br><span class="line">	while(!StackEmpty(S))&#123;</span><br><span class="line">		Pop(S,e);</span><br><span class="line">		printf(&quot;%d&quot;,e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;conversion</span><br></pre></td></tr></table></figure>

<p>行编辑程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void LineEdit()&#123;</span><br><span class="line">	&#x2F;&#x2F;利用字符栈S，从终端接受一行并传送至调用过程的数据区</span><br><span class="line">	InitStack(S);	&#x2F;&#x2F;构造空栈S</span><br><span class="line">	ch &#x3D; getchar();	&#x2F;&#x2F;从终端接收第一个字符</span><br><span class="line">	while(ch !&#x3D; EOF)&#123;	&#x2F;&#x2F;EOF为全文结束符</span><br><span class="line">		while(ch !&#x3D; EOF &amp;&amp; ch !&#x3D; &#39;\n&#39;)&#123;</span><br><span class="line">			switch(ch)&#123;</span><br><span class="line">				case &#39;#&#39;:</span><br><span class="line">					Pop(S,c);</span><br><span class="line">					break;	&#x2F;&#x2F;仅当栈非空时退栈</span><br><span class="line">				case &#39;@&#39;:</span><br><span class="line">					ClearStack(S);</span><br><span class="line">					break;	&#x2F;&#x2F;重置S为空栈</span><br><span class="line">				default:</span><br><span class="line">					Push(S,ch);</span><br><span class="line">					break;	&#x2F;&#x2F;有效字符进栈，未考虑栈满情况</span><br><span class="line">			&#125;</span><br><span class="line">			ch &#x3D; getchar();	&#x2F;&#x2F;从终端接收下一个字符</span><br><span class="line">		&#125;</span><br><span class="line">		将从栈底到栈顶的栈内字符传送至调用过程的数据区</span><br><span class="line">		ClearStack(S);	&#x2F;&#x2F;重置S为空栈</span><br><span class="line">		if(ch!&#x3D;EOF)</span><br><span class="line">			ch &#x3D; getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	DestroyStack(S);</span><br><span class="line">&#125;&#x2F;&#x2F;LineEdit</span><br></pre></td></tr></table></figure>

<p>求迷宫中一条从入口到出口的路径的算法描述：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">do&#123;</span><br><span class="line">	若当前位置可通，则&#123;</span><br><span class="line">		将当前位置压入栈顶；			   &#x2F;&#x2F;  纳入路径</span><br><span class="line">		若当前位置是出口位置，则结束；		&#x2F;&#x2F;	求得路径存放在栈中</span><br><span class="line">		否则切换当前位置的东邻方块为新的当前位置；</span><br><span class="line">	&#125;</span><br><span class="line">	否则&#123;</span><br><span class="line">		若栈不空且栈顶位置尚有其他地方尚未探索，则&#123;</span><br><span class="line">			设定新的当前位置为沿顺时针方向旋转找到的栈顶位置的下一邻块</span><br><span class="line">		&#125;</span><br><span class="line">		若栈不空但栈顶位置的四周均不可通，则&#123;</span><br><span class="line">			删去栈顶位置；				 &#x2F;&#x2F;从路径中删去该通道块</span><br><span class="line">			若栈不空，则重新测试新的栈顶位置，，</span><br><span class="line">				直至找到一个可通的相邻块或出栈至栈空；</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;while(栈不空)</span><br></pre></td></tr></table></figure>

<p>实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">typedef	struct&#123;</span><br><span class="line">	int	ord;		&#x2F;&#x2F;通道块在路径上的“序号”</span><br><span class="line">	PosType	seat;	&#x2F;&#x2F;通道块在迷宫中的“坐标位置”</span><br><span class="line">	int	di;			&#x2F;&#x2F;从此通道块走向下一通道块的“方向”</span><br><span class="line">&#125;SElemType;			&#x2F;&#x2F;栈的元素类型</span><br><span class="line"></span><br><span class="line">Status	MazePath( MazeType	maze, PosType start, PosType end )&#123;</span><br><span class="line">	&#x2F;&#x2F;若迷宫maze中存在从入口start到出口end的通道，则求得一条存放在栈中（从栈底到栈顶），并返回TRUE；</span><br><span class="line">	&#x2F;&#x2F;否则返回FALSE</span><br><span class="line">	InitStack(S);</span><br><span class="line">	curpos &#x3D; start;	&#x2F;&#x2F;设定“当前位置”为“入口位置”</span><br><span class="line">	curstep &#x3D; 1;	&#x2F;&#x2F;探索第一步</span><br><span class="line">	do&#123;</span><br><span class="line">		if(Pass(curpos))&#123;	&#x2F;&#x2F;当前位置可以通过，即是未曾走到过的通道块</span><br><span class="line">			FootPrint(curpos);	&#x2F;&#x2F;留下足迹</span><br><span class="line">			e &#x3D; ( curstep, curpos, 1 );	&#x2F;&#x2F;此处e为SElemType类型的栈（书中未提及）</span><br><span class="line">			Push(S,e);			&#x2F;&#x2F;加入路径</span><br><span class="line">			if(curpos&#x3D;&#x3D;end)</span><br><span class="line">				return	(TRUE);	&#x2F;&#x2F;到达终点，出口</span><br><span class="line">			curpos &#x3D; NextPos( curpos, 1 );	&#x2F;&#x2F;下一位置是当前位置的东邻</span><br><span class="line">			curstep++;			&#x2F;&#x2F;探索下一步</span><br><span class="line">		&#125;&#x2F;&#x2F;if</span><br><span class="line">		else&#123;		&#x2F;&#x2F;当前位置不能通过</span><br><span class="line">			if(!StackEmpty(S))&#123;</span><br><span class="line">				Pop(S,e);</span><br><span class="line">				while(e.di &#x3D;&#x3D; 4 &amp;&amp; !StackEmpty(S))&#123;</span><br><span class="line">					MarkPrint(e.seat);</span><br><span class="line">					Pop(S,e);	&#x2F;&#x2F;留下不能通过的标记，并退回一步</span><br><span class="line">				&#125;&#x2F;&#x2F;while</span><br><span class="line">				if(e.di&lt;4)&#123;</span><br><span class="line">					e.di++;</span><br><span class="line">					Push(S,e);	&#x2F;&#x2F;换下一个方向探索</span><br><span class="line">					curpos &#x3D; NextPos(e.seat, e.di);	&#x2F;&#x2F;设定当前位置是该新方向上的相邻块</span><br><span class="line">				&#125;&#x2F;&#x2F;if</span><br><span class="line">			&#125;&#x2F;&#x2F;if</span><br><span class="line">		&#125;&#x2F;&#x2F;else</span><br><span class="line">	&#125;while( !StackEmpty(S));</span><br><span class="line">	return (FALSE);</span><br><span class="line">&#125;&#x2F;&#x2F;MazePath</span><br></pre></td></tr></table></figure>

<p>带优先级的算术表达式求值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">OperandType	EvaluateExpression()&#123;</span><br><span class="line">	&#x2F;&#x2F;算数表达式求值的算符优先算法</span><br><span class="line">	&#x2F;&#x2F;设OPTR和OPND分别为运算符栈和运算数栈，OP为运算符集合</span><br><span class="line">	InitStack(OPTR);</span><br><span class="line">	Push(OPTR, &#39;#&#39;);</span><br><span class="line">	InitStack(OPND);</span><br><span class="line">	c &#x3D; getchar();</span><br><span class="line">	while(c!&#x3D;&#39;#&#39; || GetTop(OPTR)!&#x3D;&#39;#&#39;)&#123;</span><br><span class="line">		if(!In(c, OP))&#123;</span><br><span class="line">			Push(OPND, c);</span><br><span class="line">			c &#x3D; getchar();</span><br><span class="line">		&#125;&#x2F;&#x2F;不是运算符则进栈</span><br><span class="line">		else&#123;</span><br><span class="line">			switch(Precede(GetTop(OPTR),c))&#123;	&#x2F;&#x2F;Precede()函数用于监测运算符优先级</span><br><span class="line">				case &#39;&lt;&#39;:	&#x2F;&#x2F;栈顶元素优先权低</span><br><span class="line">					Push(OPTR, c);</span><br><span class="line">					c &#x3D; getchar();</span><br><span class="line">					break;</span><br><span class="line">				case &#39;&#x3D;&#39;:	&#x2F;&#x2F;脱括号并接受下一字符</span><br><span class="line">					Pop(OPTR, x);</span><br><span class="line">					c &#x3D; getchar();</span><br><span class="line">					break;</span><br><span class="line">				case &#39;&gt;&#39;:	&#x2F;&#x2F;退栈并将运算结果入栈</span><br><span class="line">					Pop(OPTR, theta);</span><br><span class="line">					Pop(OPND, b);</span><br><span class="line">					Pop(OPND, a);</span><br><span class="line">					Push(OPND, Operate(a, theta, b));</span><br><span class="line">					break;</span><br><span class="line">			&#125;&#x2F;&#x2F;switch</span><br><span class="line">		&#125;&#x2F;&#x2F;else</span><br><span class="line">	&#125;&#x2F;&#x2F;while</span><br><span class="line">	return GetTop(OPND);</span><br><span class="line">&#125;&#x2F;&#x2F;EvaluateExpression</span><br></pre></td></tr></table></figure>

<p>求解n阶Hanoi塔问题的C函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void hanoi(int n, char x, char y, char z)</span><br><span class="line">	&#x2F;&#x2F;将塔座x上按直径由小到大且自上而下编号为1至n的n个圆盘按规则搬动到塔座z上，y可用作辅助塔座</span><br><span class="line">	&#x2F;&#x2F;搬动操作move(x, n, z)可定义为（c是初值为0的全局变量，对搬动计数）：</span><br><span class="line">	&#x2F;&#x2F;printf(&quot;%i. Move disk %i from %c to %c\n&quot;, ++c, n, x, z);</span><br><span class="line">	&#123;</span><br><span class="line">		if(n&#x3D;&#x3D;1)</span><br><span class="line">			move(x,1,z);</span><br><span class="line">		else&#123;</span><br><span class="line">			honoi(n-1, x, z,y);	&#x2F;&#x2F;将x上编号为1至n-1的圆盘移到y，z作辅助塔</span><br><span class="line">			move(x, n, z);		&#x2F;&#x2F;将编号为n的圆盘从x移到z</span><br><span class="line">			hanoi(n-1, y, x, z);&#x2F;&#x2F;将y上编号为1至n-1的圆盘移到z，x作辅助塔</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>队列的抽象数据类型定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">ADT	Queue&#123;</span><br><span class="line">	数据对象:D&#x3D;&#123;ai|ai∈ElemSet, i &#x3D; 1,2,...,n, n&gt;&#x3D;0&#125;</span><br><span class="line">	数据关系:R1&#x3D;&#123;&lt;a(i-1),ai&gt;|a(i-1),ai∈D, i&#x3D;2,...,n&#125;</span><br><span class="line">			约定其中a1端为队列头，an端为队列尾</span><br><span class="line">	基本操作：</span><br><span class="line">		InitQueue(&amp;Q)</span><br><span class="line">			操作结果：构造一个空队列Q</span><br><span class="line">		DesTroyQueue(&amp;Q)</span><br><span class="line">			初始条件：队列Q已存在</span><br><span class="line">			操作结果：队列Q被销毁，不再存在</span><br><span class="line">		ClearQueue(&amp;Q)</span><br><span class="line">			初始条件：队列Q已存在</span><br><span class="line">			操作结果：将Q清为空队列</span><br><span class="line">		QueueEmpty(Q)</span><br><span class="line">			初始条件：队列Q已存在</span><br><span class="line">			操作结果：若Q为空队列，则返回TRUE，否则返回FALSE</span><br><span class="line">		QueueLength(Q)</span><br><span class="line">			初始条件：队列Q已存在</span><br><span class="line">			操作结果：返回Q的元素个数，即队列的长度</span><br><span class="line">		GetHead(Q, &amp;e)</span><br><span class="line">			初始条件：队列Q已存在</span><br><span class="line">			操作结果：用e返回Q的队头元素</span><br><span class="line">		EnQueue(&amp;Q, e)</span><br><span class="line">			初始条件：队列Q已存在</span><br><span class="line">			操作结果：插入元素e为Q的新的队尾元素</span><br><span class="line">		DeQueue(&amp;Q, &amp;e)</span><br><span class="line">			初始条件：队列Q已存在</span><br><span class="line">			操作结果：删除Q的队头元素，并用e返回其值</span><br><span class="line">		QueueTraverse(Q,visit())</span><br><span class="line">			初始条件：队列Q已存在</span><br><span class="line">			操作结果：从队头到队尾，依次对Q的每个数据元素调用函数visit()。一旦visit()失败，则操作失败</span><br><span class="line">&#125;ADT Queue</span><br></pre></td></tr></table></figure>

<p>单链队列的表示与实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;	ADT Queue的表示与实现	&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-----	单链队列——队列的链式存储结构	-----</span><br><span class="line">typedef	struct	QNode&#123;</span><br><span class="line">	QElemType	data;</span><br><span class="line">	struct	QNode	*next;</span><br><span class="line">&#125;QNode, *QueuePtr;</span><br><span class="line">typedef	struct&#123;</span><br><span class="line">	QueuePtr	front;	&#x2F;&#x2F;队头指针</span><br><span class="line">	QueuePtr	rear;	&#x2F;&#x2F;队尾指针</span><br><span class="line">&#125;&#x2F;&#x2F;LinkQueue;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-----	基本操作的函数原型说明	-----</span><br><span class="line">Status	InitQueue(LinkQueue	&amp;Q)</span><br><span class="line">	&#x2F;&#x2F;构造一个空队列Q</span><br><span class="line">Status	DestroyQueue(LinkQueue &amp;Q)</span><br><span class="line">	&#x2F;&#x2F;销毁队列Q，Q不再存在</span><br><span class="line">Status	ClearQueue(LinkQueue &amp;Q)</span><br><span class="line">	&#x2F;&#x2F;将Q清为空队列</span><br><span class="line">Status	QueueEmpty(LinkQueue Q)</span><br><span class="line">	&#x2F;&#x2F;若队列Q为空队列，则返回TRUE，否则返回FALSE</span><br><span class="line">int	QueueLength(LinkQueue Q)</span><br><span class="line">	&#x2F;&#x2F;返回队列Q的元素个数，即队列长度</span><br><span class="line">Status	GetHead(LinkQueue Q, QElemType &amp;e)</span><br><span class="line">	&#x2F;&#x2F;若队列不空，则用e返回Q的队头元素，并返回OK，否则返回ERROR</span><br><span class="line">Status	EnQueue(LinkQueue &amp;Q, QElemType &amp;e)</span><br><span class="line">	&#x2F;&#x2F;插入元素e为Q新的队尾元素</span><br><span class="line">Status	DeQueue(LinkQueue &amp;Q, QElemType &amp;e)</span><br><span class="line">	&#x2F;&#x2F;若队列不空，则删除Q的队头元素，用e返回其值，并返回OK，否则返回ERROR</span><br><span class="line">Status	QueueTraverse(LinkQueue Q, visit())</span><br><span class="line">	&#x2F;&#x2F;从队头到队尾依次对队列Q中每个元素调用函数visit()。一旦visit()失败，则操作失败</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-----	基本操作的算法描述（部分） -----</span><br><span class="line">Status	InitQueue(LinkQueue	&amp;Q)&#123;</span><br><span class="line">	&#x2F;&#x2F;构造一个空队列Q</span><br><span class="line">	Q.front &#x3D; Q.rear &#x3D; (QueuePtr)malloc(sizeof(QNode));</span><br><span class="line">	if(!Q.front)</span><br><span class="line">		exit(OVERFLOW);		&#x2F;&#x2F;存储分配失败</span><br><span class="line">	Q.front-&gt;next &#x3D; NULL;</span><br><span class="line">	return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status	DestroyQueue(LinkQueue	&amp;Q)&#123;</span><br><span class="line">	&#x2F;&#x2F;销毁队列Q</span><br><span class="line">	while(Q.front)&#123;</span><br><span class="line">		Q.rear &#x3D; Q.front-&gt;next;</span><br><span class="line">		free(Q.front);</span><br><span class="line">		Q.front &#x3D; Q.rear;</span><br><span class="line">	&#125;</span><br><span class="line">	return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status	EnQueue(LinkQueue &amp;Q, QElemType	e)&#123;</span><br><span class="line">	&#x2F;&#x2F;插入元素e为Q的新的队尾元素</span><br><span class="line">	p &#x3D; (QueuePtr)malloc(sizeof(QNode));</span><br><span class="line">	if(!p)</span><br><span class="line">		exit(OVERFLOW);		&#x2F;&#x2F;存储分配失败</span><br><span class="line">	p-&gt;data &#x3D; e;</span><br><span class="line">	p-&gt;next &#x3D; NULL;</span><br><span class="line">	Q.rear-&gt;next &#x3D; p;</span><br><span class="line">	Q.rear &#x3D; p;</span><br><span class="line">	return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status	DeQueue(LinkQueue &amp;Q, QElemType &amp;e)&#123;</span><br><span class="line">	&#x2F;&#x2F;若队列不空，则删除Q的队头元素，用e返回其值，并返回OK，否则返回ERROR</span><br><span class="line">	if(Q.front &#x3D;&#x3D; Q.rear)</span><br><span class="line">		return ERROR;</span><br><span class="line">	p &#x3D; Q.front-&gt;next;</span><br><span class="line">	e &#x3D; p-&gt;data;</span><br><span class="line">	Q.front-&gt;next &#x3D; p-&gt;next;</span><br><span class="line">	if(Q.rear &#x3D;&#x3D; p)		&#x2F;&#x2F;队列中最后一个元素被删除，队列尾指针也丢失了，需对其也进行赋值</span><br><span class="line">		Q.rear &#x3D; Q.front;</span><br><span class="line">	free(p);</span><br><span class="line">	return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环队列类型说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;-----	循环队列——队列的顺序存储结构	-----</span><br><span class="line">#define	MAXQSIZE	100		&#x2F;&#x2F;最大队列长度</span><br><span class="line">typedef	struct&#123;</span><br><span class="line">	QElemType	*base;		&#x2F;&#x2F;初始化的动态分配存储空间</span><br><span class="line">	int	front;				&#x2F;&#x2F;头指针，若队列不空，指向队列头元素</span><br><span class="line">	int	rear;				&#x2F;&#x2F;尾指针，若队列不空，指向队列尾元素的下一位置</span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-----	循环队列的基本操作的算法描述	-----</span><br><span class="line">Status	InitQueue(SqQueue &amp;Q)&#123;</span><br><span class="line">	&#x2F;&#x2F;构造一个空队列Q</span><br><span class="line">	Q.base &#x3D; (QElemType	*)malloc(MAXSIZE * sizeof(QElemType));</span><br><span class="line">	if(!Q.base)</span><br><span class="line">		exit(OVERFLOW);</span><br><span class="line">	Q.front &#x3D; Q.rear &#x3D; 0;</span><br><span class="line">	return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int	QueueLength(SqQueue	Q)&#123;</span><br><span class="line">	&#x2F;&#x2F;返回Q的元素个数，即队列的长度</span><br><span class="line">	return (Q.rear - Q.front + MAXSIZE) % MASIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status	EnQueue(SqQueue	&amp;Q, QElemType e)&#123;</span><br><span class="line">	&#x2F;&#x2F;插入元素e为Q的新的队尾元素</span><br><span class="line">	if((Q.rear + 1) % MAXSIZE &#x3D;&#x3D; Q.front)</span><br><span class="line">		return ERROR;		&#x2F;&#x2F;队列满</span><br><span class="line">	Q.base[Q.rear] &#x3D; e;</span><br><span class="line">	Q.rear &#x3D; (Q.rear + 1) % MAXSIZE;</span><br><span class="line">	return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status	DeQueue(SqQueue	&amp;Q, QElemType &amp;e)&#123;</span><br><span class="line">	&#x2F;&#x2F;若队列不空，则删除Q的队头元素，用e返回其值，并返回OK，否则返回ERROR</span><br><span class="line">	if(Q.front &#x3D;&#x3D; Q.rear)</span><br><span class="line">		return	ERROR;</span><br><span class="line">	e &#x3D; Q.base[Q.front];</span><br><span class="line">	Q.front &#x3D; (Q.front + 1) % MAXSIZE;</span><br><span class="line">	return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>银行客户的离散事件驱动模拟程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void Bank_Simulation(int CloseTime)&#123;</span><br><span class="line">	&#x2F;&#x2F;银行业务模拟，统计一天内客户在银行逗留的平均时间</span><br><span class="line">	</span><br><span class="line">	OpenForDay();							&#x2F;&#x2F;初始化</span><br><span class="line">	while(MoreEvent)&#123;</span><br><span class="line">		EventDrived(OccurTime, EventType);	&#x2F;&#x2F;事件驱动</span><br><span class="line">		switch(EventType)&#123;</span><br><span class="line">			case &#39;A&#39;:						&#x2F;&#x2F;处理客户到达事件</span><br><span class="line">				CustomerArrived();</span><br><span class="line">				break;</span><br><span class="line">			case &#39;D&#39;:						&#x2F;&#x2F;处理客户离开事件</span><br><span class="line">				CustomerDeparture();</span><br><span class="line">				break;</span><br><span class="line">			default:</span><br><span class="line">				Invalid();</span><br><span class="line">		&#125;&#x2F;&#x2F;switch</span><br><span class="line">	&#125;&#x2F;&#x2F;while</span><br><span class="line">	CloseForDay;							&#x2F;&#x2F;计算平均逗留时间</span><br><span class="line">&#125;&#x2F;&#x2F;Bank_Simulation</span><br></pre></td></tr></table></figure>

<p>所需有序链表和队列的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef	struct&#123;</span><br><span class="line">	int	OccurTime;		&#x2F;&#x2F;事件发生时刻</span><br><span class="line">	int	NType;			&#x2F;&#x2F;事件类型，0表示到达事件，1至4表示四个窗口的离开事件</span><br><span class="line">&#125;Event, Elemtype;		&#x2F;&#x2F;事件类型，有序链表LinkList的数据元素类型</span><br><span class="line"></span><br><span class="line">typedef	LinkList EventList;		&#x2F;&#x2F;事件链表类型，定义为有序链表</span><br><span class="line"></span><br><span class="line">typedef	struct&#123;</span><br><span class="line">	int	ArrivalTime;	&#x2F;&#x2F;到达时刻</span><br><span class="line">	int	Duration;		&#x2F;&#x2F;办理事务所需时间</span><br><span class="line">&#125;QElemType;				&#x2F;&#x2F;队列的数据元素类型</span><br></pre></td></tr></table></figure>

<p>银行事件驱动模拟程序算法实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">	&#x2F;&#x2F;程序中用到的主要变量</span><br><span class="line">EventList	ev;			&#x2F;&#x2F;事件表</span><br><span class="line">Event		en;			&#x2F;&#x2F;事件</span><br><span class="line">LinkQueue	q[5];		&#x2F;&#x2F;4个客户队列</span><br><span class="line">QElemType	customer;	&#x2F;&#x2F;客户记录</span><br><span class="line">int			TotalTime, CustomerNum;	&#x2F;&#x2F;累计客户逗留时间，客户数</span><br><span class="line"></span><br><span class="line">int	cmp(Event a, Event b);</span><br><span class="line">	&#x2F;&#x2F;依事件a发生的时刻&lt;,&#x3D;或&gt;事件b的发生时刻分别返回-1，0或1</span><br><span class="line">	</span><br><span class="line">void OpenForDay()&#123;</span><br><span class="line">	&#x2F;&#x2F;初始化操作</span><br><span class="line">	TotalTime &#x3D; 0;				&#x2F;&#x2F;初始化累计时间为0</span><br><span class="line">	CustomerNum &#x3D; 0;			&#x2F;&#x2F;初始化客户数为0</span><br><span class="line">	InitList(ev);				&#x2F;&#x2F;初始化事件链表为空表</span><br><span class="line">	en.OcuurTime &#x3D; 0;</span><br><span class="line">	en.NType &#x3D; 0;				&#x2F;&#x2F;设定第一个客户到达事件</span><br><span class="line">	OrderInsert(ev, en, cmp);	&#x2F;&#x2F;插入事件表</span><br><span class="line">	for(i&#x3D;1; i&lt;&#x3D;4; ++i)</span><br><span class="line">		InitQueue(q[i]);		&#x2F;&#x2F;置空队列</span><br><span class="line">&#125;&#x2F;&#x2F;OpenForDay</span><br><span class="line"></span><br><span class="line">void CustomerDeparture()&#123;</span><br><span class="line">	&#x2F;&#x2F;处理客户离开事件，en.NType&gt;0</span><br><span class="line">	i &#x3D; en.Ntype;</span><br><span class="line">	DelQueue(q[i], customer);	&#x2F;&#x2F;删除第i队列的排头客户</span><br><span class="line">	TotalTime +&#x3D; en.OccurTime - customer.ArrivalTime;	&#x2F;&#x2F;累计客户逗留时间</span><br><span class="line">	if(!QueueEmpty(q[i]))&#123;		&#x2F;&#x2F;设定第i队列的一个离开事件并插入事件表</span><br><span class="line">		GetHead(q[i], customer);</span><br><span class="line">		OrderInsert(ev, (en.OccurTime + customer.Duration, i),(*cmp)());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;CustomerDeparture</span><br><span class="line"></span><br><span class="line">void Bank_Simulation(int CloseTime)&#123;</span><br><span class="line">	OpenForDay();						&#x2F;&#x2F;初始化</span><br><span class="line">	while(!ListEmpty(ev))&#123;</span><br><span class="line">		DelFirst(GetHead(ev), p);</span><br><span class="line">		en 66&#x3D; GetCurElem(p);</span><br><span class="line">		if(en.NType &#x3D;&#x3D; 0)</span><br><span class="line">			CustomerArrived();			&#x2F;&#x2F;处理客户到达事件</span><br><span class="line">		else</span><br><span class="line">			CustomerDeparture();		&#x2F;&#x2F;处理客户离开事件</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;计算并输出平均逗留时间</span><br><span class="line">	printf(&quot;The Average	Time	is	%f\n&quot;,(float)TotalTime&#x2F;CustomerNum);</span><br><span class="line">&#125;&#x2F;&#x2F;Bank_Simulation</span><br></pre></td></tr></table></figure>

<h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><p>串的抽象数据类型定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">ADT	String&#123;</span><br><span class="line">	数据对象：D&#x3D;&#123;ai|ai∈CharacterSet, i &#x3D; 1,2,...,n, n&gt;&#x3D;0&#125;</span><br><span class="line">	数据关系：R1&#x3D;&#123;&lt;a(i-1), ai&gt;|a(i-1),ai∈D, i &#x3D; 2,...,n&#125;</span><br><span class="line">	基本操作：</span><br><span class="line">		StrAssign(&amp;T, chars)</span><br><span class="line">	初始条件：chars是字符串常量</span><br><span class="line">	操作结果：生成一个其值等于chars的串T</span><br><span class="line">		StrCopy(&amp;T, S)</span><br><span class="line">	初始条件：串S存在</span><br><span class="line">	操作结果：由串S复制得到串T</span><br><span class="line">		StrEmpty(S)</span><br><span class="line">	初始条件：串S存在</span><br><span class="line">	操作结果：若S为空串，返回TRUE，否则返回FALSE</span><br><span class="line">		StrCompare(S, T)</span><br><span class="line">	初始条件：串S和T存在</span><br><span class="line">	操作结果：若S&gt;T，则返回值&gt;0，若S&#x3D;T，则返回值&#x3D;0，若S&lt;T，则返回值&lt;0</span><br><span class="line">		StrLength(S)</span><br><span class="line">	初始条件：串S存在</span><br><span class="line">	操作结果：返回S的元素个数，称为串的长度</span><br><span class="line">		ClearString(&amp;S)</span><br><span class="line">	初始条件：串S存在</span><br><span class="line">	操作结果：将S清空为空串</span><br><span class="line">		Concat(&amp;T, S1, S2)</span><br><span class="line">	初始条件：串S1和S2存在</span><br><span class="line">	操作结果：用T返回由S1和S2联接而成的新串</span><br><span class="line">		SubString(&amp;Sub, S, pos, len)</span><br><span class="line">	初始条件：串S存在，1&lt;&#x3D;pos&lt;&#x3D;StrLength(S)且0&lt;&#x3D;len&lt;&#x3D;StrLength(S)-pos+1</span><br><span class="line">	操作结果：用Sub返回串S的第pos个字符起长度为len的子串</span><br><span class="line">		Index(S, T, pos)</span><br><span class="line">	初始条件：串S和T存在，T是非空串，1&lt;&#x3D;pos&lt;&#x3D;StrLength(S)</span><br><span class="line">	操作结果：若主串S中存在和串T值相同的子串，则返回它在主串S中第pos个字符之后第一次出现的位置，否则函数值为0</span><br><span class="line">		Replace(&amp;S, T, V)</span><br><span class="line">	初始条件：串S，T和V存在，T是非空串</span><br><span class="line">	操作结果：用V替换主串S中出现的所有与T相等的不重叠的子串</span><br><span class="line">		StrInsert(&amp;S, pos, T)</span><br><span class="line">	初始条件：串S和T存在，1&lt;&#x3D;pos&lt;&#x3D;SreLength(S)+1</span><br><span class="line">	操作结果：在串S的第pos个字符之前插入串T</span><br><span class="line">		StrDelete(&amp;S, pos, len)</span><br><span class="line">	初始条件：串S存在，1&lt;&#x3D;pos&lt;&#x3D;StrLength(S)-len+1</span><br><span class="line">	操作结果：从串S中删除第pos个字符起长度为len的字串</span><br><span class="line">		DestoryString(&amp;S)</span><br><span class="line">	初始条件：串S存在</span><br><span class="line">	操作结果：串S被销毁</span><br><span class="line">&#125;ADT String</span><br></pre></td></tr></table></figure>

<p>利用判定、求串长和求子串等操作实现定位函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int Index(String S, String T, int pos)&#123;</span><br><span class="line">	&#x2F;&#x2F;T为非空串。若主串S中第pos个字符之后存在与T相等的子串，则返回第一个这样的子串在S中的位置，否则返回0</span><br><span class="line">	if(pos&gt;0)&#123;</span><br><span class="line">		n &#x3D; StrLength(S);</span><br><span class="line">		m &#x3D; StrLength(T);</span><br><span class="line">		i &#x3D; pos;</span><br><span class="line">		while(i &lt;&#x3D; n - m + 1)&#123;</span><br><span class="line">			SubString(sub, S, i, m);</span><br><span class="line">			if(StrCompare(sub,T) !&#x3D; 0)</span><br><span class="line">				++i;</span><br><span class="line">			else</span><br><span class="line">				return i;					&#x2F;&#x2F;返回子串在主串中的位置</span><br><span class="line">		&#125;&#x2F;&#x2F;while</span><br><span class="line">	&#125;&#x2F;&#x2F;if</span><br><span class="line">	return 0;								&#x2F;&#x2F;S中不存在与T相等的子串</span><br><span class="line">&#125;&#x2F;&#x2F;Index</span><br></pre></td></tr></table></figure>

<p>定长数组描述串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">	&#x2F;&#x2F;-----串的定长顺序存储表示-----</span><br><span class="line">#define	MAXSTRLEN	255		&#x2F;&#x2F;用户可在255以内定义最大串长</span><br><span class="line">typedef	unsigned char	SString[MAXSTRLEN + 1];		&#x2F;&#x2F;0号单元存放串的长度</span><br></pre></td></tr></table></figure>

<p>串联接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Status	Concat(SString &amp;T,SString S1, SString S2)&#123;</span><br><span class="line">	&#x2F;&#x2F;用T返回由S1和S2联接而成的新串。若未截断，则返回TRUE，否则返回FALSE</span><br><span class="line">	if(S1[0] + S2[0] &lt;&#x3D; MAXSTRLEN)&#123;		&#x2F;&#x2F;未截断</span><br><span class="line">		T[1..S1[0]] &#x3D; S1[1..S1[0]];</span><br><span class="line">		T[S1[0]+1..S1[0]+S2[0]] &#x3D; S2[1..S2[0]];</span><br><span class="line">		T[0] &#x3D; S1[0] + S2[0];</span><br><span class="line">		uncut &#x3D; TRUE;</span><br><span class="line">	&#125;</span><br><span class="line">	else if(S1[0] &lt; MAXSTRLEN)&#123;			&#x2F;&#x2F;截断</span><br><span class="line">		T[1..S1[0]] &#x3D; S1[1..S1[0]];</span><br><span class="line">		T[S1[0] + 1..MAXSTRLEN] &#x3D; S2[1..MAXSTRLEN-S1[0]];</span><br><span class="line">		T[0] &#x3D; MAXSTRLEN;</span><br><span class="line">		uncut &#x3D; FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		T[0..MAXSTRLEN] &#x3D; S1[0..MAXSTRLEN];</span><br><span class="line">								&#x2F;&#x2F;T[0] &#x3D;&#x3D; S1[0] &#x3D;&#x3D;MAXSTRLEN</span><br><span class="line">		uncut &#x3D; FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	return uncut;</span><br><span class="line">&#125;&#x2F;&#x2F;Concat</span><br><span class="line">&#x2F;&#x2F;因为0位表示长度，故1..S1[0]表示从S1的第一个元素到最后一个元素，1..S2[0]同理</span><br></pre></td></tr></table></figure>

<p>求子串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Status	SubString(SString &amp;Sub,	SString S, int pos, int len)&#123;</span><br><span class="line">	&#x2F;&#x2F;用Sub返回串S的第pos个字符起长度为Len的子串</span><br><span class="line">	&#x2F;&#x2F;其中，1&lt;&#x3D;pos&lt;&#x3D;StrLength(S)且0&lt;&#x3D;len&lt;&#x3D;StrLength(S)-pos+1</span><br><span class="line">	if(pos &lt; 1 || pos &gt; S[0] || len &lt; 0 || len &gt; S[0]-pos+1)</span><br><span class="line">		return ERROR;</span><br><span class="line">	Sub[1..len] &#x3D; S[pos..pos+len-1];</span><br><span class="line">	Sub[0] &#x3D; len;</span><br><span class="line">	return	OK;</span><br><span class="line">&#125;&#x2F;&#x2F;SubString</span><br></pre></td></tr></table></figure>

<p>堆分配存储表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">	&#x2F;&#x2F;-----	串的堆分配存储表示 -----</span><br><span class="line">typedef	struct&#123;</span><br><span class="line">	char	*ch;			&#x2F;&#x2F;若是非空串，则按串长分配存储区，否则ch为NULL</span><br><span class="line">	int		length;			&#x2F;&#x2F;串长度</span><br><span class="line">&#125;HString;</span><br></pre></td></tr></table></figure>

<p>串的插入操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Status StrInsert(HString &amp;S, int pos, HString T)&#123;</span><br><span class="line">	&#x2F;&#x2F;1&lt;&#x3D;pos&lt;&#x3D;Strlength(S)+1。在串的第pos个字符之前插入串T</span><br><span class="line">	if(pos&lt;1||pos&gt;S.length+1)</span><br><span class="line">		return	ERROR;			&#x2F;&#x2F;pos不合法</span><br><span class="line">	if(T.length)&#123;				&#x2F;&#x2F;T非空，则重新分配空间，插入T</span><br><span class="line">		if(!(S.ch &#x3D; (char *)realloc(S.ch, (S.length+T.length)*sizeof(char))))</span><br><span class="line">			exit(OVERFLOW);</span><br><span class="line">		for(i&#x3D;S.length-1; i&gt;&#x3D;pos-1; --i)	&#x2F;&#x2F;为插入T而腾出位置</span><br><span class="line">			S.ch[i+T.length] &#x3D; S.ch[i];</span><br><span class="line">		S.ch[pos-1..pos+T.length-2] &#x3D; T.ch[0..T.length-1];	&#x2F;&#x2F;插入T</span><br><span class="line">		S.length +&#x3D; T.length;</span><br><span class="line">	&#125;</span><br><span class="line">	return OK;</span><br><span class="line">&#125;&#x2F;&#x2F;StrInsert</span><br></pre></td></tr></table></figure>

<p>串的表示与实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">	&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;	ADT String的表示与实现 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">	&#x2F;&#x2F;-----	串的堆分配存储表示 -----</span><br><span class="line">typedef	struct&#123;</span><br><span class="line">	char	*ch;			&#x2F;&#x2F;若是非空串，则按串长分配存储区，否则ch为NULL</span><br><span class="line">	int		length;			&#x2F;&#x2F;串长度</span><br><span class="line">&#125;HString;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-----基本操作的函数原型说明-----</span><br><span class="line">Status	StrAssign(HString &amp;T, char *chars);</span><br><span class="line">	&#x2F;&#x2F;生成一个其值为串常量chars的串T</span><br><span class="line">int	StrLength(HString S);</span><br><span class="line">	&#x2F;&#x2F;返回S的元素个数，称为串的长度</span><br><span class="line">int	StrCompare(HString S, HString T);</span><br><span class="line">	&#x2F;&#x2F;若S&gt;T，则返回值&gt;0，若S&#x3D;T，则返回值&#x3D;0，若S&lt;T，则返回值&lt;0</span><br><span class="line">Status	ClearString(HString &amp;S);</span><br><span class="line">	&#x2F;&#x2F;将S清为空串，并释放S所占的空间</span><br><span class="line">Status	Concat(HString &amp;T, HString S1, HString S2);</span><br><span class="line">	&#x2F;&#x2F;用T返回由S1和S2联接而成的新串</span><br><span class="line">HString	SubString(HString S, int pos, int len);</span><br><span class="line">	&#x2F;&#x2F;1&lt;&#x3D;pos&lt;&#x3D;StrLength(S)且0&lt;&#x3D;len&lt;&#x3D;StrLength(S)-pos+1</span><br><span class="line">	&#x2F;&#x2F;返回串S的第pos个字符起长度为len的子串</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;-----基本操作的算法描述-----</span><br><span class="line">Status	StrAssign(HString &amp;T, char *chars)&#123;</span><br><span class="line">	&#x2F;&#x2F;生成一个其值等于串常量chars的串T</span><br><span class="line">	if(T.ch)</span><br><span class="line">		free(T.ch);				&#x2F;&#x2F;释放T原空间</span><br><span class="line">		for(i&#x3D;0, c&#x3D;chars; *c; ++i, ++c)</span><br><span class="line">			;	&#x2F;&#x2F;求chars的长度i</span><br><span class="line">		if(!i)&#123;</span><br><span class="line">			T.ch &#x3D; NULL;</span><br><span class="line">			T.length &#x3D; 0;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			if(!(T.ch&#x3D;(char *)malloc(i * sizeof(char))))</span><br><span class="line">				exit(OVERFLOW);</span><br><span class="line">			T.ch[0..i-1]&#x3D;chars[0..i-1];</span><br><span class="line">			T.length &#x3D; i;</span><br><span class="line">		&#125;</span><br><span class="line">		return	OK;</span><br><span class="line">&#125;&#x2F;&#x2F;StrAssign</span><br><span class="line"></span><br><span class="line">int	StrLength(HString S)&#123;</span><br><span class="line">	&#x2F;&#x2F;返回S的元素个数，称为串的长度</span><br><span class="line">	return	S.length;</span><br><span class="line">&#125;&#x2F;&#x2F;StrLength</span><br><span class="line"></span><br><span class="line">int StrCompare(HString	S, HString	T)&#123;</span><br><span class="line">	&#x2F;&#x2F;若S&gt;T，则返回值&gt;0；若S&#x3D;T，则返回值&#x3D;0；若S&lt;T，则返回值&lt;0</span><br><span class="line">	for(i&#x3D;0; i&lt;S.length&amp;&amp;S.T.length; ++i)</span><br><span class="line">		if(S.ch[i]!&#x3D;T.ch[i])</span><br><span class="line">			return	S.ch[i] - T.ch[i];</span><br><span class="line">	return	S.length-T.length;</span><br><span class="line">&#125;&#x2F;&#x2F;StrCompare</span><br><span class="line"></span><br><span class="line">Status	ClearString(HString	&amp;S)&#123;</span><br><span class="line">	&#x2F;&#x2F;将S清为空串</span><br><span class="line">	if(S.ch)&#123;</span><br><span class="line">		free(S.ch);</span><br><span class="line">		S.ch &#x3D; NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	S.length &#x3D; 0;</span><br><span class="line">	return	OK;</span><br><span class="line">&#125;&#x2F;&#x2F;ClearString</span><br><span class="line"></span><br><span class="line">Status	Concat(HString	&amp;T, HString	S1, HString	S2)&#123;</span><br><span class="line">	&#x2F;&#x2F;用T返回由S1和S2联接而成的新串</span><br><span class="line">	if(T.ch)</span><br><span class="line">		free(T.ch);		&#x2F;&#x2F;释放旧空间</span><br><span class="line">		if(!(T.ch &#x3D; (char *)malloc((S1.length+S2.length) * sizeof(char))))</span><br><span class="line">			exit(OVERFLOW);</span><br><span class="line">		T.ch[0..S1.length-1] &#x3D; S1[0..S1.length-1];</span><br><span class="line">		T.length &#x3D; S1.length + S2.length;</span><br><span class="line">		T.ch[S1.length..T.length-1] &#x3D; S2.ch[0..S2.length-1];</span><br><span class="line">		return	OK;</span><br><span class="line">&#125;&#x2F;&#x2F;Concat</span><br><span class="line"></span><br><span class="line">Status	SubString(HString &amp;Sub, HString S, int pos, int len)&#123;</span><br><span class="line">	&#x2F;&#x2F;用Sub返回串S的第pos个字符起长度为len的子串</span><br><span class="line">	&#x2F;&#x2F;其中，1&lt;&#x3D;pos&lt;&#x3D;StrLength(S)且0&lt;&#x3D;len&lt;&#x3D;StrLength(S)-pos+1</span><br><span class="line">	if(pos &lt; 1 || pos &gt; S.length || len &lt; 0 || len &gt; S.length-pos+1)</span><br><span class="line">		return	ERROR;</span><br><span class="line">	if(Sub.ch)</span><br><span class="line">		free(Sub.ch);</span><br><span class="line">	if(!len)&#123;</span><br><span class="line">		Sub.ch &#x3D; NULL;</span><br><span class="line">		Sub.length &#x3D; 0;</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		Sub.ch &#x3D; (char *)malloc(len * sizeof(char));</span><br><span class="line">		Sub.ch[0..len-1] &#x3D; S.ch[pos-1..pos+len-2];</span><br><span class="line">		Sub.length &#x3D; len;</span><br><span class="line">	&#125;</span><br><span class="line">	return	OK;</span><br><span class="line">&#125;&#x2F;&#x2F;SubString</span><br></pre></td></tr></table></figure>

<p>串的块链结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">		&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;	串的块链存储表示 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">#define	CHUNKSIZE	80			&#x2F;&#x2F;可由用户定义块的大小</span><br><span class="line">typedef	struct	Chunk&#123;</span><br><span class="line">	char	ch[CHUNKSIZE];</span><br><span class="line">	struct	Chunk	*next;</span><br><span class="line">&#125;Chunk;</span><br><span class="line">typedef	struct&#123;</span><br><span class="line">	Chunk	*head, *tail;		&#x2F;&#x2F;串的头和尾指针</span><br><span class="line">	int		curlen;				&#x2F;&#x2F;串的当前长度</span><br><span class="line">&#125;LString;</span><br></pre></td></tr></table></figure>

<p>求子串位置的定位函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int	Index(SString S, SString T, int	pos)&#123;</span><br><span class="line">	&#x2F;&#x2F;返回子串T在主串S中第pos个字符之后的位置。若不存在，则函数值为0</span><br><span class="line">	&#x2F;&#x2F;其中，T非空，1&lt;&#x3D;pos&lt;&#x3D;StrLength(S)</span><br><span class="line">	i &#x3D; pos;</span><br><span class="line">	j &#x3D; 1;</span><br><span class="line">	while(i &lt;&#x3D; S[0] &amp;&amp; j &lt;&#x3D; T[0])&#123;</span><br><span class="line">		if(S[i] &#x3D;&#x3D; T[j])&#123;</span><br><span class="line">			++i;</span><br><span class="line">			++j;</span><br><span class="line">		&#125;	&#x2F;&#x2F;继续比较后继字符</span><br><span class="line">		else&#123;</span><br><span class="line">			i &#x3D; i-j+2;</span><br><span class="line">			j &#x3D; 1;</span><br><span class="line">		&#125;	&#x2F;&#x2F;指针后退重新开始匹配</span><br><span class="line">	&#125;</span><br><span class="line">	if(j &gt; T[0])</span><br><span class="line">		return	i-T[0];</span><br><span class="line">	else</span><br><span class="line">		return	0;</span><br><span class="line">&#125;&#x2F;&#x2F;Index</span><br></pre></td></tr></table></figure>

<p>利用模式串的next()函数的KMP算法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int	Index_KMP(SString S, SString T, int	pos)&#123;</span><br><span class="line">	&#x2F;&#x2F;利用模式串T的next函数求T在主串S中第pos个字符之后的位置的KMP算法</span><br><span class="line">	&#x2F;&#x2F;其中，T非空，1&lt;&#x3D;pos&lt;&#x3D;StrLength(S)</span><br><span class="line">	i &#x3D; pos;</span><br><span class="line">	j &#x3D; 1;</span><br><span class="line">	while(i &lt;&#x3D; S[0] &amp;&amp; j &lt;&#x3D; T[0])&#123;</span><br><span class="line">		if( j &#x3D;&#x3D; 0 || S[i] &#x3D;&#x3D; T[j] )&#123;</span><br><span class="line">			++i;</span><br><span class="line">			++j;</span><br><span class="line">		&#125;		&#x2F;&#x2F;继续比较后继字符</span><br><span class="line">		else</span><br><span class="line">			j &#x3D; next[j];</span><br><span class="line">	&#125;</span><br><span class="line">	if(j &gt; T[0])</span><br><span class="line">		return	i - T[0];</span><br><span class="line">	else</span><br><span class="line">		return	0;</span><br><span class="line">&#125;&#x2F;&#x2F;Index_KMP</span><br></pre></td></tr></table></figure>

<p>KMP算法中的next函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void get_next(SString T, int next[])&#123;</span><br><span class="line">	&#x2F;&#x2F;求模式串T的next函数值并存入数组next</span><br><span class="line">	i &#x3D; 1;</span><br><span class="line">	next[1] &#x3D; 0;</span><br><span class="line">	j &#x3D; 0;</span><br><span class="line">	while(i &lt; T[0])&#123;</span><br><span class="line">		if(j &#x3D;&#x3D; 0 || T[i] &#x3D;&#x3D; T[j])&#123;</span><br><span class="line">			++i;</span><br><span class="line">			++j;</span><br><span class="line">			next[i] &#x3D; j;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">			j &#x3D; next[j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;get_next</span><br></pre></td></tr></table></figure>

<p>计算next函数修正值的算法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void get_nextval(SString T, int nextval[])&#123;</span><br><span class="line">	&#x2F;&#x2F;求模式串T的next函数修正值并存入数组nextval</span><br><span class="line">	i &#x3D; 1;</span><br><span class="line">	nextval[1] &#x3D; 0;</span><br><span class="line">	j &#x3D; 0;</span><br><span class="line">	while(i&lt;T[0])&#123;</span><br><span class="line">		if(j &#x3D;&#x3D; 0 || T[i] &#x3D;&#x3D; T[j])&#123;</span><br><span class="line">			++i;</span><br><span class="line">			++j;</span><br><span class="line">			if(T[i] !&#x3D; T[j])</span><br><span class="line">				nextval[i] &#x3D; j;</span><br><span class="line">			else</span><br><span class="line">				nextval[i] &#x3D; nextval[j];</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">			j &#x3D; nextval[j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;get_nextval</span><br></pre></td></tr></table></figure>

<p>词典索引表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#define	MaxBookNum	1000		&#x2F;&#x2F;假设只对1000本书建索引表</span><br><span class="line">#define	MaxKeyNum	2500		&#x2F;&#x2F;索引表的最大容量</span><br><span class="line">#define	MaxLineLen	500			&#x2F;&#x2F;书目串的最大长度</span><br><span class="line">#define	MaxWordNum	10			&#x2F;&#x2F;词表的最大容量</span><br><span class="line"></span><br><span class="line">typedef	struct&#123;</span><br><span class="line">	char	*item[];			&#x2F;&#x2F;字符串的数组</span><br><span class="line">	int		last;				&#x2F;&#x2F;词表的长度</span><br><span class="line">&#125;WordListType;					&#x2F;&#x2F;词表类型（顺序表）</span><br><span class="line">typedef	int	ElemType;			&#x2F;&#x2F;定义链表的数据元素类型为整型（书号类型）</span><br><span class="line">typedef	struct&#123;</span><br><span class="line">	HString	key;				&#x2F;&#x2F;关键词</span><br><span class="line">	LinkList bnolist;			&#x2F;&#x2F;存放书号索引的链表</span><br><span class="line">&#125;IdxTermType;					&#x2F;&#x2F;索引项类型</span><br><span class="line">typedef	struct&#123;</span><br><span class="line">	IdxTermType	item[MaxKetNum+1];</span><br><span class="line">	int	last;</span><br><span class="line">&#125;IdxListType;					&#x2F;&#x2F;索引表类型（有序表）</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;主要变量</span><br><span class="line">char	*buf;					&#x2F;&#x2F;书目串缓冲区</span><br><span class="line">WordListType	wdlist;			&#x2F;&#x2F;词表</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;基本操作</span><br><span class="line">void	InitIdxList(IdxListType	&amp;idxlist);</span><br><span class="line">	&#x2F;&#x2F;初始化操作，置索引表idxlist为空表，且在idxlist.item[0]设一空串</span><br><span class="line">void	GetLine(FILE f);</span><br><span class="line">	&#x2F;&#x2F;从文件f读入一个书目信息到书目缓冲区buf</span><br><span class="line">void	ExtractKeyWord(ElemType	&amp;bno);</span><br><span class="line">	&#x2F;&#x2F;从buf中提取书名关键词到词表wdlist，书号存入bno</span><br><span class="line">Status	InsIdxList(IdxListType &amp;idxlist, ElemType bno);</span><br><span class="line">	&#x2F;&#x2F;将书号为bno的书名关键词按词典顺序插入索引表idxlist</span><br><span class="line">void PutText(FILE g, IdxListType idxlist);</span><br><span class="line">	&#x2F;&#x2F;将生成的索引表idxlist输出到文件g</span><br><span class="line">	</span><br><span class="line">void main()&#123;	&#x2F;&#x2F;主函数</span><br><span class="line">	if(f &#x3D; openf(&quot;BookInfo.txt&quot;,&quot;r&quot;))&#123;</span><br><span class="line">		if(g &#x3D; openf(&quot;BookIdx.txt&quot;,&quot;w&quot;))&#123;</span><br><span class="line">			InitIdxList(idxlist);			&#x2F;&#x2F;初始化索引表idxlist为空表</span><br><span class="line">			while(!feof(f))&#123;</span><br><span class="line">				GetLine(f);					&#x2F;&#x2F;从文件f读入一个书目信息到buf</span><br><span class="line">				ExtractKeyWord(BookNo);		&#x2F;&#x2F;从buf提取关键词到词表，书号存入BookNo</span><br><span class="line">				InsIdxList(idxlist, BookNo);&#x2F;&#x2F;将书号为BookNo的关键词插入索引表</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		PutText(g, idxlist);				&#x2F;&#x2F;将生成的索引表idxlist输出到文件g</span><br><span class="line">	&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;main</span><br></pre></td></tr></table></figure>

<p>实现插入操作所必须函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">void	GetWord(int i, HString	&amp;wd);</span><br><span class="line">	&#x2F;&#x2F;用wd返回词表wdlist中第i个关键词</span><br><span class="line">int	Locate(IdxListType idxlist, HString wd, Boolean &amp;b);</span><br><span class="line">	&#x2F;&#x2F;在索引表idxlist中查询是否存在与wd相等的关键词</span><br><span class="line">	&#x2F;&#x2F;若存在，则返回其在索引表中的位置，且b取值TRUE，否则返回插入位置，且b取值FALSE</span><br><span class="line">void InsertNewKey(IdxListType &amp;idxlist, int i, HString wd);</span><br><span class="line">	&#x2F;&#x2F;在索引表idxlist的第i项上插入新关键词wd，并初始化书号索引的链表为空表</span><br><span class="line">Status	InsIdxList(IdxListType	&amp;idxlist, int i, int bno);</span><br><span class="line">	&#x2F;&#x2F;在索引表idxlist的第i项中插入书号为bno的索引</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;插入算法</span><br><span class="line">Status	InsIdxList(IdxListType &amp;idxlist, int bno)&#123;</span><br><span class="line">	for(i&#x3D;0; i&lt;wdlist.last; ++i)&#123;</span><br><span class="line">		GetWord(i, wd);</span><br><span class="line">		j &#x3D; Locate(idxlist, wd, b);</span><br><span class="line">		if(!b)</span><br><span class="line">			InsertNewKey(idxlist, j, wd);		&#x2F;&#x2F;插入新的索引项</span><br><span class="line">		if(!InsertBook(idxlist,j,bno))</span><br><span class="line">			return	OVERFLOW；					&#x2F;&#x2F;插入书号索引</span><br><span class="line">	&#125;</span><br><span class="line">	return	OK;</span><br><span class="line">&#125;&#x2F;&#x2F;InsertIdxList</span><br><span class="line"></span><br><span class="line">void GetWord(int i, HString &amp;wd)&#123;</span><br><span class="line">	p&#x3D; *(wd.list.item + i);						&#x2F;&#x2F;取词表中第i个字符串</span><br><span class="line">	StrAssign(wd,p);							&#x2F;&#x2F;生成关键字字符串</span><br><span class="line">&#125;&#x2F;&#x2F;GetWord</span><br><span class="line"></span><br><span class="line">int Locate(IdxListType	&amp;idxlist, HString wd, Boolean &amp;b)&#123;</span><br><span class="line">	for(i &#x3D; idxlist.last - 1; (m &#x3D; StrCompare(idxlist.item[i].key, wd)) &gt; 0; --i)</span><br><span class="line">		;</span><br><span class="line">	if(m&#x3D;&#x3D;0)&#123;</span><br><span class="line">		b &#x3D;TRUE;</span><br><span class="line">		return	i;		&#x2F;&#x2F;找到</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		b &#x3D; FALSE;</span><br><span class="line">		return i+1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;Locate</span><br><span class="line"></span><br><span class="line">void InsertNewKey(int i, StrType wd)&#123;</span><br><span class="line">	for(j &#x3D; idxlist.last-1; j&gt;&#x3D;1; --j)			&#x2F;&#x2F;后移索引项</span><br><span class="line">		idxlist.item[j+1] &#x3D; idxlist.item[j];</span><br><span class="line">	&#x2F;&#x2F;插入新的索引项</span><br><span class="line">	StrCopy(idxlist.item[i].key, wd);			&#x2F;&#x2F;串赋值</span><br><span class="line">	InitList(idxlist.item[i].bnolist);			&#x2F;&#x2F;初始化书号索引表为空表</span><br><span class="line">	++idxlist.last;</span><br><span class="line">&#125;&#x2F;&#x2F;InsertNewKey</span><br><span class="line"></span><br><span class="line">Status	InsertBook(IdxListType &amp;idxlist, int i, int bno)&#123;</span><br><span class="line">	if(!MakeNode(p, bno))</span><br><span class="line">		return	ERROR;							&#x2F;&#x2F;分配失败</span><br><span class="line">	Appand(idxlist.item[i].bnolist, p);			&#x2F;&#x2F;插入新的书号索引</span><br><span class="line">	return	OK;</span><br><span class="line">&#125;&#x2F;&#x2F;InserBook</span><br></pre></td></tr></table></figure>

<h2 id="数组与广义表"><a href="#数组与广义表" class="headerlink" title="数组与广义表"></a>数组与广义表</h2><p>数组的抽象数据类型定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ADT	Array&#123;</span><br><span class="line">	数据对象：ji&#x3D;0,...,bi-1,	i &#x3D; 1,2,...,n</span><br><span class="line">			D &#x3D; &#123;aj1j2...jn |n(&gt;0)称为数组的维数，bi是数组第i维的长度，ji是数组元素的第i维下标，aj1j2...jn∈ElemSet&#125;</span><br><span class="line">	数据关系：R &#x3D; &#123;R1, R2, ..., Rn&#125;</span><br><span class="line">			Ri &#x3D; &#123;&lt;aj1...ji...jn , aj1...ji+1...jn&gt;|0&lt;&#x3D;jk&lt;&#x3D;bk-1, 1&lt;&#x3D;k&lt;&#x3D;n	且k≠i,0&lt;&#x3D;ji&lt;&#x3D;bi-2,aj1...ji...jn , 												aj1...ji+1...jn∈D, i&#x3D;2,...,n&#125;</span><br><span class="line">	基本操作：</span><br><span class="line">		InitArray(&amp;A, n, bound1, ..., boundn)</span><br><span class="line">			操作结果：若维数n和各维长度合法，则构造相应数组A，并返回OK</span><br><span class="line">		DestroyArray(&amp;A)</span><br><span class="line">			操作结果：销毁数组A</span><br><span class="line">		value(A, &amp;e, index1, ..., indexn)</span><br><span class="line">			初始条件：A是n维数组，e为元素变量，随后是n个下标值</span><br><span class="line">			操作结果：若各下标不超界，则e赋值为所指定的A的元素值，并返回OK</span><br><span class="line">		Assign(&amp;A, e, index1, ..., indexn)</span><br><span class="line">			初始条件：A是n维数组，e为元素变量，随后是n个下标</span><br><span class="line">			操作结果：若下标不越界，则将e的值赋给所指定的A的元素，并返回OK</span><br><span class="line">&#125;ADT Array</span><br></pre></td></tr></table></figure>

<p>数组的顺序存储表示及实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;-----	数组的顺序存储表示 -----</span><br><span class="line">#include	&lt;stdio.h&gt;		&#x2F;&#x2F;标准头文件，提供宏va_start、va_arg和va_end</span><br><span class="line">							&#x2F;&#x2F;用于存取变长参数表</span><br><span class="line">#define	MAX_ARRAY_DIM	8	&#x2F;&#x2F;假设数组维数的最大值为8</span><br><span class="line">typedef	struct&#123;</span><br><span class="line">	ElemType	*base;		&#x2F;&#x2F;数组元素基址，由InitArray分配</span><br><span class="line">	int			dim;		&#x2F;&#x2F;数组维数</span><br><span class="line">	int			*bounds;	&#x2F;&#x2F;数组维数基址，由InitArray分配</span><br><span class="line">	int			*constanst;	&#x2F;&#x2F;数组映像函数常量基址，由InitArray分配</span><br><span class="line">&#125;Array;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-----	基本操作的函数原型说明 -----</span><br><span class="line">Status	InitArray(Array	&amp;A, int	dim, ...);</span><br><span class="line">	&#x2F;&#x2F;若维数dim和各维长度合法，则构造相应的数组A，并返回OK</span><br><span class="line">Status	DestroyArray(Array	&amp;A);</span><br><span class="line">	&#x2F;&#x2F;销毁数组A</span><br><span class="line">Status	Value(Array	A, ElemType	&amp;e, ...);</span><br><span class="line">	&#x2F;&#x2F;A是n维数组，e为元素变量，随后是n个下标值</span><br><span class="line">	&#x2F;&#x2F;若各下标不超界，则e的赋值给所指定的A的元素值，并返回OK</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-----	基本操作的算法描述 -----</span><br><span class="line">Status	InitArray(Array	&amp;A, int dim, ...)&#123;</span><br><span class="line">	&#x2F;&#x2F;若维数dim和各维长度合法，则构造相应的数组A，并返回OK</span><br><span class="line">	if(dim &lt; 1 || dim &gt; MAX_ARRAY_DIM)</span><br><span class="line">		return	ERROR;</span><br><span class="line">	A.dim &#x3D; dim;</span><br><span class="line">	A.bounds &#x3D; (int	*)malloc(dim * sizeof( int ));</span><br><span class="line">	if(!A.bounds)</span><br><span class="line">		exit(OVERFLOW);</span><br><span class="line">	&#x2F;&#x2F;若各维长度合法，则存入A.bounds，并求出A的元素总数elemtotal</span><br><span class="line">	elemtotal &#x3D; 1;</span><br><span class="line">	va_start(ap, dim);				&#x2F;&#x2F;ap为va_list类型，是存放变长参数表信息的数组</span><br><span class="line">	for(i &#x3D; 0; i&lt;dim; ++i)&#123;</span><br><span class="line">		A.bounds[i] &#x3D; va_arg(ap, int);</span><br><span class="line">		if(A.bounds[i]&lt;0)</span><br><span class="line">			return	UNDERFLOW;</span><br><span class="line">		elemtotal *&#x3D; A.bounds[i];</span><br><span class="line">	&#125;</span><br><span class="line">	va_end(ap);</span><br><span class="line">	A.base &#x3D; (ElemType	*)malloc(elemtotal * sizeof(ElemType));</span><br><span class="line">	if(!A.base)</span><br><span class="line">		exit(OVERFLOW);</span><br><span class="line">	&#x2F;&#x2F;求映像函数的常数c，并存入A.constants[i-1], i &#x3D; 1,...,dim</span><br><span class="line">	A.constants &#x3D; (int *)malloc(dim * sizeof(int));</span><br><span class="line">	if(!A.constants)</span><br><span class="line">		exit(OVERFLOW);</span><br><span class="line">	A.constants[dim-1] &#x3D; 1;		&#x2F;&#x2F;L&#x3D;1，指针的增减以元素的大小为单位</span><br><span class="line">	for( i &#x3D; dim-2; i&gt;&#x3D;0; --i )</span><br><span class="line">		A.constants[i] &#x3D; A.bounds[i + 1] * A.constants[i + 1];</span><br><span class="line">	return	OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status	DestroyArray(Array	&amp;A)&#123;</span><br><span class="line">	&#x2F;&#x2F;销毁数组A</span><br><span class="line">	if(！A.base)</span><br><span class="line">		return	ERROR;</span><br><span class="line">	free(A.base);</span><br><span class="line">	A.base &#x3D; NULL;</span><br><span class="line">	if(A.bounds)</span><br><span class="line">		return	ERROR;</span><br><span class="line">	free(A.bounds);</span><br><span class="line">	A.bounds &#x3D; NULL;</span><br><span class="line">	if(!A.constants)</span><br><span class="line">		return	ERROR;</span><br><span class="line">	free(A.constants);</span><br><span class="line">	A.constants &#x3D; NULL;</span><br><span class="line">	return	OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status	Locate(Array A, va_list ap, int	&amp;off)&#123;</span><br><span class="line">	&#x2F;&#x2F;若ap指示的各下标值合法，则求出该元素在A中的相对地址off</span><br><span class="line">	off &#x3D; 0;</span><br><span class="line">	for( i &#x3D; 0; i&lt;A.dim; ++i)&#123;</span><br><span class="line">		ind &#x3D; va_arg(ap, int);</span><br><span class="line">		if(ind&lt;0 || ind&gt;&#x3D;A.bounds[i])</span><br><span class="line">			return	OVERFLOW;</span><br><span class="line">		off +&#x3D; A.constants[i] * ind;</span><br><span class="line">	&#125;</span><br><span class="line">	return	OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status	Value(Array A, ElemType	&amp;e, ...)&#123;</span><br><span class="line">	&#x2F;&#x2F;A是n维数组，e为元素变量，随后是n个下标值</span><br><span class="line">	&#x2F;&#x2F;若各下标值不超界，则e赋值为所指定的A的元素值，并返回OK</span><br><span class="line">	va_start(ap, e);</span><br><span class="line">	if((result &#x3D; Locate(A, ap, off))&lt;&#x3D;0)</span><br><span class="line">		return	result;</span><br><span class="line">	e &#x3D; *(A.base + off);</span><br><span class="line">	return	OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status	Assign(Array &amp;A, ElemType e, ...)&#123;</span><br><span class="line">	&#x2F;&#x2F;A是n维数组，e为元素变量，随后是n个下标值</span><br><span class="line">	&#x2F;&#x2F;若下标不超界，则将e的值赋给所指定的A的元素，并返回OK</span><br><span class="line">	va_start(ap, e);</span><br><span class="line">	if((result &#x3D; Locate(A, ap, off))&lt;&#x3D;0)</span><br><span class="line">		return	result;</span><br><span class="line">	*(A.base + off) &#x3D; e;</span><br><span class="line">	return	OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>稀疏矩阵的抽象数据类型定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">ADT	SparseMatrix&#123;</span><br><span class="line">	数据对象：D &#x3D; &#123;aij|i &#x3D; 1,2,...,n;ai,j∈ElemSet，m和n分别称为矩阵的行数和列数&#125;</span><br><span class="line">	数据关系：R &#x3D; &#123;Row, Col&#125;</span><br><span class="line">			Row &#x3D; &#123;&lt;ai,j,ai,j+1&gt;| 1&lt;&#x3D;i&lt;&#x3D;m, 1&lt;&#x3D;j&lt;&#x3D;n-1&#125;</span><br><span class="line">			Col &#x3D; &#123;&lt;ai,j,ai+1,j&gt;| 1&lt;&#x3D;i&lt;&#x3D;m-1, 1&lt;&#x3D;j&lt;&#x3D;n&#125; </span><br><span class="line">	基本操作：</span><br><span class="line">		CreateSMatrix(&amp;M);</span><br><span class="line">			操作结果：创建稀疏矩阵M</span><br><span class="line">		DestroySMatrix(&amp;M);</span><br><span class="line">			初始条件：稀疏矩阵M存在</span><br><span class="line">			操作结果：销毁稀疏矩阵M</span><br><span class="line">		PrintSMatrix(M);</span><br><span class="line">			初始条件：稀疏矩阵M存在</span><br><span class="line">			操作结果：输出稀疏矩阵M</span><br><span class="line">		CopySMatrix(M, &amp;T);</span><br><span class="line">			初始条件：稀疏矩阵M存在</span><br><span class="line">			操作结果：由稀疏矩阵M复制得到T</span><br><span class="line">		AddSMatrix(M, N, &amp;Q);</span><br><span class="line">			初始条件：稀疏矩阵M与N的行数与列数对应相等</span><br><span class="line">			操作结果：求稀疏矩阵的和Q &#x3D; M + N</span><br><span class="line">		SubSMatrix(M, N, &amp;Q);</span><br><span class="line">			初始条件：稀疏矩阵M与N的行数与列数对应相等</span><br><span class="line">			操作结果：求稀疏矩阵的差Q &#x3D; M - N</span><br><span class="line">		MultSMatrix(M, N, &amp;Q);</span><br><span class="line">			初始条件：稀疏矩阵M的列数等于N的行数</span><br><span class="line">			操作结果：求稀疏矩阵乘积Q &#x3D; M * N</span><br><span class="line">		TransposeSmatrix(M, &amp;T);</span><br><span class="line">			初始条件：稀疏矩阵M存在</span><br><span class="line">			操作结果：求稀疏矩阵M的转置矩阵T</span><br><span class="line">&#125;ADT SparseMatrix</span><br></pre></td></tr></table></figure>

<p>稀疏矩阵的三元组表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;-----	稀疏矩阵的三元组顺序表存储表示	-----</span><br><span class="line">#define	MAXSIZE	12500			&#x2F;&#x2F;假设非零元个数的最大值为12500</span><br><span class="line">typedef	struct&#123;</span><br><span class="line">	int	i, j;					&#x2F;&#x2F;该非零元的行下标和列下标</span><br><span class="line">	ElemType	e;</span><br><span class="line">&#125;Triple</span><br><span class="line">typedef	struct&#123;</span><br><span class="line">	Triple	data[MAXSIZE + 1];	&#x2F;&#x2F;非零元三元组表，data[0]未用</span><br><span class="line">	int		mu, nu, tu;			&#x2F;&#x2F;矩阵的行数，列数和非零元个数</span><br><span class="line">&#125;TSMatrix;</span><br></pre></td></tr></table></figure>

<p>三元组表示求稀疏矩阵的转置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Status	TransposeSMatrix(TSMatrix M, TSMatrix &amp;T)&#123;</span><br><span class="line">	&#x2F;&#x2F;采用三元组表存储表示，求稀疏矩阵M的转置矩阵T</span><br><span class="line">	T.mu &#x3D; M.nu;</span><br><span class="line">	T.nu &#x3D; M.nu;</span><br><span class="line">	T.tu &#x3D; M.tu;</span><br><span class="line">	if(T.tu)&#123;</span><br><span class="line">		q &#x3D; 1;</span><br><span class="line">		for(col &#x3D; 1; col&lt;&#x3D;M.nu; ++col)&#123;</span><br><span class="line">			for(p &#x3D; 1; p&lt;&#x3D;M.tu; ++p)&#123;</span><br><span class="line">				if(M.data[p].j &#x3D;&#x3D; col)&#123;</span><br><span class="line">					T.data[q].i &#x3D; M.data[p].j;</span><br><span class="line">					T.data[q].j &#x3D; M.data[p].i;</span><br><span class="line">					T.data[q].e &#x3D; M.data[p].e;</span><br><span class="line">					++q;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return	OK;</span><br><span class="line">&#125;&#x2F;&#x2F;TransposeSMatrix</span><br></pre></td></tr></table></figure>

<p>快速转置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Status	FastTransposeSMatrix(TSMatrix M, TSMatrix &amp;T)&#123;</span><br><span class="line">	&#x2F;&#x2F;采用三元组顺序表存储表示，求稀疏矩阵M的转置矩阵T</span><br><span class="line">	T.mu &#x3D; M.nu;</span><br><span class="line">	T.nu &#x3D; M.mu;</span><br><span class="line">	T.tu &#x3D; M.tu;</span><br><span class="line">	if(T.tu)&#123;</span><br><span class="line">		for(col &#x3D; 1; col&lt;&#x3D;M.nu; ++col)</span><br><span class="line">			num[col] &#x3D; 0;</span><br><span class="line">		for(t &#x3D; 1; t&lt;&#x3D;M.tu; ++t)</span><br><span class="line">			++num[M.data[t].j];	&#x2F;&#x2F;求M中每一列含非零元个数</span><br><span class="line">		cpot[1] &#x3D; 1;</span><br><span class="line">		&#x2F;&#x2F;求第col列中第一个非零元在b.data中的序号</span><br><span class="line">		for(col &#x3D; 2; col&lt;&#x3D;M.nu; ++col)</span><br><span class="line">			cpot[col] &#x3D; cpot[col - 1] + num[col - 1];</span><br><span class="line">		for(p &#x3D; 1; p&lt;&#x3D;M.tu; ++p)&#123;</span><br><span class="line">			col &#x3D; M.data[p].j;</span><br><span class="line">			q &#x3D; cpot[col];</span><br><span class="line">			T.data[q].i &#x3D; M.data[p].j;</span><br><span class="line">			T.data[q].j &#x3D; M.data[p].i;</span><br><span class="line">			T.data[q].e &#x3D; M.data[p].e;</span><br><span class="line">			++cpot[col];</span><br><span class="line">		&#125;&#x2F;&#x2F;for</span><br><span class="line">	&#125;&#x2F;&#x2F;if</span><br><span class="line">	return	OK;</span><br><span class="line">&#125;&#x2F;&#x2F;FastTransposeSmatrix</span><br></pre></td></tr></table></figure>

<p>行逻辑链接的顺序表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef	struct&#123;</span><br><span class="line">	Triple	data[MAXSIZE + 1];		&#x2F;&#x2F;非零元三元组表</span><br><span class="line">	int		rpos[MAXRC + !];		&#x2F;&#x2F;各行第一个非零元的位置表</span><br><span class="line">	int		mu, nu, tu;				&#x2F;&#x2F;矩阵的行数、列数和非零元个数</span><br><span class="line">&#125;RLSMatrix;</span><br></pre></td></tr></table></figure>

<p>两个矩阵相乘的过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Q初始化;</span><br><span class="line">if(Q是非零矩阵)&#123;		&#x2F;&#x2F;逐行压缩</span><br><span class="line">	for(arow &#x3D; 1; arow&lt;&#x3D;M.mu; ++arow)&#123;	&#x2F;&#x2F;处理M的每一行</span><br><span class="line">		ctemp[ ] &#x3D; 0;		&#x2F;&#x2F;累加器清零</span><br><span class="line">		计算Q中第arow行的积并存入ctemp[ ]中;</span><br><span class="line">		将ctemp[ ]中的非零元压缩存储到Q.data;</span><br><span class="line">	&#125;&#x2F;&#x2F;for	arow</span><br><span class="line">&#125;&#x2F;&#x2F;if</span><br></pre></td></tr></table></figure>

<p>求精后可得：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Status	MultSMatrix(RLSMatrix M, RLSMatrix N, RLSMatrix	&amp;Q)&#123;</span><br><span class="line">	&#x2F;&#x2F;求矩阵乘积Q &#x3D; M * N，采用行逻辑链接存储表示</span><br><span class="line">	if(M.nu !&#x3D; N.mu)</span><br><span class="line">		return	ERROR;</span><br><span class="line">	Q.mu &#x3D; M.mu;</span><br><span class="line">	Q.nu &#x3D; N.nu;</span><br><span class="line">	Q.tu &#x3D; 0;			&#x2F;&#x2F;Q初始化</span><br><span class="line">	if(M.tu * N.tu !&#x3D; 0)&#123;	&#x2F;&#x2F;Q是非零矩阵</span><br><span class="line">		for(arow &#x3D; 1; arow&lt;&#x3D;M.mu; ++arow)&#123;	&#x2F;&#x2F;处理M的每一行</span><br><span class="line">			ctemp[ ] &#x3D; 0;		&#x2F;&#x2F;当前行各元素累加器清零</span><br><span class="line">			Q.rpos[arow] &#x3D; Q.tu + 1;</span><br><span class="line">			if(arow&lt;M.mu)</span><br><span class="line">				tp &#x3D; M.rpos[arow + 1];</span><br><span class="line">			else&#123;</span><br><span class="line">				tp &#x3D; M.tu + 1;</span><br><span class="line">			&#125;</span><br><span class="line">			for(p &#x3D; M.rpos[arow]; p&lt;tp; ++p)&#123;	&#x2F;&#x2F;对当前行中每一个非零元</span><br><span class="line">				brow &#x3D; M.data[p].j;				&#x2F;&#x2F;找到对应元在N中的行号</span><br><span class="line">				if(brow &lt; N.mu)</span><br><span class="line">					t &#x3D; N.rpos[brow + 1];</span><br><span class="line">				else&#123;</span><br><span class="line">					t &#x3D; N.tu + 1;</span><br><span class="line">				&#125;</span><br><span class="line">				for(q &#x3D; N.rpos[brow]; q&lt;t; ++q)&#123;</span><br><span class="line">					ccol &#x3D; N.data[q].j;				&#x2F;&#x2F;乘积元素在Q中列号</span><br><span class="line">					ctemp[ccol] +&#x3D; M.data[p].e * N.data[q].e;</span><br><span class="line">				&#125;&#x2F;&#x2F;for q</span><br><span class="line">			&#125;&#x2F;&#x2F;求得Q中第crow( &#x3D;arow)行的非零元</span><br><span class="line">			for(ccol &#x3D; 1; ccol&lt;&#x3D;Q.nu; ++ccol)		&#x2F;&#x2F;压缩存储该行非零元</span><br><span class="line">				if(ctemp[ccol])&#123;</span><br><span class="line">					if( ++Q.tu &gt; MAXSIZE)</span><br><span class="line">						return	ERROR;</span><br><span class="line">					Q.data[Q.tu] &#x3D; (arow, ccol, ctemp[ccol]);</span><br><span class="line">				&#125;&#x2F;&#x2F;if</span><br><span class="line">		&#125;&#x2F;&#x2F;for arow</span><br><span class="line">	&#125;&#x2F;&#x2F;if</span><br><span class="line">	return	OK;</span><br><span class="line">&#125;&#x2F;&#x2F;MultSMatrix</span><br></pre></td></tr></table></figure>

<p>稀疏矩阵的十字链表存储表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">	&#x2F;&#x2F;-----	稀疏矩阵的十字链表存储表示 -----</span><br><span class="line">typedef	struct OLNode&#123;</span><br><span class="line">	int				i, j;			&#x2F;&#x2F;该非零元的行和列下标</span><br><span class="line">	ElemType		e;</span><br><span class="line">	struct	OLNode	*right, *down;	&#x2F;&#x2F;该非零元所在行表和列表的后继链域</span><br><span class="line">&#125;OLNode;	*OLink;</span><br><span class="line"></span><br><span class="line">typedef	struct&#123;</span><br><span class="line">	Olink	*rhead, *chead;			&#x2F;&#x2F;行和列链表的头指针向量基址，由CreatSMatrix分配</span><br><span class="line">	int		mu, nu, tu;				&#x2F;&#x2F;稀疏矩阵的行数、列数和非零元个数</span><br><span class="line">&#125;CrossList;</span><br><span class="line"></span><br><span class="line">Status	CreatSMatrix_OL(CrossList &amp;M)&#123;</span><br><span class="line">	&#x2F;&#x2F;创建稀疏矩阵，用十字链表存储表示</span><br><span class="line">	if(M)</span><br><span class="line">		free(M);</span><br><span class="line">	scanf(&amp;m, &amp;n, &amp;t);				&#x2F;&#x2F;输入m的行数、列数和非零元个数</span><br><span class="line">	M.mu :&#x3D; m；</span><br><span class="line">	M.nu :&#x3D; n;</span><br><span class="line">	M.tu :&#x3D; t;</span><br><span class="line">	if(!(M.rhead &#x3D; (OLink *)malloc((m + 1) * sizeof(OLink))))</span><br><span class="line">		exit(OVERFLOW);</span><br><span class="line">	if(!(M.chead &#x3D; (OLink *)malloc((m + 1) * sizeof(OLink))))</span><br><span class="line">		exit(OVERFLOW);</span><br><span class="line">	M.rhead[ ] &#x3D; M.chead[ ] &#x3D; NULL;	&#x2F;&#x2F;初始化行列头指针向量；各行列链表为空链表</span><br><span class="line">	for(scanf(&amp;i, &amp;j, &amp;e); i!&#x3D;0; scanf(&amp;i, &amp;j, &amp;e))&#123;	&#x2F;&#x2F;按任意次序输入非零元</span><br><span class="line">		if(!(p &#x3D; (OLNode *)malloc(sizeof(OLNode))))</span><br><span class="line">			exit(OVERFLOW);</span><br><span class="line">		p-&gt;i &#x3D; i;</span><br><span class="line">		p-&gt;j &#x3D; j;</span><br><span class="line">		p-&gt;e &#x3D; e;					&#x2F;&#x2F;生成结点</span><br><span class="line">		if(M.rhead[i] &#x3D;&#x3D; NULL || M.rhead[i]-&gt;j&gt;j)&#123;</span><br><span class="line">			p-&gt;right &#x3D; M.rhead[i];</span><br><span class="line">			M.rhead[i] &#x3D; p;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;						&#x2F;&#x2F;巡查在行表中的插入位置</span><br><span class="line">			for( q &#x3D; M.rhead[i]; (q-&gt;right) &amp;&amp; q-&gt;right-&gt;j&lt;j; q &#x3D; q-&gt;right)</span><br><span class="line">				;</span><br><span class="line">			p-&gt;right &#x3D; q-&gt;right;</span><br><span class="line">			q-&gt;rignt &#x3D; p;</span><br><span class="line">		&#125;							&#x2F;&#x2F;完成行插入</span><br><span class="line">		if(M.chead[j] &#x3D;&#x3D; NULL || M.chead[j]-&gt;i&gt;i)&#123;</span><br><span class="line">			p-&gt;down &#x3D; M.chead[j];</span><br><span class="line">			M.chead[j] &#x3D; p;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;						&#x2F;&#x2F;巡查在列表中的插入位置</span><br><span class="line">			for( q &#x3D; M.chead[i]; (q-&gt;down) &amp;&amp; q-&gt;down-&gt;i&lt;i; q &#x3D; q-&gt;down)</span><br><span class="line">				;</span><br><span class="line">			p-&gt;down &#x3D; q-&gt;down;</span><br><span class="line">			q-&gt;down &#x3D; p;</span><br><span class="line">		&#125;							&#x2F;&#x2F;完成列插入</span><br><span class="line">	&#125;</span><br><span class="line">	return	OK;</span><br><span class="line">&#125;&#x2F;&#x2F;CreateSMatrix_OL</span><br></pre></td></tr></table></figure>

<p>广义表的抽象数据类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">ADT	GList&#123;</span><br><span class="line">	数据对象：D &#x3D; &#123;ei|i &#x3D; 1,2,...,n;	ei∈AtomSet或ei∈GList,AtomSet为某个元素的数据对象&#125;</span><br><span class="line">	数据关系：R1 &#x3D; &#123;&lt;ei-1, ei&gt;|ei-1,ei∈D, 2&lt;&#x3D;i&lt;&#x3D;n&#125;</span><br><span class="line">	基本操作：</span><br><span class="line">		InitGList(&amp;L);</span><br><span class="line">			操作结果：创建空间的广义表L</span><br><span class="line">		CreateGList(&amp;L, S);</span><br><span class="line">			初始条件：S是广义表的书写形式串</span><br><span class="line">			操作结果：由S创建广义表L</span><br><span class="line">		DestroyGList(&amp;L);</span><br><span class="line">			初始条件：广义表L存在</span><br><span class="line">			操作结果：销毁广义表L</span><br><span class="line">		CopyGList(&amp;T, L);</span><br><span class="line">			初始条件：广义表L存在</span><br><span class="line">			操作结果：由广义表L复制得到广义表T</span><br><span class="line">		GListLength(L);</span><br><span class="line">			初始条件：广义表L存在</span><br><span class="line">			操作结果：求广义表的长度，即元素个数</span><br><span class="line">		GListDepth(L);</span><br><span class="line">			初始条件：广义表L存在</span><br><span class="line">			操作结果：求广义表的深度</span><br><span class="line">		GListEmpty(L);</span><br><span class="line">			初始条件：广义表L存在</span><br><span class="line">			操作结果：判定广义表L是否为空</span><br><span class="line">		GetHead(L);</span><br><span class="line">			初始条件：广义表L存在</span><br><span class="line">			操作结果：取广义表L的头</span><br><span class="line">		GetTail(L);</span><br><span class="line">			初始条件：广义表L存在</span><br><span class="line">			操作结果：取广义表L的尾</span><br><span class="line">		InsertFirst_GL(&amp;L, &amp;e);</span><br><span class="line">			初始条件：广义表L存在</span><br><span class="line">			操作结果：插入元素e作为广义表的第一元素</span><br><span class="line">		DeleteFirst_GL(&amp;L, &amp;e);</span><br><span class="line">			初始条件：广义表L存在</span><br><span class="line">			操作结果：删除广义表的第一元素，并用e返回其值</span><br><span class="line">		Traverse_GL(L, Visit());</span><br><span class="line">			初始条件：广义表L存在</span><br><span class="line">			操作结果：遍历广义表L，用函数Visit处理每个元素</span><br><span class="line">&#125;ADT	GList</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Decucin
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://yoursite.com/2020/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%EF%BC%88C%E8%AF%AD%E8%A8%80%E7%89%88%EF%BC%89/" title="数据结构算法合集（C语言版）">http://yoursite.com/2020/11/27/数据结构算法合集（C语言版）/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/11/27/%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/" rel="prev" title="准备工作">
      <i class="fa fa-chevron-left"></i> 准备工作
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/04/02/%E7%94%A8C%E6%88%96C++%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E5%B9%B6%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8F%AF%E8%BF%9B%E8%A1%8C%E5%A4%8D%E6%95%B0%E8%BF%90%E7%AE%97%E7%9A%84%E6%BC%94%E7%A4%BA%E7%A8%8B%E5%BA%8F/" rel="next" title="用C或C++语言设计并实现一个可进行复数运算的演示程序">
      用C或C++语言设计并实现一个可进行复数运算的演示程序 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  
  


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#数据结构算法合集（C语言版）"><span class="nav-number">1.</span> <span class="nav-text">数据结构算法合集（C语言版）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#绪论"><span class="nav-number">1.1.</span> <span class="nav-text">绪论</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线性表"><span class="nav-number">1.2.</span> <span class="nav-text">线性表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#栈和队列"><span class="nav-number">1.3.</span> <span class="nav-text">栈和队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#串"><span class="nav-number">1.4.</span> <span class="nav-text">串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组与广义表"><span class="nav-number">1.5.</span> <span class="nav-text">数组与广义表</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Decucin"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Decucin</p>
  <div class="site-description" itemprop="description">喜欢简单的事物和明朗的关系</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/decucin" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;decucin" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1690406856@qq.com" title="E-Mail → mailto:1690406856@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/decucin" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;decucin" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020-05 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Decucin</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">67k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">1:01</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>


	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
	<span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
	<span class="post-meta-divider">|</span>
	<span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
	<span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值矫正 -->
<script>
$(document).ready(function() {

	var int = setInterval(fixCount, 50);
	var count0ffset = 20000;
	
	function fixCount(){
		if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
		{
			$("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + count0ffset);
			clearInterval(int);
		}
		if ($("#busuanzi_value_site_pv").css("display") != "none")
		{
			$("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) +count0ffset);
			clearInterval(int);
		}
	}
});
</script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  <script type="text/javascript" src="/js/love.js"></script>
</body>
</html>
