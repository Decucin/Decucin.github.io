<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="链表部分">
<meta property="og:type" content="website">
<meta property="og:title" content="牛客题解">
<meta property="og:url" content="http://yoursite.com/solution/%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3.html">
<meta property="og:site_name" content="Blog of Decucin">
<meta property="og:description" content="链表部分">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20211014/423483716_1634206291971/4A47A0DB6E60853DEDFCFDF08A5CA249">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20220110/423483716_1641800950920/0710DD5D9C4D4B11A8FA0C06189F9E9C">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20211025/423483716_1635154005498/DA92C945EF643F1143567935F20D6B46">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20211105/423483716_1636084313645/5407F55227804F31F5C5D73558596F2C">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20211104/423483716_1635999204882/394BB7AFD5CEA3DC64D610F62E6647A6">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20211105/423483716_1636084743981/C2DB572B01B0FDC03C097BE7ABA45114">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20211014/423483716_1634212356346/9EB9CD58B9EA5E04C890326B5C1F471F">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20210114/999991351_1610616074120/036DC34FF19FB24652AFFEB00A119A76">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20210717/557336_1626492068888/41FDD435F0BA63A57E274747DE377E05">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20200807/999991351_1596786493913_8BFB3E9513755565DC67D86744BB6159">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20210605/557336_1622886924427/E1F1270919D292C9F48F51975FD07CE2">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20210926/382300087_1632642756706/A22A794C036C06431E632F9D5E2E298F">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20210926/382300087_1632642770481/3304ABDD147D8E140B2CEF3201BD8372">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20210928/382300087_1632821337680/9E290CFD3730B9B08A5CEFF25799608F">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20210928/382300087_1632821376266/DD0A63560E770A8510049C5182E6E622">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20210928/382300087_1632821404541/9CB750F8909D5985C0D01D8B71AD58BA">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20210922/382300087_1632302001586/420B82546CFC9760B45DD65BA9244888">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20210922/382300087_1632302036250/AD8C4CC119B15070FA1DBAA1EBE8FC2A">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20211109/392807_1636440937987/9C31F319601A5B78D34F62FF77A02A11">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20211109/392807_1636440984427/5E5B576E11CB2C96724680C94755ABCB">
<meta property="article:published_time" content="2022-03-13T01:24:41.000Z">
<meta property="article:modified_time" content="2022-03-13T05:44:28.832Z">
<meta property="article:author" content="Decucin">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://uploadfiles.nowcoder.com/images/20211014/423483716_1634206291971/4A47A0DB6E60853DEDFCFDF08A5CA249">

<link rel="canonical" href="http://yoursite.com/solution/%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>牛客题解 | Blog of Decucin
</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Blog of Decucin" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Blog of Decucin</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
  
  

          <div class="content page posts-expand">
            

    
    
    
    <div class="post-block" lang="zh-CN">
      <header class="post-header">

<h1 class="post-title" itemprop="name headline">牛客题解
</h1>

<div class="post-meta">
  

</div>

</header>

      
      
      
      <div class="post-body">
          <h1 id="链表部分"><a href="#链表部分" class="headerlink" title="链表部分"></a>链表部分</h1><a id="more"></a>

<h2 id="BM1-反转链表"><a href="#BM1-反转链表" class="headerlink" title="BM1 反转链表"></a>BM1 <a href="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=295&tqId=23286&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">反转链表</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个单链表的头结点pHead(该头节点是有值的，比如在下图，它的val是1)，长度为n，反转该链表后，返回新链表的表头。 </p>
<p>数据范围： 0≤<em>n</em>≤1000</p>
<p>要求：空间复杂度 O(1) ，时间复杂度 O(n)。 </p>
<p>如当输入链表{1,2,3}时， </p>
<p>经反转后，原链表变为{3,2,1}，所以对应的输出为{3,2,1}。 </p>
<p>以上转换过程如下图所示：</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20211014/423483716_1634206291971/4A47A0DB6E60853DEDFCFDF08A5CA249" alt="img"></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>反转链表的基本思想就是利用三个指针，pre，cur，nex分别表示当前节点前一个节点、当前节点以及当前节点后面的节点，之后再令cur.next = pre;其实就完成了反转操作，完成反转操作之后将三个指针依次后移即可。</p>
<h3 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 优先考虑特殊情况，一个节点都没有或是只有一个节点，直接返回即可</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode nex = cur.next;</span><br><span class="line">            <span class="comment">// 这里是反转的核心，令之前在前面的指针挪到后面</span></span><br><span class="line">            cur.next = pre;</span><br><span class="line">            <span class="comment">// 之后依次将各指针后移即可；</span></span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = nex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当退出循环时，其实就是cur == null的情况，这时</span></span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM2-链表内指定区间反转"><a href="#BM2-链表内指定区间反转" class="headerlink" title="BM2 链表内指定区间反转"></a>BM2 <a href="https://www.nowcoder.com/practice/b58434e200a648c589ca2063f1faf58c?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">链表内指定区间反转</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>将一个节点数为 size 链表 m 位置到 n 位置之间的区间反转，要求时间复杂度 O<em>(</em>n<em>)，空间复杂度 *O</em>(1)。<br>例如：<br>给出的链表为 1→2→3→4→5→<em>NULL</em>, m=2,n=4<em>m</em>=2,<em>n</em>=4,<br>返回 1→4→3→2→5→<em>NULL</em>.</p>
<p><strong>数据范围： 链表长度 0&lt;size≤1000，0&lt;m≤n≤size，链表中每个节点的值满足 |val|≤1000|val|≤1000</strong></p>
<p><strong>要求：时间复杂度 <em>O</em>(<em>n</em>) ，空间复杂度 <em>O</em>(<em>n</em>)</strong></p>
<p><strong>进阶：时间复杂度 <em>O</em>(<em>n</em>) ，空间复杂度 <em>O</em>(<em>1</em>)</strong></p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>这题的思想和反转链表实际上是一样的，关键点（与反转整个链表不同之处）在于这里反转的链表只是整个链表中的一部分，故涉及链表的截断(cur.next = null)以及连接(cur.next = head2.next)，考虑方法如下：首先需要将链表的头尾指针进行保存（考虑如下几个指针的保存，原链表截断之前的指针，截断部分的头尾指针以及截断部分之后的头指针），之后将截断部分进行反转，之后再进行链表的拼接即可。</p>
<p><strong>可用一个虚拟头节点防止头节点各种复杂条件判断</strong></p>
<h3 id="Java代码实现-1"><a href="#Java代码实现-1" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span> <span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 首先考虑特殊情况，若是m == n即有一个节点需要反转，那直接无需反转</span></span><br><span class="line">        <span class="keyword">if</span>(m == n)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 首先考虑需要的指针，总共有三条链表，用head1-3以及tail1-3分别表示其头尾</span></span><br><span class="line">        ListNode head2 = <span class="keyword">null</span>;</span><br><span class="line">        ListNode head3 = <span class="keyword">null</span>;</span><br><span class="line">        ListNode tail1 = <span class="keyword">null</span>;</span><br><span class="line">        ListNode tail2 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 此外，链表遍历还用到两个指针</span></span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="comment">// 考虑利用虚指针</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        pre = dummy;</span><br><span class="line">        <span class="comment">// 用于标记索引下标</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == m)&#123;</span><br><span class="line">                <span class="comment">//将链表截断</span></span><br><span class="line">                pre.next = <span class="keyword">null</span>;</span><br><span class="line">                tail1 = pre;</span><br><span class="line">                head2 = cur;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == n + <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//将链表截断</span></span><br><span class="line">                pre.next = <span class="keyword">null</span>;</span><br><span class="line">                tail2 = pre;</span><br><span class="line">                pre.next = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 这里可能只有n个节点，但此时到了第i + 1个节点，为null</span></span><br><span class="line">                <span class="keyword">if</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    head3 = cur;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 无论是否需要截断链表都将指针后移</span></span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将其反转拼接第一二段</span></span><br><span class="line">        tail1.next = reverse(head2);</span><br><span class="line">        <span class="comment">// 拼接二三段</span></span><br><span class="line">        head2 = tail1;</span><br><span class="line">        <span class="keyword">while</span>(head2.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            head2 = head2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        head2.next = head3;</span><br><span class="line"><span class="comment">//         这里的拼接过程，我的原本是，没有连接上，若是要连接链表，需要通过next下标</span></span><br><span class="line"><span class="comment">//         while(tail1 != null)&#123;</span></span><br><span class="line"><span class="comment">//             tail1 = tail1.next;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         tail1 = head3;</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里返回反转后的头指针</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode nex = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = nex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM3-链表中的节点每k个一组翻转"><a href="#BM3-链表中的节点每k个一组翻转" class="headerlink" title="BM3 链表中的节点每k个一组翻转"></a>BM3 <a href="https://www.nowcoder.com/practice/b49c3dc907814e9bbfa8437c251b028e?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">链表中的节点每k个一组翻转</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>将给出的链表中的节点每 k 个一组翻转，返回翻转后的链表<br>如果链表中的节点数不是 k 的倍数，将最后剩下的节点保持原样<br>你不能更改节点中的值，只能更改节点本身。</p>
<p>数据范围：0≤<em>n</em>≤2000 ，1≤<em>k</em>≤2000 ，链表中每个元素都满足 0≤<em>val</em>≤1000</p>
<p>要求空间复杂度<em>O(1)<em>，时间复杂度、</em>O(n)</em></p>
<p>例如： </p>
<p>给定的链表是1→2→3→4→5</p>
<p>对于<em>k</em>=2 , 你应该返回2→1→4→3→5</p>
<p>对于<em>k</em>=3 , 你应该返回 3→2→1→4→5</p>
<h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>先求出链表的长度，然后判断需要分几组，之后对每组进行反转并连接，过程中需要注意保存以下节点：preStart–&gt;需要反转的节点之前的节点，start–&gt;开始反转的节点，afterStart–&gt;反转结束的下一个节点，end–&gt;反转结束的节点，还有就是反转链表需要的三个节点pre，cur以及nex。</p>
<p><strong>可用一个虚拟头节点防止头节点各种复杂条件判断</strong></p>
<p><strong>注意点：每次连接时只连接一端（连接上一个链表和这一个链表），当全部反转都完成之后，再连接这一个链表和下一个链表</strong></p>
<h3 id="Java代码实现-2"><a href="#Java代码实现-2" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span> <span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 特殊情况，每1个为1组进行反转，直接返回即可</span></span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 长度</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 虚拟头节点</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        <span class="comment">// 反转节点之前的节点</span></span><br><span class="line">        ListNode preStart = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 开始反转的节点（反转之后变成了需要和后面链表进行拼接的节点）</span></span><br><span class="line">        ListNode start = dummy;</span><br><span class="line">        <span class="comment">// 反转结束的节点</span></span><br><span class="line">        ListNode end = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 反转结束节点之后的节点</span></span><br><span class="line">        ListNode afterStart = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 反转过程中需要的节点</span></span><br><span class="line">        ListNode pre = dummy;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        ListNode nex = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ++len;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断需要分几组</span></span><br><span class="line">        <span class="keyword">int</span> group = len / k;</span><br><span class="line">        <span class="comment">// 特殊情况，head为空或为1直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span> || len == <span class="number">1</span> || group &lt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; group; ++i)&#123;</span><br><span class="line">            <span class="comment">// 先记录反转之前的节点以及开始节点</span></span><br><span class="line">            preStart = start;    <span class="comment">// 反转之前的节点实际上是上一反转链表的头（第一次反转，其前一个节点为dummy，故对preStart赋初值应为dummy）</span></span><br><span class="line">            start = cur;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++j)&#123;</span><br><span class="line">                nex = cur.next;</span><br><span class="line">                <span class="comment">// 开始进行反转</span></span><br><span class="line">                cur.next = pre;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = nex;</span><br><span class="line">            &#125;</span><br><span class="line">            end = pre;</span><br><span class="line">            afterStart = cur;</span><br><span class="line">            <span class="comment">// 开始进行连接，注意这里只是连接反转之前的头和这一次的尾</span></span><br><span class="line">            preStart.next = end;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当反转全部完成时，再将这一次反转的尾和反转之后的节点进行连接</span></span><br><span class="line">        start.next = afterStart;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM4-合并两个排序的链表"><a href="#BM4-合并两个排序的链表" class="headerlink" title="BM4 合并两个排序的链表"></a>BM4 <a href="https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">合并两个排序的链表</a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两个递增的链表，单个链表的长度为n，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>
<p>数据范围： 0≤n≤10000，−1000≤节点值≤1000<br>要求：空间复杂度 O(1)，时间复杂度 O(n)</p>
<h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>双指针移动即可，但若是想达到O(1)的时间复杂度，则需要原地修改指针，故选择如下方法：将两个链表中的当前节点标记，标记当前节点的作用是，判断本次应该连接哪一个节点（链表1中的节点或是链表2中的节点），之后再将剩下的链表合并即可。</p>
<p><strong>可用一个虚拟头节点防止头节点各种复杂条件判断</strong></p>
<h3 id="Java代码实现-3"><a href="#Java代码实现-3" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 首先考虑特殊情况，即两个链表中一个链表为空时，直接返回另一个链表即可</span></span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="keyword">null</span> || list2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list1 == <span class="keyword">null</span> ? list2 : list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 首先需要两个指针分别记录两个链表走到了哪</span></span><br><span class="line">        ListNode cur1 = list1;</span><br><span class="line">        ListNode cur2 = list2;</span><br><span class="line">        <span class="comment">// 避免考虑头节点，先来个虚拟节点</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode cur = dummy;</span><br><span class="line">        <span class="comment">// 先将两个链表合并</span></span><br><span class="line">        <span class="keyword">while</span>(cur1 != <span class="keyword">null</span> &amp;&amp; cur2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur1.val &lt; cur2.val)&#123;</span><br><span class="line">                cur.next = cur1;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur.next = cur2;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 再合并剩下的部分，此时一个链表已经为空了</span></span><br><span class="line">        cur.next = cur1 == <span class="keyword">null</span> ? cur2 : cur1;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM5-合并k个已排序的链表"><a href="#BM5-合并k个已排序的链表" class="headerlink" title="BM5 合并k个已排序的链表"></a>BM5 <a href="https://www.nowcoder.com/practice/65cfde9e5b9b4cf2b6bafa5f3ef33fa6?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">合并k个已排序的链表</a></h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>合并 k 个升序的链表并将结果作为一个升序的链表返回其头节点。</p>
<p>数据范围：节点总数 0≤n≤5000，每个节点的val满足 ∣val∣&lt;=100</p>
<p>要求：时间复杂度 O(nlogn)</p>
<h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><p>这题只说了要求时间复杂度O(nlogn)，而未要求空间复杂度，我自己的想法是将链表中所有节点的值保存到ArrayList中进行排序，排序之后再依次生成节点即可。</p>
<h3 id="Java代码实现-4"><a href="#Java代码实现-4" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ArrayList&lt;ListNode&gt; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = lists.size();</span><br><span class="line">        <span class="comment">// 当前节点</span></span><br><span class="line">        ListNode cur = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 存储全部元素所用的集合</span></span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="comment">// 将每个链表的每个节点都存入</span></span><br><span class="line">            cur = lists.get(i);</span><br><span class="line">            <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">                res.add(cur.val);</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(res);</span><br><span class="line">        <span class="comment">// 建一个虚拟头指针已防止头节点的误判</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        cur = dummy;</span><br><span class="line">        <span class="keyword">for</span>(Integer num : res)&#123;</span><br><span class="line">            cur.next = <span class="keyword">new</span> ListNode(num);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是注意以上题解并未使用到一个条件–&gt;这n个链表均为有序链表，因此时间复杂度肯定不是最佳，想到用k个指针进行迭代，但经过k - 1次比较之后才能完成1个数的排序，故其时间复杂度为O(kn)，由此想到维护一个一直有序的数组，每次取出下标为0的位置，并将该数所在链表的后一个节点放入数组中（保证其有序–&gt;这里可以使用二分找到对应的下标），但此时出现矛盾，使用二分进行查找，那数组更合适，但若是涉及插入操作，则链表更合适，，，矛盾，故舍弃此思路。</p>
<p>但看题解是发现大部分此思路采用的是优先队列来实现，队列自动维护，每次只需取出队头就行。</p>
<p>看了题解后发现：不是使用k个指针，而是每次合并的时候是两两合并，如有链表1, 2, 3, 4, 5, 6, 7, 8，第一次合并，将12合并，34合并，56合并，78合并，得到四个新链表1, 2, 3, 4，之后再次合并，12合并，34合并，得到链表1, 2，最后再将12合并得到所需的链表，完整题解如下：</p>
<h3 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h3><p>采用分治法的思想（先分后并），将所给的k个链表分成两份，一直持续地分，分到不能再分为止（k个链表被分为k份），之后再依次将两个链表进行合并，直到合并为最后一个链表为止。</p>
<h3 id="Java代码实现-5"><a href="#Java代码实现-5" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ArrayList&lt;ListNode&gt; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = lists.size();</span><br><span class="line">        <span class="comment">// 此函数确定需要合并的下标范围0----n-1</span></span><br><span class="line">        <span class="keyword">return</span> merge(lists, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这个函数的作用是从left合并到right</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">merge</span><span class="params">(ArrayList&lt;ListNode&gt; lists, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 若是无法再分，则直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">            <span class="keyword">return</span> lists.get(left);</span><br><span class="line">            <span class="comment">// left &gt; right表示长度为0，即merge(lists, 0, -1)，数组中有任何一个链表为空时都会产生此情况</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 否则考虑合并left， mid为一个链表，mid +1 到right为一个链表</span></span><br><span class="line">            <span class="keyword">return</span> merge2Lists(merge(lists, left, mid), merge(lists, mid + <span class="number">1</span>, right));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这一部分完全就是合并两个链表的代码</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">merge2Lists</span><span class="params">(ListNode list1, ListNode list2)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 首先考虑特殊情况，即两个链表中一个链表为空时，直接返回另一个链表即可</span></span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="keyword">null</span> || list2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list1 == <span class="keyword">null</span> ? list2 : list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 首先需要两个指针分别记录两个链表走到了哪</span></span><br><span class="line">        ListNode cur1 = list1;</span><br><span class="line">        ListNode cur2 = list2;</span><br><span class="line">        <span class="comment">// 避免考虑头节点，先来个虚拟节点</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode cur = dummy;</span><br><span class="line">        <span class="comment">// 先将两个链表合并</span></span><br><span class="line">        <span class="keyword">while</span>(cur1 != <span class="keyword">null</span> &amp;&amp; cur2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur1.val &lt; cur2.val)&#123;</span><br><span class="line">                cur.next = cur1;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur.next = cur2;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 再合并剩下的部分，此时一个链表已经为空了</span></span><br><span class="line">        cur.next = cur1 == <span class="keyword">null</span> ? cur2 : cur1;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM6-判断链表中是否有环"><a href="#BM6-判断链表中是否有环" class="headerlink" title="BM6 判断链表中是否有环"></a>BM6 <a href="https://www.nowcoder.com/practice/650474f313294468a4ded3ce0f7898b9?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">判断链表中是否有环</a></h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>判断给定的链表中是否有环。如果有环则返回true，否则返回false。 </p>
<p>数据范围：链表长度 0≤n≤10000，链表中任意节点的值满足 ∣val∣&lt;=100000</p>
<p>要求：空间复杂度 O(1)，时间复杂度 O(n)</p>
<p>输入分为两部分，第一部分为链表，第二部分代表是否有环，然后将组成的head头结点传入到函数里面。-1代表无环，其它的数字代表有环，这些参数解释仅仅是为了方便读者自测调试。实际在编程时读入的是链表的头节点。</p>
<p>例如输入{3,2,0,-4},1时，对应的链表结构如下图所示： </p>
<p><img src="https://uploadfiles.nowcoder.com/images/20220110/423483716_1641800950920/0710DD5D9C4D4B11A8FA0C06189F9E9C" alt="img"></p>
<p>可以看出环的入口结点为从头结点开始的第1个结点（注：头结点为第0个结点），所以输出true。</p>
<h3 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h3><p>快慢指针，一个每次走一格，一个每次走两个，若是有环则必会相遇，这里题目中没说任意节点的值均不同，判断两指针是否相遇时最好不只是判断两个节点的val是否相遇而是判断两个指针的地址是否相同</p>
<h3 id="Java代码实现-6"><a href="#Java代码实现-6" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里注意题目中说0 &lt;= n，故有可能为0，特殊情况优先考虑</span></span><br><span class="line">        <span class="comment">// 由于之后的fast和slow都是先赋值，为了防止对空指针进行操作，需要先进行判断</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head.next;</span><br><span class="line">        ListNode fast = head.next.next;</span><br><span class="line">        <span class="comment">// 快慢指针，若是有一个先遍历完，那必然是快指针</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 这里是先比较后移动，因为第一次移动过了</span></span><br><span class="line">            <span class="keyword">if</span>(slow == fast)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="comment">// 增加这个判断是防止当fast到了最后一个元素时，fast.next.next就对空指针进行了操作</span></span><br><span class="line">            <span class="comment">// 也可以将判断条件加在while循环中，即：while(fast != null &amp;&amp; fast.next != null)</span></span><br><span class="line">            <span class="keyword">if</span>(fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">                fast = fast.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM7-链表中环的入口节点"><a href="#BM7-链表中环的入口节点" class="headerlink" title="BM7 链表中环的入口节点"></a>BM7 <a href="https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">链表中环的入口节点</a></h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><p>给一个长度为n链表，若其中包含环，请找出该链表的环的入口结点，否则，返回null。 </p>
<p>数据范围： n≤10000，1&lt;=结点值&lt;=10000</p>
<p>要求：空间复杂度 O(1)，时间复杂度 O(n)</p>
<p>例如，输入{1,2},{3,4,5}时，对应的环形链表如下图所示：</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20211025/423483716_1635154005498/DA92C945EF643F1143567935F20D6B46" alt="img"></p>
<p>可以看到环的入口结点的结点值为3，所以返回结点值为3的结点。</p>
<h4 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h4><p>输入分为2段，第一段是入环前的链表部分，第二段是链表环的部分，后台会根据第二段是否为空将这两段组装成一个无环或者有环单链表</p>
<h4 id="返回值描述"><a href="#返回值描述" class="headerlink" title="返回值描述"></a>返回值描述</h4><p>返回链表的环的入口结点即可，我们后台程序会打印这个结点对应的结点值；若没有，则返回对应编程语言的空结点即可。</p>
<h3 id="题解-7"><a href="#题解-7" class="headerlink" title="题解"></a>题解</h3><p>这题的做法和判断是否有环类似，都是先使用快慢指针找到两个指针重合的位置判定有环，之后注意一个点，此时将其中一个指针移至原链表头并让两个指针以相同的速度移动，那么当两个指针再次相遇时的节点即为入口节点，具体证明如下，图可参考<a href="https://blog.nowcoder.net/n/9d3ffa4b004e43d1aff512141d0d7dac" target="_blank" rel="noopener">官方题解</a>：</p>
<p>首先假设链表中无环的部分（从头节点到环的入口节点）距离为x，从环的入口到相遇节点的距离为y，从相遇节点再次到环的入口距离为m，则由快慢指针的速度可得如下距离方程：</p>
<p>(x + y + m + y) / (x + y) = 2</p>
<p>其中除号左边为快指针走的距离，除号右边为慢指针走的距离，两者走了相同的时间，距离刚好与速度成正比</p>
<h3 id="Java代码实现-7"><a href="#Java代码实现-7" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况优先考虑</span></span><br><span class="line">        <span class="keyword">if</span>(pHead == <span class="keyword">null</span> || pHead.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode fast = pHead.next.next;</span><br><span class="line">        ListNode slow = pHead.next;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">                <span class="comment">// 此时有环，开始第二轮遍历</span></span><br><span class="line">                fast = pHead;</span><br><span class="line">                <span class="keyword">while</span>(fast != slow)&#123;</span><br><span class="line">                    fast = fast.next;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> fast;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 退出了循环证明无环</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM8-链表中倒数最后k个节点"><a href="#BM8-链表中倒数最后k个节点" class="headerlink" title="BM8 链表中倒数最后k个节点"></a>BM8 <a href="https://www.nowcoder.com/practice/886370fe658f41b498d40fb34ae76ff9?tpId=295&tqId=1377477&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">链表中倒数最后k个节点</a></h2><h3 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个长度为 n 的链表，设链表中的元素的值为 ai ，返回该链表中倒数第k个节点。 </p>
<p>如果该链表长度小于k，请返回一个长度为 0 的链表。 </p>
<p>数据范围：0≤n≤105，0≤ai≤109，0≤k≤109</p>
<p>要求：空间复杂度 O(n)，时间复杂度 O(n)</p>
<p>进阶：空间复杂度 O(1)，时间复杂度 O(n)</p>
<p>例如输入{1,2,3,4,5},2时，对应的链表结构如下图所示： </p>
<p><img src="https://uploadfiles.nowcoder.com/images/20211105/423483716_1636084313645/5407F55227804F31F5C5D73558596F2C" alt="img"></p>
<p>其中蓝色部分为该链表的最后2个结点，所以返回倒数第2个结点（也即结点值为4的结点）即可，系统会打印后面所有的节点来比较。</p>
<h3 id="题解-8"><a href="#题解-8" class="headerlink" title="题解"></a>题解</h3><p>两次遍历链表，第一次求出链表长度，第二次直接返回最后k个节点的开始节点</p>
<h3 id="Java代码实现-8"><a href="#Java代码实现-8" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pHead ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span> <span class="params">(ListNode pHead, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        ListNode cur = pHead;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ++len;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 题目中说若是链表长度小于k则返回空链表，这里已经考虑了链表为空的情况(len = 0)</span></span><br><span class="line">        <span class="keyword">if</span>(len &lt; k)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = pHead;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 这里需要稍微考虑下i++到底应该小于多少</span></span><br><span class="line">        <span class="keyword">while</span>(i++ &lt; len - k)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM9-删除链表的倒数第n个节点"><a href="#BM9-删除链表的倒数第n个节点" class="headerlink" title="BM9 删除链表的倒数第n个节点"></a>BM9 <a href="https://www.nowcoder.com/practice/f95dcdafbde44b22a6d741baf71653f6?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">删除链表的倒数第n个节点</a></h2><h3 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个链表，删除链表的倒数第 n 个节点并返回链表的头指针<br>例如， </p>
<p>给出的链表为: 1→2→3→4→5, n=2.<br>删除了链表的倒数第 n<em>n</em> 个节点之后,链表变为1→2→3→5.</p>
<p>数据范围： 链表长度 0≤n≤1000，链表中任意节点的值满足 0≤val≤100</p>
<p>要求：空间复杂度 O(1)，时间复杂度 O(n)<br>备注： </p>
<p>题目保证 n 一定是有效的</p>
<h3 id="题解-9"><a href="#题解-9" class="headerlink" title="题解"></a>题解</h3><p>这里的思路也是两次遍历链表，然后找到需要删除的节点，但要注意保存需要删除的节点之前的节点。</p>
<p><strong>可用一个虚拟头节点防止各种复杂条件判断</strong></p>
<h3 id="Java代码实现-9"><a href="#Java代码实现-9" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span> <span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 虚拟头节点</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        <span class="comment">// 遍历需要的两个节点</span></span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        ListNode pre = dummy;</span><br><span class="line">        <span class="comment">// 开始第一次遍历求出链表长度</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ++len;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 题目中说n符合要求，故无需判断，直接二次遍历即可</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//注意这里将cur指针返回head</span></span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span>(i++ &lt; len - n)&#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里将cur节点删除，实际上就是将cur之前的指针与cur之后的指针进行连接即可</span></span><br><span class="line">        pre.next = cur.next;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM10-两个链表的第一个公共结点"><a href="#BM10-两个链表的第一个公共结点" class="headerlink" title="BM10 两个链表的第一个公共结点"></a>BM10 <a href="https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">两个链表的第一个公共结点</a></h2><h3 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两个无环的单向链表，找出它们的第一个公共结点，如果没有公共节点则返回空。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的） </p>
<p>数据范围： n≤1000<br>要求：空间复杂度 O(1)，时间复杂度 O(n)</p>
<p>例如，输入{1,2,3},{4,5},{6,7}时，两个无环的单向链表的结构如下图所示：</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20211104/423483716_1635999204882/394BB7AFD5CEA3DC64D610F62E6647A6" alt="img"></p>
<p>可以看到它们的第一个公共结点的结点值为6，所以返回结点值为6的结点。</p>
<h4 id="输入描述："><a href="#输入描述：" class="headerlink" title="输入描述："></a>输入描述：</h4><p>输入分为是3段，第一段是第一个链表的非公共部分，第二段是第二个链表的非公共部分，第三段是第一个链表和第二个链表的公共部分。 后台会将这3个参数组装为两个链表，并将这两个链表对应的头节点传入到函数FindFirstCommonNode里面，用户得到的输入只有pHead1和pHead2。</p>
<h4 id="返回值描述："><a href="#返回值描述：" class="headerlink" title="返回值描述："></a>返回值描述：</h4><p>返回传入的pHead1和pHead2的第一个公共结点，后台会打印以该节点为头节点的链表。</p>
<h3 id="题解-10"><a href="#题解-10" class="headerlink" title="题解"></a>题解</h3><p>最简单的方法是先将一个链表中的所有节点放入一个set中，之后对于第二个链表中的每一个节点，若是set中已有，则返回该节点（需要的是第一个公共节点，故只要找到就直接返回），若是遍历完之后仍然没有找到公共节点，那么返回null，但此方法空间复杂度为O(n)，不合题意，若是想要O(1)的时间复杂度可采取如下思路：</p>
<p>两次遍历链表，第一次遍历记载两个链表的长度，然后找到一个链表比另一个链表长多少(len1 - len2)，较长的链表先走(len1 - len2)格，之后两个链表一起走，若是某时刻两个节点相同，那直接返回，之后若是遍历完仍然未找到相同元素，返回null</p>
<h3 id="Java代码实现-10"><a href="#Java代码实现-10" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况，若是两个链表某一个为空，那直接返回null</span></span><br><span class="line">        <span class="keyword">if</span>(pHead1 == <span class="keyword">null</span> || pHead2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len2 = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 当前链表1走到了哪</span></span><br><span class="line">        ListNode cur1 = pHead1;</span><br><span class="line">        <span class="comment">// 当前链表2走到了哪</span></span><br><span class="line">        ListNode cur2 = pHead2;</span><br><span class="line">        <span class="keyword">while</span>(cur1 != <span class="keyword">null</span> || cur2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">                ++len1;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">                ++len2;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将指针放回头部</span></span><br><span class="line">        cur1 = pHead1;</span><br><span class="line">        cur2 = pHead2;</span><br><span class="line">        <span class="keyword">if</span>(len1 &gt;= len2)&#123;</span><br><span class="line">            <span class="keyword">return</span> run(cur1, cur2, len1 - len2);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> run(cur2, cur1, len2 - len1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">run</span><span class="params">(ListNode head1, ListNode head2, <span class="keyword">int</span> lenSub)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 先让head1走lenSub格，已经确保head1不比head2短</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i++ &lt; lenSub)&#123;</span><br><span class="line">            head1 = head1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 之后两个一起走</span></span><br><span class="line">        <span class="keyword">while</span>(head1 != <span class="keyword">null</span> &amp;&amp; head2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head1 == head2)&#123;</span><br><span class="line">                <span class="keyword">return</span> head1;</span><br><span class="line">            &#125;</span><br><span class="line">            head1 = head1.next;</span><br><span class="line">            head2 = head2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 要是退出循环（遍历完）还未找到说明不存在</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM11-链表相加（二）"><a href="#BM11-链表相加（二）" class="headerlink" title="BM11 链表相加（二）"></a>BM11 <a href="https://www.nowcoder.com/practice/c56f6c70fb3f4849bc56e33ff2a50b6b?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">链表相加（二）</a></h2><h3 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h3><p>假设链表中每一个节点的值都在 0 - 9 之间，那么链表整体就可以代表一个整数。 </p>
<p>给定两个这种链表，请生成代表两个整数相加值的结果链表。 </p>
<p>数据范围：0≤n,m≤1000000，链表任意值 0≤val≤9<br>要求：空间复杂度 O(n)，时间复杂度 O(n)</p>
<p>例如：链表 1 为 9-&gt;3-&gt;7，链表 2 为 6-&gt;3，最后生成新的结果链表为 1-&gt;0-&gt;0-&gt;0。 </p>
<p><img src="https://uploadfiles.nowcoder.com/images/20211105/423483716_1636084743981/C2DB572B01B0FDC03C097BE7ABA45114" alt="img"></p>
<h3 id="题解-11"><a href="#题解-11" class="headerlink" title="题解"></a>题解</h3><p>最简单的方法，将链表中的每一个元素取出来，两个数相加之后再返回，但是注意数据范围是0≤n,m≤1000000，此方法无法保存这么大的数据，故舍弃。</p>
<p>考虑直接对链表节点进行相加，但涉及两个问题，一是顺序问题（链表是正序的，但是相加时需要逆序），而是考虑进位问题，对于顺序问题，先进后出考虑用栈解决，进位只需多一个节点进行保存即可。</p>
<h3 id="Java代码实现-11"><a href="#Java代码实现-11" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head1 ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head2 ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addInList</span> <span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 特殊情况优先考虑，若是两个链表一个为空那直接返回另一个即可</span></span><br><span class="line">        <span class="keyword">if</span>(head1 == <span class="keyword">null</span> || head2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head1 == <span class="keyword">null</span> ? head2 : head1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 栈中存节点空间消耗太大，直接存节点中的值即可</span></span><br><span class="line">        <span class="comment">// 保存第一个链表中的数</span></span><br><span class="line">        Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">// 保存第二个链表中的数</span></span><br><span class="line">        Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">// 保存相加之后的结果</span></span><br><span class="line">        Stack&lt;Integer&gt; ans = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        ListNode cur = head1;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack1.push(cur.val);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head2;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack2.push(cur.val);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 进位</span></span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stack1.isEmpty() || !stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> num1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> num2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(!stack1.isEmpty())&#123;</span><br><span class="line">                num1 = stack1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!stack2.isEmpty())&#123;</span><br><span class="line">                num2 = stack2.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> sum = num1 + num2 + carry;</span><br><span class="line">            ans.push(sum % <span class="number">10</span>);</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里最后判断一下进位是否为0，若进位不是0则需要处理</span></span><br><span class="line">        <span class="keyword">if</span>(carry != <span class="number">0</span>)&#123;</span><br><span class="line">            ans.push(carry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 生成链表</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        cur = dummy;</span><br><span class="line">        <span class="keyword">while</span>(!ans.isEmpty())&#123;</span><br><span class="line">            cur.next = <span class="keyword">new</span> ListNode(ans.pop());</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM12-单链表的排序问题"><a href="#BM12-单链表的排序问题" class="headerlink" title="BM12 单链表的排序问题"></a>BM12 <a href="https://www.nowcoder.com/practice/f23604257af94d939848729b1a5cda08?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">单链表的排序问题</a></h2><h3 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个节点数为n的无序单链表，对其按升序排序。</p>
<p>数据范围：0&lt;n≤100000</p>
<p>要求：空间复杂度 O(n)，时间复杂度 O(nlogn)</p>
<h3 id="题解-12"><a href="#题解-12" class="headerlink" title="题解"></a>题解</h3><p>最简单的做法是遍历链表，将链表中每个节点的值放入数组中，对数组进行排序，之后再逐个取出元素并新建链表节点，这里注意将链表的每个节点值存入数组中空间占用更小</p>
<h3 id="Java代码实现-12"><a href="#Java代码实现-12" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 the head node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortInList</span> <span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 特殊情况，只有一个元素时无需排序（题目中说节点数n &gt; 0）</span></span><br><span class="line">        <span class="keyword">if</span>(head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            list.add(cur.val);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        <span class="comment">// 记得把指针回退</span></span><br><span class="line">        cur = dummy;</span><br><span class="line">        <span class="comment">// 逐一构造</span></span><br><span class="line">        <span class="keyword">for</span>(Integer num : list)&#123;</span><br><span class="line">            cur.next = <span class="keyword">new</span> ListNode(num);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM13-判断一个链表是否是回文结构"><a href="#BM13-判断一个链表是否是回文结构" class="headerlink" title="BM13 判断一个链表是否是回文结构"></a>BM13 <a href="https://www.nowcoder.com/practice/3fed228444e740c8be66232ce8b87c2f?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">判断一个链表是否是回文结构</a></h2><h3 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个链表，请判断该链表是否为回文结构。</p>
<p>回文是指该字符串正序逆序完全一致。 </p>
<p>数据范围： 链表节点数 0≤n≤105，链表中每个节点的值满足 ∣val∣≤107</p>
<h3 id="题解-13"><a href="#题解-13" class="headerlink" title="题解"></a>题解</h3><p>很多实惠，直接对链表进行操作不方便，可以借助数组辅助操作，这里只要将节点中的每个数放入数组中进行比较即可，但这里注意一点，题目中说了回文但是每个节点的值满足|val|&lt;=10^7，那{1, 235, 235, 1}算回文还是{1, 235, 532, 1}算回文，若是第一种的话，只要将每个节点的值放入数组中，两个指针同时移动，判断是否相等即可，若是另一种，则建议将整数转化为字符串进行操作，之后对于字符串中的每个字符进行操作。</p>
<h3 id="Java代码实现-13"><a href="#Java代码实现-13" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 the head</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPail</span> <span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 特殊情况head为null</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; nums = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            nums.add(cur.val);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="comment">// 注意这里用的是equals而不是==，用==比较的是地址，只有当两个数都在常量池中时才会成功</span></span><br><span class="line">            <span class="keyword">if</span>(!nums.get(i).equals(nums.get(n - i - <span class="number">1</span>)))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码最终是正确的，因此这里所说的回文是第一种，不过需要注意的是在比较Integer的过程中用equals而不是用==，或者就利用自动装箱机制转换为int，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num1 = nums.get(i);</span><br><span class="line"><span class="keyword">int</span> num2 = nums.get(n - i - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(num1 != num2)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM14-链表的奇偶重拍"><a href="#BM14-链表的奇偶重拍" class="headerlink" title="BM14 链表的奇偶重拍"></a>BM14 <a href="https://www.nowcoder.com/practice/02bf49ea45cd486daa031614f9bd6fc3?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">链表的奇偶重拍</a></h2><h3 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个单链表，请设定一个函数，将链表的奇数位节点和偶数位节点分别放在一起，重排后输出。 </p>
<p>注意是节点的编号而非节点的数值。 </p>
<p>数据范围：节点数量满足 0≤n≤105，节点中的值都满足 0≤val≤1000</p>
<p>要求：空间复杂度 O(n)，时间复杂度 O(n)</p>
<h3 id="题解-14"><a href="#题解-14" class="headerlink" title="题解"></a>题解</h3><p>新建两个链表，一个用于放奇数的节点，一个用于放偶数的节点，再将两个链表连接即可。</p>
<h3 id="Java代码实现-14"><a href="#Java代码实现-14" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">oddEvenList</span> <span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 特殊情况依旧优先考虑，当链表有012个节点时直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结果链表以及奇偶链表的头节点</span></span><br><span class="line">        ListNode dummy1 = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode dummy2 = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 当前的初始链表以及奇偶链表到达的位置</span></span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        ListNode cur1 = dummy1;</span><br><span class="line">        ListNode cur2 = dummy2;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ++len;</span><br><span class="line">            <span class="comment">// 这里是奇偶判断，只不过位运算更快，故选择位运算</span></span><br><span class="line">            <span class="keyword">if</span>((len &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">                cur1.next = cur;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur2.next = cur;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 防止有粘连，先将链表断开</span></span><br><span class="line">        <span class="comment">// 但思考之后发现只需要断开偶数的即可，因为奇数的后一步操作实际上已经断开了</span></span><br><span class="line">        <span class="keyword">if</span>(cur1.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            cur1.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur2.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            cur2.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将奇链表与偶链表连接，cur1即为奇链表的尾</span></span><br><span class="line">        <span class="comment">// 这里其实已经避免了奇数的粘连</span></span><br><span class="line">        cur1.next = dummy2.next;    <span class="comment">// 注意这里偶链表真正开始的节点为dummy2.next（虚节点）</span></span><br><span class="line">        <span class="keyword">return</span> dummy1.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这里有必要提一下我注释中说到的粘连，假设有链表{1, 2, 3, 4, 5, 6}，当进行上述代码的操作之后得到的链表实际是这样的{1, 3, 5, 6} 和{2, 4, 6}，我们需要的只有1 3 5，但6由于在原始链表中是5的next，故也放到了链表中，这对于原链表长度为偶数的时候不影响（因为后面连接的操作实际上已经把粘连部分去除了），但当原链表长度为奇数时就有影响了，假设有链表{1, 2, 3, 4, 5}，操作之后得到的链表是{1, 3, 5}和{2, 4, 5}，此时就无法得到正常结果</strong></p>
<h2 id="BM15-删除有序链表中重复的元素-I"><a href="#BM15-删除有序链表中重复的元素-I" class="headerlink" title="BM15 删除有序链表中重复的元素-I"></a>BM15 <a href="https://www.nowcoder.com/practice/c087914fae584da886a0091e877f2c79?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">删除有序链表中重复的元素-I</a></h2><h3 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h3><p>删除给出链表中的重复元素（链表中元素从小到大有序），使链表中的所有元素都只出现一次<br>例如：<br>给出的链表为1→1→2,返回1→2.<br>给出的链表为1→1→2→3→3,返回1→2→3. </p>
<h3 id="题解-15"><a href="#题解-15" class="headerlink" title="题解"></a>题解</h3><p>去重最简单的办法是利用HashSet，每次将节点的值放入HashSet中，又考虑之后还要有序构建，因此考虑LinedHashSet，但此时空间复杂度为O(n)，不合题意。</p>
<p>想到利用两个指针，一个记录当前位，另一个记录下一位，使用两个指针的目的是，当遇到当前元素与下一位元素相同时，不移动当前位，移动下一位直至当前位与下一位不同时，将当前位与下一位连接，如此遍历数组即可</p>
<h3 id="Java代码实现-15"><a href="#Java代码实现-15" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span> <span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 特殊情况优先考虑</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        ListNode nex = head.next;</span><br><span class="line">        <span class="comment">// 肯定是后一个先到，但存在一种情况就是后面几个元素都相同时需要显式地令cur.nex = null</span></span><br><span class="line">        <span class="keyword">while</span>(nex != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.val == nex.val)&#123;</span><br><span class="line">                nex = nex.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur.next = nex;</span><br><span class="line">                cur = nex;</span><br><span class="line">                nex = nex.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时cur所在的位置可能有多种</span></span><br><span class="line">        <span class="comment">// 一是倒数第一个元素</span></span><br><span class="line">        <span class="comment">// 二是倒数第k个元素（后面k个元素值都相同）</span></span><br><span class="line">        <span class="comment">// 此时只需比较cur以及其后面第一个元素（前提是其后面有元素），要是相同则显式令其next为null，反之则无需操作</span></span><br><span class="line">        <span class="keyword">if</span>(cur.next != <span class="keyword">null</span> &amp;&amp; cur.val == cur.next.val)&#123;</span><br><span class="line">            cur.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM16-删除有序列表中重复的元素-II"><a href="#BM16-删除有序列表中重复的元素-II" class="headerlink" title="BM16 删除有序列表中重复的元素-II"></a>BM16 <a href="https://www.nowcoder.com/practice/71cef9f8b5564579bf7ed93fbe0b2024?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">删除有序列表中重复的元素-II</a></h2><h3 id="题目描述-15"><a href="#题目描述-15" class="headerlink" title="题目描述"></a>题目描述</h3><p>给出一个升序排序的链表，删除链表中的所有重复出现的元素，只保留原链表中只出现一次的元素。<br>例如：<br>给出的链表为1→2→3→3→4→4→5, 返回1→2→5.<br>给出的链表为1→1→1→2→3, 返回2→3. </p>
<h3 id="题解-16"><a href="#题解-16" class="headerlink" title="题解"></a>题解</h3><p>第一种思路是使用两个Set加一个数组实现一个set放全部元素，另一个set放重复的元素，数组按序放节点的值，第一次遍历，若是发现放全部元素的Set中已有这个元素，那么将此元素放入放置重复元素的Set中，此外第一次遍历还需要将链表中的全部节点值放入数组中，第二次遍历数组，若是数组中的元素并不属于放重复元素的Set中，那么以此值新建节点并连接到链表中，但此时空间复杂度为O(n)，不合题意。</p>
<p>正确思路是：使用三个指针，pre表示前一个，cur表示当前，nex表示后一个，若是遇到相同元素，则移动nex指针直到cur与nex值不相同，若是不同则直接pre指向nex，然后三个指针依次后移一位即可</p>
<h3 id="Java代码实现-16"><a href="#Java代码实现-16" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span> <span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 特殊情况优先考虑</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 防止出现第一个元素就需要删除的情况，用虚拟头节点</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode pre = dummy;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        ListNode nex = head.next;</span><br><span class="line">        <span class="keyword">while</span>(nex != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.val == nex.val)&#123;</span><br><span class="line">                <span class="comment">// 元素相同时不断移动nex指针</span></span><br><span class="line">                <span class="keyword">while</span>(nex != <span class="keyword">null</span> &amp;&amp; cur.val == nex.val)&#123;</span><br><span class="line">                    nex = nex.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//此时以及移动完了，修改指针</span></span><br><span class="line">                pre.next = nex;</span><br><span class="line">                cur = nex;</span><br><span class="line">                <span class="comment">// 退出循环还有一种情况是nex为null了，此时不再后移nex指针</span></span><br><span class="line">                <span class="keyword">if</span>(nex != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    nex = nex.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 元素不同时先连接pre和nex，再移动</span></span><br><span class="line">                pre.next = cur;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = nex;</span><br><span class="line">                nex = nex.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二分查找-排序"><a href="#二分查找-排序" class="headerlink" title="二分查找/排序"></a>二分查找/排序</h1><h2 id="BM17-二分查找-I"><a href="#BM17-二分查找-I" class="headerlink" title="BM17 二分查找-I"></a>BM17 <a href="https://www.nowcoder.com/practice/d3df40bd23594118b57554129cadf47b?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">二分查找-I</a></h2><h3 id="题目描述-16"><a href="#题目描述-16" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现无重复数字的升序数组的二分查找 </p>
<p>给定一个 元素升序的、无重复数字的整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标（下标从 0 开始），否则返回 -1 </p>
<p>数据范围：0≤len(nums)≤2×105， 数组中任意值满足 ∣val∣≤109</p>
<p>进阶：时间复杂度 O(log⁡n)，空间复杂度 O(1)</p>
<h3 id="题解-17"><a href="#题解-17" class="headerlink" title="题解"></a>题解</h3><p>二分实际上就是把一个数组分为左右两份，每次比较目标值与中间值，若是中间值比较大那证明在左半部分，若是目标值比较大说明在右半部分，若是最后（那部分只有一个数切这个数不为目标值，那证明此数组中没有该目标值）。</p>
<h3 id="Java代码实现-17"><a href="#Java代码实现-17" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span> <span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">                <span class="comment">// 相等了直接返回</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                <span class="comment">// 比目标值小说明在右半部分</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 否则在左半部分</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM18-二维数组中的查找"><a href="#BM18-二维数组中的查找" class="headerlink" title="BM18 二维数组中的查找"></a>BM18 二维数组中的查找</h2><h3 id="题目描述-17"><a href="#题目描述-17" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个二维数组array中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 </p>
<p>[ </p>
<p>[1,2,8,9],<br>[2,4,9,12],<br>[4,7,10,13],<br>[6,8,11,15]</p>
<p>] </p>
<p>给定 target = 7，返回 true。 </p>
<p>给定 target = 3，返回 false。 </p>
<p>数据范围：矩阵的长宽满足 0≤n,m≤500， 矩阵中的值满足 0≤val≤109<br>进阶：空间复杂度 O(1)，时间复杂度 O(n+m)</p>
<h3 id="题解-18"><a href="#题解-18" class="headerlink" title="题解"></a>题解</h3><p>这题首先保证目标值和当前值大小关系确定时只需向一个方向移动（比如说当前值小于目标值时是应该向下移动或是向右移动），为了保证这一点，我们可以从数组的右上或是左下开始遍历，从右上遍历保证当前数是这一行最大的，当前这一列最小的，若是需要更大的只需要往下找即可，若是需要更小的只需要往左找即可，从左下开始遍历可以保证每个数都是当前这一行最小的，当前这一列最大的，若是需要更大的就往右走，若是需要更小的就往左走。</p>
<h3 id="Java代码实现-18"><a href="#Java代码实现-18" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(array == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 确定行列数</span></span><br><span class="line">        <span class="keyword">int</span> m = array.length;</span><br><span class="line">        <span class="keyword">int</span> n = array[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// 从右上开始遍历，行数为0列数为n-1</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= m - <span class="number">1</span> &amp;&amp; j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i][j] == target)&#123;</span><br><span class="line">                <span class="comment">// 相等返回true</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[i][j] &lt; target)&#123;</span><br><span class="line">                <span class="comment">// 小于就往下找</span></span><br><span class="line">                ++i;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 大于就往左找</span></span><br><span class="line">                --j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时仍未找到就返回false；</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM19-寻找峰值"><a href="#BM19-寻找峰值" class="headerlink" title="BM19 寻找峰值"></a>BM19 <a href="https://www.nowcoder.com/practice/fcf87540c4f347bcb4cf720b5b350c76?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">寻找峰值</a></h2><h3 id="题目描述-18"><a href="#题目描述-18" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个长度为n的数组nums，请你找到峰值并返回其索引。数组可能包含多个峰值，在这种情况下，返回任何一个所在位置即可。 </p>
<p>1.峰值元素是指其值严格大于左右相邻值的元素。严格大于即不能有等于</p>
<p>2.假设 nums[-1] = nums[n] = −∞</p>
<p>3.对于所有有效的 i 都有 nums[i] != nums[i + 1] </p>
<p>4.你可以使用O(logN)的时间复杂度实现此问题吗？ </p>
<p>数据范围： </p>
<p>1≤nums.length≤2×105</p>
<p>−231&lt;=nums[i]&lt;=2^31−1</p>
<p>如输入[2,4,1,2,7,8,4]时，会形成两个山峰，一个是索引为1，峰值为4的山峰，另一个是索引为5，峰值为8的山峰，如下图所示： </p>
<p><img src="https://uploadfiles.nowcoder.com/images/20211014/423483716_1634212356346/9EB9CD58B9EA5E04C890326B5C1F471F" alt="img"></p>
<h3 id="题解-19"><a href="#题解-19" class="headerlink" title="题解"></a>题解</h3><p>题目中已经假定数组之外的部分都为无穷小，那么当发现此时数组是递增的，那么就一定会存在山峰，因为即使递增到数组的边界，那边界值就是山峰（边界之外的部分是无穷小），反之若是递减则不一定存在山峰。</p>
<p>明确了以上问题之后，可以用二分的方式进行查询，但二分的思想需要一个目标值target，让target与中间值比较，在这里我们选择使用中间值的后一位作为target（这里注意只有当left == right == n - 1中间值才取到最后一位的，但此时实际上right即为波峰），那么当target大于中间值时，从中间值到target必有一部分是递增的，当target小于中间值的时候，我们考虑数组的另一部分。</p>
<h3 id="Java代码实现-19"><a href="#Java代码实现-19" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span> <span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 特殊情况只有一个元素时是波峰</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 这里的不同之处在于不能取等号，因为最后面返回的值是最大值，即只要一直在上坡，那么right永远大于mid大于left</span></span><br><span class="line">        <span class="comment">// 反之若是发现在下坡，那就寻找另一半</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[mid + <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="comment">// 此时右侧为上坡，继续寻找即可</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 此时右侧为下坡，为了避免当前值为波峰，这里right应为mid而不是mid - 1</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM20-数组中的逆序对"><a href="#BM20-数组中的逆序对" class="headerlink" title="BM20 数组中的逆序对"></a>BM20 <a href="https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">数组中的逆序对</a></h2><h3 id="题目描述-19"><a href="#题目描述-19" class="headerlink" title="题目描述"></a>题目描述</h3><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P mod 1000000007</p>
<p>数据范围： 对于 50%50% 的数据, size≤104<br>对于 100%100% 的数据, size≤105</p>
<p>数组中所有数字的值满足 0≤val≤1000000</p>
<p>要求：空间复杂度 O(n)，时间复杂度 O(nlogn)</p>
<h2 id="题解-20"><a href="#题解-20" class="headerlink" title="题解"></a>题解</h2><p>这题由于是逆序对（只有两个元素），因此最简单的方法是将数组中所有的数对都表示出来，之后判断是否是逆序对，是的话在逆序对计数的地方加1，如此便能解决问题，但时间复杂度为O(n^2)，题目中要求的是O(nlogn)，不合题意。</p>
<p>这题看时间复杂度想到用合并排序的思想来解决问题，合并排序中需要对两个有序数组进行合并，此时需要移动元素，若是当前元素比其前一个元素小，那么就需要前移元素，此时，一个前移操作就找到了一个逆序对，计算出每次合并需要的元素个数即为逆序对的数目。</p>
<h3 id="Java代码实现-20"><a href="#Java代码实现-20" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOD = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(array == <span class="keyword">null</span> || array.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在分治的过程中求出解</span></span><br><span class="line">        mergeSort(array);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分治算法的思想，先将数组分为有限个子序列，先令子序列有序，再合并有序的字序列</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] nums1 = Arrays.copyOfRange(nums, <span class="number">0</span>, n / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">int</span>[] nums2 = Arrays.copyOfRange(nums, n / <span class="number">2</span>, n);</span><br><span class="line">            mergeSort(nums1);</span><br><span class="line">            mergeSort(nums2);</span><br><span class="line">            merge(nums, nums1, nums2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在这里对两个数组进行合并并在每次合并中查找逆序对</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] sorted, <span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> n2 = nums2.length;</span><br><span class="line">        <span class="comment">// 标记当前两个数组走到了哪</span></span><br><span class="line">        <span class="keyword">int</span> cur1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cur2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sorted.length; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur1 == n1)&#123;</span><br><span class="line">                <span class="comment">// 第一个数组遍历完了</span></span><br><span class="line">                sorted[i] = nums2[cur2];</span><br><span class="line">                ++cur2;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur2 == n2)&#123;</span><br><span class="line">                <span class="comment">// 第二个数组遍历完了</span></span><br><span class="line">                sorted[i] = nums1[cur1];</span><br><span class="line">                ++cur1;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 两个数组都没遍历完</span></span><br><span class="line">                <span class="keyword">if</span>(nums1[cur1] &gt; nums2[cur2])&#123;</span><br><span class="line">                    <span class="comment">// 需要先插入后面的元素</span></span><br><span class="line">                    sorted[i] = nums2[cur2];</span><br><span class="line">                  	<span class="comment">// 特别注意这里，总共有6个元素，当前下标为3表示是第四个元素（这个元素已经后面的全部元素都是逆序对）</span></span><br><span class="line">                    res += n1 - cur1;</span><br><span class="line">                    res %= MOD;</span><br><span class="line">                    ++cur2;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    sorted[i] = nums1[cur1];</span><br><span class="line">                    ++cur1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这个题解跟大部分的思路不同，采用了最原始的Arrays.copyOfRange()方法，因此res += 部分也与其余题解有所不同，但思路一致。</strong></p>
<h2 id="BM21-旋转数组的最小数字"><a href="#BM21-旋转数组的最小数字" class="headerlink" title="BM21 旋转数组的最小数字"></a>BM21 <a href="https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">旋转数组的最小数字</a></h2><h3 id="题目描述-20"><a href="#题目描述-20" class="headerlink" title="题目描述"></a>题目描述</h3><p>有一个长度为 n 的非降序数组，比如[1,2,3,4,5]，将它进行旋转，即把一个数组最开始的若干个元素搬到数组的末尾，变成一个旋转数组，比如变成了[3,4,5,1,2]，或者[4,5,1,2,3]这样的。请问，给定这样一个旋转数组，求数组中的最小值。</p>
<p>数据范围：1≤n≤10000，数组中任意元素的值: 0≤val≤10000</p>
<p>要求：空间复杂度：O(1)，时间复杂度：O(logn)</p>
<h3 id="题解-21"><a href="#题解-21" class="headerlink" title="题解"></a>题解</h3><p>最简单的方法是遍历数组找到最小值，但时间复杂度是O(n)，不合题意。由于数组原始是非降序的之后将最开始的几个元素搬到了末尾，那么数组部分是有序的，可以使用二分，以数组的端点作为target值，当中间值小于target时，证明在左半部分（由于原数组非降序，不可能出现大于最大值之后，从最小值开始仍然大于中间值，即不可能出现mid到target是{6, 7, 1, 4, 8}的情况），当中间值大于target时，证明在右半部分，若是特别特殊，两者相等，即原数组为{5, 5, 5, 5, 5, 1, 2, 3, 4, 5}或者{1, 0, 1, 1, 1}时，无法确定属于哪部分，令target = nums[right - 1]，缩小范围后继续，如此循环便能找到。</p>
<h3 id="Java代码实现-21"><a href="#Java代码实现-21" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(array.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[mid] &lt; array[right])&#123;</span><br><span class="line">                <span class="comment">// 小于表示在左半部分</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[mid] &gt; array[right])&#123;</span><br><span class="line">                <span class="comment">// 大于表示在右半部分</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 等于则缩小范围</span></span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用二分法时，有时题目中没有target，那么需要考虑如何选择target才最优，寻找山峰问题target是中间值的下一位，而这里target是right</strong></p>
<h2 id="BM22-比较版本号"><a href="#BM22-比较版本号" class="headerlink" title="BM22 比较版本号"></a>BM22 <a href="https://www.nowcoder.com/practice/2b317e02f14247a49ffdbdba315459e7?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">比较版本号</a></h2><h3 id="题目描述-21"><a href="#题目描述-21" class="headerlink" title="题目描述"></a>题目描述</h3><p>牛客项目发布项目版本时会有版本号，比如1.02.11，2.14.4等等 </p>
<p>现在给你2个版本号version1和version2，请你比较他们的大小</p>
<p>版本号是由修订号组成，修订号与修订号之间由一个”.”连接。1个修订号可能有多位数字组成，修订号可能包含前导0，且是合法的。例如，1.02.11，0.1，0.2都是合法的版本号</p>
<p>每个版本号至少包含1个修订号。 </p>
<p>修订号从左到右编号，下标从0开始，最左边的修订号下标为0，下一个修订号下标为1，以此类推。 </p>
<p>比较规则： </p>
<p>一. 比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较忽略任何前导零后的整数值。比如”0.1”和”0.01”的版本号是相等的 </p>
<p>二. 如果版本号没有指定某个下标处的修订号，则该修订号视为0。例如，”1.1”的版本号小于”1.1.1”。因为”1.1”的版本号相当于”1.1.0”，第3位修订号的下标为0，小于1 </p>
<p>三. version1 &gt; version2 返回1，如果 version1 &lt; version2 返回-1，不然返回0. </p>
<p>数据范围： </p>
<p>1&lt;=version1.length,version2.length&lt;=1000</p>
<p>version1 和 version2 的修订号不会超过int的表达范围，即不超过 <strong>32 位整数</strong> 的范围</p>
<p>进阶： 空间复杂度 O(1)， 时间复杂度 O(n)</p>
<h3 id="题解-22"><a href="#题解-22" class="headerlink" title="题解"></a>题解</h3><p>最简单的方法是利用.将两个字符串分解为字符数组，之后逐个比较，但此方法需要额外开辟空间，空间复杂度为O(n)，不合题意。</p>
<h3 id="Java代码实现如下"><a href="#Java代码实现如下" class="headerlink" title="Java代码实现如下"></a>Java代码实现如下</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 比较版本号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> version1 string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> version2 string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span> <span class="params">(String version1, String version2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">      	<span class="comment">// 这里注意正则表达式的书写，\需要转译</span></span><br><span class="line">        String[] strs1 = version1.split(<span class="string">"\\."</span>);</span><br><span class="line">        String[] strs2 = version2.split(<span class="string">"\\."</span>);</span><br><span class="line">        <span class="keyword">int</span> len1 = strs1.length;</span><br><span class="line">        <span class="keyword">int</span> len2 = strs2.length;</span><br><span class="line">        <span class="keyword">int</span> minLen = len1 &lt; len2 ? len1 : len2;</span><br><span class="line">      	<span class="comment">// 匹配两者都有的部分</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; minLen; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> num1 = Integer.parseInt(strs1[i]);</span><br><span class="line">            <span class="keyword">int</span> num2 = Integer.parseInt(strs2[i]);</span><br><span class="line">            <span class="keyword">if</span>(num1 &lt; num2)&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num1 &gt; num2)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// 匹配完了开始判断</span></span><br><span class="line">        <span class="keyword">if</span>(len1 == len2)&#123;</span><br><span class="line">            <span class="comment">// 长度相等直接返回0（之前已经能确定全部匹配）</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len1 &gt; len2)&#123;</span><br><span class="line">            <span class="comment">// version1比较长，多出来的和0比较</span></span><br><span class="line">            <span class="keyword">while</span>(minLen &lt; len1)&#123;</span><br><span class="line">                <span class="keyword">if</span>(Integer.parseInt(strs1[minLen]) != <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ++minLen;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// version2长同理，和0比较</span></span><br><span class="line">            <span class="keyword">while</span>(minLen &lt; len2)&#123;</span><br><span class="line">                <span class="keyword">if</span>(Integer.parseInt(strs2[minLen]) != <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ++minLen;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题解-23"><a href="#题解-23" class="headerlink" title="题解"></a>题解</h3><p>若是想达到O(1)的空间复杂度，可以考虑使用双指针，一个指针用于解析version1，一个指针用于解析version2，对于前导0的处理是不处理（因为每次只用处理一个字符，若是当前字符不是’.’，那么直接用已经解析出的值（当前值前面的值） * 10 + 当前的值），遇到前导0，已经解析出的值为0，0 * 10 + 0 = 0，并无影响，此方法主要是逐个读取字符，即：”103”的解析过程为1，1 * 10 + 0 = 10，10 * 10 + 3 = 103。</p>
<h3 id="Java代码实现-22"><a href="#Java代码实现-22" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 比较版本号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> version1 string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> version2 string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span> <span class="params">(String version1, String version2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">char</span>[] str1 = version1.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] str2 = version2.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> len1 = str1.length;</span><br><span class="line">        <span class="keyword">int</span> len2 = str2.length;</span><br><span class="line">        <span class="comment">// 两个遍历指针</span></span><br><span class="line">        <span class="keyword">int</span> cur1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cur2 = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 只要两个字符串中任何一个没有解析完，那就继续解析</span></span><br><span class="line">        <span class="keyword">while</span>(cur1 &lt; len1 || cur2 &lt; len2)&#123;</span><br><span class="line">            <span class="comment">// 设置解析出的元素，初始值为0</span></span><br><span class="line">            <span class="keyword">int</span> num1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> num2 = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 只有str1未解析完才解析，否则其为0</span></span><br><span class="line">            <span class="keyword">if</span>(cur1 &lt; len1)&#123;</span><br><span class="line">                <span class="comment">// 这里必须是cur++，否则会导致解析不到.之前的那个数，而且这样也直接跳过了.</span></span><br><span class="line">                <span class="keyword">while</span>(cur1 &lt; len1 &amp;&amp; str1[cur1++] != <span class="string">'.'</span>)&#123;</span><br><span class="line">                    <span class="comment">// 这里为什么是cur-1呢，因为前面已经自增过一次</span></span><br><span class="line">                    num1 = <span class="number">10</span> * num1 + str1[cur1 - <span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 同理只有str2未解析完才解析，否则为初始值0</span></span><br><span class="line">            <span class="keyword">if</span>(cur2 &lt; len2)&#123;</span><br><span class="line">                <span class="comment">// 这里必须是cur++，否则会导致解析不到.之前的那个数，而且这样也直接跳过了.</span></span><br><span class="line">                <span class="keyword">while</span>(cur2 &lt; len2 &amp;&amp; str2[cur2++] != <span class="string">'.'</span>)&#123;</span><br><span class="line">                    <span class="comment">// 这里为什么是cur-1呢，因为前面已经自增过一次</span></span><br><span class="line">                    num2 = <span class="number">10</span> * num2 + str2[cur2 - <span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 通过以上步骤已经将两个都解析了，这里只需要判断就好</span></span><br><span class="line">            <span class="keyword">if</span>(num1 &gt; num2)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num1 &lt; num2)&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="BM23-二叉树的前序遍历"><a href="#BM23-二叉树的前序遍历" class="headerlink" title="BM23 二叉树的前序遍历"></a>BM23 <a href="https://www.nowcoder.com/practice/5e2135f4d2b14eb8a5b06fab4c938635?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">二叉树的前序遍历</a></h3><h3 id="题目描述-22"><a href="#题目描述-22" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你二叉树的根节点 root ，返回它节点值的 前序 遍历。</p>
<p>数据范围：二叉树的节点数量满足 1≤n≤100，二叉树节点的值满足 1≤val≤100，树的各节点的值各不相同</p>
<h3 id="题解-24"><a href="#题解-24" class="headerlink" title="题解"></a>题解</h3><p>二叉树的前序遍历就是先访问根节点，再访问左右子树，即“根左右”。</p>
<h3 id="Java代码实现-23"><a href="#Java代码实现-23" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] preorderTraversal (TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 用于保存返回结果</span></span><br><span class="line">        ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(root, ans);</span><br><span class="line">        <span class="comment">// 这里这个方法之前没用过，若是不用此方法也可以，如下：</span></span><br><span class="line">        <span class="comment">// int[] res = new int(ans.size());</span></span><br><span class="line">        <span class="comment">// for(int i = 0; i &lt; ans.size(); ++i)&#123;</span></span><br><span class="line">        <span class="comment">//     res[i] = ans.get(i);</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="keyword">return</span> ans.stream().mapToInt(Integer::valueOf).toArray();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; nums)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 可以不用这个cur变量直接在root上操作，但使用这个变量可以保证root不会变化</span></span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            nums.add(root.val);</span><br><span class="line">            dfs(root.left, nums);</span><br><span class="line">            dfs(root.right, nums);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM24-二叉树的中序遍历"><a href="#BM24-二叉树的中序遍历" class="headerlink" title="BM24 二叉树的中序遍历"></a>BM24 <a href="https://www.nowcoder.com/practice/0bf071c135e64ee2a027783b80bf781d?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">二叉树的中序遍历</a></h2><h3 id="题目描述-23"><a href="#题目描述-23" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树的根节点root，返回它的中序遍历结果。 </p>
<p>数据范围：树上节点数满足 0≤n≤1000，树上每个节点的值满足 0≤val≤1000<br>进阶：空间复杂度 O(n)，时间复杂度 O(n)</p>
<h3 id="题解-25"><a href="#题解-25" class="headerlink" title="题解"></a>题解</h3><p>二叉树的中序遍历就是先访问左子树，再访问根节点，最后访问右子树，即“左根右”。</p>
<h3 id="Java代码实现-24"><a href="#Java代码实现-24" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] inorderTraversal (TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 用于保存返回结果</span></span><br><span class="line">        ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(root, ans);</span><br><span class="line">        <span class="keyword">return</span> ans.stream().mapToInt(Integer::valueOf).toArray();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; nums)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 可以不用这个cur变量直接在root上操作，但使用这个变量可以保证root不会变化</span></span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            dfs(root.left, nums);</span><br><span class="line">            nums.add(root.val);</span><br><span class="line">            dfs(root.right, nums);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM25-二叉树的后序遍历"><a href="#BM25-二叉树的后序遍历" class="headerlink" title="BM25 二叉树的后序遍历"></a>BM25 <a href="https://www.nowcoder.com/practice/1291064f4d5d4bdeaefbf0dd47d78541?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">二叉树的后序遍历</a></h2><h3 id="题目描述-24"><a href="#题目描述-24" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树，返回他的后序遍历的序列。 </p>
<p>后序遍历是值按照 左节点-&gt;右节点-&gt;根节点 的顺序的遍历。 </p>
<p>数据范围：二叉树的节点数量满足 1≤n≤100，二叉树节点的值满足 1≤val≤100，树的各节点的值各不相同</p>
<h3 id="题解-26"><a href="#题解-26" class="headerlink" title="题解"></a>题解</h3><p>二叉树的后序遍历就是先访问左右子树，再访问根节点，即“左右根”。</p>
<h3 id="Java代码实现-25"><a href="#Java代码实现-25" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] postorderTraversal (TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 用于保存返回结果</span></span><br><span class="line">        ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(root, ans);</span><br><span class="line">        <span class="keyword">return</span> ans.stream().mapToInt(Integer::valueOf).toArray();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; nums)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 可以不用这个cur变量直接在root上操作，但使用这个变量可以保证root不会变化</span></span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            dfs(root.left, nums);</span><br><span class="line">            dfs(root.right, nums);</span><br><span class="line">            nums.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>前中后序遍历只有dfs函数的顺序不同，其余操作完全一致</strong></p>
<h2 id="BM26-求二叉树的层序遍历"><a href="#BM26-求二叉树的层序遍历" class="headerlink" title="BM26 求二叉树的层序遍历"></a>BM26 <a href="https://www.nowcoder.com/practice/04a5560e43e24e9db4595865dc9c63a3?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">求二叉树的层序遍历</a></h2><h2 id="题目描述-25"><a href="#题目描述-25" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树，返回该二叉树层序遍历的结果，（从左到右，一层一层地遍历）<br>例如：<br>给定的二叉树是{3,9,20,#,#,15,7},<br><img src="https://uploadfiles.nowcoder.com/images/20210114/999991351_1610616074120/036DC34FF19FB24652AFFEB00A119A76" alt="img"><br>该二叉树层序遍历的结果是<br>[<br>[3],<br>[9,20],<br>[15,7] </p>
<p>] </p>
<p>提示: </p>
<p>0 &lt;= 二叉树的结点数 &lt;= 1500</p>
<h3 id="题解-27"><a href="#题解-27" class="headerlink" title="题解"></a>题解</h3><p>层序遍历实际上就是BFS（广度优先搜索），一般情况下，深度优先遍历用栈辅助操作，广度优先遍历用队列辅助操作，具体操作如下：</p>
<p>首先判断根节点是否为空，若是为空直接返回空，不为空将根节点放入队列中，当队列不为空的时候就不断循环，取出队头，将其左右子树分别插入队尾，直到队列为空时就得到了BFS结果。</p>
<h3 id="Java代码实现-26"><a href="#Java代码实现-26" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型ArrayList&lt;ArrayList&lt;&gt;&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelOrder (TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 用于返回结果</span></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 特殊情况优先考虑</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用于存放每一层的节点</span></span><br><span class="line">        ArrayList&lt;TreeNode&gt; nodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 链表实际上实现了Queue接口</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 将根节点放入队列中</span></span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; nums = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">// 取出当前层所有节点</span></span><br><span class="line">            <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">                TreeNode cur = queue.poll();</span><br><span class="line">                nums.add(cur.val);</span><br><span class="line">                nodes.add(cur);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对于这一层的所有节点，遍历</span></span><br><span class="line">            <span class="keyword">for</span>(TreeNode cur : nodes)&#123;</span><br><span class="line">                <span class="comment">// 左子树不为空，放入队列</span></span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.offer(cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 右子树不为空，放入队列</span></span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.offer(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(nums);</span><br><span class="line">            <span class="comment">// 注意结束后将nodes置空</span></span><br><span class="line">            nodes.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这里的话注意返回的是一个二维数组，故每次都需要将这一层的数据取完，保存在一个中间数组中，之后在每一层新建一个数组用于放置节点值</strong></p>
<h2 id="BM27-按之字形顺序打印二叉树"><a href="#BM27-按之字形顺序打印二叉树" class="headerlink" title="BM27 按之字形顺序打印二叉树"></a>BM27 <a href="https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">按之字形顺序打印二叉树</a></h2><h3 id="题目描述-26"><a href="#题目描述-26" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树，返回该二叉树的之字形层序遍历，（第一层从左向右，下一层从右向左，一直这样交替） </p>
<p>数据范围：0≤n≤1500,树上每个节点的val满足 ∣val∣&lt;=150<br>要求：空间复杂度：O(n)<em>O</em>(<em>n</em>)，时间复杂度：O(n)<em>O</em>(<em>n</em>)</p>
<p>例如：<br>给定的二叉树是{1,2,3,#,#,4,5}<br><img src="https://uploadfiles.nowcoder.com/images/20210717/557336_1626492068888/41FDD435F0BA63A57E274747DE377E05" alt="img"><br>该二叉树之字形层序遍历的结果是 </p>
<p>[ </p>
<p>[1], </p>
<p>[3,2], </p>
<p>[4,5] </p>
<p>]</p>
<h3 id="题解-28"><a href="#题解-28" class="headerlink" title="题解"></a>题解</h3><p>这题也是层序遍历只不过遍历的顺序不一致，这就需要考虑利用辅助变量level外加栈来控制顺序，首先将根节点放入栈中，此时level为1，若是level为奇数则先放左子树后放右子树，因为栈的性质，在下一次遍历时右子树就会优先被输出，若是level为偶数，那么先放右子树后方左子树，那么下次遍历时左子树就会优先被输出，知道栈空位置。</p>
<h3 id="Java代码实现-27"><a href="#Java代码实现-27" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 特殊情况依旧优先考虑</span></span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用于判断层数（奇数先右后左，偶数先左后右）</span></span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 用于存储某一层的全部节点</span></span><br><span class="line">        ArrayList&lt;TreeNode&gt; nodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 先将根节点入栈</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(pRoot);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// 用于保存这一层所有元素</span></span><br><span class="line">            ArrayList&lt;Integer&gt; nums = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">// 取出这一层所有元素</span></span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">                TreeNode cur = stack.pop();</span><br><span class="line">                nums.add(cur.val);</span><br><span class="line">                nodes.add(cur);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((level &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 奇数层，那么表示下一次是偶数层，需要从右到左，因为栈的性质，先放左子树</span></span><br><span class="line">                <span class="keyword">for</span>(TreeNode node : nodes)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        stack.push(node.left);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        stack.push(node.right);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 偶数层，下一层是奇数层，需要从左到右，因为栈的性质，先放右子树</span></span><br><span class="line">                <span class="keyword">for</span>(TreeNode node : nodes)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        stack.push(node.right);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        stack.push(node.left);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将这一层的结果加入结果集中</span></span><br><span class="line">            res.add(nums);</span><br><span class="line">            <span class="comment">// 增加层数</span></span><br><span class="line">            ++level;</span><br><span class="line">            <span class="comment">// 将nodes集置空</span></span><br><span class="line">            nodes.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对于BFS，一般使用队列，对于这种需要确定顺序的，只需要在偶数层反转队列即可，Java中队列没有自带的reverse方法，故不考虑此做法，这里插一句，利用两个队列可以实现一个栈，利用两个栈也可以实现一个队列，具体做法是，只保证其中一个有数据，插入时只查到有数据的那个，删除时将前n-1个数据移到另一部分，再将最后一个元素取出</strong></p>
<p><strong>这里判断奇偶性使用的是或运算而不是对2求余，这样会快一些</strong></p>
<h2 id="BM28-二叉树的最大深度"><a href="#BM28-二叉树的最大深度" class="headerlink" title="BM28 二叉树的最大深度"></a>BM28 <a href="https://www.nowcoder.com/practice/8a2b2bf6c19b4f23a9bdb9b233eefa73?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">二叉树的最大深度</a></h2><h3 id="题目描述-27"><a href="#题目描述-27" class="headerlink" title="题目描述"></a>题目描述</h3><p>求给定二叉树的最大深度， </p>
<p>深度是指树的根节点到任一叶子节点路径上节点的数量。 </p>
<p>最大深度是所有叶子节点的深度的最大值。 </p>
<p>（注：叶子节点是指没有子节点的节点。）</p>
<p>数据范围：0≤n≤100000，树上每个节点的val满足 ∣val∣≤100<br>要求： 空间复杂度 O(1),时间复杂度 O(n)</p>
<h3 id="题解-29"><a href="#题解-29" class="headerlink" title="题解"></a>题解</h3><p>两个思路，一是利用栈，栈的最大长度即为二叉树的最大深度，但使用栈会导致空间复杂度为O(n)，不合题意舍弃。</p>
<p>直接dfs，并在dfs的过程中维护最大深度，但此方法递归调用，空间复杂度也是O(n)，愚以为没有O(1)空间复杂度的方法。</p>
<h3 id="Java代码实现-28"><a href="#Java代码实现-28" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span> <span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 特殊情况优先考虑</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则就递归求左右子树中比较大的那个 + 1就是答案</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM29-二叉树中和为某一值的路径"><a href="#BM29-二叉树中和为某一值的路径" class="headerlink" title="BM29 二叉树中和为某一值的路径"></a>BM29 <a href="https://www.nowcoder.com/practice/508378c0823c423baa723ce448cbfd0c?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">二叉树中和为某一值的路径</a></h2><h3 id="题目描述-28"><a href="#题目描述-28" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树root和一个值 sum ，判断是否有从根节点到叶子节点的节点值之和等于 sum 的路径。</p>
<p>1.该题路径定义为从树的根结点开始往下一直到叶子结点所经过的结点</p>
<p>2.叶子节点是指没有子节点的节点</p>
<p>3.路径只能从父节点到子节点，不能从子节点到父节点</p>
<p>4.总节点数目为n</p>
<p>例如：<br>给出如下的二叉树， sum=22，<br><img src="https://uploadfiles.nowcoder.com/images/20200807/999991351_1596786493913_8BFB3E9513755565DC67D86744BB6159" alt="img"><br>返回true，因为存在一条路径 5→4→11→2的节点值之和为 22 </p>
<p>数据范围： </p>
<p>1.树上的节点数满足 0≤n≤10000</p>
<p>2.每 个节点的值都满足 ∣val∣≤1000</p>
<p>要求：空间复杂度 O(n)，时间复杂度 O(n)</p>
<p>进阶：空间复杂度 O(树的高度)，时间复杂度 O(n)</p>
<h3 id="题解-30"><a href="#题解-30" class="headerlink" title="题解"></a>题解</h3><p>毫无疑问BFS，两种思路，一是直接递归，二是使用栈保存遍历的节点，退出的条件是，当前节点值为需要的值且此节点是叶子节点，若是不是叶子节点那么继续dfs，只不过dfs的变量变为root.left和sum - root.val</p>
<h3 id="Java代码实现-29"><a href="#Java代码实现-29" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sum int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span> <span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 这里特殊情况先考虑，之后再dfs</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum -= root.val;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; sum == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left, sum) || hasPathSum(root.right, sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这里为什么不直接if(root == null &amp;&amp; sum == 0) return true;主要原因是，若是某一个节点左子树或者右子树为null，当遍历到这个节点的时候，sum已经== 0 了但是这不是路径，因此当遍历到它那棵空子树时就会导致此条件成立，但此时并不是路径（考虑用例{1, 2}, sum = 1）</strong></p>
<h2 id="BM30-二叉搜索树与双向链表"><a href="#BM30-二叉搜索树与双向链表" class="headerlink" title="BM30 二叉搜索树与双向链表"></a>BM30 <a href="https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">二叉搜索树与双向链表</a></h2><h3 id="题目描述-29"><a href="#题目描述-29" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。如下图所示 </p>
<p><img src="https://uploadfiles.nowcoder.com/images/20210605/557336_1622886924427/E1F1270919D292C9F48F51975FD07CE2" alt="img"></p>
<p>数据范围：输入二叉树的节点数 0≤n≤1000，二叉树中每个节点的值 0≤val≤1000<br>要求：空间复杂度O(1)（即在原树上操作），时间复杂度 O(n)</p>
<p>注意: </p>
<p>1.要求不能创建任何新的结点，只能调整树中结点指针的指向。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继<br>2.返回链表中的第一个节点的指针<br>3.函数返回的TreeNode，有左右指针，其实可以看成一个双向链表的数据结构 </p>
<p>4.你不用输出双向链表，程序会根据你的返回值自动打印输出</p>
<h4 id="输入描述：-1"><a href="#输入描述：-1" class="headerlink" title="输入描述："></a>输入描述：</h4><p>二叉树的根节点</p>
<h4 id="返回值描述：-1"><a href="#返回值描述：-1" class="headerlink" title="返回值描述："></a>返回值描述：</h4><p>双向链表的其中一个头节点。</p>
<h3 id="题解-31"><a href="#题解-31" class="headerlink" title="题解"></a>题解</h3><p>最简单的方法是二叉树中序遍历得到一个结果数组，再利用数组中的每一个值新建节点构成双向链表，最后返回，但此法需要额外申请空间，空间复杂度为O(n)，不合题意。</p>
<p>若是需要在原树上进行操作，对于一个节点，其前驱节点（左子树）应为其左子树中序遍历的最后一个值，其后继节点因为其中序遍历的第一个值，而且只有最左的节点没有前驱节点，最右的节点没有后继节点。</p>
<h3 id="Java代码实现-30"><a href="#Java代码实现-30" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 链表的根</span></span><br><span class="line">    TreeNode root = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 上一次反转得到的链表尾</span></span><br><span class="line">    TreeNode preTail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况优先考虑</span></span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 中序遍历，先左</span></span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            Convert(pRootOfTree.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 保存根节点，这里保存根节点的目的是，每次操作之后就只剩下了当前这课子树的头</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            root = pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 中序遍历，再根，在这里对左右子树进行修改操作</span></span><br><span class="line">        <span class="keyword">if</span>(preTail != <span class="keyword">null</span>)&#123;</span><br><span class="line">            preTail.right = pRootOfTree;</span><br><span class="line">            pRootOfTree.left = preTail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里注意将这个指针移位</span></span><br><span class="line">        preTail = pRootOfTree;</span><br><span class="line">        <span class="comment">// 中序遍历，后右</span></span><br><span class="line">        Convert(pRootOfTree.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了递归版本，那自然也有非递归版本，非递归版本实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况优先考虑</span></span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree == <span class="keyword">null</span> || (pRootOfTree.left == <span class="keyword">null</span> &amp;&amp; pRootOfTree.right == <span class="keyword">null</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">        TreeNode cur = pRootOfTree;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">// 这里一次找到最左边的节点，也就是链表的头</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取出这个最左边的节点并保存，保存的原因是它需要作为头节点</span></span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        pRootOfTree = cur;</span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="comment">// 这里实际上cur = null</span></span><br><span class="line">        cur = cur.right;</span><br><span class="line">        <span class="comment">// 之后将所有的元素一一放入</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// 对于每个节点也是左根右</span></span><br><span class="line">            <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 这里思考一个问题，遍历一次之后其实已经将cur变为cur.right了，因此这里已经将cur.right放入栈中了</span></span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = stack.pop();</span><br><span class="line">            cur.left = pre;</span><br><span class="line">            pre.right = cur;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对于这个栈，先不停地将左节点放入，之后进行根节点的变换(由于第一个元素已经单独拿出来考虑，因此无需担心对pre的空指针操作，也可学习链表，初始时pre是一个虚拟头节点)，最后将当前节点转化为右子树</span></span><br><span class="line">        <span class="keyword">return</span> pRootOfTree;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中序非递归的核心代码是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dfs(TreeNode root)&#123;</span><br><span class="line">  	Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">		<span class="keyword">while</span>(root != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">      	<span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">          	stack.push(root);</span><br><span class="line">          	root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">//对于根节点进行操作</span></span><br><span class="line">      	<span class="keyword">do</span> something;</span><br><span class="line">      	root = root.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM31对称的二叉树"><a href="#BM31对称的二叉树" class="headerlink" title="BM31对称的二叉树"></a>BM31<a href="https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">对称的二叉树</a></h2><h3 id="题目描述-30"><a href="#题目描述-30" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一棵二叉树，判断其是否是自身的镜像（即：是否对称）<br>例如：                 下面这棵二叉树是对称的<br><img src="https://uploadfiles.nowcoder.com/images/20210926/382300087_1632642756706/A22A794C036C06431E632F9D5E2E298F" alt="img"><br>下面这棵二叉树不对称。<br><img src="https://uploadfiles.nowcoder.com/images/20210926/382300087_1632642770481/3304ABDD147D8E140B2CEF3201BD8372" alt="img"></p>
<p>数据范围：节点数满足 0≤n≤1000，节点上的值满足 ∣val∣≤1000</p>
<p>要求：空间复杂度 O(n)，时间复杂度 O(n)</p>
<p>备注： </p>
<p>你可以用递归和迭代两种方法解决这个问题</p>
<h3 id="题解-32"><a href="#题解-32" class="headerlink" title="题解"></a>题解</h3><p>建立一个辅助函数帮助判断左右子树是否对称。</p>
<p>当左右子树均为空时返回true，当左右子树有一个为空时返回false；否则判断两个子树根节点的值是否相等以及左子树的左子树是否和右子树的右子树对称以及左子树的右子树是否和右子树的左子树对称。</p>
<h3 id="Java代码实现-31"><a href="#Java代码实现-31" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(pRoot.left, pRoot.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(TreeNode left, TreeNode right)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 两子树均为空时true</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时已经确定两棵子树不同为空，那么满足条件时只有一棵子树为空</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span> || right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 看当前左右子树根节点是否对称以及左子树的左子树是否和右子树的右子树对称以及左子树的右子树是否和右子树的左子树对称</span></span><br><span class="line">        <span class="keyword">return</span> left.val == right.val &amp;&amp; helper(left.left, right.right) &amp;&amp; helper(left.right, right.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM32-合并二叉树"><a href="#BM32-合并二叉树" class="headerlink" title="BM32 合并二叉树"></a>BM32 <a href="https://www.nowcoder.com/practice/7298353c24cc42e3bd5f0e0bd3d1d759?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">合并二叉树</a></h2><h3 id="题目描述-31"><a href="#题目描述-31" class="headerlink" title="题目描述"></a>题目描述</h3><p>已知两颗二叉树，将它们合并成一颗二叉树。合并规则是：都存在的结点，就将结点值加起来，否则空的位置就由另一个树的结点来代替。例如：<br>两颗二叉树是:<br>                                  Tree 1 </p>
<p><img src="https://uploadfiles.nowcoder.com/images/20210928/382300087_1632821337680/9E290CFD3730B9B08A5CEFF25799608F" alt="img"></p>
<p>​                                    Tree 2<br><img src="https://uploadfiles.nowcoder.com/images/20210928/382300087_1632821376266/DD0A63560E770A8510049C5182E6E622" alt="img"><br>​                                  合并后的树为<br><img src="https://uploadfiles.nowcoder.com/images/20210928/382300087_1632821404541/9CB750F8909D5985C0D01D8B71AD58BA" alt="img"></p>
<p>数据范围：树上节点数量满足 0≤n≤500，树上节点的值一定在32位整型范围内。 </p>
<p>进阶：空间复杂度 O(1)，时间复杂度 O(n)</p>
<h3 id="题解-33"><a href="#题解-33" class="headerlink" title="题解"></a>题解</h3><p>对于两个树，都以某种顺序进行遍历，直达左右节点都为null时结束。</p>
<h3 id="Java代码实现-32"><a href="#Java代码实现-32" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t1 TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t2 TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> TreeNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span> <span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 特殊情况优先考虑</span></span><br><span class="line">        <span class="keyword">if</span>(t1 == <span class="keyword">null</span> || t2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> t1 == <span class="keyword">null</span> ? t2 : t1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时确保两者都不为空</span></span><br><span class="line">        t1.val += t2.val;</span><br><span class="line">      	<span class="comment">// t1的左子树为合并t1 t2左子树的结果</span></span><br><span class="line">        t1.left = mergeTrees(t1.left, t2.left);</span><br><span class="line">      	<span class="comment">// t1的右子树为合并t1 t2右子树的结果</span></span><br><span class="line">        t1.right = mergeTrees(t1.right, t2.right);</span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM33-二叉树的镜像"><a href="#BM33-二叉树的镜像" class="headerlink" title="BM33 二叉树的镜像"></a>BM33 <a href="https://www.nowcoder.com/practice/a9d0ecbacef9410ca97463e4a5c83be7?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">二叉树的镜像</a></h2><h3 id="题目描述-32"><a href="#题目描述-32" class="headerlink" title="题目描述"></a>题目描述</h3><p>操作给定的二叉树，将其变换为源二叉树的镜像。 </p>
<p>数据范围：二叉树的节点数 0≤n≤1000， 二叉树每个节点的值 0≤val≤1000</p>
<p>要求： 空间复杂度 O(n)。本题也有原地操作，即空间复杂度 O(1)的解法，时间复杂度 O(n)</p>
<p>比如： </p>
<p>源二叉树</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20210922/382300087_1632302001586/420B82546CFC9760B45DD65BA9244888" alt="img"></p>
<p>镜像二叉树 </p>
<p><img src="https://uploadfiles.nowcoder.com/images/20210922/382300087_1632302036250/AD8C4CC119B15070FA1DBAA1EBE8FC2A" alt="img"></p>
<h3 id="题解-34"><a href="#题解-34" class="headerlink" title="题解"></a>题解</h3><p>递归实现，先将当前节点的左右子树交换，之后再递归实现左右子树的镜像。</p>
<h3 id="Java代码实现-33"><a href="#Java代码实现-33" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pRoot TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> TreeNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Mirror</span> <span class="params">(TreeNode pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span> || pRoot.left == <span class="keyword">null</span> &amp;&amp; pRoot.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> pRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode temp = pRoot.left;</span><br><span class="line">        pRoot.left = pRoot.right;</span><br><span class="line">        pRoot.right = temp;</span><br><span class="line">        Mirror(pRoot.left);</span><br><span class="line">        Mirror(pRoot.right);</span><br><span class="line">        <span class="keyword">return</span> pRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM34-判断是不是二叉搜索树"><a href="#BM34-判断是不是二叉搜索树" class="headerlink" title="BM34 判断是不是二叉搜索树"></a>BM34 <a href="https://www.nowcoder.com/practice/a69242b39baf45dea217815c7dedb52b?tpId=295&tqId=2288088&ru=%2Fpractice%2Fa9d0ecbacef9410ca97463e4a5c83be7&qru=%2Fta%2Fformat-top101%2Fquestion-ranking&sourceUrl=%2Fexam%2Foj" target="_blank" rel="noopener">判断是不是二叉搜索树</a></h2><h3 id="题目描述-33"><a href="#题目描述-33" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树根节点，请你判断这棵树是不是二叉搜索树。 </p>
<p>二叉搜索树满足每个节点的左子树上的所有节点均小于当前节点且右子树上的所有节点均大于当前节点。 </p>
<p>例： </p>
<p><img src="https://uploadfiles.nowcoder.com/images/20211109/392807_1636440937987/9C31F319601A5B78D34F62FF77A02A11" alt="img"></p>
<p>图1 </p>
<p><img src="https://uploadfiles.nowcoder.com/images/20211109/392807_1636440984427/5E5B576E11CB2C96724680C94755ABCB" alt="img"></p>
<p>图2 </p>
<p>数据范围：节点数量满足 1≤n≤104，节点上的值满足 −231≤val≤231−1</p>
<h3 id="题解-35"><a href="#题解-35" class="headerlink" title="题解"></a>题解</h3><p>最简单的方法是中序遍历二叉树得到数组，看数组中每个元素是否严格小于后一个数</p>
<h3 id="Java代码实现-34"><a href="#Java代码实现-34" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span> <span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; nums = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(root, nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.size() - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums.get(i) &gt;= nums.get(i + <span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            dfs(root.left, nums);</span><br><span class="line">            nums.add(root.val);</span><br><span class="line">            dfs(root.right, nums);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题解-36"><a href="#题解-36" class="headerlink" title="题解"></a>题解</h3><p>或者就是在中序遍历的过程中直接比较，不使用额外数组</p>
<h3 id="Java代码实现-35"><a href="#Java代码实现-35" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> pre = Integer.MIN_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span> <span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dfs(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            flag = (flag &amp;&amp; dfs(root.left));</span><br><span class="line">            flag = (flag &amp;&amp; (root.val &gt; pre));</span><br><span class="line">            pre = root.val;</span><br><span class="line">            flag = (flag &amp;&amp; dfs(root.right));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      </div>
      
      
      
    </div>
    

    
    
    


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#链表部分"><span class="nav-number">1.</span> <span class="nav-text">链表部分</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#BM1-反转链表"><span class="nav-number">1.1.</span> <span class="nav-text">BM1 反转链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述"><span class="nav-number">1.1.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解"><span class="nav-number">1.1.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现"><span class="nav-number">1.1.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM2-链表内指定区间反转"><span class="nav-number">1.2.</span> <span class="nav-text">BM2 链表内指定区间反转</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-1"><span class="nav-number">1.2.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-1"><span class="nav-number">1.2.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-1"><span class="nav-number">1.2.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM3-链表中的节点每k个一组翻转"><span class="nav-number">1.3.</span> <span class="nav-text">BM3 链表中的节点每k个一组翻转</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-2"><span class="nav-number">1.3.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-2"><span class="nav-number">1.3.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-2"><span class="nav-number">1.3.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM4-合并两个排序的链表"><span class="nav-number">1.4.</span> <span class="nav-text">BM4 合并两个排序的链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-3"><span class="nav-number">1.4.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-3"><span class="nav-number">1.4.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-3"><span class="nav-number">1.4.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM5-合并k个已排序的链表"><span class="nav-number">1.5.</span> <span class="nav-text">BM5 合并k个已排序的链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-4"><span class="nav-number">1.5.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-4"><span class="nav-number">1.5.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-4"><span class="nav-number">1.5.3.</span> <span class="nav-text">Java代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-5"><span class="nav-number">1.5.4.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-5"><span class="nav-number">1.5.5.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM6-判断链表中是否有环"><span class="nav-number">1.6.</span> <span class="nav-text">BM6 判断链表中是否有环</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-5"><span class="nav-number">1.6.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-6"><span class="nav-number">1.6.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-6"><span class="nav-number">1.6.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM7-链表中环的入口节点"><span class="nav-number">1.7.</span> <span class="nav-text">BM7 链表中环的入口节点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-6"><span class="nav-number">1.7.1.</span> <span class="nav-text">题目描述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#输入描述"><span class="nav-number">1.7.1.1.</span> <span class="nav-text">输入描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值描述"><span class="nav-number">1.7.1.2.</span> <span class="nav-text">返回值描述</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-7"><span class="nav-number">1.7.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-7"><span class="nav-number">1.7.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM8-链表中倒数最后k个节点"><span class="nav-number">1.8.</span> <span class="nav-text">BM8 链表中倒数最后k个节点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-7"><span class="nav-number">1.8.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-8"><span class="nav-number">1.8.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-8"><span class="nav-number">1.8.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM9-删除链表的倒数第n个节点"><span class="nav-number">1.9.</span> <span class="nav-text">BM9 删除链表的倒数第n个节点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-8"><span class="nav-number">1.9.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-9"><span class="nav-number">1.9.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-9"><span class="nav-number">1.9.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM10-两个链表的第一个公共结点"><span class="nav-number">1.10.</span> <span class="nav-text">BM10 两个链表的第一个公共结点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-9"><span class="nav-number">1.10.1.</span> <span class="nav-text">题目描述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#输入描述："><span class="nav-number">1.10.1.1.</span> <span class="nav-text">输入描述：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值描述："><span class="nav-number">1.10.1.2.</span> <span class="nav-text">返回值描述：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-10"><span class="nav-number">1.10.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-10"><span class="nav-number">1.10.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM11-链表相加（二）"><span class="nav-number">1.11.</span> <span class="nav-text">BM11 链表相加（二）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-10"><span class="nav-number">1.11.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-11"><span class="nav-number">1.11.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-11"><span class="nav-number">1.11.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM12-单链表的排序问题"><span class="nav-number">1.12.</span> <span class="nav-text">BM12 单链表的排序问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-11"><span class="nav-number">1.12.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-12"><span class="nav-number">1.12.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-12"><span class="nav-number">1.12.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM13-判断一个链表是否是回文结构"><span class="nav-number">1.13.</span> <span class="nav-text">BM13 判断一个链表是否是回文结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-12"><span class="nav-number">1.13.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-13"><span class="nav-number">1.13.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-13"><span class="nav-number">1.13.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM14-链表的奇偶重拍"><span class="nav-number">1.14.</span> <span class="nav-text">BM14 链表的奇偶重拍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-13"><span class="nav-number">1.14.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-14"><span class="nav-number">1.14.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-14"><span class="nav-number">1.14.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM15-删除有序链表中重复的元素-I"><span class="nav-number">1.15.</span> <span class="nav-text">BM15 删除有序链表中重复的元素-I</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-14"><span class="nav-number">1.15.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-15"><span class="nav-number">1.15.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-15"><span class="nav-number">1.15.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM16-删除有序列表中重复的元素-II"><span class="nav-number">1.16.</span> <span class="nav-text">BM16 删除有序列表中重复的元素-II</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-15"><span class="nav-number">1.16.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-16"><span class="nav-number">1.16.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-16"><span class="nav-number">1.16.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二分查找-排序"><span class="nav-number">2.</span> <span class="nav-text">二分查找&#x2F;排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#BM17-二分查找-I"><span class="nav-number">2.1.</span> <span class="nav-text">BM17 二分查找-I</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-16"><span class="nav-number">2.1.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-17"><span class="nav-number">2.1.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-17"><span class="nav-number">2.1.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM18-二维数组中的查找"><span class="nav-number">2.2.</span> <span class="nav-text">BM18 二维数组中的查找</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-17"><span class="nav-number">2.2.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-18"><span class="nav-number">2.2.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-18"><span class="nav-number">2.2.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM19-寻找峰值"><span class="nav-number">2.3.</span> <span class="nav-text">BM19 寻找峰值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-18"><span class="nav-number">2.3.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-19"><span class="nav-number">2.3.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-19"><span class="nav-number">2.3.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM20-数组中的逆序对"><span class="nav-number">2.4.</span> <span class="nav-text">BM20 数组中的逆序对</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-19"><span class="nav-number">2.4.1.</span> <span class="nav-text">题目描述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解-20"><span class="nav-number">2.5.</span> <span class="nav-text">题解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-20"><span class="nav-number">2.5.1.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM21-旋转数组的最小数字"><span class="nav-number">2.6.</span> <span class="nav-text">BM21 旋转数组的最小数字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-20"><span class="nav-number">2.6.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-21"><span class="nav-number">2.6.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-21"><span class="nav-number">2.6.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM22-比较版本号"><span class="nav-number">2.7.</span> <span class="nav-text">BM22 比较版本号</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-21"><span class="nav-number">2.7.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-22"><span class="nav-number">2.7.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现如下"><span class="nav-number">2.7.3.</span> <span class="nav-text">Java代码实现如下</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-23"><span class="nav-number">2.7.4.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-22"><span class="nav-number">2.7.5.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉树"><span class="nav-number">2.8.</span> <span class="nav-text">二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BM23-二叉树的前序遍历"><span class="nav-number">2.8.1.</span> <span class="nav-text">BM23 二叉树的前序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-22"><span class="nav-number">2.8.2.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-24"><span class="nav-number">2.8.3.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-23"><span class="nav-number">2.8.4.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM24-二叉树的中序遍历"><span class="nav-number">2.9.</span> <span class="nav-text">BM24 二叉树的中序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-23"><span class="nav-number">2.9.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-25"><span class="nav-number">2.9.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-24"><span class="nav-number">2.9.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM25-二叉树的后序遍历"><span class="nav-number">2.10.</span> <span class="nav-text">BM25 二叉树的后序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-24"><span class="nav-number">2.10.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-26"><span class="nav-number">2.10.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-25"><span class="nav-number">2.10.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM26-求二叉树的层序遍历"><span class="nav-number">2.11.</span> <span class="nav-text">BM26 求二叉树的层序遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-25"><span class="nav-number">2.12.</span> <span class="nav-text">题目描述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-27"><span class="nav-number">2.12.1.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-26"><span class="nav-number">2.12.2.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM27-按之字形顺序打印二叉树"><span class="nav-number">2.13.</span> <span class="nav-text">BM27 按之字形顺序打印二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-26"><span class="nav-number">2.13.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-28"><span class="nav-number">2.13.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-27"><span class="nav-number">2.13.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM28-二叉树的最大深度"><span class="nav-number">2.14.</span> <span class="nav-text">BM28 二叉树的最大深度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-27"><span class="nav-number">2.14.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-29"><span class="nav-number">2.14.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-28"><span class="nav-number">2.14.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM29-二叉树中和为某一值的路径"><span class="nav-number">2.15.</span> <span class="nav-text">BM29 二叉树中和为某一值的路径</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-28"><span class="nav-number">2.15.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-30"><span class="nav-number">2.15.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-29"><span class="nav-number">2.15.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM30-二叉搜索树与双向链表"><span class="nav-number">2.16.</span> <span class="nav-text">BM30 二叉搜索树与双向链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-29"><span class="nav-number">2.16.1.</span> <span class="nav-text">题目描述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#输入描述：-1"><span class="nav-number">2.16.1.1.</span> <span class="nav-text">输入描述：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值描述：-1"><span class="nav-number">2.16.1.2.</span> <span class="nav-text">返回值描述：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-31"><span class="nav-number">2.16.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-30"><span class="nav-number">2.16.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM31对称的二叉树"><span class="nav-number">2.17.</span> <span class="nav-text">BM31对称的二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-30"><span class="nav-number">2.17.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-32"><span class="nav-number">2.17.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-31"><span class="nav-number">2.17.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM32-合并二叉树"><span class="nav-number">2.18.</span> <span class="nav-text">BM32 合并二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-31"><span class="nav-number">2.18.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-33"><span class="nav-number">2.18.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-32"><span class="nav-number">2.18.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM33-二叉树的镜像"><span class="nav-number">2.19.</span> <span class="nav-text">BM33 二叉树的镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-32"><span class="nav-number">2.19.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-34"><span class="nav-number">2.19.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-33"><span class="nav-number">2.19.3.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM34-判断是不是二叉搜索树"><span class="nav-number">2.20.</span> <span class="nav-text">BM34 判断是不是二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-33"><span class="nav-number">2.20.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-35"><span class="nav-number">2.20.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-34"><span class="nav-number">2.20.3.</span> <span class="nav-text">Java代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题解-36"><span class="nav-number">2.20.4.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码实现-35"><span class="nav-number">2.20.5.</span> <span class="nav-text">Java代码实现</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Decucin"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Decucin</p>
  <div class="site-description" itemprop="description">喜欢简单的事物和明朗的关系</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/decucin" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;decucin" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1690406856@qq.com" title="E-Mail → mailto:1690406856@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/decucin" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;decucin" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020-05 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Decucin</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">219k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">3:19</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>


	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
	<span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
	<span class="post-meta-divider">|</span>
	<span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
	<span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值矫正 -->
<script>
$(document).ready(function() {

	var int = setInterval(fixCount, 50);
	var count0ffset = 20000;
	
	function fixCount(){
		if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
		{
			$("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + count0ffset);
			clearInterval(int);
		}
		if ($("#busuanzi_value_site_pv").css("display") != "none")
		{
			$("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) +count0ffset);
			clearInterval(int);
		}
	}
});
</script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  <script type="text/javascript" src="/js/love.js"></script>
</body>
</html>
